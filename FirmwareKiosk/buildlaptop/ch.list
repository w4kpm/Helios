
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002c1 	.word	0x080002c1
 8000008:	080002c3 	.word	0x080002c3
 800000c:	080002c2 	.word	0x080002c2
 8000010:	080002c2 	.word	0x080002c2
 8000014:	080002c2 	.word	0x080002c2
 8000018:	080002c2 	.word	0x080002c2
 800001c:	080002c2 	.word	0x080002c2
 8000020:	080002c2 	.word	0x080002c2
 8000024:	080002c2 	.word	0x080002c2
 8000028:	080002c2 	.word	0x080002c2
 800002c:	08005a91 	.word	0x08005a91
 8000030:	080002c2 	.word	0x080002c2
 8000034:	080002c2 	.word	0x080002c2
 8000038:	080002c2 	.word	0x080002c2
 800003c:	080002c2 	.word	0x080002c2
 8000040:	080002c2 	.word	0x080002c2
 8000044:	080002c2 	.word	0x080002c2
 8000048:	080002c2 	.word	0x080002c2
 800004c:	080002c2 	.word	0x080002c2
 8000050:	080002c2 	.word	0x080002c2
 8000054:	080002c2 	.word	0x080002c2
 8000058:	080002c2 	.word	0x080002c2
 800005c:	080002c2 	.word	0x080002c2
 8000060:	080002c2 	.word	0x080002c2
 8000064:	080002c2 	.word	0x080002c2
 8000068:	080002c2 	.word	0x080002c2
 800006c:	08009b61 	.word	0x08009b61
 8000070:	08009a81 	.word	0x08009a81
 8000074:	080099a1 	.word	0x080099a1
 8000078:	080098c1 	.word	0x080098c1
 800007c:	080097e1 	.word	0x080097e1
 8000080:	08009701 	.word	0x08009701
 8000084:	08009621 	.word	0x08009621
 8000088:	08009e81 	.word	0x08009e81
 800008c:	080002c2 	.word	0x080002c2
 8000090:	080002c2 	.word	0x080002c2
 8000094:	080002c2 	.word	0x080002c2
 8000098:	080002c2 	.word	0x080002c2
 800009c:	080002c2 	.word	0x080002c2
 80000a0:	080002c2 	.word	0x080002c2
 80000a4:	080002c2 	.word	0x080002c2
 80000a8:	080002c2 	.word	0x080002c2
 80000ac:	080002c2 	.word	0x080002c2
 80000b0:	08008fa1 	.word	0x08008fa1
 80000b4:	080002c2 	.word	0x080002c2
 80000b8:	080002c2 	.word	0x080002c2
 80000bc:	080002c2 	.word	0x080002c2
 80000c0:	080002c2 	.word	0x080002c2
 80000c4:	080002c2 	.word	0x080002c2
 80000c8:	080002c2 	.word	0x080002c2
 80000cc:	080002c2 	.word	0x080002c2
 80000d0:	080002c2 	.word	0x080002c2
 80000d4:	08008ea1 	.word	0x08008ea1
 80000d8:	08008da1 	.word	0x08008da1
 80000dc:	080002c2 	.word	0x080002c2
 80000e0:	080002c2 	.word	0x080002c2
 80000e4:	080002c2 	.word	0x080002c2
 80000e8:	080002c2 	.word	0x080002c2
 80000ec:	080002c2 	.word	0x080002c2
 80000f0:	080002c2 	.word	0x080002c2
 80000f4:	080002c2 	.word	0x080002c2
 80000f8:	080002c2 	.word	0x080002c2
 80000fc:	08009d81 	.word	0x08009d81
 8000100:	080002c2 	.word	0x080002c2
 8000104:	080002c2 	.word	0x080002c2
 8000108:	080002c2 	.word	0x080002c2
 800010c:	080002c2 	.word	0x080002c2
 8000110:	080002c2 	.word	0x080002c2
 8000114:	080002c2 	.word	0x080002c2
 8000118:	080002c2 	.word	0x080002c2
 800011c:	080002c2 	.word	0x080002c2
 8000120:	08009501 	.word	0x08009501
 8000124:	08009401 	.word	0x08009401
 8000128:	08009321 	.word	0x08009321
 800012c:	08009241 	.word	0x08009241
 8000130:	08009161 	.word	0x08009161
 8000134:	08009c81 	.word	0x08009c81
 8000138:	080002c2 	.word	0x080002c2
 800013c:	080002c2 	.word	0x080002c2
 8000140:	080002c2 	.word	0x080002c2
 8000144:	080002c2 	.word	0x080002c2
 8000148:	080002c2 	.word	0x080002c2
 800014c:	080002c2 	.word	0x080002c2
 8000150:	080002c2 	.word	0x080002c2
 8000154:	080002c2 	.word	0x080002c2
 8000158:	080002c2 	.word	0x080002c2
 800015c:	080002c2 	.word	0x080002c2
 8000160:	080002c2 	.word	0x080002c2
 8000164:	080002c2 	.word	0x080002c2
 8000168:	080002c2 	.word	0x080002c2
 800016c:	080002c2 	.word	0x080002c2
 8000170:	080002c2 	.word	0x080002c2
 8000174:	080002c2 	.word	0x080002c2
 8000178:	080002c2 	.word	0x080002c2
 800017c:	080002c2 	.word	0x080002c2
 8000180:	080002c2 	.word	0x080002c2
 8000184:	080002c2 	.word	0x080002c2
 8000188:	080002c2 	.word	0x080002c2
 800018c:	080002c2 	.word	0x080002c2
 8000190:	080002c2 	.word	0x080002c2
 8000194:	080002c2 	.word	0x080002c2
 8000198:	080002c2 	.word	0x080002c2
 800019c:	080002c2 	.word	0x080002c2

Disassembly of section .text:

080001a0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001a2:	4839      	ldr	r0, [pc, #228]	; (8000288 <endfiniloop+0x6>)
                msr     MSP, r0
 80001a4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001a8:	4838      	ldr	r0, [pc, #224]	; (800028c <endfiniloop+0xa>)
                msr     PSP, r0
 80001aa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ae:	4838      	ldr	r0, [pc, #224]	; (8000290 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001b0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001b8:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001ba:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001be:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 80001c2:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 80001c6:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001ca:	6008      	str	r0, [r1, #0]
                dsb
 80001cc:	f3bf 8f4f 	dsb	sy
                isb
 80001d0:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 80001d4:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 80001d8:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 80001dc:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 80001e0:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001e4:	6008      	str	r0, [r1, #0]
                dsb
 80001e6:	f3bf 8f4f 	dsb	sy
                isb
 80001ea:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 80001ee:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 80001f2:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 80001f6:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 80001fa:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001fe:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000200:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000202:	f380 8814 	msr	CONTROL, r0
                isb
 8000206:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800020a:	f009 ff01 	bl	800a010 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800020e:	f008 fcff 	bl	8008c10 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000212:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000216:	491f      	ldr	r1, [pc, #124]	; (8000294 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8000218:	4a1b      	ldr	r2, [pc, #108]	; (8000288 <endfiniloop+0x6>)

0800021a <msloop>:
msloop:
                cmp     r1, r2
 800021a:	4291      	cmp	r1, r2
                itt     lo
 800021c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800021e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000222:	e7fa      	bcc.n	800021a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000224:	491c      	ldr	r1, [pc, #112]	; (8000298 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8000226:	4a19      	ldr	r2, [pc, #100]	; (800028c <endfiniloop+0xa>)

08000228 <psloop>:
psloop:
                cmp     r1, r2
 8000228:	4291      	cmp	r1, r2
                itt     lo
 800022a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800022c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000230:	e7fa      	bcc.n	8000228 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000232:	491a      	ldr	r1, [pc, #104]	; (800029c <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8000234:	4a1a      	ldr	r2, [pc, #104]	; (80002a0 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 8000236:	4b1b      	ldr	r3, [pc, #108]	; (80002a4 <endfiniloop+0x22>)

08000238 <dloop>:
dloop:
                cmp     r2, r3
 8000238:	429a      	cmp	r2, r3
                ittt    lo
 800023a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800023c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000240:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000244:	e7f8      	bcc.n	8000238 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000246:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000248:	4917      	ldr	r1, [pc, #92]	; (80002a8 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 800024a:	4a18      	ldr	r2, [pc, #96]	; (80002ac <endfiniloop+0x2a>)

0800024c <bloop>:
bloop:
                cmp     r1, r2
 800024c:	4291      	cmp	r1, r2
                itt     lo
 800024e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000250:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000254:	e7fa      	bcc.n	800024c <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000256:	f009 fe9b 	bl	8009f90 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800025a:	f009 fed1 	bl	800a000 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800025e:	4c14      	ldr	r4, [pc, #80]	; (80002b0 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 8000260:	4d14      	ldr	r5, [pc, #80]	; (80002b4 <endfiniloop+0x32>)

08000262 <initloop>:
initloop:
                cmp     r4, r5
 8000262:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000264:	da03      	bge.n	800026e <endinitloop>
                ldr     r1, [r4], #4
 8000266:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800026a:	4788      	blx	r1
                b       initloop
 800026c:	e7f9      	b.n	8000262 <initloop>

0800026e <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800026e:	f006 fdcf 	bl	8006e10 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000272:	4c11      	ldr	r4, [pc, #68]	; (80002b8 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000274:	4d11      	ldr	r5, [pc, #68]	; (80002bc <endfiniloop+0x3a>)

08000276 <finiloop>:
finiloop:
                cmp     r4, r5
 8000276:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000278:	da03      	bge.n	8000282 <endfiniloop>
                ldr     r1, [r4], #4
 800027a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800027e:	4788      	blx	r1
                b       finiloop
 8000280:	e7f9      	b.n	8000276 <finiloop>

08000282 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000282:	f009 beb5 	b.w	8009ff0 <__default_exit>
 8000286:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000288:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 800028c:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000290:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 8000294:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000298:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 800029c:	0801de90 	.word	0x0801de90
                ldr     r2, =_data_start
 80002a0:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002a4:	200011dc 	.word	0x200011dc
                ldr     r1, =_bss_start
 80002a8:	200011e0 	.word	0x200011e0
                ldr     r2, =_bss_end
 80002ac:	20005da4 	.word	0x20005da4
                ldr     r4, =__init_array_start
 80002b0:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end
 80002b4:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_start
 80002b8:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end
 80002bc:	080001a0 	.word	0x080001a0

080002c0 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002c0:	e76e      	b.n	80001a0 <_crt0_entry>

080002c2 <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
 80002c2:	f000 f800 	bl	80002c6 <_unhandled_exception>

080002c6 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002c6:	e7fe      	b.n	80002c6 <_unhandled_exception>

080002c8 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 80002cc:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002d0:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002d4:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002d6:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 80002d8:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e0 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002e0:	f004 ffce 	bl	8005280 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002e4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002e6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002ea:	4628      	mov	r0, r5
                blx     r4
 80002ec:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002ee:	2000      	movs	r0, #0
                bl      chThdExit
 80002f0:	f005 fbde 	bl	8005ab0 <chThdExit>

080002f4 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80002f4:	f004 ffec 	bl	80052d0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80002f8:	f005 fc52 	bl	8005ba0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002fc:	f004 ffc0 	bl	8005280 <_dbg_check_unlock>

08000300 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000300:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000302:	e7fe      	b.n	8000302 <_port_exit_from_isr+0x2>

08000304 <__aeabi_drsub>:
 8000304:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000308:	e002      	b.n	8000310 <__adddf3>
 800030a:	bf00      	nop

0800030c <__aeabi_dsub>:
 800030c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000310 <__adddf3>:
 8000310:	b530      	push	{r4, r5, lr}
 8000312:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000316:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800031a:	ea94 0f05 	teq	r4, r5
 800031e:	bf08      	it	eq
 8000320:	ea90 0f02 	teqeq	r0, r2
 8000324:	bf1f      	itttt	ne
 8000326:	ea54 0c00 	orrsne.w	ip, r4, r0
 800032a:	ea55 0c02 	orrsne.w	ip, r5, r2
 800032e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000332:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000336:	f000 80e2 	beq.w	80004fe <__adddf3+0x1ee>
 800033a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800033e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000342:	bfb8      	it	lt
 8000344:	426d      	neglt	r5, r5
 8000346:	dd0c      	ble.n	8000362 <__adddf3+0x52>
 8000348:	442c      	add	r4, r5
 800034a:	ea80 0202 	eor.w	r2, r0, r2
 800034e:	ea81 0303 	eor.w	r3, r1, r3
 8000352:	ea82 0000 	eor.w	r0, r2, r0
 8000356:	ea83 0101 	eor.w	r1, r3, r1
 800035a:	ea80 0202 	eor.w	r2, r0, r2
 800035e:	ea81 0303 	eor.w	r3, r1, r3
 8000362:	2d36      	cmp	r5, #54	; 0x36
 8000364:	bf88      	it	hi
 8000366:	bd30      	pophi	{r4, r5, pc}
 8000368:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800036c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000370:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000374:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000378:	d002      	beq.n	8000380 <__adddf3+0x70>
 800037a:	4240      	negs	r0, r0
 800037c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000380:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000384:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000388:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800038c:	d002      	beq.n	8000394 <__adddf3+0x84>
 800038e:	4252      	negs	r2, r2
 8000390:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000394:	ea94 0f05 	teq	r4, r5
 8000398:	f000 80a7 	beq.w	80004ea <__adddf3+0x1da>
 800039c:	f1a4 0401 	sub.w	r4, r4, #1
 80003a0:	f1d5 0e20 	rsbs	lr, r5, #32
 80003a4:	db0d      	blt.n	80003c2 <__adddf3+0xb2>
 80003a6:	fa02 fc0e 	lsl.w	ip, r2, lr
 80003aa:	fa22 f205 	lsr.w	r2, r2, r5
 80003ae:	1880      	adds	r0, r0, r2
 80003b0:	f141 0100 	adc.w	r1, r1, #0
 80003b4:	fa03 f20e 	lsl.w	r2, r3, lr
 80003b8:	1880      	adds	r0, r0, r2
 80003ba:	fa43 f305 	asr.w	r3, r3, r5
 80003be:	4159      	adcs	r1, r3
 80003c0:	e00e      	b.n	80003e0 <__adddf3+0xd0>
 80003c2:	f1a5 0520 	sub.w	r5, r5, #32
 80003c6:	f10e 0e20 	add.w	lr, lr, #32
 80003ca:	2a01      	cmp	r2, #1
 80003cc:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003d0:	bf28      	it	cs
 80003d2:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003d6:	fa43 f305 	asr.w	r3, r3, r5
 80003da:	18c0      	adds	r0, r0, r3
 80003dc:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003e0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003e4:	d507      	bpl.n	80003f6 <__adddf3+0xe6>
 80003e6:	f04f 0e00 	mov.w	lr, #0
 80003ea:	f1dc 0c00 	rsbs	ip, ip, #0
 80003ee:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003f2:	eb6e 0101 	sbc.w	r1, lr, r1
 80003f6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003fa:	d31b      	bcc.n	8000434 <__adddf3+0x124>
 80003fc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000400:	d30c      	bcc.n	800041c <__adddf3+0x10c>
 8000402:	0849      	lsrs	r1, r1, #1
 8000404:	ea5f 0030 	movs.w	r0, r0, rrx
 8000408:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800040c:	f104 0401 	add.w	r4, r4, #1
 8000410:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000414:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000418:	f080 809a 	bcs.w	8000550 <__adddf3+0x240>
 800041c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000420:	bf08      	it	eq
 8000422:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000426:	f150 0000 	adcs.w	r0, r0, #0
 800042a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800042e:	ea41 0105 	orr.w	r1, r1, r5
 8000432:	bd30      	pop	{r4, r5, pc}
 8000434:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000438:	4140      	adcs	r0, r0
 800043a:	eb41 0101 	adc.w	r1, r1, r1
 800043e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000442:	f1a4 0401 	sub.w	r4, r4, #1
 8000446:	d1e9      	bne.n	800041c <__adddf3+0x10c>
 8000448:	f091 0f00 	teq	r1, #0
 800044c:	bf04      	itt	eq
 800044e:	4601      	moveq	r1, r0
 8000450:	2000      	moveq	r0, #0
 8000452:	fab1 f381 	clz	r3, r1
 8000456:	bf08      	it	eq
 8000458:	3320      	addeq	r3, #32
 800045a:	f1a3 030b 	sub.w	r3, r3, #11
 800045e:	f1b3 0220 	subs.w	r2, r3, #32
 8000462:	da0c      	bge.n	800047e <__adddf3+0x16e>
 8000464:	320c      	adds	r2, #12
 8000466:	dd08      	ble.n	800047a <__adddf3+0x16a>
 8000468:	f102 0c14 	add.w	ip, r2, #20
 800046c:	f1c2 020c 	rsb	r2, r2, #12
 8000470:	fa01 f00c 	lsl.w	r0, r1, ip
 8000474:	fa21 f102 	lsr.w	r1, r1, r2
 8000478:	e00c      	b.n	8000494 <__adddf3+0x184>
 800047a:	f102 0214 	add.w	r2, r2, #20
 800047e:	bfd8      	it	le
 8000480:	f1c2 0c20 	rsble	ip, r2, #32
 8000484:	fa01 f102 	lsl.w	r1, r1, r2
 8000488:	fa20 fc0c 	lsr.w	ip, r0, ip
 800048c:	bfdc      	itt	le
 800048e:	ea41 010c 	orrle.w	r1, r1, ip
 8000492:	4090      	lslle	r0, r2
 8000494:	1ae4      	subs	r4, r4, r3
 8000496:	bfa2      	ittt	ge
 8000498:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800049c:	4329      	orrge	r1, r5
 800049e:	bd30      	popge	{r4, r5, pc}
 80004a0:	ea6f 0404 	mvn.w	r4, r4
 80004a4:	3c1f      	subs	r4, #31
 80004a6:	da1c      	bge.n	80004e2 <__adddf3+0x1d2>
 80004a8:	340c      	adds	r4, #12
 80004aa:	dc0e      	bgt.n	80004ca <__adddf3+0x1ba>
 80004ac:	f104 0414 	add.w	r4, r4, #20
 80004b0:	f1c4 0220 	rsb	r2, r4, #32
 80004b4:	fa20 f004 	lsr.w	r0, r0, r4
 80004b8:	fa01 f302 	lsl.w	r3, r1, r2
 80004bc:	ea40 0003 	orr.w	r0, r0, r3
 80004c0:	fa21 f304 	lsr.w	r3, r1, r4
 80004c4:	ea45 0103 	orr.w	r1, r5, r3
 80004c8:	bd30      	pop	{r4, r5, pc}
 80004ca:	f1c4 040c 	rsb	r4, r4, #12
 80004ce:	f1c4 0220 	rsb	r2, r4, #32
 80004d2:	fa20 f002 	lsr.w	r0, r0, r2
 80004d6:	fa01 f304 	lsl.w	r3, r1, r4
 80004da:	ea40 0003 	orr.w	r0, r0, r3
 80004de:	4629      	mov	r1, r5
 80004e0:	bd30      	pop	{r4, r5, pc}
 80004e2:	fa21 f004 	lsr.w	r0, r1, r4
 80004e6:	4629      	mov	r1, r5
 80004e8:	bd30      	pop	{r4, r5, pc}
 80004ea:	f094 0f00 	teq	r4, #0
 80004ee:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004f2:	bf06      	itte	eq
 80004f4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004f8:	3401      	addeq	r4, #1
 80004fa:	3d01      	subne	r5, #1
 80004fc:	e74e      	b.n	800039c <__adddf3+0x8c>
 80004fe:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000502:	bf18      	it	ne
 8000504:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000508:	d029      	beq.n	800055e <__adddf3+0x24e>
 800050a:	ea94 0f05 	teq	r4, r5
 800050e:	bf08      	it	eq
 8000510:	ea90 0f02 	teqeq	r0, r2
 8000514:	d005      	beq.n	8000522 <__adddf3+0x212>
 8000516:	ea54 0c00 	orrs.w	ip, r4, r0
 800051a:	bf04      	itt	eq
 800051c:	4619      	moveq	r1, r3
 800051e:	4610      	moveq	r0, r2
 8000520:	bd30      	pop	{r4, r5, pc}
 8000522:	ea91 0f03 	teq	r1, r3
 8000526:	bf1e      	ittt	ne
 8000528:	2100      	movne	r1, #0
 800052a:	2000      	movne	r0, #0
 800052c:	bd30      	popne	{r4, r5, pc}
 800052e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000532:	d105      	bne.n	8000540 <__adddf3+0x230>
 8000534:	0040      	lsls	r0, r0, #1
 8000536:	4149      	adcs	r1, r1
 8000538:	bf28      	it	cs
 800053a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800053e:	bd30      	pop	{r4, r5, pc}
 8000540:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000544:	bf3c      	itt	cc
 8000546:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800054a:	bd30      	popcc	{r4, r5, pc}
 800054c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000550:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000554:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000558:	f04f 0000 	mov.w	r0, #0
 800055c:	bd30      	pop	{r4, r5, pc}
 800055e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000562:	bf1a      	itte	ne
 8000564:	4619      	movne	r1, r3
 8000566:	4610      	movne	r0, r2
 8000568:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800056c:	bf1c      	itt	ne
 800056e:	460b      	movne	r3, r1
 8000570:	4602      	movne	r2, r0
 8000572:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000576:	bf06      	itte	eq
 8000578:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800057c:	ea91 0f03 	teqeq	r1, r3
 8000580:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000584:	bd30      	pop	{r4, r5, pc}
 8000586:	bf00      	nop

08000588 <__aeabi_ui2d>:
 8000588:	f090 0f00 	teq	r0, #0
 800058c:	bf04      	itt	eq
 800058e:	2100      	moveq	r1, #0
 8000590:	4770      	bxeq	lr
 8000592:	b530      	push	{r4, r5, lr}
 8000594:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000598:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800059c:	f04f 0500 	mov.w	r5, #0
 80005a0:	f04f 0100 	mov.w	r1, #0
 80005a4:	e750      	b.n	8000448 <__adddf3+0x138>
 80005a6:	bf00      	nop

080005a8 <__aeabi_i2d>:
 80005a8:	f090 0f00 	teq	r0, #0
 80005ac:	bf04      	itt	eq
 80005ae:	2100      	moveq	r1, #0
 80005b0:	4770      	bxeq	lr
 80005b2:	b530      	push	{r4, r5, lr}
 80005b4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005b8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005bc:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005c0:	bf48      	it	mi
 80005c2:	4240      	negmi	r0, r0
 80005c4:	f04f 0100 	mov.w	r1, #0
 80005c8:	e73e      	b.n	8000448 <__adddf3+0x138>
 80005ca:	bf00      	nop

080005cc <__aeabi_f2d>:
 80005cc:	0042      	lsls	r2, r0, #1
 80005ce:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005d2:	ea4f 0131 	mov.w	r1, r1, rrx
 80005d6:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005da:	bf1f      	itttt	ne
 80005dc:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005e0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005e4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005e8:	4770      	bxne	lr
 80005ea:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005ee:	bf08      	it	eq
 80005f0:	4770      	bxeq	lr
 80005f2:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005f6:	bf04      	itt	eq
 80005f8:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005fc:	4770      	bxeq	lr
 80005fe:	b530      	push	{r4, r5, lr}
 8000600:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000604:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000608:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800060c:	e71c      	b.n	8000448 <__adddf3+0x138>
 800060e:	bf00      	nop

08000610 <__aeabi_ul2d>:
 8000610:	ea50 0201 	orrs.w	r2, r0, r1
 8000614:	bf08      	it	eq
 8000616:	4770      	bxeq	lr
 8000618:	b530      	push	{r4, r5, lr}
 800061a:	f04f 0500 	mov.w	r5, #0
 800061e:	e00a      	b.n	8000636 <__aeabi_l2d+0x16>

08000620 <__aeabi_l2d>:
 8000620:	ea50 0201 	orrs.w	r2, r0, r1
 8000624:	bf08      	it	eq
 8000626:	4770      	bxeq	lr
 8000628:	b530      	push	{r4, r5, lr}
 800062a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800062e:	d502      	bpl.n	8000636 <__aeabi_l2d+0x16>
 8000630:	4240      	negs	r0, r0
 8000632:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000636:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800063a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800063e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000642:	f43f aed8 	beq.w	80003f6 <__adddf3+0xe6>
 8000646:	f04f 0203 	mov.w	r2, #3
 800064a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800064e:	bf18      	it	ne
 8000650:	3203      	addne	r2, #3
 8000652:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000656:	bf18      	it	ne
 8000658:	3203      	addne	r2, #3
 800065a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800065e:	f1c2 0320 	rsb	r3, r2, #32
 8000662:	fa00 fc03 	lsl.w	ip, r0, r3
 8000666:	fa20 f002 	lsr.w	r0, r0, r2
 800066a:	fa01 fe03 	lsl.w	lr, r1, r3
 800066e:	ea40 000e 	orr.w	r0, r0, lr
 8000672:	fa21 f102 	lsr.w	r1, r1, r2
 8000676:	4414      	add	r4, r2
 8000678:	e6bd      	b.n	80003f6 <__adddf3+0xe6>
 800067a:	bf00      	nop

0800067c <__aeabi_dmul>:
 800067c:	b570      	push	{r4, r5, r6, lr}
 800067e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000682:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000686:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800068a:	bf1d      	ittte	ne
 800068c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000690:	ea94 0f0c 	teqne	r4, ip
 8000694:	ea95 0f0c 	teqne	r5, ip
 8000698:	f000 f8de 	bleq	8000858 <__aeabi_dmul+0x1dc>
 800069c:	442c      	add	r4, r5
 800069e:	ea81 0603 	eor.w	r6, r1, r3
 80006a2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80006a6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80006aa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80006ae:	bf18      	it	ne
 80006b0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80006b4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006b8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006bc:	d038      	beq.n	8000730 <__aeabi_dmul+0xb4>
 80006be:	fba0 ce02 	umull	ip, lr, r0, r2
 80006c2:	f04f 0500 	mov.w	r5, #0
 80006c6:	fbe1 e502 	umlal	lr, r5, r1, r2
 80006ca:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80006ce:	fbe0 e503 	umlal	lr, r5, r0, r3
 80006d2:	f04f 0600 	mov.w	r6, #0
 80006d6:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006da:	f09c 0f00 	teq	ip, #0
 80006de:	bf18      	it	ne
 80006e0:	f04e 0e01 	orrne.w	lr, lr, #1
 80006e4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006e8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006ec:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006f0:	d204      	bcs.n	80006fc <__aeabi_dmul+0x80>
 80006f2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006f6:	416d      	adcs	r5, r5
 80006f8:	eb46 0606 	adc.w	r6, r6, r6
 80006fc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000700:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000704:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000708:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800070c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000710:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000714:	bf88      	it	hi
 8000716:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800071a:	d81e      	bhi.n	800075a <__aeabi_dmul+0xde>
 800071c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000720:	bf08      	it	eq
 8000722:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000726:	f150 0000 	adcs.w	r0, r0, #0
 800072a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800072e:	bd70      	pop	{r4, r5, r6, pc}
 8000730:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000734:	ea46 0101 	orr.w	r1, r6, r1
 8000738:	ea40 0002 	orr.w	r0, r0, r2
 800073c:	ea81 0103 	eor.w	r1, r1, r3
 8000740:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000744:	bfc2      	ittt	gt
 8000746:	ebd4 050c 	rsbsgt	r5, r4, ip
 800074a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800074e:	bd70      	popgt	{r4, r5, r6, pc}
 8000750:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000754:	f04f 0e00 	mov.w	lr, #0
 8000758:	3c01      	subs	r4, #1
 800075a:	f300 80ab 	bgt.w	80008b4 <__aeabi_dmul+0x238>
 800075e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000762:	bfde      	ittt	le
 8000764:	2000      	movle	r0, #0
 8000766:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800076a:	bd70      	pople	{r4, r5, r6, pc}
 800076c:	f1c4 0400 	rsb	r4, r4, #0
 8000770:	3c20      	subs	r4, #32
 8000772:	da35      	bge.n	80007e0 <__aeabi_dmul+0x164>
 8000774:	340c      	adds	r4, #12
 8000776:	dc1b      	bgt.n	80007b0 <__aeabi_dmul+0x134>
 8000778:	f104 0414 	add.w	r4, r4, #20
 800077c:	f1c4 0520 	rsb	r5, r4, #32
 8000780:	fa00 f305 	lsl.w	r3, r0, r5
 8000784:	fa20 f004 	lsr.w	r0, r0, r4
 8000788:	fa01 f205 	lsl.w	r2, r1, r5
 800078c:	ea40 0002 	orr.w	r0, r0, r2
 8000790:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000794:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000798:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800079c:	fa21 f604 	lsr.w	r6, r1, r4
 80007a0:	eb42 0106 	adc.w	r1, r2, r6
 80007a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a8:	bf08      	it	eq
 80007aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ae:	bd70      	pop	{r4, r5, r6, pc}
 80007b0:	f1c4 040c 	rsb	r4, r4, #12
 80007b4:	f1c4 0520 	rsb	r5, r4, #32
 80007b8:	fa00 f304 	lsl.w	r3, r0, r4
 80007bc:	fa20 f005 	lsr.w	r0, r0, r5
 80007c0:	fa01 f204 	lsl.w	r2, r1, r4
 80007c4:	ea40 0002 	orr.w	r0, r0, r2
 80007c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007d0:	f141 0100 	adc.w	r1, r1, #0
 80007d4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007d8:	bf08      	it	eq
 80007da:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007de:	bd70      	pop	{r4, r5, r6, pc}
 80007e0:	f1c4 0520 	rsb	r5, r4, #32
 80007e4:	fa00 f205 	lsl.w	r2, r0, r5
 80007e8:	ea4e 0e02 	orr.w	lr, lr, r2
 80007ec:	fa20 f304 	lsr.w	r3, r0, r4
 80007f0:	fa01 f205 	lsl.w	r2, r1, r5
 80007f4:	ea43 0302 	orr.w	r3, r3, r2
 80007f8:	fa21 f004 	lsr.w	r0, r1, r4
 80007fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000800:	fa21 f204 	lsr.w	r2, r1, r4
 8000804:	ea20 0002 	bic.w	r0, r0, r2
 8000808:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800080c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000810:	bf08      	it	eq
 8000812:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000816:	bd70      	pop	{r4, r5, r6, pc}
 8000818:	f094 0f00 	teq	r4, #0
 800081c:	d10f      	bne.n	800083e <__aeabi_dmul+0x1c2>
 800081e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000822:	0040      	lsls	r0, r0, #1
 8000824:	eb41 0101 	adc.w	r1, r1, r1
 8000828:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800082c:	bf08      	it	eq
 800082e:	3c01      	subeq	r4, #1
 8000830:	d0f7      	beq.n	8000822 <__aeabi_dmul+0x1a6>
 8000832:	ea41 0106 	orr.w	r1, r1, r6
 8000836:	f095 0f00 	teq	r5, #0
 800083a:	bf18      	it	ne
 800083c:	4770      	bxne	lr
 800083e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000842:	0052      	lsls	r2, r2, #1
 8000844:	eb43 0303 	adc.w	r3, r3, r3
 8000848:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800084c:	bf08      	it	eq
 800084e:	3d01      	subeq	r5, #1
 8000850:	d0f7      	beq.n	8000842 <__aeabi_dmul+0x1c6>
 8000852:	ea43 0306 	orr.w	r3, r3, r6
 8000856:	4770      	bx	lr
 8000858:	ea94 0f0c 	teq	r4, ip
 800085c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000860:	bf18      	it	ne
 8000862:	ea95 0f0c 	teqne	r5, ip
 8000866:	d00c      	beq.n	8000882 <__aeabi_dmul+0x206>
 8000868:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800086c:	bf18      	it	ne
 800086e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000872:	d1d1      	bne.n	8000818 <__aeabi_dmul+0x19c>
 8000874:	ea81 0103 	eor.w	r1, r1, r3
 8000878:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800087c:	f04f 0000 	mov.w	r0, #0
 8000880:	bd70      	pop	{r4, r5, r6, pc}
 8000882:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000886:	bf06      	itte	eq
 8000888:	4610      	moveq	r0, r2
 800088a:	4619      	moveq	r1, r3
 800088c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000890:	d019      	beq.n	80008c6 <__aeabi_dmul+0x24a>
 8000892:	ea94 0f0c 	teq	r4, ip
 8000896:	d102      	bne.n	800089e <__aeabi_dmul+0x222>
 8000898:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800089c:	d113      	bne.n	80008c6 <__aeabi_dmul+0x24a>
 800089e:	ea95 0f0c 	teq	r5, ip
 80008a2:	d105      	bne.n	80008b0 <__aeabi_dmul+0x234>
 80008a4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80008a8:	bf1c      	itt	ne
 80008aa:	4610      	movne	r0, r2
 80008ac:	4619      	movne	r1, r3
 80008ae:	d10a      	bne.n	80008c6 <__aeabi_dmul+0x24a>
 80008b0:	ea81 0103 	eor.w	r1, r1, r3
 80008b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008b8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008bc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80008c0:	f04f 0000 	mov.w	r0, #0
 80008c4:	bd70      	pop	{r4, r5, r6, pc}
 80008c6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008ca:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80008ce:	bd70      	pop	{r4, r5, r6, pc}

080008d0 <__aeabi_ddiv>:
 80008d0:	b570      	push	{r4, r5, r6, lr}
 80008d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008de:	bf1d      	ittte	ne
 80008e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008e4:	ea94 0f0c 	teqne	r4, ip
 80008e8:	ea95 0f0c 	teqne	r5, ip
 80008ec:	f000 f8a7 	bleq	8000a3e <__aeabi_ddiv+0x16e>
 80008f0:	eba4 0405 	sub.w	r4, r4, r5
 80008f4:	ea81 0e03 	eor.w	lr, r1, r3
 80008f8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008fc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000900:	f000 8088 	beq.w	8000a14 <__aeabi_ddiv+0x144>
 8000904:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000908:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800090c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000910:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000914:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000918:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800091c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000920:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000924:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000928:	429d      	cmp	r5, r3
 800092a:	bf08      	it	eq
 800092c:	4296      	cmpeq	r6, r2
 800092e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000932:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000936:	d202      	bcs.n	800093e <__aeabi_ddiv+0x6e>
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	1ab6      	subs	r6, r6, r2
 8000940:	eb65 0503 	sbc.w	r5, r5, r3
 8000944:	085b      	lsrs	r3, r3, #1
 8000946:	ea4f 0232 	mov.w	r2, r2, rrx
 800094a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800094e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000952:	ebb6 0e02 	subs.w	lr, r6, r2
 8000956:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095a:	bf22      	ittt	cs
 800095c:	1ab6      	subcs	r6, r6, r2
 800095e:	4675      	movcs	r5, lr
 8000960:	ea40 000c 	orrcs.w	r0, r0, ip
 8000964:	085b      	lsrs	r3, r3, #1
 8000966:	ea4f 0232 	mov.w	r2, r2, rrx
 800096a:	ebb6 0e02 	subs.w	lr, r6, r2
 800096e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000972:	bf22      	ittt	cs
 8000974:	1ab6      	subcs	r6, r6, r2
 8000976:	4675      	movcs	r5, lr
 8000978:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800097c:	085b      	lsrs	r3, r3, #1
 800097e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000982:	ebb6 0e02 	subs.w	lr, r6, r2
 8000986:	eb75 0e03 	sbcs.w	lr, r5, r3
 800098a:	bf22      	ittt	cs
 800098c:	1ab6      	subcs	r6, r6, r2
 800098e:	4675      	movcs	r5, lr
 8000990:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000994:	085b      	lsrs	r3, r3, #1
 8000996:	ea4f 0232 	mov.w	r2, r2, rrx
 800099a:	ebb6 0e02 	subs.w	lr, r6, r2
 800099e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009a2:	bf22      	ittt	cs
 80009a4:	1ab6      	subcs	r6, r6, r2
 80009a6:	4675      	movcs	r5, lr
 80009a8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80009ac:	ea55 0e06 	orrs.w	lr, r5, r6
 80009b0:	d018      	beq.n	80009e4 <__aeabi_ddiv+0x114>
 80009b2:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80009b6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80009ba:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80009be:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80009c2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80009c6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80009ca:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80009ce:	d1c0      	bne.n	8000952 <__aeabi_ddiv+0x82>
 80009d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009d4:	d10b      	bne.n	80009ee <__aeabi_ddiv+0x11e>
 80009d6:	ea41 0100 	orr.w	r1, r1, r0
 80009da:	f04f 0000 	mov.w	r0, #0
 80009de:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009e2:	e7b6      	b.n	8000952 <__aeabi_ddiv+0x82>
 80009e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009e8:	bf04      	itt	eq
 80009ea:	4301      	orreq	r1, r0
 80009ec:	2000      	moveq	r0, #0
 80009ee:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009f2:	bf88      	it	hi
 80009f4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009f8:	f63f aeaf 	bhi.w	800075a <__aeabi_dmul+0xde>
 80009fc:	ebb5 0c03 	subs.w	ip, r5, r3
 8000a00:	bf04      	itt	eq
 8000a02:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000a06:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000a0a:	f150 0000 	adcs.w	r0, r0, #0
 8000a0e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000a12:	bd70      	pop	{r4, r5, r6, pc}
 8000a14:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000a18:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000a1c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000a20:	bfc2      	ittt	gt
 8000a22:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000a26:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000a2a:	bd70      	popgt	{r4, r5, r6, pc}
 8000a2c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a30:	f04f 0e00 	mov.w	lr, #0
 8000a34:	3c01      	subs	r4, #1
 8000a36:	e690      	b.n	800075a <__aeabi_dmul+0xde>
 8000a38:	ea45 0e06 	orr.w	lr, r5, r6
 8000a3c:	e68d      	b.n	800075a <__aeabi_dmul+0xde>
 8000a3e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a42:	ea94 0f0c 	teq	r4, ip
 8000a46:	bf08      	it	eq
 8000a48:	ea95 0f0c 	teqeq	r5, ip
 8000a4c:	f43f af3b 	beq.w	80008c6 <__aeabi_dmul+0x24a>
 8000a50:	ea94 0f0c 	teq	r4, ip
 8000a54:	d10a      	bne.n	8000a6c <__aeabi_ddiv+0x19c>
 8000a56:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a5a:	f47f af34 	bne.w	80008c6 <__aeabi_dmul+0x24a>
 8000a5e:	ea95 0f0c 	teq	r5, ip
 8000a62:	f47f af25 	bne.w	80008b0 <__aeabi_dmul+0x234>
 8000a66:	4610      	mov	r0, r2
 8000a68:	4619      	mov	r1, r3
 8000a6a:	e72c      	b.n	80008c6 <__aeabi_dmul+0x24a>
 8000a6c:	ea95 0f0c 	teq	r5, ip
 8000a70:	d106      	bne.n	8000a80 <__aeabi_ddiv+0x1b0>
 8000a72:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a76:	f43f aefd 	beq.w	8000874 <__aeabi_dmul+0x1f8>
 8000a7a:	4610      	mov	r0, r2
 8000a7c:	4619      	mov	r1, r3
 8000a7e:	e722      	b.n	80008c6 <__aeabi_dmul+0x24a>
 8000a80:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a84:	bf18      	it	ne
 8000a86:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a8a:	f47f aec5 	bne.w	8000818 <__aeabi_dmul+0x19c>
 8000a8e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a92:	f47f af0d 	bne.w	80008b0 <__aeabi_dmul+0x234>
 8000a96:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a9a:	f47f aeeb 	bne.w	8000874 <__aeabi_dmul+0x1f8>
 8000a9e:	e712      	b.n	80008c6 <__aeabi_dmul+0x24a>

08000aa0 <__gedf2>:
 8000aa0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8000aa4:	e006      	b.n	8000ab4 <__cmpdf2+0x4>
 8000aa6:	bf00      	nop

08000aa8 <__ledf2>:
 8000aa8:	f04f 0c01 	mov.w	ip, #1
 8000aac:	e002      	b.n	8000ab4 <__cmpdf2+0x4>
 8000aae:	bf00      	nop

08000ab0 <__cmpdf2>:
 8000ab0:	f04f 0c01 	mov.w	ip, #1
 8000ab4:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000ab8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000abc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ac0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ac4:	bf18      	it	ne
 8000ac6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000aca:	d01b      	beq.n	8000b04 <__cmpdf2+0x54>
 8000acc:	b001      	add	sp, #4
 8000ace:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000ad2:	bf0c      	ite	eq
 8000ad4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000ad8:	ea91 0f03 	teqne	r1, r3
 8000adc:	bf02      	ittt	eq
 8000ade:	ea90 0f02 	teqeq	r0, r2
 8000ae2:	2000      	moveq	r0, #0
 8000ae4:	4770      	bxeq	lr
 8000ae6:	f110 0f00 	cmn.w	r0, #0
 8000aea:	ea91 0f03 	teq	r1, r3
 8000aee:	bf58      	it	pl
 8000af0:	4299      	cmppl	r1, r3
 8000af2:	bf08      	it	eq
 8000af4:	4290      	cmpeq	r0, r2
 8000af6:	bf2c      	ite	cs
 8000af8:	17d8      	asrcs	r0, r3, #31
 8000afa:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000afe:	f040 0001 	orr.w	r0, r0, #1
 8000b02:	4770      	bx	lr
 8000b04:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b08:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b0c:	d102      	bne.n	8000b14 <__cmpdf2+0x64>
 8000b0e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b12:	d107      	bne.n	8000b24 <__cmpdf2+0x74>
 8000b14:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b18:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b1c:	d1d6      	bne.n	8000acc <__cmpdf2+0x1c>
 8000b1e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b22:	d0d3      	beq.n	8000acc <__cmpdf2+0x1c>
 8000b24:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000b28:	4770      	bx	lr
 8000b2a:	bf00      	nop

08000b2c <__aeabi_cdrcmple>:
 8000b2c:	4684      	mov	ip, r0
 8000b2e:	4610      	mov	r0, r2
 8000b30:	4662      	mov	r2, ip
 8000b32:	468c      	mov	ip, r1
 8000b34:	4619      	mov	r1, r3
 8000b36:	4663      	mov	r3, ip
 8000b38:	e000      	b.n	8000b3c <__aeabi_cdcmpeq>
 8000b3a:	bf00      	nop

08000b3c <__aeabi_cdcmpeq>:
 8000b3c:	b501      	push	{r0, lr}
 8000b3e:	f7ff ffb7 	bl	8000ab0 <__cmpdf2>
 8000b42:	2800      	cmp	r0, #0
 8000b44:	bf48      	it	mi
 8000b46:	f110 0f00 	cmnmi.w	r0, #0
 8000b4a:	bd01      	pop	{r0, pc}

08000b4c <__aeabi_dcmpeq>:
 8000b4c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b50:	f7ff fff4 	bl	8000b3c <__aeabi_cdcmpeq>
 8000b54:	bf0c      	ite	eq
 8000b56:	2001      	moveq	r0, #1
 8000b58:	2000      	movne	r0, #0
 8000b5a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b5e:	bf00      	nop

08000b60 <__aeabi_dcmplt>:
 8000b60:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b64:	f7ff ffea 	bl	8000b3c <__aeabi_cdcmpeq>
 8000b68:	bf34      	ite	cc
 8000b6a:	2001      	movcc	r0, #1
 8000b6c:	2000      	movcs	r0, #0
 8000b6e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b72:	bf00      	nop

08000b74 <__aeabi_dcmple>:
 8000b74:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b78:	f7ff ffe0 	bl	8000b3c <__aeabi_cdcmpeq>
 8000b7c:	bf94      	ite	ls
 8000b7e:	2001      	movls	r0, #1
 8000b80:	2000      	movhi	r0, #0
 8000b82:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b86:	bf00      	nop

08000b88 <__aeabi_dcmpge>:
 8000b88:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b8c:	f7ff ffce 	bl	8000b2c <__aeabi_cdrcmple>
 8000b90:	bf94      	ite	ls
 8000b92:	2001      	movls	r0, #1
 8000b94:	2000      	movhi	r0, #0
 8000b96:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b9a:	bf00      	nop

08000b9c <__aeabi_dcmpgt>:
 8000b9c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ba0:	f7ff ffc4 	bl	8000b2c <__aeabi_cdrcmple>
 8000ba4:	bf34      	ite	cc
 8000ba6:	2001      	movcc	r0, #1
 8000ba8:	2000      	movcs	r0, #0
 8000baa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bae:	bf00      	nop

08000bb0 <__aeabi_dcmpun>:
 8000bb0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000bb4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000bb8:	d102      	bne.n	8000bc0 <__aeabi_dcmpun+0x10>
 8000bba:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000bbe:	d10a      	bne.n	8000bd6 <__aeabi_dcmpun+0x26>
 8000bc0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000bc4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000bc8:	d102      	bne.n	8000bd0 <__aeabi_dcmpun+0x20>
 8000bca:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000bce:	d102      	bne.n	8000bd6 <__aeabi_dcmpun+0x26>
 8000bd0:	f04f 0000 	mov.w	r0, #0
 8000bd4:	4770      	bx	lr
 8000bd6:	f04f 0001 	mov.w	r0, #1
 8000bda:	4770      	bx	lr

08000bdc <__aeabi_d2iz>:
 8000bdc:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000be0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000be4:	d215      	bcs.n	8000c12 <__aeabi_d2iz+0x36>
 8000be6:	d511      	bpl.n	8000c0c <__aeabi_d2iz+0x30>
 8000be8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000bec:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bf0:	d912      	bls.n	8000c18 <__aeabi_d2iz+0x3c>
 8000bf2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bf6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bfa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000bfe:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000c02:	fa23 f002 	lsr.w	r0, r3, r2
 8000c06:	bf18      	it	ne
 8000c08:	4240      	negne	r0, r0
 8000c0a:	4770      	bx	lr
 8000c0c:	f04f 0000 	mov.w	r0, #0
 8000c10:	4770      	bx	lr
 8000c12:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000c16:	d105      	bne.n	8000c24 <__aeabi_d2iz+0x48>
 8000c18:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000c1c:	bf08      	it	eq
 8000c1e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000c22:	4770      	bx	lr
 8000c24:	f04f 0000 	mov.w	r0, #0
 8000c28:	4770      	bx	lr
 8000c2a:	bf00      	nop

08000c2c <__aeabi_d2f>:
 8000c2c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c30:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000c34:	bf24      	itt	cs
 8000c36:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000c3a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000c3e:	d90d      	bls.n	8000c5c <__aeabi_d2f+0x30>
 8000c40:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000c44:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c48:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c4c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000c50:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c54:	bf08      	it	eq
 8000c56:	f020 0001 	biceq.w	r0, r0, #1
 8000c5a:	4770      	bx	lr
 8000c5c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000c60:	d121      	bne.n	8000ca6 <__aeabi_d2f+0x7a>
 8000c62:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000c66:	bfbc      	itt	lt
 8000c68:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000c6c:	4770      	bxlt	lr
 8000c6e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000c72:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c76:	f1c2 0218 	rsb	r2, r2, #24
 8000c7a:	f1c2 0c20 	rsb	ip, r2, #32
 8000c7e:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c82:	fa20 f002 	lsr.w	r0, r0, r2
 8000c86:	bf18      	it	ne
 8000c88:	f040 0001 	orrne.w	r0, r0, #1
 8000c8c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c90:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000c94:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c98:	ea40 000c 	orr.w	r0, r0, ip
 8000c9c:	fa23 f302 	lsr.w	r3, r3, r2
 8000ca0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ca4:	e7cc      	b.n	8000c40 <__aeabi_d2f+0x14>
 8000ca6:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000caa:	d107      	bne.n	8000cbc <__aeabi_d2f+0x90>
 8000cac:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000cb0:	bf1e      	ittt	ne
 8000cb2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000cb6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000cba:	4770      	bxne	lr
 8000cbc:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000cc0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000cc4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000cc8:	4770      	bx	lr
 8000cca:	bf00      	nop

08000ccc <memcpy>:
 8000ccc:	4684      	mov	ip, r0
 8000cce:	ea41 0300 	orr.w	r3, r1, r0
 8000cd2:	f013 0303 	ands.w	r3, r3, #3
 8000cd6:	d16d      	bne.n	8000db4 <memcpy+0xe8>
 8000cd8:	3a40      	subs	r2, #64	; 0x40
 8000cda:	d341      	bcc.n	8000d60 <memcpy+0x94>
 8000cdc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000ce0:	f840 3b04 	str.w	r3, [r0], #4
 8000ce4:	f851 3b04 	ldr.w	r3, [r1], #4
 8000ce8:	f840 3b04 	str.w	r3, [r0], #4
 8000cec:	f851 3b04 	ldr.w	r3, [r1], #4
 8000cf0:	f840 3b04 	str.w	r3, [r0], #4
 8000cf4:	f851 3b04 	ldr.w	r3, [r1], #4
 8000cf8:	f840 3b04 	str.w	r3, [r0], #4
 8000cfc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d00:	f840 3b04 	str.w	r3, [r0], #4
 8000d04:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d08:	f840 3b04 	str.w	r3, [r0], #4
 8000d0c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d10:	f840 3b04 	str.w	r3, [r0], #4
 8000d14:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d18:	f840 3b04 	str.w	r3, [r0], #4
 8000d1c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d20:	f840 3b04 	str.w	r3, [r0], #4
 8000d24:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d28:	f840 3b04 	str.w	r3, [r0], #4
 8000d2c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d30:	f840 3b04 	str.w	r3, [r0], #4
 8000d34:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d38:	f840 3b04 	str.w	r3, [r0], #4
 8000d3c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d40:	f840 3b04 	str.w	r3, [r0], #4
 8000d44:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d48:	f840 3b04 	str.w	r3, [r0], #4
 8000d4c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d50:	f840 3b04 	str.w	r3, [r0], #4
 8000d54:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d58:	f840 3b04 	str.w	r3, [r0], #4
 8000d5c:	3a40      	subs	r2, #64	; 0x40
 8000d5e:	d2bd      	bcs.n	8000cdc <memcpy+0x10>
 8000d60:	3230      	adds	r2, #48	; 0x30
 8000d62:	d311      	bcc.n	8000d88 <memcpy+0xbc>
 8000d64:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d68:	f840 3b04 	str.w	r3, [r0], #4
 8000d6c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d70:	f840 3b04 	str.w	r3, [r0], #4
 8000d74:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d78:	f840 3b04 	str.w	r3, [r0], #4
 8000d7c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d80:	f840 3b04 	str.w	r3, [r0], #4
 8000d84:	3a10      	subs	r2, #16
 8000d86:	d2ed      	bcs.n	8000d64 <memcpy+0x98>
 8000d88:	320c      	adds	r2, #12
 8000d8a:	d305      	bcc.n	8000d98 <memcpy+0xcc>
 8000d8c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000d90:	f840 3b04 	str.w	r3, [r0], #4
 8000d94:	3a04      	subs	r2, #4
 8000d96:	d2f9      	bcs.n	8000d8c <memcpy+0xc0>
 8000d98:	3204      	adds	r2, #4
 8000d9a:	d008      	beq.n	8000dae <memcpy+0xe2>
 8000d9c:	07d2      	lsls	r2, r2, #31
 8000d9e:	bf1c      	itt	ne
 8000da0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000da4:	f800 3b01 	strbne.w	r3, [r0], #1
 8000da8:	d301      	bcc.n	8000dae <memcpy+0xe2>
 8000daa:	880b      	ldrh	r3, [r1, #0]
 8000dac:	8003      	strh	r3, [r0, #0]
 8000dae:	4660      	mov	r0, ip
 8000db0:	4770      	bx	lr
 8000db2:	bf00      	nop
 8000db4:	2a08      	cmp	r2, #8
 8000db6:	d313      	bcc.n	8000de0 <memcpy+0x114>
 8000db8:	078b      	lsls	r3, r1, #30
 8000dba:	d08d      	beq.n	8000cd8 <memcpy+0xc>
 8000dbc:	f010 0303 	ands.w	r3, r0, #3
 8000dc0:	d08a      	beq.n	8000cd8 <memcpy+0xc>
 8000dc2:	f1c3 0304 	rsb	r3, r3, #4
 8000dc6:	1ad2      	subs	r2, r2, r3
 8000dc8:	07db      	lsls	r3, r3, #31
 8000dca:	bf1c      	itt	ne
 8000dcc:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000dd0:	f800 3b01 	strbne.w	r3, [r0], #1
 8000dd4:	d380      	bcc.n	8000cd8 <memcpy+0xc>
 8000dd6:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000dda:	f820 3b02 	strh.w	r3, [r0], #2
 8000dde:	e77b      	b.n	8000cd8 <memcpy+0xc>
 8000de0:	3a04      	subs	r2, #4
 8000de2:	d3d9      	bcc.n	8000d98 <memcpy+0xcc>
 8000de4:	3a01      	subs	r2, #1
 8000de6:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000dea:	f800 3b01 	strb.w	r3, [r0], #1
 8000dee:	d2f9      	bcs.n	8000de4 <memcpy+0x118>
 8000df0:	780b      	ldrb	r3, [r1, #0]
 8000df2:	7003      	strb	r3, [r0, #0]
 8000df4:	784b      	ldrb	r3, [r1, #1]
 8000df6:	7043      	strb	r3, [r0, #1]
 8000df8:	788b      	ldrb	r3, [r1, #2]
 8000dfa:	7083      	strb	r3, [r0, #2]
 8000dfc:	4660      	mov	r0, ip
 8000dfe:	4770      	bx	lr

08000e00 <strlen>:
 8000e00:	f890 f000 	pld	[r0]
 8000e04:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8000e08:	f020 0107 	bic.w	r1, r0, #7
 8000e0c:	f06f 0c00 	mvn.w	ip, #0
 8000e10:	f010 0407 	ands.w	r4, r0, #7
 8000e14:	f891 f020 	pld	[r1, #32]
 8000e18:	f040 8049 	bne.w	8000eae <strlen+0xae>
 8000e1c:	f04f 0400 	mov.w	r4, #0
 8000e20:	f06f 0007 	mvn.w	r0, #7
 8000e24:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000e28:	f891 f040 	pld	[r1, #64]	; 0x40
 8000e2c:	f100 0008 	add.w	r0, r0, #8
 8000e30:	fa82 f24c 	uadd8	r2, r2, ip
 8000e34:	faa4 f28c 	sel	r2, r4, ip
 8000e38:	fa83 f34c 	uadd8	r3, r3, ip
 8000e3c:	faa2 f38c 	sel	r3, r2, ip
 8000e40:	bb4b      	cbnz	r3, 8000e96 <strlen+0x96>
 8000e42:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000e46:	fa82 f24c 	uadd8	r2, r2, ip
 8000e4a:	f100 0008 	add.w	r0, r0, #8
 8000e4e:	faa4 f28c 	sel	r2, r4, ip
 8000e52:	fa83 f34c 	uadd8	r3, r3, ip
 8000e56:	faa2 f38c 	sel	r3, r2, ip
 8000e5a:	b9e3      	cbnz	r3, 8000e96 <strlen+0x96>
 8000e5c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8000e60:	fa82 f24c 	uadd8	r2, r2, ip
 8000e64:	f100 0008 	add.w	r0, r0, #8
 8000e68:	faa4 f28c 	sel	r2, r4, ip
 8000e6c:	fa83 f34c 	uadd8	r3, r3, ip
 8000e70:	faa2 f38c 	sel	r3, r2, ip
 8000e74:	b97b      	cbnz	r3, 8000e96 <strlen+0x96>
 8000e76:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 8000e7a:	f101 0120 	add.w	r1, r1, #32
 8000e7e:	fa82 f24c 	uadd8	r2, r2, ip
 8000e82:	f100 0008 	add.w	r0, r0, #8
 8000e86:	faa4 f28c 	sel	r2, r4, ip
 8000e8a:	fa83 f34c 	uadd8	r3, r3, ip
 8000e8e:	faa2 f38c 	sel	r3, r2, ip
 8000e92:	2b00      	cmp	r3, #0
 8000e94:	d0c6      	beq.n	8000e24 <strlen+0x24>
 8000e96:	2a00      	cmp	r2, #0
 8000e98:	bf04      	itt	eq
 8000e9a:	3004      	addeq	r0, #4
 8000e9c:	461a      	moveq	r2, r3
 8000e9e:	ba12      	rev	r2, r2
 8000ea0:	fab2 f282 	clz	r2, r2
 8000ea4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 8000ea8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8000eac:	4770      	bx	lr
 8000eae:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000eb2:	f004 0503 	and.w	r5, r4, #3
 8000eb6:	f1c4 0000 	rsb	r0, r4, #0
 8000eba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000ebe:	f014 0f04 	tst.w	r4, #4
 8000ec2:	f891 f040 	pld	[r1, #64]	; 0x40
 8000ec6:	fa0c f505 	lsl.w	r5, ip, r5
 8000eca:	ea62 0205 	orn	r2, r2, r5
 8000ece:	bf1c      	itt	ne
 8000ed0:	ea63 0305 	ornne	r3, r3, r5
 8000ed4:	4662      	movne	r2, ip
 8000ed6:	f04f 0400 	mov.w	r4, #0
 8000eda:	e7a9      	b.n	8000e30 <strlen+0x30>
 8000edc:	0000      	movs	r0, r0
	...

08000ee0 <memchr>:
 8000ee0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000ee4:	2a10      	cmp	r2, #16
 8000ee6:	db2b      	blt.n	8000f40 <memchr+0x60>
 8000ee8:	f010 0f07 	tst.w	r0, #7
 8000eec:	d008      	beq.n	8000f00 <memchr+0x20>
 8000eee:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000ef2:	3a01      	subs	r2, #1
 8000ef4:	428b      	cmp	r3, r1
 8000ef6:	d02d      	beq.n	8000f54 <memchr+0x74>
 8000ef8:	f010 0f07 	tst.w	r0, #7
 8000efc:	b342      	cbz	r2, 8000f50 <memchr+0x70>
 8000efe:	d1f6      	bne.n	8000eee <memchr+0xe>
 8000f00:	b4f0      	push	{r4, r5, r6, r7}
 8000f02:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000f06:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 8000f0a:	f022 0407 	bic.w	r4, r2, #7
 8000f0e:	f07f 0700 	mvns.w	r7, #0
 8000f12:	2300      	movs	r3, #0
 8000f14:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000f18:	3c08      	subs	r4, #8
 8000f1a:	ea85 0501 	eor.w	r5, r5, r1
 8000f1e:	ea86 0601 	eor.w	r6, r6, r1
 8000f22:	fa85 f547 	uadd8	r5, r5, r7
 8000f26:	faa3 f587 	sel	r5, r3, r7
 8000f2a:	fa86 f647 	uadd8	r6, r6, r7
 8000f2e:	faa5 f687 	sel	r6, r5, r7
 8000f32:	b98e      	cbnz	r6, 8000f58 <memchr+0x78>
 8000f34:	d1ee      	bne.n	8000f14 <memchr+0x34>
 8000f36:	bcf0      	pop	{r4, r5, r6, r7}
 8000f38:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000f3c:	f002 0207 	and.w	r2, r2, #7
 8000f40:	b132      	cbz	r2, 8000f50 <memchr+0x70>
 8000f42:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000f46:	3a01      	subs	r2, #1
 8000f48:	ea83 0301 	eor.w	r3, r3, r1
 8000f4c:	b113      	cbz	r3, 8000f54 <memchr+0x74>
 8000f4e:	d1f8      	bne.n	8000f42 <memchr+0x62>
 8000f50:	2000      	movs	r0, #0
 8000f52:	4770      	bx	lr
 8000f54:	3801      	subs	r0, #1
 8000f56:	4770      	bx	lr
 8000f58:	2d00      	cmp	r5, #0
 8000f5a:	bf06      	itte	eq
 8000f5c:	4635      	moveq	r5, r6
 8000f5e:	3803      	subeq	r0, #3
 8000f60:	3807      	subne	r0, #7
 8000f62:	f015 0f01 	tst.w	r5, #1
 8000f66:	d107      	bne.n	8000f78 <memchr+0x98>
 8000f68:	3001      	adds	r0, #1
 8000f6a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8000f6e:	bf02      	ittt	eq
 8000f70:	3001      	addeq	r0, #1
 8000f72:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000f76:	3001      	addeq	r0, #1
 8000f78:	bcf0      	pop	{r4, r5, r6, r7}
 8000f7a:	3801      	subs	r0, #1
 8000f7c:	4770      	bx	lr
 8000f7e:	bf00      	nop

08000f80 <__aeabi_uldivmod>:
 8000f80:	b953      	cbnz	r3, 8000f98 <__aeabi_uldivmod+0x18>
 8000f82:	b94a      	cbnz	r2, 8000f98 <__aeabi_uldivmod+0x18>
 8000f84:	2900      	cmp	r1, #0
 8000f86:	bf08      	it	eq
 8000f88:	2800      	cmpeq	r0, #0
 8000f8a:	bf1c      	itt	ne
 8000f8c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000f90:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000f94:	f000 b972 	b.w	800127c <__aeabi_idiv0>
 8000f98:	f1ad 0c08 	sub.w	ip, sp, #8
 8000f9c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000fa0:	f000 f806 	bl	8000fb0 <__udivmoddi4>
 8000fa4:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000fa8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000fac:	b004      	add	sp, #16
 8000fae:	4770      	bx	lr

08000fb0 <__udivmoddi4>:
 8000fb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000fb4:	9e08      	ldr	r6, [sp, #32]
 8000fb6:	4604      	mov	r4, r0
 8000fb8:	4688      	mov	r8, r1
 8000fba:	2b00      	cmp	r3, #0
 8000fbc:	d14b      	bne.n	8001056 <__udivmoddi4+0xa6>
 8000fbe:	428a      	cmp	r2, r1
 8000fc0:	4615      	mov	r5, r2
 8000fc2:	d967      	bls.n	8001094 <__udivmoddi4+0xe4>
 8000fc4:	fab2 f282 	clz	r2, r2
 8000fc8:	b14a      	cbz	r2, 8000fde <__udivmoddi4+0x2e>
 8000fca:	f1c2 0720 	rsb	r7, r2, #32
 8000fce:	fa01 f302 	lsl.w	r3, r1, r2
 8000fd2:	fa20 f707 	lsr.w	r7, r0, r7
 8000fd6:	4095      	lsls	r5, r2
 8000fd8:	ea47 0803 	orr.w	r8, r7, r3
 8000fdc:	4094      	lsls	r4, r2
 8000fde:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000fe2:	0c23      	lsrs	r3, r4, #16
 8000fe4:	fbb8 f7fe 	udiv	r7, r8, lr
 8000fe8:	fa1f fc85 	uxth.w	ip, r5
 8000fec:	fb0e 8817 	mls	r8, lr, r7, r8
 8000ff0:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000ff4:	fb07 f10c 	mul.w	r1, r7, ip
 8000ff8:	4299      	cmp	r1, r3
 8000ffa:	d909      	bls.n	8001010 <__udivmoddi4+0x60>
 8000ffc:	18eb      	adds	r3, r5, r3
 8000ffe:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 8001002:	f080 811b 	bcs.w	800123c <__udivmoddi4+0x28c>
 8001006:	4299      	cmp	r1, r3
 8001008:	f240 8118 	bls.w	800123c <__udivmoddi4+0x28c>
 800100c:	3f02      	subs	r7, #2
 800100e:	442b      	add	r3, r5
 8001010:	1a5b      	subs	r3, r3, r1
 8001012:	b2a4      	uxth	r4, r4
 8001014:	fbb3 f0fe 	udiv	r0, r3, lr
 8001018:	fb0e 3310 	mls	r3, lr, r0, r3
 800101c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8001020:	fb00 fc0c 	mul.w	ip, r0, ip
 8001024:	45a4      	cmp	ip, r4
 8001026:	d909      	bls.n	800103c <__udivmoddi4+0x8c>
 8001028:	192c      	adds	r4, r5, r4
 800102a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800102e:	f080 8107 	bcs.w	8001240 <__udivmoddi4+0x290>
 8001032:	45a4      	cmp	ip, r4
 8001034:	f240 8104 	bls.w	8001240 <__udivmoddi4+0x290>
 8001038:	3802      	subs	r0, #2
 800103a:	442c      	add	r4, r5
 800103c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8001040:	eba4 040c 	sub.w	r4, r4, ip
 8001044:	2700      	movs	r7, #0
 8001046:	b11e      	cbz	r6, 8001050 <__udivmoddi4+0xa0>
 8001048:	40d4      	lsrs	r4, r2
 800104a:	2300      	movs	r3, #0
 800104c:	e9c6 4300 	strd	r4, r3, [r6]
 8001050:	4639      	mov	r1, r7
 8001052:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001056:	428b      	cmp	r3, r1
 8001058:	d909      	bls.n	800106e <__udivmoddi4+0xbe>
 800105a:	2e00      	cmp	r6, #0
 800105c:	f000 80eb 	beq.w	8001236 <__udivmoddi4+0x286>
 8001060:	2700      	movs	r7, #0
 8001062:	e9c6 0100 	strd	r0, r1, [r6]
 8001066:	4638      	mov	r0, r7
 8001068:	4639      	mov	r1, r7
 800106a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800106e:	fab3 f783 	clz	r7, r3
 8001072:	2f00      	cmp	r7, #0
 8001074:	d147      	bne.n	8001106 <__udivmoddi4+0x156>
 8001076:	428b      	cmp	r3, r1
 8001078:	d302      	bcc.n	8001080 <__udivmoddi4+0xd0>
 800107a:	4282      	cmp	r2, r0
 800107c:	f200 80fa 	bhi.w	8001274 <__udivmoddi4+0x2c4>
 8001080:	1a84      	subs	r4, r0, r2
 8001082:	eb61 0303 	sbc.w	r3, r1, r3
 8001086:	2001      	movs	r0, #1
 8001088:	4698      	mov	r8, r3
 800108a:	2e00      	cmp	r6, #0
 800108c:	d0e0      	beq.n	8001050 <__udivmoddi4+0xa0>
 800108e:	e9c6 4800 	strd	r4, r8, [r6]
 8001092:	e7dd      	b.n	8001050 <__udivmoddi4+0xa0>
 8001094:	b902      	cbnz	r2, 8001098 <__udivmoddi4+0xe8>
 8001096:	deff      	udf	#255	; 0xff
 8001098:	fab2 f282 	clz	r2, r2
 800109c:	2a00      	cmp	r2, #0
 800109e:	f040 808f 	bne.w	80011c0 <__udivmoddi4+0x210>
 80010a2:	1b49      	subs	r1, r1, r5
 80010a4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80010a8:	fa1f f885 	uxth.w	r8, r5
 80010ac:	2701      	movs	r7, #1
 80010ae:	fbb1 fcfe 	udiv	ip, r1, lr
 80010b2:	0c23      	lsrs	r3, r4, #16
 80010b4:	fb0e 111c 	mls	r1, lr, ip, r1
 80010b8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80010bc:	fb08 f10c 	mul.w	r1, r8, ip
 80010c0:	4299      	cmp	r1, r3
 80010c2:	d907      	bls.n	80010d4 <__udivmoddi4+0x124>
 80010c4:	18eb      	adds	r3, r5, r3
 80010c6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80010ca:	d202      	bcs.n	80010d2 <__udivmoddi4+0x122>
 80010cc:	4299      	cmp	r1, r3
 80010ce:	f200 80cd 	bhi.w	800126c <__udivmoddi4+0x2bc>
 80010d2:	4684      	mov	ip, r0
 80010d4:	1a59      	subs	r1, r3, r1
 80010d6:	b2a3      	uxth	r3, r4
 80010d8:	fbb1 f0fe 	udiv	r0, r1, lr
 80010dc:	fb0e 1410 	mls	r4, lr, r0, r1
 80010e0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80010e4:	fb08 f800 	mul.w	r8, r8, r0
 80010e8:	45a0      	cmp	r8, r4
 80010ea:	d907      	bls.n	80010fc <__udivmoddi4+0x14c>
 80010ec:	192c      	adds	r4, r5, r4
 80010ee:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80010f2:	d202      	bcs.n	80010fa <__udivmoddi4+0x14a>
 80010f4:	45a0      	cmp	r8, r4
 80010f6:	f200 80b6 	bhi.w	8001266 <__udivmoddi4+0x2b6>
 80010fa:	4618      	mov	r0, r3
 80010fc:	eba4 0408 	sub.w	r4, r4, r8
 8001100:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8001104:	e79f      	b.n	8001046 <__udivmoddi4+0x96>
 8001106:	f1c7 0c20 	rsb	ip, r7, #32
 800110a:	40bb      	lsls	r3, r7
 800110c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8001110:	ea4e 0e03 	orr.w	lr, lr, r3
 8001114:	fa01 f407 	lsl.w	r4, r1, r7
 8001118:	fa20 f50c 	lsr.w	r5, r0, ip
 800111c:	fa21 f30c 	lsr.w	r3, r1, ip
 8001120:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8001124:	4325      	orrs	r5, r4
 8001126:	fbb3 f9f8 	udiv	r9, r3, r8
 800112a:	0c2c      	lsrs	r4, r5, #16
 800112c:	fb08 3319 	mls	r3, r8, r9, r3
 8001130:	fa1f fa8e 	uxth.w	sl, lr
 8001134:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8001138:	fb09 f40a 	mul.w	r4, r9, sl
 800113c:	429c      	cmp	r4, r3
 800113e:	fa02 f207 	lsl.w	r2, r2, r7
 8001142:	fa00 f107 	lsl.w	r1, r0, r7
 8001146:	d90b      	bls.n	8001160 <__udivmoddi4+0x1b0>
 8001148:	eb1e 0303 	adds.w	r3, lr, r3
 800114c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8001150:	f080 8087 	bcs.w	8001262 <__udivmoddi4+0x2b2>
 8001154:	429c      	cmp	r4, r3
 8001156:	f240 8084 	bls.w	8001262 <__udivmoddi4+0x2b2>
 800115a:	f1a9 0902 	sub.w	r9, r9, #2
 800115e:	4473      	add	r3, lr
 8001160:	1b1b      	subs	r3, r3, r4
 8001162:	b2ad      	uxth	r5, r5
 8001164:	fbb3 f0f8 	udiv	r0, r3, r8
 8001168:	fb08 3310 	mls	r3, r8, r0, r3
 800116c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8001170:	fb00 fa0a 	mul.w	sl, r0, sl
 8001174:	45a2      	cmp	sl, r4
 8001176:	d908      	bls.n	800118a <__udivmoddi4+0x1da>
 8001178:	eb1e 0404 	adds.w	r4, lr, r4
 800117c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8001180:	d26b      	bcs.n	800125a <__udivmoddi4+0x2aa>
 8001182:	45a2      	cmp	sl, r4
 8001184:	d969      	bls.n	800125a <__udivmoddi4+0x2aa>
 8001186:	3802      	subs	r0, #2
 8001188:	4474      	add	r4, lr
 800118a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800118e:	fba0 8902 	umull	r8, r9, r0, r2
 8001192:	eba4 040a 	sub.w	r4, r4, sl
 8001196:	454c      	cmp	r4, r9
 8001198:	46c2      	mov	sl, r8
 800119a:	464b      	mov	r3, r9
 800119c:	d354      	bcc.n	8001248 <__udivmoddi4+0x298>
 800119e:	d051      	beq.n	8001244 <__udivmoddi4+0x294>
 80011a0:	2e00      	cmp	r6, #0
 80011a2:	d069      	beq.n	8001278 <__udivmoddi4+0x2c8>
 80011a4:	ebb1 050a 	subs.w	r5, r1, sl
 80011a8:	eb64 0403 	sbc.w	r4, r4, r3
 80011ac:	fa04 fc0c 	lsl.w	ip, r4, ip
 80011b0:	40fd      	lsrs	r5, r7
 80011b2:	40fc      	lsrs	r4, r7
 80011b4:	ea4c 0505 	orr.w	r5, ip, r5
 80011b8:	e9c6 5400 	strd	r5, r4, [r6]
 80011bc:	2700      	movs	r7, #0
 80011be:	e747      	b.n	8001050 <__udivmoddi4+0xa0>
 80011c0:	f1c2 0320 	rsb	r3, r2, #32
 80011c4:	fa20 f703 	lsr.w	r7, r0, r3
 80011c8:	4095      	lsls	r5, r2
 80011ca:	fa01 f002 	lsl.w	r0, r1, r2
 80011ce:	fa21 f303 	lsr.w	r3, r1, r3
 80011d2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80011d6:	4338      	orrs	r0, r7
 80011d8:	0c01      	lsrs	r1, r0, #16
 80011da:	fbb3 f7fe 	udiv	r7, r3, lr
 80011de:	fa1f f885 	uxth.w	r8, r5
 80011e2:	fb0e 3317 	mls	r3, lr, r7, r3
 80011e6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80011ea:	fb07 f308 	mul.w	r3, r7, r8
 80011ee:	428b      	cmp	r3, r1
 80011f0:	fa04 f402 	lsl.w	r4, r4, r2
 80011f4:	d907      	bls.n	8001206 <__udivmoddi4+0x256>
 80011f6:	1869      	adds	r1, r5, r1
 80011f8:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 80011fc:	d22f      	bcs.n	800125e <__udivmoddi4+0x2ae>
 80011fe:	428b      	cmp	r3, r1
 8001200:	d92d      	bls.n	800125e <__udivmoddi4+0x2ae>
 8001202:	3f02      	subs	r7, #2
 8001204:	4429      	add	r1, r5
 8001206:	1acb      	subs	r3, r1, r3
 8001208:	b281      	uxth	r1, r0
 800120a:	fbb3 f0fe 	udiv	r0, r3, lr
 800120e:	fb0e 3310 	mls	r3, lr, r0, r3
 8001212:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8001216:	fb00 f308 	mul.w	r3, r0, r8
 800121a:	428b      	cmp	r3, r1
 800121c:	d907      	bls.n	800122e <__udivmoddi4+0x27e>
 800121e:	1869      	adds	r1, r5, r1
 8001220:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8001224:	d217      	bcs.n	8001256 <__udivmoddi4+0x2a6>
 8001226:	428b      	cmp	r3, r1
 8001228:	d915      	bls.n	8001256 <__udivmoddi4+0x2a6>
 800122a:	3802      	subs	r0, #2
 800122c:	4429      	add	r1, r5
 800122e:	1ac9      	subs	r1, r1, r3
 8001230:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8001234:	e73b      	b.n	80010ae <__udivmoddi4+0xfe>
 8001236:	4637      	mov	r7, r6
 8001238:	4630      	mov	r0, r6
 800123a:	e709      	b.n	8001050 <__udivmoddi4+0xa0>
 800123c:	4607      	mov	r7, r0
 800123e:	e6e7      	b.n	8001010 <__udivmoddi4+0x60>
 8001240:	4618      	mov	r0, r3
 8001242:	e6fb      	b.n	800103c <__udivmoddi4+0x8c>
 8001244:	4541      	cmp	r1, r8
 8001246:	d2ab      	bcs.n	80011a0 <__udivmoddi4+0x1f0>
 8001248:	ebb8 0a02 	subs.w	sl, r8, r2
 800124c:	eb69 020e 	sbc.w	r2, r9, lr
 8001250:	3801      	subs	r0, #1
 8001252:	4613      	mov	r3, r2
 8001254:	e7a4      	b.n	80011a0 <__udivmoddi4+0x1f0>
 8001256:	4660      	mov	r0, ip
 8001258:	e7e9      	b.n	800122e <__udivmoddi4+0x27e>
 800125a:	4618      	mov	r0, r3
 800125c:	e795      	b.n	800118a <__udivmoddi4+0x1da>
 800125e:	4667      	mov	r7, ip
 8001260:	e7d1      	b.n	8001206 <__udivmoddi4+0x256>
 8001262:	4681      	mov	r9, r0
 8001264:	e77c      	b.n	8001160 <__udivmoddi4+0x1b0>
 8001266:	3802      	subs	r0, #2
 8001268:	442c      	add	r4, r5
 800126a:	e747      	b.n	80010fc <__udivmoddi4+0x14c>
 800126c:	f1ac 0c02 	sub.w	ip, ip, #2
 8001270:	442b      	add	r3, r5
 8001272:	e72f      	b.n	80010d4 <__udivmoddi4+0x124>
 8001274:	4638      	mov	r0, r7
 8001276:	e708      	b.n	800108a <__udivmoddi4+0xda>
 8001278:	4637      	mov	r7, r6
 800127a:	e6e9      	b.n	8001050 <__udivmoddi4+0xa0>

0800127c <__aeabi_idiv0>:
 800127c:	4770      	bx	lr
 800127e:	bf00      	nop

08001280 <chTMStartMeasurementX.constprop.27>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001280:	4b01      	ldr	r3, [pc, #4]	; (8001288 <chTMStartMeasurementX.constprop.27+0x8>)
 8001282:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001284:	6083      	str	r3, [r0, #8]
}
 8001286:	4770      	bx	lr
 8001288:	e0001000 	.word	0xe0001000
 800128c:	00000000 	.word	0x00000000

08001290 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8001290:	4a02      	ldr	r2, [pc, #8]	; (800129c <notify1+0xc>)
 8001292:	6813      	ldr	r3, [r2, #0]
 8001294:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001298:	6013      	str	r3, [r2, #0]
}
 800129a:	4770      	bx	lr
 800129c:	40013800 	.word	0x40013800

080012a0 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80012a0:	4a02      	ldr	r2, [pc, #8]	; (80012ac <notify2+0xc>)
 80012a2:	6813      	ldr	r3, [r2, #0]
 80012a4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80012a8:	6013      	str	r3, [r2, #0]
}
 80012aa:	4770      	bx	lr
 80012ac:	40004400 	.word	0x40004400

080012b0 <write_flash>:

}

void unlock_flash()
{
    if (FLASH->CR & FLASH_CR_LOCK){
 80012b0:	4b18      	ldr	r3, [pc, #96]	; (8001314 <write_flash+0x64>)
 80012b2:	691a      	ldr	r2, [r3, #16]
 80012b4:	0612      	lsls	r2, r2, #24
    
}


void write_flash(uint16_t value,uint16_t* flash)
{
 80012b6:	b410      	push	{r4}
    if (FLASH->CR & FLASH_CR_LOCK){
 80012b8:	d503      	bpl.n	80012c2 <write_flash+0x12>
	FLASH->KEYR = 0x45670123;
 80012ba:	4c17      	ldr	r4, [pc, #92]	; (8001318 <write_flash+0x68>)
	FLASH->KEYR = 0xCDEF89AB;
 80012bc:	4a17      	ldr	r2, [pc, #92]	; (800131c <write_flash+0x6c>)
	FLASH->KEYR = 0x45670123;
 80012be:	605c      	str	r4, [r3, #4]
	FLASH->KEYR = 0xCDEF89AB;
 80012c0:	605a      	str	r2, [r3, #4]
    FLASH->CR |= FLASH_CR_PER;             // set page erase
 80012c2:	691c      	ldr	r4, [r3, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80012c4:	4a13      	ldr	r2, [pc, #76]	; (8001314 <write_flash+0x64>)
    FLASH->CR |= FLASH_CR_PER;             // set page erase
 80012c6:	f044 0402 	orr.w	r4, r4, #2
 80012ca:	611c      	str	r4, [r3, #16]
    FLASH->AR = flash;                     // set page to flash
 80012cc:	6159      	str	r1, [r3, #20]
    FLASH->CR |= FLASH_CR_STRT;            // start erasing
 80012ce:	691c      	ldr	r4, [r3, #16]
 80012d0:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 80012d4:	611c      	str	r4, [r3, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80012d6:	68d3      	ldr	r3, [r2, #12]
 80012d8:	07dc      	lsls	r4, r3, #31
 80012da:	d4fc      	bmi.n	80012d6 <write_flash+0x26>
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 80012dc:	68d4      	ldr	r4, [r2, #12]
					   // things up
    
    *flash = value;                        // actually write the value

    
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80012de:	4b0d      	ldr	r3, [pc, #52]	; (8001314 <write_flash+0x64>)
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 80012e0:	f044 0420 	orr.w	r4, r4, #32
 80012e4:	60d4      	str	r4, [r2, #12]
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PER)); // found note online that you must
 80012e6:	6914      	ldr	r4, [r2, #16]
 80012e8:	f024 0402 	bic.w	r4, r4, #2
 80012ec:	6114      	str	r4, [r2, #16]
    SET_BIT(FLASH->CR, (FLASH_CR_PG));     // we are already unlocked, trying
 80012ee:	6914      	ldr	r4, [r2, #16]
 80012f0:	f044 0401 	orr.w	r4, r4, #1
 80012f4:	6114      	str	r4, [r2, #16]
    *flash = value;                        // actually write the value
 80012f6:	8008      	strh	r0, [r1, #0]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80012f8:	68da      	ldr	r2, [r3, #12]
 80012fa:	07d2      	lsls	r2, r2, #31
 80012fc:	d4fc      	bmi.n	80012f8 <write_flash+0x48>
							// watchdog should
							// reset if it gets
							// stuck
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 80012fe:	691a      	ldr	r2, [r3, #16]
					   // again
    
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
}
 8001300:	f85d 4b04 	ldr.w	r4, [sp], #4
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 8001304:	f022 0201 	bic.w	r2, r2, #1
 8001308:	611a      	str	r2, [r3, #16]
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 800130a:	68da      	ldr	r2, [r3, #12]
 800130c:	f042 0220 	orr.w	r2, r2, #32
 8001310:	60da      	str	r2, [r3, #12]
}
 8001312:	4770      	bx	lr
 8001314:	40022000 	.word	0x40022000
 8001318:	45670123 	.word	0x45670123
 800131c:	cdef89ab 	.word	0xcdef89ab

08001320 <chTMStopMeasurementX>:
 8001320:	4b0e      	ldr	r3, [pc, #56]	; (800135c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001322:	4a0f      	ldr	r2, [pc, #60]	; (8001360 <chTMStopMeasurementX+0x40>)
 8001324:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 8001326:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001328:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 800132a:	6884      	ldr	r4, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800132c:	f8d2 6884 	ldr.w	r6, [r2, #2180]	; 0x884
  if (tmp->last > tmp->worst) {
 8001330:	6842      	ldr	r2, [r0, #4]
  tmp->last = (now - tmp->last) - offset;
 8001332:	1b1b      	subs	r3, r3, r4
  tmp->cumulative += (rttime_t)tmp->last;
 8001334:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001338:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 800133a:	18e6      	adds	r6, r4, r3
 800133c:	f145 0700 	adc.w	r7, r5, #0
  if (tmp->last > tmp->worst) {
 8001340:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8001342:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8001344:	bf88      	it	hi
 8001346:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8001348:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 800134a:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800134c:	e9c0 6704 	strd	r6, r7, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001350:	e9c0 3102 	strd	r3, r1, [r0, #8]
    tmp->best = tmp->last;
 8001354:	bf38      	it	cc
 8001356:	6003      	strcc	r3, [r0, #0]
}
 8001358:	bcf0      	pop	{r4, r5, r6, r7}
 800135a:	4770      	bx	lr
 800135c:	e0001000 	.word	0xe0001000
 8001360:	2000159c 	.word	0x2000159c
	...

08001370 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8001370:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8001372:	4a0b      	ldr	r2, [pc, #44]	; (80013a0 <trace_next+0x30>)
 8001374:	480b      	ldr	r0, [pc, #44]	; (80013a4 <trace_next+0x34>)
 8001376:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001378:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800137c:	6819      	ldr	r1, [r3, #0]
 800137e:	6a64      	ldr	r4, [r4, #36]	; 0x24
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8001380:	605c      	str	r4, [r3, #4]
 8001382:	6840      	ldr	r0, [r0, #4]
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8001384:	f360 211f 	bfi	r1, r0, #8, #24
 8001388:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800138c:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 8001390:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8001392:	bf28      	it	cs
 8001394:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8001398:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800139a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800139e:	4770      	bx	lr
 80013a0:	2000159c 	.word	0x2000159c
 80013a4:	e0001000 	.word	0xe0001000
	...

080013b0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80013b0:	b508      	push	{r3, lr}
 80013b2:	4605      	mov	r5, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013b4:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 80013b6:	4c06      	ldr	r4, [pc, #24]	; (80013d0 <chSysHalt+0x20>)
 80013b8:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80013ba:	075b      	lsls	r3, r3, #29
 80013bc:	d501      	bpl.n	80013c2 <chSysHalt+0x12>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80013be:	62e5      	str	r5, [r4, #44]	; 0x2c
 80013c0:	e7fe      	b.n	80013c0 <chSysHalt+0x10>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80013c2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80013c4:	2204      	movs	r2, #4
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 80013c6:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80013c8:	701a      	strb	r2, [r3, #0]
    trace_next();
 80013ca:	f7ff ffd1 	bl	8001370 <trace_next>
 80013ce:	e7f6      	b.n	80013be <chSysHalt+0xe>
 80013d0:	2000159c 	.word	0x2000159c
	...

080013e0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80013e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80013e2:	4b05      	ldr	r3, [pc, #20]	; (80013f8 <chDbgCheckClassS+0x18>)
 80013e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80013e6:	b91a      	cbnz	r2, 80013f0 <chDbgCheckClassS+0x10>
 80013e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80013ea:	2b00      	cmp	r3, #0
 80013ec:	dd00      	ble.n	80013f0 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 80013ee:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 80013f0:	4802      	ldr	r0, [pc, #8]	; (80013fc <chDbgCheckClassS+0x1c>)
 80013f2:	f7ff ffdd 	bl	80013b0 <chSysHalt>
 80013f6:	bf00      	nop
 80013f8:	2000159c 	.word	0x2000159c
 80013fc:	0800e714 	.word	0x0800e714

08001400 <spi_lld_serve_tx_interrupt>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001400:	070a      	lsls	r2, r1, #28
 8001402:	d400      	bmi.n	8001406 <spi_lld_serve_tx_interrupt+0x6>
 8001404:	4770      	bx	lr
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001406:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8001408:	4801      	ldr	r0, [pc, #4]	; (8001410 <spi_lld_serve_tx_interrupt+0x10>)
 800140a:	f7ff ffd1 	bl	80013b0 <chSysHalt>
 800140e:	bf00      	nop
 8001410:	0801d99c 	.word	0x0801d99c
	...

08001420 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
 8001420:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001422:	4b05      	ldr	r3, [pc, #20]	; (8001438 <chDbgCheckClassI+0x18>)
 8001424:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001426:	2a00      	cmp	r2, #0
 8001428:	db03      	blt.n	8001432 <chDbgCheckClassI+0x12>
 800142a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800142c:	2b00      	cmp	r3, #0
 800142e:	dd00      	ble.n	8001432 <chDbgCheckClassI+0x12>
}
 8001430:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8001432:	4802      	ldr	r0, [pc, #8]	; (800143c <chDbgCheckClassI+0x1c>)
 8001434:	f7ff ffbc 	bl	80013b0 <chSysHalt>
 8001438:	2000159c 	.word	0x2000159c
 800143c:	0800e70c 	.word	0x0800e70c

08001440 <chCoreAllocAlignedI>:
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001440:	4b12      	ldr	r3, [pc, #72]	; (800148c <chCoreAllocAlignedI+0x4c>)
 8001442:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001444:	2a00      	cmp	r2, #0
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8001446:	b570      	push	{r4, r5, r6, lr}
 8001448:	db17      	blt.n	800147a <chCoreAllocAlignedI+0x3a>
 800144a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800144c:	2b00      	cmp	r3, #0
 800144e:	dd14      	ble.n	800147a <chCoreAllocAlignedI+0x3a>
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001450:	b1b1      	cbz	r1, 8001480 <chCoreAllocAlignedI+0x40>
 8001452:	1e4b      	subs	r3, r1, #1
 8001454:	ea11 0603 	ands.w	r6, r1, r3
 8001458:	d112      	bne.n	8001480 <chCoreAllocAlignedI+0x40>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800145a:	4c0d      	ldr	r4, [pc, #52]	; (8001490 <chCoreAllocAlignedI+0x50>)
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800145c:	e9d4 5200 	ldrd	r5, r2, [r4]
  size = MEM_ALIGN_NEXT(size, align);
 8001460:	4403      	add	r3, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001462:	1e68      	subs	r0, r5, #1
 8001464:	4408      	add	r0, r1
  size = MEM_ALIGN_NEXT(size, align);
 8001466:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001468:	4008      	ands	r0, r1
  size = MEM_ALIGN_NEXT(size, align);
 800146a:	4019      	ands	r1, r3
  next = p + size;
 800146c:	4401      	add	r1, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800146e:	4291      	cmp	r1, r2
 8001470:	d809      	bhi.n	8001486 <chCoreAllocAlignedI+0x46>
 8001472:	428d      	cmp	r5, r1
 8001474:	d807      	bhi.n	8001486 <chCoreAllocAlignedI+0x46>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8001476:	6021      	str	r1, [r4, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8001478:	bd70      	pop	{r4, r5, r6, pc}
    chSysHalt("SV#10");
 800147a:	4806      	ldr	r0, [pc, #24]	; (8001494 <chCoreAllocAlignedI+0x54>)
 800147c:	f7ff ff98 	bl	80013b0 <chSysHalt>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001480:	4805      	ldr	r0, [pc, #20]	; (8001498 <chCoreAllocAlignedI+0x58>)
 8001482:	f7ff ff95 	bl	80013b0 <chSysHalt>
    return NULL;
 8001486:	4630      	mov	r0, r6
 8001488:	bd70      	pop	{r4, r5, r6, pc}
 800148a:	bf00      	nop
 800148c:	2000159c 	.word	0x2000159c
 8001490:	20001fc8 	.word	0x20001fc8
 8001494:	0800e70c 	.word	0x0800e70c
 8001498:	0800e290 	.word	0x0800e290
 800149c:	00000000 	.word	0x00000000

080014a0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 80014a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80014a2:	2320      	movs	r3, #32
 80014a4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80014a8:	4b1b      	ldr	r3, [pc, #108]	; (8001518 <chCoreAllocAlignedWithOffset+0x78>)
 80014aa:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80014ac:	b90c      	cbnz	r4, 80014b2 <chCoreAllocAlignedWithOffset+0x12>
 80014ae:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80014b0:	b114      	cbz	r4, 80014b8 <chCoreAllocAlignedWithOffset+0x18>
    chSysHalt("SV#4");
 80014b2:	481a      	ldr	r0, [pc, #104]	; (800151c <chCoreAllocAlignedWithOffset+0x7c>)
 80014b4:	f7ff ff7c 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 80014b8:	2401      	movs	r4, #1
 80014ba:	635c      	str	r4, [r3, #52]	; 0x34
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80014bc:	b321      	cbz	r1, 8001508 <chCoreAllocAlignedWithOffset+0x68>
 80014be:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
 80014c2:	ea11 070e 	ands.w	r7, r1, lr
 80014c6:	d11f      	bne.n	8001508 <chCoreAllocAlignedWithOffset+0x68>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80014c8:	4d15      	ldr	r5, [pc, #84]	; (8001520 <chCoreAllocAlignedWithOffset+0x80>)
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80014ca:	e9d5 6400 	ldrd	r6, r4, [r5]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80014ce:	eb06 0c02 	add.w	ip, r6, r2
  size = MEM_ALIGN_NEXT(size, align);
 80014d2:	4249      	negs	r1, r1
 80014d4:	eb00 020e 	add.w	r2, r0, lr
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80014d8:	eb0c 000e 	add.w	r0, ip, lr
  size = MEM_ALIGN_NEXT(size, align);
 80014dc:	400a      	ands	r2, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80014de:	4008      	ands	r0, r1
  next = p + size;
 80014e0:	4402      	add	r2, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80014e2:	42a2      	cmp	r2, r4
 80014e4:	d813      	bhi.n	800150e <chCoreAllocAlignedWithOffset+0x6e>
 80014e6:	4296      	cmp	r6, r2
 80014e8:	d811      	bhi.n	800150e <chCoreAllocAlignedWithOffset+0x6e>
  ch_memcore.nextmem = next;
 80014ea:	602a      	str	r2, [r5, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80014ec:	681a      	ldr	r2, [r3, #0]
  _dbg_leave_lock();
 80014ee:	2100      	movs	r1, #0
 80014f0:	429a      	cmp	r2, r3
 80014f2:	6359      	str	r1, [r3, #52]	; 0x34
 80014f4:	d004      	beq.n	8001500 <chCoreAllocAlignedWithOffset+0x60>
 80014f6:	6999      	ldr	r1, [r3, #24]
 80014f8:	6893      	ldr	r3, [r2, #8]
 80014fa:	688a      	ldr	r2, [r1, #8]
 80014fc:	429a      	cmp	r2, r3
 80014fe:	d308      	bcc.n	8001512 <chCoreAllocAlignedWithOffset+0x72>
 8001500:	2300      	movs	r3, #0
 8001502:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8001506:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001508:	4806      	ldr	r0, [pc, #24]	; (8001524 <chCoreAllocAlignedWithOffset+0x84>)
 800150a:	f7ff ff51 	bl	80013b0 <chSysHalt>
    return NULL;
 800150e:	4638      	mov	r0, r7
 8001510:	e7ec      	b.n	80014ec <chCoreAllocAlignedWithOffset+0x4c>
 8001512:	4805      	ldr	r0, [pc, #20]	; (8001528 <chCoreAllocAlignedWithOffset+0x88>)
 8001514:	f7ff ff4c 	bl	80013b0 <chSysHalt>
 8001518:	2000159c 	.word	0x2000159c
 800151c:	0800e704 	.word	0x0800e704
 8001520:	20001fc8 	.word	0x20001fc8
 8001524:	0800e290 	.word	0x0800e290
 8001528:	0800e208 	.word	0x0800e208
 800152c:	00000000 	.word	0x00000000

08001530 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001530:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001532:	4b11      	ldr	r3, [pc, #68]	; (8001578 <chSchReadyI+0x48>)
 8001534:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001536:	2900      	cmp	r1, #0
 8001538:	db18      	blt.n	800156c <chSchReadyI+0x3c>
 800153a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800153c:	2900      	cmp	r1, #0
 800153e:	dd15      	ble.n	800156c <chSchReadyI+0x3c>
 8001540:	4602      	mov	r2, r0
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8001542:	b1b0      	cbz	r0, 8001572 <chSchReadyI+0x42>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001544:	f890 1020 	ldrb.w	r1, [r0, #32]
 8001548:	b199      	cbz	r1, 8001572 <chSchReadyI+0x42>
 800154a:	290f      	cmp	r1, #15
 800154c:	d011      	beq.n	8001572 <chSchReadyI+0x42>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800154e:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 8001550:	6880      	ldr	r0, [r0, #8]
  tp->state = CH_STATE_READY;
 8001552:	f882 1020 	strb.w	r1, [r2, #32]
    cp = cp->queue.next;
 8001556:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001558:	6899      	ldr	r1, [r3, #8]
 800155a:	4281      	cmp	r1, r0
 800155c:	d2fb      	bcs.n	8001556 <chSchReadyI+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800155e:	6859      	ldr	r1, [r3, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 8001560:	4610      	mov	r0, r2
  tp->queue.prev             = cp->queue.prev;
 8001562:	e9c2 3100 	strd	r3, r1, [r2]
  tp->queue.prev->queue.next = tp;
 8001566:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001568:	605a      	str	r2, [r3, #4]
}
 800156a:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 800156c:	4803      	ldr	r0, [pc, #12]	; (800157c <chSchReadyI+0x4c>)
 800156e:	f7ff ff1f 	bl	80013b0 <chSysHalt>
  chDbgCheck(tp != NULL);
 8001572:	4803      	ldr	r0, [pc, #12]	; (8001580 <chSchReadyI+0x50>)
 8001574:	f7ff ff1c 	bl	80013b0 <chSysHalt>
 8001578:	2000159c 	.word	0x2000159c
 800157c:	0800e70c 	.word	0x0800e70c
 8001580:	0800e258 	.word	0x0800e258
	...

08001590 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001592:	4b22      	ldr	r3, [pc, #136]	; (800161c <chEvtBroadcastFlagsI+0x8c>)
 8001594:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001596:	2a00      	cmp	r2, #0
 8001598:	db13      	blt.n	80015c2 <chEvtBroadcastFlagsI+0x32>
 800159a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800159c:	2b00      	cmp	r3, #0
 800159e:	dd10      	ble.n	80015c2 <chEvtBroadcastFlagsI+0x32>
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
 80015a0:	2800      	cmp	r0, #0
 80015a2:	d034      	beq.n	800160e <chEvtBroadcastFlagsI+0x7e>

  elp = esp->next;
 80015a4:	6803      	ldr	r3, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80015a6:	4298      	cmp	r0, r3
 80015a8:	d00a      	beq.n	80015c0 <chEvtBroadcastFlagsI+0x30>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80015aa:	2500      	movs	r5, #0
    elp->flags |= flags;
 80015ac:	68da      	ldr	r2, [r3, #12]
 80015ae:	430a      	orrs	r2, r1
 80015b0:	60da      	str	r2, [r3, #12]
    if ((flags == (eventflags_t)0) ||
 80015b2:	b149      	cbz	r1, 80015c8 <chEvtBroadcastFlagsI+0x38>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 80015b4:	691c      	ldr	r4, [r3, #16]
    if ((flags == (eventflags_t)0) ||
 80015b6:	4222      	tst	r2, r4
 80015b8:	d106      	bne.n	80015c8 <chEvtBroadcastFlagsI+0x38>
    elp = elp->next;
 80015ba:	681b      	ldr	r3, [r3, #0]
  while (elp != (event_listener_t *)esp) {
 80015bc:	4298      	cmp	r0, r3
 80015be:	d1f5      	bne.n	80015ac <chEvtBroadcastFlagsI+0x1c>
}
 80015c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    chSysHalt("SV#10");
 80015c2:	4817      	ldr	r0, [pc, #92]	; (8001620 <chEvtBroadcastFlagsI+0x90>)
 80015c4:	f7ff fef4 	bl	80013b0 <chSysHalt>
      chEvtSignalI(elp->listener, elp->events);
 80015c8:	685a      	ldr	r2, [r3, #4]
  chDbgCheck(tp != NULL);
 80015ca:	b31a      	cbz	r2, 8001614 <chEvtBroadcastFlagsI+0x84>
  tp->epending |= events;
 80015cc:	689c      	ldr	r4, [r3, #8]
 80015ce:	6b57      	ldr	r7, [r2, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015d0:	f892 6020 	ldrb.w	r6, [r2, #32]
  tp->epending |= events;
 80015d4:	433c      	orrs	r4, r7
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015d6:	2e0a      	cmp	r6, #10
  tp->epending |= events;
 80015d8:	6354      	str	r4, [r2, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015da:	d014      	beq.n	8001606 <chEvtBroadcastFlagsI+0x76>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80015dc:	2e0b      	cmp	r6, #11
 80015de:	d1ec      	bne.n	80015ba <chEvtBroadcastFlagsI+0x2a>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80015e0:	6a56      	ldr	r6, [r2, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 80015e2:	ea36 0404 	bics.w	r4, r6, r4
 80015e6:	d1e8      	bne.n	80015ba <chEvtBroadcastFlagsI+0x2a>
  } while (cp->prio >= tp->prio);
 80015e8:	6897      	ldr	r7, [r2, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80015ea:	4c0c      	ldr	r4, [pc, #48]	; (800161c <chEvtBroadcastFlagsI+0x8c>)
    tp->u.rdymsg = MSG_OK;
 80015ec:	6255      	str	r5, [r2, #36]	; 0x24
  tp->state = CH_STATE_READY;
 80015ee:	f882 5020 	strb.w	r5, [r2, #32]
    cp = cp->queue.next;
 80015f2:	6824      	ldr	r4, [r4, #0]
  } while (cp->prio >= tp->prio);
 80015f4:	68a6      	ldr	r6, [r4, #8]
 80015f6:	42be      	cmp	r6, r7
 80015f8:	d2fb      	bcs.n	80015f2 <chEvtBroadcastFlagsI+0x62>
  tp->queue.prev             = cp->queue.prev;
 80015fa:	6866      	ldr	r6, [r4, #4]
 80015fc:	e9c2 4600 	strd	r4, r6, [r2]
  tp->queue.prev->queue.next = tp;
 8001600:	6032      	str	r2, [r6, #0]
  cp->queue.prev             = tp;
 8001602:	6062      	str	r2, [r4, #4]
 8001604:	e7d9      	b.n	80015ba <chEvtBroadcastFlagsI+0x2a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8001606:	6a56      	ldr	r6, [r2, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001608:	4234      	tst	r4, r6
 800160a:	d1ed      	bne.n	80015e8 <chEvtBroadcastFlagsI+0x58>
 800160c:	e7d5      	b.n	80015ba <chEvtBroadcastFlagsI+0x2a>
  chDbgCheck(esp != NULL);
 800160e:	4805      	ldr	r0, [pc, #20]	; (8001624 <chEvtBroadcastFlagsI+0x94>)
 8001610:	f7ff fece 	bl	80013b0 <chSysHalt>
  chDbgCheck(tp != NULL);
 8001614:	4804      	ldr	r0, [pc, #16]	; (8001628 <chEvtBroadcastFlagsI+0x98>)
 8001616:	f7ff fecb 	bl	80013b0 <chSysHalt>
 800161a:	bf00      	nop
 800161c:	2000159c 	.word	0x2000159c
 8001620:	0800e70c 	.word	0x0800e70c
 8001624:	0800e2c8 	.word	0x0800e2c8
 8001628:	0800e31c 	.word	0x0800e31c
 800162c:	00000000 	.word	0x00000000

08001630 <chSysUnlock.lto_priv.78>:
static inline void chSysUnlock(void) {
 8001630:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001632:	4b0c      	ldr	r3, [pc, #48]	; (8001664 <chSysUnlock.lto_priv.78+0x34>)
 8001634:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001636:	b97a      	cbnz	r2, 8001658 <chSysUnlock.lto_priv.78+0x28>
 8001638:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800163a:	2900      	cmp	r1, #0
 800163c:	dd0c      	ble.n	8001658 <chSysUnlock.lto_priv.78+0x28>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800163e:	6819      	ldr	r1, [r3, #0]
  _dbg_leave_lock();
 8001640:	635a      	str	r2, [r3, #52]	; 0x34
 8001642:	4299      	cmp	r1, r3
 8001644:	d004      	beq.n	8001650 <chSysUnlock.lto_priv.78+0x20>
 8001646:	699a      	ldr	r2, [r3, #24]
 8001648:	688b      	ldr	r3, [r1, #8]
 800164a:	6892      	ldr	r2, [r2, #8]
 800164c:	429a      	cmp	r2, r3
 800164e:	d306      	bcc.n	800165e <chSysUnlock.lto_priv.78+0x2e>
 8001650:	2300      	movs	r3, #0
 8001652:	f383 8811 	msr	BASEPRI, r3
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
}
 8001656:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 8001658:	4803      	ldr	r0, [pc, #12]	; (8001668 <chSysUnlock.lto_priv.78+0x38>)
 800165a:	f7ff fea9 	bl	80013b0 <chSysHalt>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800165e:	4803      	ldr	r0, [pc, #12]	; (800166c <chSysUnlock.lto_priv.78+0x3c>)
 8001660:	f7ff fea6 	bl	80013b0 <chSysHalt>
 8001664:	2000159c 	.word	0x2000159c
 8001668:	0800e72c 	.word	0x0800e72c
 800166c:	0800e1e4 	.word	0x0800e1e4

08001670 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
 8001670:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001672:	4b06      	ldr	r3, [pc, #24]	; (800168c <_dbg_check_unlock_from_isr+0x1c>)
 8001674:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001676:	2a00      	cmp	r2, #0
 8001678:	dd05      	ble.n	8001686 <_dbg_check_unlock_from_isr+0x16>
 800167a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800167c:	2a00      	cmp	r2, #0
 800167e:	dd02      	ble.n	8001686 <_dbg_check_unlock_from_isr+0x16>
  _dbg_leave_lock();
 8001680:	2200      	movs	r2, #0
 8001682:	635a      	str	r2, [r3, #52]	; 0x34
}
 8001684:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
 8001686:	4802      	ldr	r0, [pc, #8]	; (8001690 <_dbg_check_unlock_from_isr+0x20>)
 8001688:	f7ff fe92 	bl	80013b0 <chSysHalt>
 800168c:	2000159c 	.word	0x2000159c
 8001690:	0800e5b4 	.word	0x0800e5b4
	...

080016a0 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
 80016a0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80016a2:	4b06      	ldr	r3, [pc, #24]	; (80016bc <_dbg_check_lock_from_isr+0x1c>)
 80016a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80016a6:	2a00      	cmp	r2, #0
 80016a8:	dd01      	ble.n	80016ae <_dbg_check_lock_from_isr+0xe>
 80016aa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016ac:	b112      	cbz	r2, 80016b4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 80016ae:	4804      	ldr	r0, [pc, #16]	; (80016c0 <_dbg_check_lock_from_isr+0x20>)
 80016b0:	f7ff fe7e 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 80016b4:	2201      	movs	r2, #1
 80016b6:	635a      	str	r2, [r3, #52]	; 0x34
}
 80016b8:	bd08      	pop	{r3, pc}
 80016ba:	bf00      	nop
 80016bc:	2000159c 	.word	0x2000159c
 80016c0:	0800e5ac 	.word	0x0800e5ac
	...

080016d0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80016d0:	b530      	push	{r4, r5, lr}
 80016d2:	2320      	movs	r3, #32
 80016d4:	b083      	sub	sp, #12
 80016d6:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80016da:	4c2c      	ldr	r4, [pc, #176]	; (800178c <wakeup+0xbc>)
 80016dc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80016de:	2b00      	cmp	r3, #0
 80016e0:	dd01      	ble.n	80016e6 <wakeup+0x16>
 80016e2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80016e4:	b113      	cbz	r3, 80016ec <wakeup+0x1c>
    chSysHalt("SV#6");
 80016e6:	482a      	ldr	r0, [pc, #168]	; (8001790 <wakeup+0xc0>)
 80016e8:	f7ff fe62 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 80016ec:	2301      	movs	r3, #1
 80016ee:	6363      	str	r3, [r4, #52]	; 0x34
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 80016f0:	f890 3020 	ldrb.w	r3, [r0, #32]
 80016f4:	2b07      	cmp	r3, #7
 80016f6:	d812      	bhi.n	800171e <wakeup+0x4e>
 80016f8:	e8df f003 	tbb	[pc, r3]
 80016fc:	3611113a 	.word	0x3611113a
 8001700:	0c11040c 	.word	0x0c11040c
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8001704:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8001706:	9001      	str	r0, [sp, #4]
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8001708:	f7ff fe8a 	bl	8001420 <chDbgCheckClassI>

  sp->cnt++;
 800170c:	68ab      	ldr	r3, [r5, #8]
 800170e:	9801      	ldr	r0, [sp, #4]
 8001710:	3301      	adds	r3, #1
 8001712:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001714:	e9d0 2300 	ldrd	r2, r3, [r0]
 8001718:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800171a:	6802      	ldr	r2, [r0, #0]
 800171c:	6053      	str	r3, [r2, #4]
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800171e:	6b21      	ldr	r1, [r4, #48]	; 0x30
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001720:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001724:	2900      	cmp	r1, #0
 8001726:	6243      	str	r3, [r0, #36]	; 0x24
 8001728:	db1b      	blt.n	8001762 <wakeup+0x92>
 800172a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800172c:	2b00      	cmp	r3, #0
 800172e:	dd18      	ble.n	8001762 <wakeup+0x92>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001730:	f890 3020 	ldrb.w	r3, [r0, #32]
 8001734:	b31b      	cbz	r3, 800177e <wakeup+0xae>
 8001736:	2b0f      	cmp	r3, #15
 8001738:	d021      	beq.n	800177e <wakeup+0xae>
  tp->state = CH_STATE_READY;
 800173a:	2200      	movs	r2, #0
  } while (cp->prio >= tp->prio);
 800173c:	6885      	ldr	r5, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 800173e:	4b13      	ldr	r3, [pc, #76]	; (800178c <wakeup+0xbc>)
  tp->state = CH_STATE_READY;
 8001740:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 8001744:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001746:	689a      	ldr	r2, [r3, #8]
 8001748:	42aa      	cmp	r2, r5
 800174a:	d2fb      	bcs.n	8001744 <wakeup+0x74>
  tp->queue.prev             = cp->queue.prev;
 800174c:	685a      	ldr	r2, [r3, #4]
 800174e:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8001752:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8001754:	6058      	str	r0, [r3, #4]
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001756:	b1a9      	cbz	r1, 8001784 <wakeup+0xb4>
  _dbg_leave_lock();
 8001758:	2300      	movs	r3, #0
 800175a:	6363      	str	r3, [r4, #52]	; 0x34
 800175c:	f383 8811 	msr	BASEPRI, r3
 8001760:	e00b      	b.n	800177a <wakeup+0xaa>
    chSysHalt("SV#10");
 8001762:	480c      	ldr	r0, [pc, #48]	; (8001794 <wakeup+0xc4>)
 8001764:	f7ff fe24 	bl	80013b0 <chSysHalt>
    *tp->u.wttrp = NULL;
 8001768:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800176a:	2200      	movs	r2, #0
 800176c:	601a      	str	r2, [r3, #0]
 800176e:	e7d6      	b.n	800171e <wakeup+0x4e>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001770:	f7ff ff7e 	bl	8001670 <_dbg_check_unlock_from_isr>
 8001774:	2300      	movs	r3, #0
 8001776:	f383 8811 	msr	BASEPRI, r3
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 800177a:	b003      	add	sp, #12
 800177c:	bd30      	pop	{r4, r5, pc}
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800177e:	4806      	ldr	r0, [pc, #24]	; (8001798 <wakeup+0xc8>)
 8001780:	f7ff fe16 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#7");
 8001784:	4805      	ldr	r0, [pc, #20]	; (800179c <wakeup+0xcc>)
 8001786:	f7ff fe13 	bl	80013b0 <chSysHalt>
 800178a:	bf00      	nop
 800178c:	2000159c 	.word	0x2000159c
 8001790:	0800e5ac 	.word	0x0800e5ac
 8001794:	0800e70c 	.word	0x0800e70c
 8001798:	0800e258 	.word	0x0800e258
 800179c:	0800e5b4 	.word	0x0800e5b4

080017a0 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
 80017a0:	b508      	push	{r3, lr}
 80017a2:	2320      	movs	r3, #32
 80017a4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80017a8:	4a06      	ldr	r2, [pc, #24]	; (80017c4 <_dbg_check_leave_isr+0x24>)
 80017aa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80017ac:	2b00      	cmp	r3, #0
 80017ae:	dd01      	ble.n	80017b4 <_dbg_check_leave_isr+0x14>
 80017b0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80017b2:	b111      	cbz	r1, 80017ba <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 80017b4:	4804      	ldr	r0, [pc, #16]	; (80017c8 <_dbg_check_leave_isr+0x28>)
 80017b6:	f7ff fdfb 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 80017ba:	3b01      	subs	r3, #1
 80017bc:	6313      	str	r3, [r2, #48]	; 0x30
 80017be:	f381 8811 	msr	BASEPRI, r1
}
 80017c2:	bd08      	pop	{r3, pc}
 80017c4:	2000159c 	.word	0x2000159c
 80017c8:	0800e5a4 	.word	0x0800e5a4
 80017cc:	00000000 	.word	0x00000000

080017d0 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
 80017d0:	b508      	push	{r3, lr}
 80017d2:	2320      	movs	r3, #32
 80017d4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80017d8:	4a06      	ldr	r2, [pc, #24]	; (80017f4 <_dbg_check_enter_isr+0x24>)
 80017da:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80017dc:	2b00      	cmp	r3, #0
 80017de:	db01      	blt.n	80017e4 <_dbg_check_enter_isr+0x14>
 80017e0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80017e2:	b111      	cbz	r1, 80017ea <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 80017e4:	4804      	ldr	r0, [pc, #16]	; (80017f8 <_dbg_check_enter_isr+0x28>)
 80017e6:	f7ff fde3 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 80017ea:	3301      	adds	r3, #1
 80017ec:	6313      	str	r3, [r2, #48]	; 0x30
 80017ee:	f381 8811 	msr	BASEPRI, r1
}
 80017f2:	bd08      	pop	{r3, pc}
 80017f4:	2000159c 	.word	0x2000159c
 80017f8:	0800e59c 	.word	0x0800e59c
 80017fc:	00000000 	.word	0x00000000

08001800 <_idle_thread>:
static void _idle_thread(void *p) {
 8001800:	e7fe      	b.n	8001800 <_idle_thread>
 8001802:	bf00      	nop
	...

08001810 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 8001810:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  USART_TypeDef *u = sdp->usart;
 8001814:	6d46      	ldr	r6, [r0, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 8001816:	6837      	ldr	r7, [r6, #0]
  isr = u->ISR;
 8001818:	69f5      	ldr	r5, [r6, #28]
  u->ICR = isr;
 800181a:	6235      	str	r5, [r6, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800181c:	072b      	lsls	r3, r5, #28
static void serve_interrupt(SerialDriver *sdp) {
 800181e:	4604      	mov	r4, r0
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8001820:	f040 8082 	bne.w	8001928 <serve_interrupt+0x118>
  if (isr & USART_ISR_LBDF) {
 8001824:	05eb      	lsls	r3, r5, #23
 8001826:	d46f      	bmi.n	8001908 <serve_interrupt+0xf8>
  if (isr & USART_ISR_RXNE) {
 8001828:	06a8      	lsls	r0, r5, #26
 800182a:	d43a      	bmi.n	80018a2 <serve_interrupt+0x92>
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800182c:	0639      	lsls	r1, r7, #24
 800182e:	d404      	bmi.n	800183a <serve_interrupt+0x2a>
  if (isr & USART_ISR_TC) {
 8001830:	066b      	lsls	r3, r5, #25
 8001832:	f100 80bc 	bmi.w	80019ae <serve_interrupt+0x19e>
}
 8001836:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800183a:	062a      	lsls	r2, r5, #24
 800183c:	d5f8      	bpl.n	8001830 <serve_interrupt+0x20>
 800183e:	2320      	movs	r3, #32
 8001840:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001844:	f7ff ff2c 	bl	80016a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();
 8001848:	f7ff fdea 	bl	8001420 <chDbgCheckClassI>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 800184c:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8001850:	429a      	cmp	r2, r3
    b = oqGetI(&sdp->oqueue);
 8001852:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8001856:	f000 80de 	beq.w	8001a16 <serve_interrupt+0x206>
    uint8_t b;

    oqp->q_counter++;
 800185a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 800185c:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 800185e:	3201      	adds	r2, #1
 8001860:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 8001862:	64a0      	str	r0, [r4, #72]	; 0x48
 8001864:	f893 8000 	ldrb.w	r8, [r3]
    if (oqp->q_rdptr >= oqp->q_top) {
 8001868:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800186a:	4298      	cmp	r0, r3
 800186c:	d301      	bcc.n	8001872 <serve_interrupt+0x62>
      oqp->q_rdptr = oqp->q_buffer;
 800186e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001870:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001872:	6b20      	ldr	r0, [r4, #48]	; 0x30
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001874:	4281      	cmp	r1, r0
 8001876:	d00a      	beq.n	800188e <serve_interrupt+0x7e>
  tqp->next             = tp->queue.next;
 8001878:	6803      	ldr	r3, [r0, #0]
 800187a:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 800187c:	6059      	str	r1, [r3, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800187e:	f890 3020 	ldrb.w	r3, [r0, #32]
 8001882:	2b04      	cmp	r3, #4
 8001884:	d13d      	bne.n	8001902 <serve_interrupt+0xf2>

  tp->u.rdymsg = msg;
 8001886:	2300      	movs	r3, #0
 8001888:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800188a:	f7ff fe51 	bl	8001530 <chSchReadyI>
      u->TDR = b;
 800188e:	fa1f f888 	uxth.w	r8, r8
 8001892:	f8a6 8028 	strh.w	r8, [r6, #40]	; 0x28
  _dbg_check_unlock_from_isr();
 8001896:	f7ff feeb 	bl	8001670 <_dbg_check_unlock_from_isr>
 800189a:	2300      	movs	r3, #0
 800189c:	f383 8811 	msr	BASEPRI, r3
 80018a0:	e7c6      	b.n	8001830 <serve_interrupt+0x20>
 80018a2:	2320      	movs	r3, #32
 80018a4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80018a8:	f7ff fefa 	bl	80016a0 <_dbg_check_lock_from_isr>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 80018ac:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 80018ae:	f894 805c 	ldrb.w	r8, [r4, #92]	; 0x5c
 80018b2:	ea08 0803 	and.w	r8, r8, r3
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 80018b6:	f7ff fdb3 	bl	8001420 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80018ba:	6963      	ldr	r3, [r4, #20]
 80018bc:	2b00      	cmp	r3, #0
 80018be:	f000 809d 	beq.w	80019fc <serve_interrupt+0x1ec>
  osalDbgCheckClassI();
 80018c2:	f7ff fdad 	bl	8001420 <chDbgCheckClassI>
  if (!iqIsFullI(iqp)) {
 80018c6:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 80018ca:	4293      	cmp	r3, r2
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80018cc:	f104 010c 	add.w	r1, r4, #12
 80018d0:	f000 808a 	beq.w	80019e8 <serve_interrupt+0x1d8>
    iqp->q_counter++;
 80018d4:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 80018d6:	1c58      	adds	r0, r3, #1
    iqp->q_counter++;
 80018d8:	3201      	adds	r2, #1
 80018da:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 80018dc:	6220      	str	r0, [r4, #32]
 80018de:	f883 8000 	strb.w	r8, [r3]
    if (iqp->q_wrptr >= iqp->q_top) {
 80018e2:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80018e6:	429a      	cmp	r2, r3
 80018e8:	d301      	bcc.n	80018ee <serve_interrupt+0xde>
      iqp->q_wrptr = iqp->q_buffer;
 80018ea:	69a3      	ldr	r3, [r4, #24]
 80018ec:	6223      	str	r3, [r4, #32]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80018ee:	68e0      	ldr	r0, [r4, #12]
 80018f0:	4281      	cmp	r1, r0
 80018f2:	d073      	beq.n	80019dc <serve_interrupt+0x1cc>
  tqp->next             = tp->queue.next;
 80018f4:	6803      	ldr	r3, [r0, #0]
 80018f6:	60e3      	str	r3, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 80018f8:	6059      	str	r1, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80018fa:	f890 3020 	ldrb.w	r3, [r0, #32]
 80018fe:	2b04      	cmp	r3, #4
 8001900:	d068      	beq.n	80019d4 <serve_interrupt+0x1c4>
 8001902:	484c      	ldr	r0, [pc, #304]	; (8001a34 <serve_interrupt+0x224>)
 8001904:	f7ff fd54 	bl	80013b0 <chSysHalt>
 8001908:	2320      	movs	r3, #32
 800190a:	f383 8811 	msr	BASEPRI, r3
 800190e:	f7ff fec7 	bl	80016a0 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001912:	1d20      	adds	r0, r4, #4
 8001914:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001918:	f7ff fe3a 	bl	8001590 <chEvtBroadcastFlagsI>
  _dbg_check_unlock_from_isr();
 800191c:	f7ff fea8 	bl	8001670 <_dbg_check_unlock_from_isr>
 8001920:	2300      	movs	r3, #0
 8001922:	f383 8811 	msr	BASEPRI, r3
 8001926:	e77f      	b.n	8001828 <serve_interrupt+0x18>
  if (isr & USART_ISR_ORE)
 8001928:	f005 0308 	and.w	r3, r5, #8
 800192c:	2b00      	cmp	r3, #0
 800192e:	bf15      	itete	ne
 8001930:	f44f 73c0 	movne.w	r3, #384	; 0x180
 8001934:	f44f 7380 	moveq.w	r3, #256	; 0x100
 8001938:	f44f 71e0 	movne.w	r1, #448	; 0x1c0
 800193c:	f44f 71a0 	moveq.w	r1, #320	; 0x140
 8001940:	bf15      	itete	ne
 8001942:	22c0      	movne	r2, #192	; 0xc0
 8001944:	2240      	moveq	r2, #64	; 0x40
 8001946:	f44f 79d0 	movne.w	r9, #416	; 0x1a0
 800194a:	f44f 7990 	moveq.w	r9, #288	; 0x120
 800194e:	bf15      	itete	ne
 8001950:	f44f 7ef0 	movne.w	lr, #480	; 0x1e0
 8001954:	f44f 7eb0 	moveq.w	lr, #352	; 0x160
 8001958:	f04f 0ce0 	movne.w	ip, #224	; 0xe0
 800195c:	f04f 0c60 	moveq.w	ip, #96	; 0x60
 8001960:	bf15      	itete	ne
 8001962:	20a0      	movne	r0, #160	; 0xa0
 8001964:	2020      	moveq	r0, #32
 8001966:	f04f 0880 	movne.w	r8, #128	; 0x80
 800196a:	f04f 0800 	moveq.w	r8, #0
  if (isr & USART_ISR_PE)
 800196e:	f015 0f01 	tst.w	r5, #1
 8001972:	d003      	beq.n	800197c <serve_interrupt+0x16c>
 8001974:	464b      	mov	r3, r9
 8001976:	4671      	mov	r1, lr
 8001978:	4662      	mov	r2, ip
    sts |= SD_PARITY_ERROR;
 800197a:	4680      	mov	r8, r0
  if (isr & USART_ISR_FE)
 800197c:	f005 0002 	and.w	r0, r5, #2
 8001980:	2800      	cmp	r0, #0
 8001982:	bf1c      	itt	ne
 8001984:	460b      	movne	r3, r1
 8001986:	4690      	movne	r8, r2
    sts |= SD_NOISE_ERROR;
 8001988:	f015 0f04 	tst.w	r5, #4
 800198c:	bf18      	it	ne
 800198e:	4698      	movne	r8, r3
 8001990:	2320      	movs	r3, #32
 8001992:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001996:	f7ff fe83 	bl	80016a0 <_dbg_check_lock_from_isr>
 800199a:	4641      	mov	r1, r8
 800199c:	1d20      	adds	r0, r4, #4
 800199e:	f7ff fdf7 	bl	8001590 <chEvtBroadcastFlagsI>
  _dbg_check_unlock_from_isr();
 80019a2:	f7ff fe65 	bl	8001670 <_dbg_check_unlock_from_isr>
 80019a6:	2300      	movs	r3, #0
 80019a8:	f383 8811 	msr	BASEPRI, r3
 80019ac:	e73a      	b.n	8001824 <serve_interrupt+0x14>
 80019ae:	2320      	movs	r3, #32
 80019b0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80019b4:	f7ff fe74 	bl	80016a0 <_dbg_check_lock_from_isr>
    if (oqIsEmptyI(&sdp->oqueue))
 80019b8:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 80019bc:	429a      	cmp	r2, r3
 80019be:	d022      	beq.n	8001a06 <serve_interrupt+0x1f6>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80019c0:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 80019c4:	6037      	str	r7, [r6, #0]
  _dbg_check_unlock_from_isr();
 80019c6:	f7ff fe53 	bl	8001670 <_dbg_check_unlock_from_isr>
 80019ca:	2300      	movs	r3, #0
 80019cc:	f383 8811 	msr	BASEPRI, r3
}
 80019d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  tp->u.rdymsg = msg;
 80019d4:	2300      	movs	r3, #0
 80019d6:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80019d8:	f7ff fdaa 	bl	8001530 <chSchReadyI>
 80019dc:	f7ff fe48 	bl	8001670 <_dbg_check_unlock_from_isr>
 80019e0:	2300      	movs	r3, #0
 80019e2:	f383 8811 	msr	BASEPRI, r3
 80019e6:	e721      	b.n	800182c <serve_interrupt+0x1c>
  if (!iqIsFullI(iqp)) {
 80019e8:	6962      	ldr	r2, [r4, #20]
 80019ea:	2a00      	cmp	r2, #0
 80019ec:	f43f af72 	beq.w	80018d4 <serve_interrupt+0xc4>
 80019f0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80019f4:	1d20      	adds	r0, r4, #4
 80019f6:	f7ff fdcb 	bl	8001590 <chEvtBroadcastFlagsI>
 80019fa:	e7ef      	b.n	80019dc <serve_interrupt+0x1cc>
 80019fc:	2104      	movs	r1, #4
 80019fe:	1860      	adds	r0, r4, r1
 8001a00:	f7ff fdc6 	bl	8001590 <chEvtBroadcastFlagsI>
 8001a04:	e75d      	b.n	80018c2 <serve_interrupt+0xb2>
    if (oqIsEmptyI(&sdp->oqueue))
 8001a06:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001a08:	2b00      	cmp	r3, #0
 8001a0a:	d0d9      	beq.n	80019c0 <serve_interrupt+0x1b0>
 8001a0c:	1d20      	adds	r0, r4, #4
 8001a0e:	2110      	movs	r1, #16
 8001a10:	f7ff fdbe 	bl	8001590 <chEvtBroadcastFlagsI>
 8001a14:	e7d4      	b.n	80019c0 <serve_interrupt+0x1b0>
  if (!oqIsEmptyI(oqp)) {
 8001a16:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001a18:	2a00      	cmp	r2, #0
 8001a1a:	f43f af1e 	beq.w	800185a <serve_interrupt+0x4a>
 8001a1e:	2108      	movs	r1, #8
 8001a20:	1d20      	adds	r0, r4, #4
 8001a22:	f7ff fdb5 	bl	8001590 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001a26:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 8001a2a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001a2e:	6033      	str	r3, [r6, #0]
 8001a30:	e731      	b.n	8001896 <serve_interrupt+0x86>
 8001a32:	bf00      	nop
 8001a34:	0800e22c 	.word	0x0800e22c
	...

08001a40 <spi_lld_serve_rx_interrupt>:
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001a40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001a44:	070c      	lsls	r4, r1, #28
 8001a46:	d43b      	bmi.n	8001ac0 <spi_lld_serve_rx_interrupt+0x80>
  if (spip->config->circular) {
 8001a48:	6843      	ldr	r3, [r0, #4]
 8001a4a:	781a      	ldrb	r2, [r3, #0]
 8001a4c:	685b      	ldr	r3, [r3, #4]
 8001a4e:	4604      	mov	r4, r0
 8001a50:	bb4a      	cbnz	r2, 8001aa6 <spi_lld_serve_rx_interrupt+0x66>
    dmaStreamDisable(spip->dmarx);
 8001a52:	e9d0 1208 	ldrd	r1, r2, [r0, #32]
    dmaStreamDisable(spip->dmatx);
 8001a56:	e9d2 7600 	ldrd	r7, r6, [r2]
 8001a5a:	6835      	ldr	r5, [r6, #0]
 8001a5c:	f025 050f 	bic.w	r5, r5, #15
 8001a60:	6035      	str	r5, [r6, #0]
 8001a62:	7c15      	ldrb	r5, [r2, #16]
    dmaStreamDisable(spip->dmarx);
 8001a64:	684e      	ldr	r6, [r1, #4]
    dmaStreamDisable(spip->dmatx);
 8001a66:	220e      	movs	r2, #14
 8001a68:	fa02 f505 	lsl.w	r5, r2, r5
 8001a6c:	607d      	str	r5, [r7, #4]
    dmaStreamDisable(spip->dmarx);
 8001a6e:	6835      	ldr	r5, [r6, #0]
 8001a70:	680f      	ldr	r7, [r1, #0]
 8001a72:	f025 050f 	bic.w	r5, r5, #15
 8001a76:	6035      	str	r5, [r6, #0]
 8001a78:	7c09      	ldrb	r1, [r1, #16]
 8001a7a:	408a      	lsls	r2, r1
 8001a7c:	607a      	str	r2, [r7, #4]
    _spi_isr_code(spip);
 8001a7e:	2b00      	cmp	r3, #0
 8001a80:	d03c      	beq.n	8001afc <spi_lld_serve_rx_interrupt+0xbc>
 8001a82:	2204      	movs	r2, #4
 8001a84:	7002      	strb	r2, [r0, #0]
 8001a86:	4798      	blx	r3
 8001a88:	7823      	ldrb	r3, [r4, #0]
 8001a8a:	2b04      	cmp	r3, #4
 8001a8c:	d036      	beq.n	8001afc <spi_lld_serve_rx_interrupt+0xbc>
 8001a8e:	2320      	movs	r3, #32
 8001a90:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001a94:	4d1f      	ldr	r5, [pc, #124]	; (8001b14 <spi_lld_serve_rx_interrupt+0xd4>)
 8001a96:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001a98:	2b00      	cmp	r3, #0
 8001a9a:	dd01      	ble.n	8001aa0 <spi_lld_serve_rx_interrupt+0x60>
 8001a9c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001a9e:	b1bb      	cbz	r3, 8001ad0 <spi_lld_serve_rx_interrupt+0x90>
    chSysHalt("SV#6");
 8001aa0:	481d      	ldr	r0, [pc, #116]	; (8001b18 <spi_lld_serve_rx_interrupt+0xd8>)
 8001aa2:	f7ff fc85 	bl	80013b0 <chSysHalt>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 8001aa6:	074a      	lsls	r2, r1, #29
 8001aa8:	d40d      	bmi.n	8001ac6 <spi_lld_serve_rx_interrupt+0x86>
      _spi_isr_code_half2(spip);
 8001aaa:	b13b      	cbz	r3, 8001abc <spi_lld_serve_rx_interrupt+0x7c>
 8001aac:	2204      	movs	r2, #4
 8001aae:	7002      	strb	r2, [r0, #0]
 8001ab0:	4798      	blx	r3
 8001ab2:	7823      	ldrb	r3, [r4, #0]
 8001ab4:	2b04      	cmp	r3, #4
 8001ab6:	d101      	bne.n	8001abc <spi_lld_serve_rx_interrupt+0x7c>
 8001ab8:	2303      	movs	r3, #3
 8001aba:	7023      	strb	r3, [r4, #0]
}
 8001abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  chSysHalt(reason);
 8001ac0:	4816      	ldr	r0, [pc, #88]	; (8001b1c <spi_lld_serve_rx_interrupt+0xdc>)
 8001ac2:	f7ff fc75 	bl	80013b0 <chSysHalt>
      _spi_isr_code_half1(spip);
 8001ac6:	2b00      	cmp	r3, #0
 8001ac8:	d0f8      	beq.n	8001abc <spi_lld_serve_rx_interrupt+0x7c>
}
 8001aca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      _spi_isr_code_half1(spip);
 8001ace:	4718      	bx	r3
  if (*trp != NULL) {
 8001ad0:	68a2      	ldr	r2, [r4, #8]
  _dbg_enter_lock();
 8001ad2:	2101      	movs	r1, #1
 8001ad4:	6369      	str	r1, [r5, #52]	; 0x34
 8001ad6:	b1ba      	cbz	r2, 8001b08 <spi_lld_serve_rx_interrupt+0xc8>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001ad8:	f892 1020 	ldrb.w	r1, [r2, #32]
 8001adc:	2903      	cmp	r1, #3
 8001ade:	d110      	bne.n	8001b02 <spi_lld_serve_rx_interrupt+0xc2>
    *trp = NULL;
 8001ae0:	60a3      	str	r3, [r4, #8]
    (void) chSchReadyI(tp);
 8001ae2:	4610      	mov	r0, r2
    tp->u.rdymsg = msg;
 8001ae4:	6253      	str	r3, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001ae6:	f7ff fd23 	bl	8001530 <chSchReadyI>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001aea:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001aec:	2b00      	cmp	r3, #0
 8001aee:	dd02      	ble.n	8001af6 <spi_lld_serve_rx_interrupt+0xb6>
 8001af0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001af2:	2b00      	cmp	r3, #0
 8001af4:	dc08      	bgt.n	8001b08 <spi_lld_serve_rx_interrupt+0xc8>
    chSysHalt("SV#7");
 8001af6:	480a      	ldr	r0, [pc, #40]	; (8001b20 <spi_lld_serve_rx_interrupt+0xe0>)
 8001af8:	f7ff fc5a 	bl	80013b0 <chSysHalt>
    _spi_isr_code(spip);
 8001afc:	2302      	movs	r3, #2
 8001afe:	7023      	strb	r3, [r4, #0]
 8001b00:	e7c5      	b.n	8001a8e <spi_lld_serve_rx_interrupt+0x4e>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001b02:	4808      	ldr	r0, [pc, #32]	; (8001b24 <spi_lld_serve_rx_interrupt+0xe4>)
 8001b04:	f7ff fc54 	bl	80013b0 <chSysHalt>
  _dbg_leave_lock();
 8001b08:	2300      	movs	r3, #0
 8001b0a:	636b      	str	r3, [r5, #52]	; 0x34
 8001b0c:	f383 8811 	msr	BASEPRI, r3
 8001b10:	e7d4      	b.n	8001abc <spi_lld_serve_rx_interrupt+0x7c>
 8001b12:	bf00      	nop
 8001b14:	2000159c 	.word	0x2000159c
 8001b18:	0800e5ac 	.word	0x0800e5ac
 8001b1c:	0801d99c 	.word	0x0801d99c
 8001b20:	0800e5b4 	.word	0x0800e5b4
 8001b24:	0800e360 	.word	0x0800e360
	...

08001b30 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001b30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001b34:	f002 0803 	and.w	r8, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001b38:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001b3c:	f3c2 1741 	ubfx	r7, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001b40:	46c6      	mov	lr, r8
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001b42:	09d2      	lsrs	r2, r2, #7
  uint32_t bit     = 0;
 8001b44:	2600      	movs	r6, #0
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8001b46:	f04f 0a01 	mov.w	sl, #1
      m2 = 3 << (bit * 2);
 8001b4a:	f04f 0903 	mov.w	r9, #3
 8001b4e:	e014      	b.n	8001b7a <_pal_lld_setgroupmode+0x4a>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001b50:	f8d0 b000 	ldr.w	fp, [r0]
 8001b54:	ea03 030b 	and.w	r3, r3, fp
 8001b58:	ea43 030e 	orr.w	r3, r3, lr
        if (bit < 8)
 8001b5c:	2e07      	cmp	r6, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 8001b5e:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 8001b60:	d83f      	bhi.n	8001be2 <_pal_lld_setgroupmode+0xb2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001b62:	6a03      	ldr	r3, [r0, #32]
 8001b64:	401d      	ands	r5, r3
 8001b66:	432c      	orrs	r4, r5
 8001b68:	6204      	str	r4, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8001b6a:	0849      	lsrs	r1, r1, #1
 8001b6c:	d037      	beq.n	8001bde <_pal_lld_setgroupmode+0xae>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8001b6e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 8001b72:	00bf      	lsls	r7, r7, #2
    moder <<= 2;
 8001b74:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 8001b78:	3601      	adds	r6, #1
    if ((mask & 1) != 0) {
 8001b7a:	07cb      	lsls	r3, r1, #31
 8001b7c:	d5f5      	bpl.n	8001b6a <_pal_lld_setgroupmode+0x3a>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001b7e:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 8001b80:	fa0a f406 	lsl.w	r4, sl, r6
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001b84:	ea23 0304 	bic.w	r3, r3, r4
 8001b88:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 8001b8a:	0073      	lsls	r3, r6, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001b8c:	6884      	ldr	r4, [r0, #8]
      m2 = 3 << (bit * 2);
 8001b8e:	fa09 f303 	lsl.w	r3, r9, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001b92:	43db      	mvns	r3, r3
 8001b94:	401c      	ands	r4, r3
 8001b96:	ea44 040c 	orr.w	r4, r4, ip
 8001b9a:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001b9c:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8001b9e:	f006 0407 	and.w	r4, r6, #7
 8001ba2:	00a4      	lsls	r4, r4, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001ba4:	401d      	ands	r5, r3
      m4 = 15 << ((bit & 7) * 4);
 8001ba6:	f04f 0b0f 	mov.w	fp, #15
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001baa:	433d      	orrs	r5, r7
      m4 = 15 << ((bit & 7) * 4);
 8001bac:	fa0b fb04 	lsl.w	fp, fp, r4
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001bb0:	f1b8 0f02 	cmp.w	r8, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001bb4:	60c5      	str	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8001bb6:	fa02 f404 	lsl.w	r4, r2, r4
 8001bba:	ea6f 050b 	mvn.w	r5, fp
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001bbe:	d1c7      	bne.n	8001b50 <_pal_lld_setgroupmode+0x20>
        if (bit < 8)
 8001bc0:	2e07      	cmp	r6, #7
 8001bc2:	d813      	bhi.n	8001bec <_pal_lld_setgroupmode+0xbc>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001bc4:	f8d0 b020 	ldr.w	fp, [r0, #32]
 8001bc8:	ea05 050b 	and.w	r5, r5, fp
 8001bcc:	432c      	orrs	r4, r5
 8001bce:	6204      	str	r4, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 8001bd0:	6804      	ldr	r4, [r0, #0]
 8001bd2:	4023      	ands	r3, r4
 8001bd4:	ea43 030e 	orr.w	r3, r3, lr
    if (!mask)
 8001bd8:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 8001bda:	6003      	str	r3, [r0, #0]
    if (!mask)
 8001bdc:	d1c7      	bne.n	8001b6e <_pal_lld_setgroupmode+0x3e>
  }
}
 8001bde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001be2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001be4:	401d      	ands	r5, r3
 8001be6:	432c      	orrs	r4, r5
 8001be8:	6244      	str	r4, [r0, #36]	; 0x24
 8001bea:	e7be      	b.n	8001b6a <_pal_lld_setgroupmode+0x3a>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001bec:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 8001bf0:	ea05 050b 	and.w	r5, r5, fp
 8001bf4:	432c      	orrs	r4, r5
 8001bf6:	6244      	str	r4, [r0, #36]	; 0x24
 8001bf8:	e7ea      	b.n	8001bd0 <_pal_lld_setgroupmode+0xa0>
 8001bfa:	bf00      	nop
 8001bfc:	0000      	movs	r0, r0
	...

08001c00 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8001c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);
 8001c02:	b358      	cbz	r0, 8001c5c <dmaStreamRelease+0x5c>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma.streams_mask & (1 << dmastp->selfindex)) != 0U,
 8001c04:	491d      	ldr	r1, [pc, #116]	; (8001c7c <dmaStreamRelease+0x7c>)
 8001c06:	7c46      	ldrb	r6, [r0, #17]
 8001c08:	680b      	ldr	r3, [r1, #0]
 8001c0a:	2701      	movs	r7, #1
 8001c0c:	fa07 f206 	lsl.w	r2, r7, r6
 8001c10:	421a      	tst	r2, r3
 8001c12:	d023      	beq.n	8001c5c <dmaStreamRelease+0x5c>
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma.streams_mask &= ~(1U << dmastp->selfindex);
  dma.isr_mask &= ~(1U << dmastp->selfindex);
 8001c14:	684d      	ldr	r5, [r1, #4]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma.streams_mask & dmastp->cmask) == 0U) {
 8001c16:	6884      	ldr	r4, [r0, #8]
  dma.streams_mask &= ~(1U << dmastp->selfindex);
 8001c18:	43d2      	mvns	r2, r2
 8001c1a:	4013      	ands	r3, r2
  dma.isr_mask &= ~(1U << dmastp->selfindex);
 8001c1c:	402a      	ands	r2, r5
 8001c1e:	e9c1 3200 	strd	r3, r2, [r1]
  if ((dma.streams_mask & dmastp->cmask) == 0U) {
 8001c22:	ea13 0204 	ands.w	r2, r3, r4
 8001c26:	d01c      	beq.n	8001c62 <dmaStreamRelease+0x62>
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8001c28:	4a15      	ldr	r2, [pc, #84]	; (8001c80 <dmaStreamRelease+0x80>)
 8001c2a:	2100      	movs	r1, #0
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8001c2c:	eb02 00c6 	add.w	r0, r2, r6, lsl #3
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8001c30:	f842 1036 	str.w	r1, [r2, r6, lsl #3]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma.streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001c34:	065a      	lsls	r2, r3, #25
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8001c36:	6041      	str	r1, [r0, #4]
  if ((dma.streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001c38:	d107      	bne.n	8001c4a <dmaStreamRelease+0x4a>
    rccDisableDMA1();
 8001c3a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8001c3e:	f501 3104 	add.w	r1, r1, #135168	; 0x21000
 8001c42:	694a      	ldr	r2, [r1, #20]
 8001c44:	f022 0201 	bic.w	r2, r2, #1
 8001c48:	614a      	str	r2, [r1, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma.streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8001c4a:	f413 6f78 	tst.w	r3, #3968	; 0xf80
 8001c4e:	d104      	bne.n	8001c5a <dmaStreamRelease+0x5a>
    rccDisableDMA2();
 8001c50:	4a0c      	ldr	r2, [pc, #48]	; (8001c84 <dmaStreamRelease+0x84>)
 8001c52:	6953      	ldr	r3, [r2, #20]
 8001c54:	f023 0302 	bic.w	r3, r3, #2
 8001c58:	6153      	str	r3, [r2, #20]
  }
#endif
}
 8001c5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgCheck(dmastp != NULL);
 8001c5c:	480a      	ldr	r0, [pc, #40]	; (8001c88 <dmaStreamRelease+0x88>)
 8001c5e:	f7ff fba7 	bl	80013b0 <chSysHalt>
    nvicDisableVector(dmastp->vector);
 8001c62:	7c81      	ldrb	r1, [r0, #18]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001c64:	4c09      	ldr	r4, [pc, #36]	; (8001c8c <dmaStreamRelease+0x8c>)
 8001c66:	0948      	lsrs	r0, r1, #5
 8001c68:	f001 051f 	and.w	r5, r1, #31
 8001c6c:	3020      	adds	r0, #32
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8001c6e:	4421      	add	r1, r4
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001c70:	40af      	lsls	r7, r5
 8001c72:	f844 7020 	str.w	r7, [r4, r0, lsl #2]
  NVIC->IP[n] = 0U;
 8001c76:	f881 2300 	strb.w	r2, [r1, #768]	; 0x300
 8001c7a:	e7d5      	b.n	8001c28 <dmaStreamRelease+0x28>
 8001c7c:	20001ff4 	.word	0x20001ff4
 8001c80:	20001534 	.word	0x20001534
 8001c84:	40021000 	.word	0x40021000
 8001c88:	0800e560 	.word	0x0800e560
 8001c8c:	e000e100 	.word	0xe000e100

08001c90 <dmaStreamAllocate>:
                       void *param) {
 8001c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  osalDbgCheck(dmastp != NULL);
 8001c92:	2800      	cmp	r0, #0
 8001c94:	d03b      	beq.n	8001d0e <dmaStreamAllocate+0x7e>
  if ((dma.streams_mask & (1U << dmastp->selfindex)) != 0U)
 8001c96:	4e2b      	ldr	r6, [pc, #172]	; (8001d44 <dmaStreamAllocate+0xb4>)
 8001c98:	f890 c011 	ldrb.w	ip, [r0, #17]
 8001c9c:	6834      	ldr	r4, [r6, #0]
 8001c9e:	2501      	movs	r5, #1
 8001ca0:	fa05 f70c 	lsl.w	r7, r5, ip
 8001ca4:	423c      	tst	r4, r7
 8001ca6:	d130      	bne.n	8001d0a <dmaStreamAllocate+0x7a>
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001ca8:	4d27      	ldr	r5, [pc, #156]	; (8001d48 <dmaStreamAllocate+0xb8>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001caa:	eb05 0ecc 	add.w	lr, r5, ip, lsl #3
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001cae:	f845 203c 	str.w	r2, [r5, ip, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001cb2:	f8ce 3004 	str.w	r3, [lr, #4]
  if ((dma.streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001cb6:	0663      	lsls	r3, r4, #25
 8001cb8:	d104      	bne.n	8001cc4 <dmaStreamAllocate+0x34>
    rccEnableDMA1(true);
 8001cba:	4a24      	ldr	r2, [pc, #144]	; (8001d4c <dmaStreamAllocate+0xbc>)
 8001cbc:	6953      	ldr	r3, [r2, #20]
 8001cbe:	f043 0301 	orr.w	r3, r3, #1
 8001cc2:	6153      	str	r3, [r2, #20]
  if ((dma.streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8001cc4:	f414 6f78 	tst.w	r4, #3968	; 0xf80
 8001cc8:	d104      	bne.n	8001cd4 <dmaStreamAllocate+0x44>
    rccEnableDMA2(true);
 8001cca:	4a20      	ldr	r2, [pc, #128]	; (8001d4c <dmaStreamAllocate+0xbc>)
 8001ccc:	6953      	ldr	r3, [r2, #20]
 8001cce:	f043 0302 	orr.w	r3, r3, #2
 8001cd2:	6153      	str	r3, [r2, #20]
  dmaStreamDisable(dmastp);
 8001cd4:	e9d0 c200 	ldrd	ip, r2, [r0]
 8001cd8:	6813      	ldr	r3, [r2, #0]
 8001cda:	f023 030f 	bic.w	r3, r3, #15
 8001cde:	6013      	str	r3, [r2, #0]
 8001ce0:	f890 e010 	ldrb.w	lr, [r0, #16]
    if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001ce4:	6873      	ldr	r3, [r6, #4]
  dmaStreamDisable(dmastp);
 8001ce6:	250e      	movs	r5, #14
 8001ce8:	fa05 f50e 	lsl.w	r5, r5, lr
 8001cec:	f8cc 5004 	str.w	r5, [ip, #4]
    if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001cf0:	6885      	ldr	r5, [r0, #8]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001cf2:	f04f 0c00 	mov.w	ip, #0
    if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001cf6:	422b      	tst	r3, r5
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001cf8:	f8c2 c000 	str.w	ip, [r2]
    if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001cfc:	d00a      	beq.n	8001d14 <dmaStreamAllocate+0x84>
    dma.isr_mask |= (1U << dmastp->selfindex);
 8001cfe:	433b      	orrs	r3, r7
  dma.streams_mask |= (1U << dmastp->selfindex);
 8001d00:	433c      	orrs	r4, r7
 8001d02:	e9c6 4300 	strd	r4, r3, [r6]
 8001d06:	2000      	movs	r0, #0
}
 8001d08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return true;
 8001d0a:	4628      	mov	r0, r5
}
 8001d0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgCheck(dmastp != NULL);
 8001d0e:	4810      	ldr	r0, [pc, #64]	; (8001d50 <dmaStreamAllocate+0xc0>)
 8001d10:	f7ff fb4e 	bl	80013b0 <chSysHalt>
      nvicEnableVector(dmastp->vector, priority);
 8001d14:	7c80      	ldrb	r0, [r0, #18]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d16:	0942      	lsrs	r2, r0, #5
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d18:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 8001d1c:	0092      	lsls	r2, r2, #2
 8001d1e:	0109      	lsls	r1, r1, #4
 8001d20:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
 8001d24:	b2c9      	uxtb	r1, r1
 8001d26:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8001d2a:	f885 1300 	strb.w	r1, [r5, #768]	; 0x300
 8001d2e:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d32:	f000 001f 	and.w	r0, r0, #31
 8001d36:	2101      	movs	r1, #1
 8001d38:	fa01 f000 	lsl.w	r0, r1, r0
 8001d3c:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001d40:	6010      	str	r0, [r2, #0]
 8001d42:	e7dc      	b.n	8001cfe <dmaStreamAllocate+0x6e>
 8001d44:	20001ff4 	.word	0x20001ff4
 8001d48:	20001534 	.word	0x20001534
 8001d4c:	40021000 	.word	0x40021000
 8001d50:	0800e54c 	.word	0x0800e54c
	...

08001d60 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 8001d60:	b570      	push	{r4, r5, r6, lr}
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8001d62:	7803      	ldrb	r3, [r0, #0]
 8001d64:	2b01      	cmp	r3, #1
void spi_lld_start(SPIDriver *spip) {
 8001d66:	4604      	mov	r4, r0
  if (spip->state == SPI_STOP) {
 8001d68:	d030      	beq.n	8001dcc <spi_lld_start+0x6c>
 8001d6a:	69c3      	ldr	r3, [r0, #28]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 8001d6c:	6865      	ldr	r5, [r4, #4]
 8001d6e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001d70:	8a6a      	ldrh	r2, [r5, #18]
 8001d72:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 8001d74:	f402 6670 	and.w	r6, r2, #3840	; 0xf00
 8001d78:	f5b6 6fe0 	cmp.w	r6, #1792	; 0x700
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  if (spip->config->circular) {
 8001d7c:	782e      	ldrb	r6, [r5, #0]
 8001d7e:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
 8001d82:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8001d86:	bf84      	itt	hi
 8001d88:	f441 61a0 	orrhi.w	r1, r1, #1280	; 0x500
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8001d8c:	f440 60a0 	orrhi.w	r0, r0, #1280	; 0x500
  if (spip->config->circular) {
 8001d90:	b9be      	cbnz	r6, 8001dc2 <spi_lld_start+0x62>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  }
  else {
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8001d92:	f021 0124 	bic.w	r1, r1, #36	; 0x24
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8001d96:	f020 0024 	bic.w	r0, r0, #36	; 0x24
  }

  /* SPI setup and enable.*/
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 8001d9a:	681e      	ldr	r6, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 8001d9c:	8a2d      	ldrh	r5, [r5, #16]
 8001d9e:	62e0      	str	r0, [r4, #44]	; 0x2c
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8001da0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001da4:	f042 0207 	orr.w	r2, r2, #7
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 8001da8:	f045 0004 	orr.w	r0, r5, #4
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 8001dac:	f026 0640 	bic.w	r6, r6, #64	; 0x40
 8001db0:	62a1      	str	r1, [r4, #40]	; 0x28
 8001db2:	601e      	str	r6, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 8001db4:	6018      	str	r0, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 8001db6:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 8001db8:	681a      	ldr	r2, [r3, #0]
 8001dba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001dbe:	601a      	str	r2, [r3, #0]
}
 8001dc0:	bd70      	pop	{r4, r5, r6, pc}
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8001dc2:	f041 0124 	orr.w	r1, r1, #36	; 0x24
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8001dc6:	f040 0024 	orr.w	r0, r0, #36	; 0x24
 8001dca:	e7e6      	b.n	8001d9a <spi_lld_start+0x3a>
    if (&SPID1 == spip) {
 8001dcc:	4b2a      	ldr	r3, [pc, #168]	; (8001e78 <spi_lld_start+0x118>)
 8001dce:	4298      	cmp	r0, r3
 8001dd0:	d023      	beq.n	8001e1a <spi_lld_start+0xba>
    if (&SPID2 == spip) {
 8001dd2:	4b2a      	ldr	r3, [pc, #168]	; (8001e7c <spi_lld_start+0x11c>)
 8001dd4:	4298      	cmp	r0, r3
 8001dd6:	d02a      	beq.n	8001e2e <spi_lld_start+0xce>
    if (&SPID3 == spip) {
 8001dd8:	4b29      	ldr	r3, [pc, #164]	; (8001e80 <spi_lld_start+0x120>)
 8001dda:	4298      	cmp	r0, r3
 8001ddc:	d009      	beq.n	8001df2 <spi_lld_start+0x92>
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8001dde:	e9d4 1208 	ldrd	r1, r2, [r4, #32]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8001de2:	69e3      	ldr	r3, [r4, #28]
 8001de4:	6848      	ldr	r0, [r1, #4]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8001de6:	6851      	ldr	r1, [r2, #4]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8001de8:	f103 020c 	add.w	r2, r3, #12
 8001dec:	6082      	str	r2, [r0, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8001dee:	608a      	str	r2, [r1, #8]
 8001df0:	e7bc      	b.n	8001d6c <spi_lld_start+0xc>
      b = dmaStreamAllocate(spip->dmarx,
 8001df2:	4603      	mov	r3, r0
 8001df4:	4a23      	ldr	r2, [pc, #140]	; (8001e84 <spi_lld_start+0x124>)
 8001df6:	6a00      	ldr	r0, [r0, #32]
 8001df8:	210a      	movs	r1, #10
 8001dfa:	f7ff ff49 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001dfe:	b998      	cbnz	r0, 8001e28 <spi_lld_start+0xc8>
      b = dmaStreamAllocate(spip->dmatx,
 8001e00:	4623      	mov	r3, r4
 8001e02:	4a21      	ldr	r2, [pc, #132]	; (8001e88 <spi_lld_start+0x128>)
 8001e04:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001e06:	210a      	movs	r1, #10
 8001e08:	f7ff ff42 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001e0c:	b960      	cbnz	r0, 8001e28 <spi_lld_start+0xc8>
      rccEnableSPI3(true);
 8001e0e:	4a1f      	ldr	r2, [pc, #124]	; (8001e8c <spi_lld_start+0x12c>)
 8001e10:	69d3      	ldr	r3, [r2, #28]
 8001e12:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001e16:	61d3      	str	r3, [r2, #28]
 8001e18:	e7e1      	b.n	8001dde <spi_lld_start+0x7e>
      b = dmaStreamAllocate(spip->dmarx,
 8001e1a:	4603      	mov	r3, r0
 8001e1c:	4a19      	ldr	r2, [pc, #100]	; (8001e84 <spi_lld_start+0x124>)
 8001e1e:	6a00      	ldr	r0, [r0, #32]
 8001e20:	210a      	movs	r1, #10
 8001e22:	f7ff ff35 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001e26:	b1c0      	cbz	r0, 8001e5a <spi_lld_start+0xfa>
 8001e28:	4819      	ldr	r0, [pc, #100]	; (8001e90 <spi_lld_start+0x130>)
 8001e2a:	f7ff fac1 	bl	80013b0 <chSysHalt>
      b = dmaStreamAllocate(spip->dmarx,
 8001e2e:	4603      	mov	r3, r0
 8001e30:	4a14      	ldr	r2, [pc, #80]	; (8001e84 <spi_lld_start+0x124>)
 8001e32:	6a00      	ldr	r0, [r0, #32]
 8001e34:	210a      	movs	r1, #10
 8001e36:	f7ff ff2b 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001e3a:	2800      	cmp	r0, #0
 8001e3c:	d1f4      	bne.n	8001e28 <spi_lld_start+0xc8>
      b = dmaStreamAllocate(spip->dmatx,
 8001e3e:	4623      	mov	r3, r4
 8001e40:	4a11      	ldr	r2, [pc, #68]	; (8001e88 <spi_lld_start+0x128>)
 8001e42:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001e44:	210a      	movs	r1, #10
 8001e46:	f7ff ff23 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001e4a:	2800      	cmp	r0, #0
 8001e4c:	d1ec      	bne.n	8001e28 <spi_lld_start+0xc8>
      rccEnableSPI2(true);
 8001e4e:	4a0f      	ldr	r2, [pc, #60]	; (8001e8c <spi_lld_start+0x12c>)
 8001e50:	69d3      	ldr	r3, [r2, #28]
 8001e52:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001e56:	61d3      	str	r3, [r2, #28]
 8001e58:	e7c1      	b.n	8001dde <spi_lld_start+0x7e>
      b = dmaStreamAllocate(spip->dmatx,
 8001e5a:	4623      	mov	r3, r4
 8001e5c:	4a0a      	ldr	r2, [pc, #40]	; (8001e88 <spi_lld_start+0x128>)
 8001e5e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001e60:	210a      	movs	r1, #10
 8001e62:	f7ff ff15 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8001e66:	2800      	cmp	r0, #0
 8001e68:	d1de      	bne.n	8001e28 <spi_lld_start+0xc8>
      rccEnableSPI1(true);
 8001e6a:	4a08      	ldr	r2, [pc, #32]	; (8001e8c <spi_lld_start+0x12c>)
 8001e6c:	6993      	ldr	r3, [r2, #24]
 8001e6e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001e72:	6193      	str	r3, [r2, #24]
 8001e74:	e7b3      	b.n	8001dde <spi_lld_start+0x7e>
 8001e76:	bf00      	nop
 8001e78:	20001498 	.word	0x20001498
 8001e7c:	200014c8 	.word	0x200014c8
 8001e80:	200014f8 	.word	0x200014f8
 8001e84:	08001a41 	.word	0x08001a41
 8001e88:	08001401 	.word	0x08001401
 8001e8c:	40021000 	.word	0x40021000
 8001e90:	0800e40c 	.word	0x0800e40c
	...

08001ea0 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001ea0:	6b01      	ldr	r1, [r0, #48]	; 0x30
  adc_lld_stop_adc(adcp);
 8001ea2:	6a82      	ldr	r2, [r0, #40]	; 0x28
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001ea4:	b430      	push	{r4, r5}
  dmaStreamDisable(adcp->dmastp);
 8001ea6:	e9d1 5400 	ldrd	r5, r4, [r1]
 8001eaa:	6820      	ldr	r0, [r4, #0]
 8001eac:	f020 000f 	bic.w	r0, r0, #15
 8001eb0:	6020      	str	r0, [r4, #0]
 8001eb2:	7c09      	ldrb	r1, [r1, #16]
 8001eb4:	230e      	movs	r3, #14
 8001eb6:	408b      	lsls	r3, r1
 8001eb8:	606b      	str	r3, [r5, #4]
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001eba:	6893      	ldr	r3, [r2, #8]
 8001ebc:	0759      	lsls	r1, r3, #29
 8001ebe:	d506      	bpl.n	8001ece <adc_lld_stop_conversion+0x2e>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001ec0:	6893      	ldr	r3, [r2, #8]
 8001ec2:	f043 0310 	orr.w	r3, r3, #16
 8001ec6:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001ec8:	6893      	ldr	r3, [r2, #8]
 8001eca:	06db      	lsls	r3, r3, #27
 8001ecc:	d4fc      	bmi.n	8001ec8 <adc_lld_stop_conversion+0x28>
}
 8001ece:	bc30      	pop	{r4, r5}
 8001ed0:	4770      	bx	lr
 8001ed2:	bf00      	nop
	...

08001ee0 <adc_lld_start_conversion>:
  const ADCConversionGroup *grpp = adcp->grpp;
 8001ee0:	6902      	ldr	r2, [r0, #16]
 8001ee2:	68c3      	ldr	r3, [r0, #12]
  if (grpp->circular) {
 8001ee4:	7811      	ldrb	r1, [r2, #0]
void adc_lld_start_conversion(ADCDriver *adcp) {
 8001ee6:	b5f0      	push	{r4, r5, r6, r7, lr}
  dmamode = adcp->dmamode;
 8001ee8:	6b46      	ldr	r6, [r0, #52]	; 0x34
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8001eea:	68d5      	ldr	r5, [r2, #12]
  if (grpp->circular) {
 8001eec:	2900      	cmp	r1, #0
 8001eee:	d033      	beq.n	8001f58 <adc_lld_start_conversion+0x78>
    if (adcp->depth > 1) {
 8001ef0:	2b01      	cmp	r3, #1
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 8001ef2:	f045 0503 	orr.w	r5, r5, #3
    dmamode |= STM32_DMA_CR_CIRC;
 8001ef6:	bf94      	ite	ls
 8001ef8:	f046 0620 	orrls.w	r6, r6, #32
      dmamode |= STM32_DMA_CR_HTIE;
 8001efc:	f046 0624 	orrhi.w	r6, r6, #36	; 0x24
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8001f00:	6b04      	ldr	r4, [r0, #48]	; 0x30
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8001f02:	8851      	ldrh	r1, [r2, #2]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8001f04:	6864      	ldr	r4, [r4, #4]
 8001f06:	6887      	ldr	r7, [r0, #8]
 8001f08:	60e7      	str	r7, [r4, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8001f0a:	fb03 f301 	mul.w	r3, r3, r1
 8001f0e:	6063      	str	r3, [r4, #4]
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8001f10:	6026      	str	r6, [r4, #0]
  dmaStreamEnable(adcp->dmastp);
 8001f12:	6826      	ldr	r6, [r4, #0]
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8001f14:	6a83      	ldr	r3, [r0, #40]	; 0x28
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001f16:	f8d2 e01c 	ldr.w	lr, [r2, #28]
  adcp->adcm->TR1   = grpp->tr1;
 8001f1a:	f8d2 c010 	ldr.w	ip, [r2, #16]
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8001f1e:	6957      	ldr	r7, [r2, #20]
  dmaStreamEnable(adcp->dmastp);
 8001f20:	f046 0601 	orr.w	r6, r6, #1
 8001f24:	6026      	str	r6, [r4, #0]
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8001f26:	6818      	ldr	r0, [r3, #0]
 8001f28:	6018      	str	r0, [r3, #0]
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
 8001f2a:	2090      	movs	r0, #144	; 0x90
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8001f2c:	6996      	ldr	r6, [r2, #24]
  adcp->adcm->SQR2  = grpp->sqr[1];
 8001f2e:	6a14      	ldr	r4, [r2, #32]
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
 8001f30:	6058      	str	r0, [r3, #4]
  adcp->adcm->SQR4  = grpp->sqr[3];
 8001f32:	e9d2 0209 	ldrd	r0, r2, [r2, #36]	; 0x24
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001f36:	3901      	subs	r1, #1
 8001f38:	ea41 010e 	orr.w	r1, r1, lr
  adcp->adcm->TR1   = grpp->tr1;
 8001f3c:	f8c3 c020 	str.w	ip, [r3, #32]
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8001f40:	615f      	str	r7, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8001f42:	619e      	str	r6, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001f44:	6319      	str	r1, [r3, #48]	; 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8001f46:	635c      	str	r4, [r3, #52]	; 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8001f48:	6398      	str	r0, [r3, #56]	; 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 8001f4a:	63da      	str	r2, [r3, #60]	; 0x3c
  adcp->adcm->CFGR  = cfgr;
 8001f4c:	60dd      	str	r5, [r3, #12]
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	f042 0204 	orr.w	r2, r2, #4
 8001f54:	609a      	str	r2, [r3, #8]
}
 8001f56:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8001f58:	f045 0501 	orr.w	r5, r5, #1
 8001f5c:	e7d0      	b.n	8001f00 <adc_lld_start_conversion+0x20>
 8001f5e:	bf00      	nop

08001f60 <adc_lld_serve_interrupt>:
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8001f60:	b538      	push	{r3, r4, r5, lr}
  if (adcp->grpp != NULL) {
 8001f62:	6903      	ldr	r3, [r0, #16]
 8001f64:	b17b      	cbz	r3, 8001f86 <adc_lld_serve_interrupt+0x26>
    if ((isr & ADC_ISR_OVR) &&
 8001f66:	06cb      	lsls	r3, r1, #27
 8001f68:	4604      	mov	r4, r0
 8001f6a:	460d      	mov	r5, r1
 8001f6c:	d505      	bpl.n	8001f7a <adc_lld_serve_interrupt+0x1a>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 8001f6e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001f70:	685b      	ldr	r3, [r3, #4]
 8001f72:	685b      	ldr	r3, [r3, #4]
    if ((isr & ADC_ISR_OVR) &&
 8001f74:	2b00      	cmp	r3, #0
 8001f76:	f040 808f 	bne.w	8002098 <adc_lld_serve_interrupt+0x138>
    if (isr & ADC_ISR_AWD1) {
 8001f7a:	0629      	lsls	r1, r5, #24
 8001f7c:	d404      	bmi.n	8001f88 <adc_lld_serve_interrupt+0x28>
    if (isr & ADC_ISR_AWD2) {
 8001f7e:	05ea      	lsls	r2, r5, #23
 8001f80:	d431      	bmi.n	8001fe6 <adc_lld_serve_interrupt+0x86>
    if (isr & ADC_ISR_AWD3) {
 8001f82:	05ab      	lsls	r3, r5, #22
 8001f84:	d45c      	bmi.n	8002040 <adc_lld_serve_interrupt+0xe0>
}
 8001f86:	bd38      	pop	{r3, r4, r5, pc}
      _adc_isr_error_code(adcp, ADC_ERR_AWD1);
 8001f88:	4620      	mov	r0, r4
 8001f8a:	f7ff ff89 	bl	8001ea0 <adc_lld_stop_conversion>
 8001f8e:	6923      	ldr	r3, [r4, #16]
 8001f90:	689b      	ldr	r3, [r3, #8]
 8001f92:	2b00      	cmp	r3, #0
 8001f94:	f000 80b1 	beq.w	80020fa <adc_lld_serve_interrupt+0x19a>
 8001f98:	2205      	movs	r2, #5
 8001f9a:	7022      	strb	r2, [r4, #0]
 8001f9c:	2102      	movs	r1, #2
 8001f9e:	4620      	mov	r0, r4
 8001fa0:	4798      	blx	r3
 8001fa2:	7823      	ldrb	r3, [r4, #0]
 8001fa4:	2b05      	cmp	r3, #5
 8001fa6:	bf04      	itt	eq
 8001fa8:	2302      	moveq	r3, #2
 8001faa:	7023      	strbeq	r3, [r4, #0]
 8001fac:	2300      	movs	r3, #0
 8001fae:	6123      	str	r3, [r4, #16]
 8001fb0:	2320      	movs	r3, #32
 8001fb2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001fb6:	f7ff fb73 	bl	80016a0 <_dbg_check_lock_from_isr>
  if (*trp != NULL) {
 8001fba:	6963      	ldr	r3, [r4, #20]
 8001fbc:	b163      	cbz	r3, 8001fd8 <adc_lld_serve_interrupt+0x78>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001fbe:	f893 2020 	ldrb.w	r2, [r3, #32]
 8001fc2:	2a03      	cmp	r2, #3
 8001fc4:	f040 8092 	bne.w	80020ec <adc_lld_serve_interrupt+0x18c>
    *trp = NULL;
 8001fc8:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 8001fca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    *trp = NULL;
 8001fce:	6161      	str	r1, [r4, #20]
    (void) chSchReadyI(tp);
 8001fd0:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8001fd2:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001fd4:	f7ff faac 	bl	8001530 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 8001fd8:	f7ff fb4a 	bl	8001670 <_dbg_check_unlock_from_isr>
 8001fdc:	2300      	movs	r3, #0
 8001fde:	f383 8811 	msr	BASEPRI, r3
    if (isr & ADC_ISR_AWD2) {
 8001fe2:	05ea      	lsls	r2, r5, #23
 8001fe4:	d5cd      	bpl.n	8001f82 <adc_lld_serve_interrupt+0x22>
      _adc_isr_error_code(adcp, ADC_ERR_AWD2);
 8001fe6:	4620      	mov	r0, r4
 8001fe8:	f7ff ff5a 	bl	8001ea0 <adc_lld_stop_conversion>
 8001fec:	6923      	ldr	r3, [r4, #16]
 8001fee:	689b      	ldr	r3, [r3, #8]
 8001ff0:	2b00      	cmp	r3, #0
 8001ff2:	d07e      	beq.n	80020f2 <adc_lld_serve_interrupt+0x192>
 8001ff4:	2205      	movs	r2, #5
 8001ff6:	7022      	strb	r2, [r4, #0]
 8001ff8:	2103      	movs	r1, #3
 8001ffa:	4620      	mov	r0, r4
 8001ffc:	4798      	blx	r3
 8001ffe:	7823      	ldrb	r3, [r4, #0]
 8002000:	2b05      	cmp	r3, #5
 8002002:	bf04      	itt	eq
 8002004:	2302      	moveq	r3, #2
 8002006:	7023      	strbeq	r3, [r4, #0]
 8002008:	2300      	movs	r3, #0
 800200a:	6123      	str	r3, [r4, #16]
 800200c:	2320      	movs	r3, #32
 800200e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8002012:	f7ff fb45 	bl	80016a0 <_dbg_check_lock_from_isr>
  if (*trp != NULL) {
 8002016:	6963      	ldr	r3, [r4, #20]
 8002018:	b15b      	cbz	r3, 8002032 <adc_lld_serve_interrupt+0xd2>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800201a:	f893 2020 	ldrb.w	r2, [r3, #32]
 800201e:	2a03      	cmp	r2, #3
 8002020:	d164      	bne.n	80020ec <adc_lld_serve_interrupt+0x18c>
    *trp = NULL;
 8002022:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 8002024:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    *trp = NULL;
 8002028:	6161      	str	r1, [r4, #20]
    (void) chSchReadyI(tp);
 800202a:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 800202c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800202e:	f7ff fa7f 	bl	8001530 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 8002032:	f7ff fb1d 	bl	8001670 <_dbg_check_unlock_from_isr>
 8002036:	2300      	movs	r3, #0
 8002038:	f383 8811 	msr	BASEPRI, r3
    if (isr & ADC_ISR_AWD3) {
 800203c:	05ab      	lsls	r3, r5, #22
 800203e:	d5a2      	bpl.n	8001f86 <adc_lld_serve_interrupt+0x26>
      _adc_isr_error_code(adcp, ADC_ERR_AWD3);
 8002040:	4620      	mov	r0, r4
 8002042:	f7ff ff2d 	bl	8001ea0 <adc_lld_stop_conversion>
 8002046:	6923      	ldr	r3, [r4, #16]
 8002048:	689b      	ldr	r3, [r3, #8]
 800204a:	2b00      	cmp	r3, #0
 800204c:	d059      	beq.n	8002102 <adc_lld_serve_interrupt+0x1a2>
 800204e:	2205      	movs	r2, #5
 8002050:	7022      	strb	r2, [r4, #0]
 8002052:	2104      	movs	r1, #4
 8002054:	4620      	mov	r0, r4
 8002056:	4798      	blx	r3
 8002058:	7823      	ldrb	r3, [r4, #0]
 800205a:	2b05      	cmp	r3, #5
 800205c:	bf04      	itt	eq
 800205e:	2302      	moveq	r3, #2
 8002060:	7023      	strbeq	r3, [r4, #0]
 8002062:	2300      	movs	r3, #0
 8002064:	6123      	str	r3, [r4, #16]
 8002066:	2320      	movs	r3, #32
 8002068:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800206c:	f7ff fb18 	bl	80016a0 <_dbg_check_lock_from_isr>
  if (*trp != NULL) {
 8002070:	6963      	ldr	r3, [r4, #20]
 8002072:	b15b      	cbz	r3, 800208c <adc_lld_serve_interrupt+0x12c>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002074:	f893 2020 	ldrb.w	r2, [r3, #32]
 8002078:	2a03      	cmp	r2, #3
 800207a:	d137      	bne.n	80020ec <adc_lld_serve_interrupt+0x18c>
    *trp = NULL;
 800207c:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 800207e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    *trp = NULL;
 8002082:	6161      	str	r1, [r4, #20]
    (void) chSchReadyI(tp);
 8002084:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8002086:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002088:	f7ff fa52 	bl	8001530 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 800208c:	f7ff faf0 	bl	8001670 <_dbg_check_unlock_from_isr>
 8002090:	2300      	movs	r3, #0
 8002092:	f383 8811 	msr	BASEPRI, r3
}
 8002096:	bd38      	pop	{r3, r4, r5, pc}
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 8002098:	f7ff ff02 	bl	8001ea0 <adc_lld_stop_conversion>
 800209c:	6923      	ldr	r3, [r4, #16]
 800209e:	689b      	ldr	r3, [r3, #8]
 80020a0:	b39b      	cbz	r3, 800210a <adc_lld_serve_interrupt+0x1aa>
 80020a2:	2205      	movs	r2, #5
 80020a4:	7022      	strb	r2, [r4, #0]
 80020a6:	2101      	movs	r1, #1
 80020a8:	4620      	mov	r0, r4
 80020aa:	4798      	blx	r3
 80020ac:	7823      	ldrb	r3, [r4, #0]
 80020ae:	2b05      	cmp	r3, #5
 80020b0:	bf04      	itt	eq
 80020b2:	2302      	moveq	r3, #2
 80020b4:	7023      	strbeq	r3, [r4, #0]
 80020b6:	2300      	movs	r3, #0
 80020b8:	6123      	str	r3, [r4, #16]
 80020ba:	2320      	movs	r3, #32
 80020bc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80020c0:	f7ff faee 	bl	80016a0 <_dbg_check_lock_from_isr>
  if (*trp != NULL) {
 80020c4:	6963      	ldr	r3, [r4, #20]
 80020c6:	b15b      	cbz	r3, 80020e0 <adc_lld_serve_interrupt+0x180>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80020c8:	f893 2020 	ldrb.w	r2, [r3, #32]
 80020cc:	2a03      	cmp	r2, #3
 80020ce:	d10d      	bne.n	80020ec <adc_lld_serve_interrupt+0x18c>
    *trp = NULL;
 80020d0:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 80020d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    *trp = NULL;
 80020d6:	6161      	str	r1, [r4, #20]
    (void) chSchReadyI(tp);
 80020d8:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 80020da:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80020dc:	f7ff fa28 	bl	8001530 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 80020e0:	f7ff fac6 	bl	8001670 <_dbg_check_unlock_from_isr>
 80020e4:	2300      	movs	r3, #0
 80020e6:	f383 8811 	msr	BASEPRI, r3
 80020ea:	e746      	b.n	8001f7a <adc_lld_serve_interrupt+0x1a>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80020ec:	4809      	ldr	r0, [pc, #36]	; (8002114 <adc_lld_serve_interrupt+0x1b4>)
 80020ee:	f7ff f95f 	bl	80013b0 <chSysHalt>
      _adc_isr_error_code(adcp, ADC_ERR_AWD2);
 80020f2:	2202      	movs	r2, #2
 80020f4:	6123      	str	r3, [r4, #16]
 80020f6:	7022      	strb	r2, [r4, #0]
 80020f8:	e788      	b.n	800200c <adc_lld_serve_interrupt+0xac>
      _adc_isr_error_code(adcp, ADC_ERR_AWD1);
 80020fa:	2202      	movs	r2, #2
 80020fc:	6123      	str	r3, [r4, #16]
 80020fe:	7022      	strb	r2, [r4, #0]
 8002100:	e756      	b.n	8001fb0 <adc_lld_serve_interrupt+0x50>
      _adc_isr_error_code(adcp, ADC_ERR_AWD3);
 8002102:	2202      	movs	r2, #2
 8002104:	6123      	str	r3, [r4, #16]
 8002106:	7022      	strb	r2, [r4, #0]
 8002108:	e7ad      	b.n	8002066 <adc_lld_serve_interrupt+0x106>
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 800210a:	2202      	movs	r2, #2
 800210c:	6123      	str	r3, [r4, #16]
 800210e:	7022      	strb	r2, [r4, #0]
 8002110:	e7d3      	b.n	80020ba <adc_lld_serve_interrupt+0x15a>
 8002112:	bf00      	nop
 8002114:	0800e360 	.word	0x0800e360
	...

08002120 <adc_lld_serve_dma_interrupt>:
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8002120:	b570      	push	{r4, r5, r6, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002122:	070d      	lsls	r5, r1, #28
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8002124:	4604      	mov	r4, r0
 8002126:	6903      	ldr	r3, [r0, #16]
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002128:	d41a      	bmi.n	8002160 <adc_lld_serve_dma_interrupt+0x40>
    if (adcp->grpp != NULL) {
 800212a:	b1c3      	cbz	r3, 800215e <adc_lld_serve_dma_interrupt+0x3e>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800212c:	078d      	lsls	r5, r1, #30
 800212e:	d548      	bpl.n	80021c2 <adc_lld_serve_dma_interrupt+0xa2>
        _adc_isr_full_code(adcp);
 8002130:	781a      	ldrb	r2, [r3, #0]
 8002132:	2a00      	cmp	r2, #0
 8002134:	d069      	beq.n	800220a <adc_lld_serve_dma_interrupt+0xea>
 8002136:	685d      	ldr	r5, [r3, #4]
 8002138:	b18d      	cbz	r5, 800215e <adc_lld_serve_dma_interrupt+0x3e>
 800213a:	e9d0 1202 	ldrd	r1, r2, [r0, #8]
 800213e:	2a01      	cmp	r2, #1
 8002140:	f240 8090 	bls.w	8002264 <adc_lld_serve_dma_interrupt+0x144>
 8002144:	885b      	ldrh	r3, [r3, #2]
 8002146:	0852      	lsrs	r2, r2, #1
 8002148:	0054      	lsls	r4, r2, #1
 800214a:	fb04 1103 	mla	r1, r4, r3, r1
 800214e:	462b      	mov	r3, r5
}
 8002150:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
 8002154:	4718      	bx	r3
 8002156:	2300      	movs	r3, #0
 8002158:	636b      	str	r3, [r5, #52]	; 0x34
 800215a:	f383 8811 	msr	BASEPRI, r3
}
 800215e:	bd70      	pop	{r4, r5, r6, pc}
  dmaStreamDisable(adcp->dmastp);
 8002160:	6b00      	ldr	r0, [r0, #48]	; 0x30
  adc_lld_stop_adc(adcp);
 8002162:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  dmaStreamDisable(adcp->dmastp);
 8002164:	6845      	ldr	r5, [r0, #4]
 8002166:	682a      	ldr	r2, [r5, #0]
 8002168:	f022 020f 	bic.w	r2, r2, #15
 800216c:	602a      	str	r2, [r5, #0]
 800216e:	7c05      	ldrb	r5, [r0, #16]
 8002170:	6800      	ldr	r0, [r0, #0]
 8002172:	220e      	movs	r2, #14
 8002174:	40aa      	lsls	r2, r5
 8002176:	6042      	str	r2, [r0, #4]
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8002178:	688a      	ldr	r2, [r1, #8]
 800217a:	0752      	lsls	r2, r2, #29
 800217c:	d506      	bpl.n	800218c <adc_lld_serve_dma_interrupt+0x6c>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 800217e:	688a      	ldr	r2, [r1, #8]
 8002180:	f042 0210 	orr.w	r2, r2, #16
 8002184:	608a      	str	r2, [r1, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8002186:	688a      	ldr	r2, [r1, #8]
 8002188:	06d6      	lsls	r6, r2, #27
 800218a:	d4fc      	bmi.n	8002186 <adc_lld_serve_dma_interrupt+0x66>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800218c:	689b      	ldr	r3, [r3, #8]
 800218e:	2b00      	cmp	r3, #0
 8002190:	d06c      	beq.n	800226c <adc_lld_serve_dma_interrupt+0x14c>
 8002192:	2205      	movs	r2, #5
 8002194:	7022      	strb	r2, [r4, #0]
 8002196:	2100      	movs	r1, #0
 8002198:	4620      	mov	r0, r4
 800219a:	4798      	blx	r3
 800219c:	7823      	ldrb	r3, [r4, #0]
 800219e:	2b05      	cmp	r3, #5
 80021a0:	bf04      	itt	eq
 80021a2:	2302      	moveq	r3, #2
 80021a4:	7023      	strbeq	r3, [r4, #0]
 80021a6:	2300      	movs	r3, #0
 80021a8:	6123      	str	r3, [r4, #16]
 80021aa:	2320      	movs	r3, #32
 80021ac:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80021b0:	4d30      	ldr	r5, [pc, #192]	; (8002274 <adc_lld_serve_dma_interrupt+0x154>)
 80021b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	dd01      	ble.n	80021bc <adc_lld_serve_dma_interrupt+0x9c>
 80021b8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80021ba:	b16b      	cbz	r3, 80021d8 <adc_lld_serve_dma_interrupt+0xb8>
    chSysHalt("SV#6");
 80021bc:	482e      	ldr	r0, [pc, #184]	; (8002278 <adc_lld_serve_dma_interrupt+0x158>)
 80021be:	f7ff f8f7 	bl	80013b0 <chSysHalt>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 80021c2:	074a      	lsls	r2, r1, #29
 80021c4:	d5cb      	bpl.n	800215e <adc_lld_serve_dma_interrupt+0x3e>
        _adc_isr_half_code(adcp);
 80021c6:	685b      	ldr	r3, [r3, #4]
 80021c8:	2b00      	cmp	r3, #0
 80021ca:	d0c8      	beq.n	800215e <adc_lld_serve_dma_interrupt+0x3e>
 80021cc:	e9d0 1202 	ldrd	r1, r2, [r0, #8]
}
 80021d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_half_code(adcp);
 80021d4:	0852      	lsrs	r2, r2, #1
 80021d6:	4718      	bx	r3
  if (*trp != NULL) {
 80021d8:	6962      	ldr	r2, [r4, #20]
  _dbg_enter_lock();
 80021da:	2101      	movs	r1, #1
 80021dc:	6369      	str	r1, [r5, #52]	; 0x34
 80021de:	2a00      	cmp	r2, #0
 80021e0:	d0b9      	beq.n	8002156 <adc_lld_serve_dma_interrupt+0x36>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80021e2:	f892 1020 	ldrb.w	r1, [r2, #32]
 80021e6:	2903      	cmp	r1, #3
 80021e8:	d134      	bne.n	8002254 <adc_lld_serve_dma_interrupt+0x134>
    tp->u.rdymsg = msg;
 80021ea:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    *trp = NULL;
 80021ee:	6163      	str	r3, [r4, #20]
    (void) chSchReadyI(tp);
 80021f0:	4610      	mov	r0, r2
    tp->u.rdymsg = msg;
 80021f2:	6251      	str	r1, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 80021f4:	f7ff f99c 	bl	8001530 <chSchReadyI>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80021f8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80021fa:	2b00      	cmp	r3, #0
 80021fc:	dd02      	ble.n	8002204 <adc_lld_serve_dma_interrupt+0xe4>
 80021fe:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002200:	2b00      	cmp	r3, #0
 8002202:	dca8      	bgt.n	8002156 <adc_lld_serve_dma_interrupt+0x36>
    chSysHalt("SV#7");
 8002204:	481d      	ldr	r0, [pc, #116]	; (800227c <adc_lld_serve_dma_interrupt+0x15c>)
 8002206:	f7ff f8d3 	bl	80013b0 <chSysHalt>
        _adc_isr_full_code(adcp);
 800220a:	f7ff fe49 	bl	8001ea0 <adc_lld_stop_conversion>
 800220e:	6923      	ldr	r3, [r4, #16]
 8002210:	685b      	ldr	r3, [r3, #4]
 8002212:	b313      	cbz	r3, 800225a <adc_lld_serve_dma_interrupt+0x13a>
 8002214:	2204      	movs	r2, #4
 8002216:	7022      	strb	r2, [r4, #0]
 8002218:	4620      	mov	r0, r4
 800221a:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800221e:	4798      	blx	r3
 8002220:	7823      	ldrb	r3, [r4, #0]
 8002222:	2b04      	cmp	r3, #4
 8002224:	d019      	beq.n	800225a <adc_lld_serve_dma_interrupt+0x13a>
 8002226:	2320      	movs	r3, #32
 8002228:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800222c:	f7ff fa38 	bl	80016a0 <_dbg_check_lock_from_isr>
  if (*trp != NULL) {
 8002230:	6963      	ldr	r3, [r4, #20]
 8002232:	b14b      	cbz	r3, 8002248 <adc_lld_serve_dma_interrupt+0x128>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002234:	f893 2020 	ldrb.w	r2, [r3, #32]
 8002238:	2a03      	cmp	r2, #3
 800223a:	d10b      	bne.n	8002254 <adc_lld_serve_dma_interrupt+0x134>
    *trp = NULL;
 800223c:	2200      	movs	r2, #0
 800223e:	6162      	str	r2, [r4, #20]
    (void) chSchReadyI(tp);
 8002240:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8002242:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002244:	f7ff f974 	bl	8001530 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 8002248:	f7ff fa12 	bl	8001670 <_dbg_check_unlock_from_isr>
 800224c:	2300      	movs	r3, #0
 800224e:	f383 8811 	msr	BASEPRI, r3
}
 8002252:	bd70      	pop	{r4, r5, r6, pc}
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002254:	480a      	ldr	r0, [pc, #40]	; (8002280 <adc_lld_serve_dma_interrupt+0x160>)
 8002256:	f7ff f8ab 	bl	80013b0 <chSysHalt>
        _adc_isr_full_code(adcp);
 800225a:	2202      	movs	r2, #2
 800225c:	2300      	movs	r3, #0
 800225e:	7022      	strb	r2, [r4, #0]
 8002260:	6123      	str	r3, [r4, #16]
 8002262:	e7e0      	b.n	8002226 <adc_lld_serve_dma_interrupt+0x106>
 8002264:	462b      	mov	r3, r5
}
 8002266:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
 800226a:	4718      	bx	r3
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800226c:	2202      	movs	r2, #2
 800226e:	6123      	str	r3, [r4, #16]
 8002270:	7022      	strb	r2, [r4, #0]
 8002272:	e79a      	b.n	80021aa <adc_lld_serve_dma_interrupt+0x8a>
 8002274:	2000159c 	.word	0x2000159c
 8002278:	0800e5ac 	.word	0x0800e5ac
 800227c:	0800e5b4 	.word	0x0800e5b4
 8002280:	0800e360 	.word	0x0800e360
	...

08002290 <chSysUnlock.lto_priv.76>:
static inline void chSysUnlock(void) {
 8002290:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002292:	4b0c      	ldr	r3, [pc, #48]	; (80022c4 <chSysUnlock.lto_priv.76+0x34>)
 8002294:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002296:	b97a      	cbnz	r2, 80022b8 <chSysUnlock.lto_priv.76+0x28>
 8002298:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800229a:	2900      	cmp	r1, #0
 800229c:	dd0c      	ble.n	80022b8 <chSysUnlock.lto_priv.76+0x28>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800229e:	6819      	ldr	r1, [r3, #0]
  _dbg_leave_lock();
 80022a0:	635a      	str	r2, [r3, #52]	; 0x34
 80022a2:	4299      	cmp	r1, r3
 80022a4:	d004      	beq.n	80022b0 <chSysUnlock.lto_priv.76+0x20>
 80022a6:	699a      	ldr	r2, [r3, #24]
 80022a8:	688b      	ldr	r3, [r1, #8]
 80022aa:	6892      	ldr	r2, [r2, #8]
 80022ac:	429a      	cmp	r2, r3
 80022ae:	d306      	bcc.n	80022be <chSysUnlock.lto_priv.76+0x2e>
 80022b0:	2300      	movs	r3, #0
 80022b2:	f383 8811 	msr	BASEPRI, r3
}
 80022b6:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 80022b8:	4803      	ldr	r0, [pc, #12]	; (80022c8 <chSysUnlock.lto_priv.76+0x38>)
 80022ba:	f7ff f879 	bl	80013b0 <chSysHalt>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80022be:	4803      	ldr	r0, [pc, #12]	; (80022cc <chSysUnlock.lto_priv.76+0x3c>)
 80022c0:	f7ff f876 	bl	80013b0 <chSysHalt>
 80022c4:	2000159c 	.word	0x2000159c
 80022c8:	0800e72c 	.word	0x0800e72c
 80022cc:	0800e1cc 	.word	0x0800e1cc

080022d0 <_ctl>:
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 80022d0:	b508      	push	{r3, lr}
  osalDbgCheck(sdp != NULL);
 80022d2:	b118      	cbz	r0, 80022dc <_ctl+0xc>
  switch (operation) {
 80022d4:	b111      	cbz	r1, 80022dc <_ctl+0xc>
 80022d6:	2901      	cmp	r1, #1
 80022d8:	d103      	bne.n	80022e2 <_ctl+0x12>
    osalDbgCheck(arg == NULL);
 80022da:	b112      	cbz	r2, 80022e2 <_ctl+0x12>
    osalDbgAssert(false, "invalid CTL operation");
 80022dc:	4802      	ldr	r0, [pc, #8]	; (80022e8 <_ctl+0x18>)
 80022de:	f7ff f867 	bl	80013b0 <chSysHalt>
}
 80022e2:	2000      	movs	r0, #0
 80022e4:	bd08      	pop	{r3, pc}
 80022e6:	bf00      	nop
 80022e8:	0800e498 	.word	0x0800e498
 80022ec:	00000000 	.word	0x00000000

080022f0 <wdgReset.constprop.34>:
 *
 * @param[in] wdgp      pointer to the @p WDGDriver object
 *
 * @api
 */
void wdgReset(WDGDriver *wdgp) {
 80022f0:	b510      	push	{r4, lr}
 80022f2:	2320      	movs	r3, #32
 80022f4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80022f8:	4b12      	ldr	r3, [pc, #72]	; (8002344 <wdgReset.constprop.34+0x54>)
 80022fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80022fc:	b90a      	cbnz	r2, 8002302 <wdgReset.constprop.34+0x12>
 80022fe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002300:	b112      	cbz	r2, 8002308 <wdgReset.constprop.34+0x18>
    chSysHalt("SV#4");
 8002302:	4811      	ldr	r0, [pc, #68]	; (8002348 <wdgReset.constprop.34+0x58>)
 8002304:	f7ff f854 	bl	80013b0 <chSysHalt>

  osalDbgCheck(wdgp != NULL);

  osalSysLock();
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 8002308:	4910      	ldr	r1, [pc, #64]	; (800234c <wdgReset.constprop.34+0x5c>)
 800230a:	7808      	ldrb	r0, [r1, #0]
  _dbg_enter_lock();
 800230c:	2401      	movs	r4, #1
 800230e:	2802      	cmp	r0, #2
 8002310:	635c      	str	r4, [r3, #52]	; 0x34
 8002312:	d002      	beq.n	800231a <wdgReset.constprop.34+0x2a>
 8002314:	480e      	ldr	r0, [pc, #56]	; (8002350 <wdgReset.constprop.34+0x60>)
 8002316:	f7ff f84b 	bl	80013b0 <chSysHalt>
 *
 * @notapi
 */
void wdg_lld_reset(WDGDriver * wdgp) {

  wdgp->wdg->KR = KR_KEY_RELOAD;
 800231a:	6888      	ldr	r0, [r1, #8]
 800231c:	6819      	ldr	r1, [r3, #0]
 800231e:	f64a 24aa 	movw	r4, #43690	; 0xaaaa
 8002322:	4299      	cmp	r1, r3
 8002324:	6004      	str	r4, [r0, #0]
  _dbg_leave_lock();
 8002326:	635a      	str	r2, [r3, #52]	; 0x34
 8002328:	d004      	beq.n	8002334 <wdgReset.constprop.34+0x44>
 800232a:	699a      	ldr	r2, [r3, #24]
 800232c:	688b      	ldr	r3, [r1, #8]
 800232e:	6892      	ldr	r2, [r2, #8]
 8002330:	429a      	cmp	r2, r3
 8002332:	d303      	bcc.n	800233c <wdgReset.constprop.34+0x4c>
 8002334:	2300      	movs	r3, #0
 8002336:	f383 8811 	msr	BASEPRI, r3
  wdgResetI(wdgp);
  osalSysUnlock();
}
 800233a:	bd10      	pop	{r4, pc}
 800233c:	4805      	ldr	r0, [pc, #20]	; (8002354 <wdgReset.constprop.34+0x64>)
 800233e:	f7ff f837 	bl	80013b0 <chSysHalt>
 8002342:	bf00      	nop
 8002344:	2000159c 	.word	0x2000159c
 8002348:	0800e704 	.word	0x0800e704
 800234c:	20001528 	.word	0x20001528
 8002350:	0800e3e8 	.word	0x0800e3e8
 8002354:	0800e1d8 	.word	0x0800e1d8
	...

08002360 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8002360:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002362:	4c1b      	ldr	r4, [pc, #108]	; (80023d0 <chSchGoSleepS+0x70>)
 8002364:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002366:	bb63      	cbnz	r3, 80023c2 <chSchGoSleepS+0x62>
 8002368:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800236a:	2b00      	cmp	r3, #0
 800236c:	dd29      	ble.n	80023c2 <chSchGoSleepS+0x62>
  thread_t *otp = currp;
 800236e:	69a5      	ldr	r5, [r4, #24]
  thread_t *tp = tqp->next;
 8002370:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8002372:	f885 0020 	strb.w	r0, [r5, #32]
  tqp->next             = tp->queue.next;
 8002376:	681a      	ldr	r2, [r3, #0]
 8002378:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 800237a:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800237c:	6054      	str	r4, [r2, #4]
 800237e:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002382:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002384:	61a3      	str	r3, [r4, #24]
 8002386:	07d3      	lsls	r3, r2, #31
 8002388:	d40f      	bmi.n	80023aa <chSchGoSleepS+0x4a>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800238a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800238c:	6a68      	ldr	r0, [r5, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800238e:	7813      	ldrb	r3, [r2, #0]
 8002390:	f361 0302 	bfi	r3, r1, #0, #3
 8002394:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002396:	f895 1020 	ldrb.w	r1, [r5, #32]
 800239a:	f361 03c7 	bfi	r3, r1, #3, #5
 800239e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80023a0:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80023a2:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 80023a6:	f7fe ffe3 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80023aa:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 80023ae:	69ea      	ldr	r2, [r5, #28]
 80023b0:	3b64      	subs	r3, #100	; 0x64
 80023b2:	429a      	cmp	r2, r3
 80023b4:	d808      	bhi.n	80023c8 <chSchGoSleepS+0x68>
 80023b6:	4629      	mov	r1, r5
 80023b8:	69a0      	ldr	r0, [r4, #24]
}
 80023ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 80023be:	f7fd bf83 	b.w	80002c8 <_port_switch>
    chSysHalt("SV#11");
 80023c2:	4804      	ldr	r0, [pc, #16]	; (80023d4 <chSchGoSleepS+0x74>)
 80023c4:	f7fe fff4 	bl	80013b0 <chSysHalt>
 80023c8:	4803      	ldr	r0, [pc, #12]	; (80023d8 <chSchGoSleepS+0x78>)
 80023ca:	f7fe fff1 	bl	80013b0 <chSysHalt>
 80023ce:	bf00      	nop
 80023d0:	2000159c 	.word	0x2000159c
 80023d4:	0800e714 	.word	0x0800e714
 80023d8:	0800e71c 	.word	0x0800e71c
 80023dc:	00000000 	.word	0x00000000

080023e0 <spi_read.constprop.10>:
    spiUnselect(&SPID3);
    spiStop(&SPID3);
    palSetPad(GPIOC,cp);
}

void spi_read(location,cp)
 80023e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
    palClearPad(GPIOC,cp);
 80023e2:	2301      	movs	r3, #1
 80023e4:	fa03 f000 	lsl.w	r0, r3, r0
 80023e8:	4aa0      	ldr	r2, [pc, #640]	; (800266c <spi_read.constprop.10+0x28c>)
 80023ea:	b284      	uxth	r4, r0
 80023ec:	8354      	strh	r4, [r2, #26]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023ee:	2220      	movs	r2, #32
 80023f0:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80023f4:	4d9e      	ldr	r5, [pc, #632]	; (8002670 <spi_read.constprop.10+0x290>)
 80023f6:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80023f8:	b90a      	cbnz	r2, 80023fe <spi_read.constprop.10+0x1e>
 80023fa:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80023fc:	b112      	cbz	r2, 8002404 <spi_read.constprop.10+0x24>
    chSysHalt("SV#4");
 80023fe:	489d      	ldr	r0, [pc, #628]	; (8002674 <spi_read.constprop.10+0x294>)
 8002400:	f7fe ffd6 	bl	80013b0 <chSysHalt>
void spiStart(SPIDriver *spip, const SPIConfig *config) {

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8002404:	4e9c      	ldr	r6, [pc, #624]	; (8002678 <spi_read.constprop.10+0x298>)
  _dbg_enter_lock();
 8002406:	636b      	str	r3, [r5, #52]	; 0x34
 8002408:	7833      	ldrb	r3, [r6, #0]
 800240a:	3b01      	subs	r3, #1
 800240c:	2b01      	cmp	r3, #1
 800240e:	d902      	bls.n	8002416 <spi_read.constprop.10+0x36>
 8002410:	489a      	ldr	r0, [pc, #616]	; (800267c <spi_read.constprop.10+0x29c>)
 8002412:	f7fe ffcd 	bl	80013b0 <chSysHalt>
                "invalid state");
  spip->config = config;
 8002416:	4b9a      	ldr	r3, [pc, #616]	; (8002680 <spi_read.constprop.10+0x2a0>)
 8002418:	6073      	str	r3, [r6, #4]
  spi_lld_start(spip);
 800241a:	4630      	mov	r0, r6
 800241c:	f7ff fca0 	bl	8001d60 <spi_lld_start>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002420:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  spip->state = SPI_READY;
 8002422:	2202      	movs	r2, #2
 8002424:	7032      	strb	r2, [r6, #0]
 8002426:	b9fb      	cbnz	r3, 8002468 <spi_read.constprop.10+0x88>
 8002428:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800242a:	2a00      	cmp	r2, #0
 800242c:	dd1c      	ble.n	8002468 <spi_read.constprop.10+0x88>
 800242e:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 8002430:	636b      	str	r3, [r5, #52]	; 0x34
 8002432:	42aa      	cmp	r2, r5
 8002434:	d004      	beq.n	8002440 <spi_read.constprop.10+0x60>
 8002436:	69a9      	ldr	r1, [r5, #24]
 8002438:	6893      	ldr	r3, [r2, #8]
 800243a:	688a      	ldr	r2, [r1, #8]
 800243c:	429a      	cmp	r2, r3
 800243e:	d316      	bcc.n	800246e <spi_read.constprop.10+0x8e>
 8002440:	2300      	movs	r3, #0
 8002442:	f383 8811 	msr	BASEPRI, r3
 8002446:	2320      	movs	r3, #32
 8002448:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800244c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800244e:	2b00      	cmp	r3, #0
 8002450:	d1d5      	bne.n	80023fe <spi_read.constprop.10+0x1e>
 8002452:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002454:	2b00      	cmp	r3, #0
 8002456:	d1d2      	bne.n	80023fe <spi_read.constprop.10+0x1e>
void spiSelect(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8002458:	7831      	ldrb	r1, [r6, #0]
  _dbg_enter_lock();
 800245a:	2201      	movs	r2, #1
 800245c:	2902      	cmp	r1, #2
 800245e:	636a      	str	r2, [r5, #52]	; 0x34
 8002460:	d008      	beq.n	8002474 <spi_read.constprop.10+0x94>
 8002462:	4888      	ldr	r0, [pc, #544]	; (8002684 <spi_read.constprop.10+0x2a4>)
 8002464:	f7fe ffa4 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8002468:	4887      	ldr	r0, [pc, #540]	; (8002688 <spi_read.constprop.10+0x2a8>)
 800246a:	f7fe ffa1 	bl	80013b0 <chSysHalt>
 800246e:	4887      	ldr	r0, [pc, #540]	; (800268c <spi_read.constprop.10+0x2ac>)
 8002470:	f7fe ff9e 	bl	80013b0 <chSysHalt>
  spiSelectI(spip);
 8002474:	6871      	ldr	r1, [r6, #4]
 8002476:	6828      	ldr	r0, [r5, #0]
 8002478:	e9d1 1702 	ldrd	r1, r7, [r1, #8]
 800247c:	40ba      	lsls	r2, r7
 800247e:	b292      	uxth	r2, r2
 8002480:	42a8      	cmp	r0, r5
 8002482:	834a      	strh	r2, [r1, #26]
  _dbg_leave_lock();
 8002484:	636b      	str	r3, [r5, #52]	; 0x34
 8002486:	d004      	beq.n	8002492 <spi_read.constprop.10+0xb2>
 8002488:	69aa      	ldr	r2, [r5, #24]
 800248a:	6883      	ldr	r3, [r0, #8]
 800248c:	6892      	ldr	r2, [r2, #8]
 800248e:	429a      	cmp	r2, r3
 8002490:	d3ed      	bcc.n	800246e <spi_read.constprop.10+0x8e>
 8002492:	2300      	movs	r3, #0
 8002494:	f383 8811 	msr	BASEPRI, r3
    spiStart(&SPID3,&std_spicfg0);
    spiSelect(&SPID3);
    txbuf[0] = location;
 8002498:	f8df c218 	ldr.w	ip, [pc, #536]	; 80026b4 <spi_read.constprop.10+0x2d4>
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));
#if SPI_SUPPORTS_CIRCULAR
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
 800249c:	6872      	ldr	r2, [r6, #4]
 800249e:	f88c 3000 	strb.w	r3, [ip]
 80024a2:	7813      	ldrb	r3, [r2, #0]
 80024a4:	b113      	cbz	r3, 80024ac <spi_read.constprop.10+0xcc>
 80024a6:	487a      	ldr	r0, [pc, #488]	; (8002690 <spi_read.constprop.10+0x2b0>)
 80024a8:	f7fe ff82 	bl	80013b0 <chSysHalt>
 80024ac:	2320      	movs	r3, #32
 80024ae:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80024b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80024b4:	2b00      	cmp	r3, #0
 80024b6:	d1a2      	bne.n	80023fe <spi_read.constprop.10+0x1e>
 80024b8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80024ba:	2b00      	cmp	r3, #0
 80024bc:	d19f      	bne.n	80023fe <spi_read.constprop.10+0x1e>
#endif

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80024be:	7833      	ldrb	r3, [r6, #0]
  _dbg_enter_lock();
 80024c0:	2701      	movs	r7, #1
 80024c2:	2b02      	cmp	r3, #2
 80024c4:	636f      	str	r7, [r5, #52]	; 0x34
 80024c6:	d1ee      	bne.n	80024a6 <spi_read.constprop.10+0xc6>

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80024c8:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80024cc:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80024ce:	6852      	ldr	r2, [r2, #4]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80024d0:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80024d2:	4870      	ldr	r0, [pc, #448]	; (8002694 <spi_read.constprop.10+0x2b4>)
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80024d4:	f8d6 e028 	ldr.w	lr, [r6, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80024d8:	60d0      	str	r0, [r2, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80024da:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  spiStartSendI(spip, n, txbuf);
 80024de:	2003      	movs	r0, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80024e0:	6057      	str	r7, [r2, #4]
 80024e2:	7030      	strb	r0, [r6, #0]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80024e4:	f8c2 e000 	str.w	lr, [r2]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80024e8:	f8c3 c00c 	str.w	ip, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80024ec:	605f      	str	r7, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80024ee:	6019      	str	r1, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 80024f0:	6811      	ldr	r1, [r2, #0]
  chDbgAssert(*trp == NULL, "not NULL");
 80024f2:	68b7      	ldr	r7, [r6, #8]
 80024f4:	f041 0101 	orr.w	r1, r1, #1
 80024f8:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 80024fa:	681a      	ldr	r2, [r3, #0]
 80024fc:	f042 0201 	orr.w	r2, r2, #1
 8002500:	601a      	str	r2, [r3, #0]
 8002502:	b117      	cbz	r7, 800250a <spi_read.constprop.10+0x12a>
 8002504:	4864      	ldr	r0, [pc, #400]	; (8002698 <spi_read.constprop.10+0x2b8>)
 8002506:	f7fe ff53 	bl	80013b0 <chSysHalt>
  return ch.rlist.current;
 800250a:	69ab      	ldr	r3, [r5, #24]
  tp->u.wttrp = trp;
 800250c:	4f63      	ldr	r7, [pc, #396]	; (800269c <spi_read.constprop.10+0x2bc>)
 800250e:	625f      	str	r7, [r3, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002510:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  *trp = tp;
 8002512:	60b3      	str	r3, [r6, #8]
 8002514:	b9e2      	cbnz	r2, 8002550 <spi_read.constprop.10+0x170>
 8002516:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002518:	2b00      	cmp	r3, #0
 800251a:	dd19      	ble.n	8002550 <spi_read.constprop.10+0x170>
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800251c:	f7ff ff20 	bl	8002360 <chSchGoSleepS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002520:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  }

  return currp->u.rdymsg;
 8002522:	69a9      	ldr	r1, [r5, #24]
 8002524:	2a00      	cmp	r2, #0
 8002526:	d19f      	bne.n	8002468 <spi_read.constprop.10+0x88>
 8002528:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800252a:	2b00      	cmp	r3, #0
 800252c:	dd9c      	ble.n	8002468 <spi_read.constprop.10+0x88>
 800252e:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 8002530:	636a      	str	r2, [r5, #52]	; 0x34
 8002532:	42ab      	cmp	r3, r5
 8002534:	d003      	beq.n	800253e <spi_read.constprop.10+0x15e>
 8002536:	688a      	ldr	r2, [r1, #8]
 8002538:	689b      	ldr	r3, [r3, #8]
 800253a:	429a      	cmp	r2, r3
 800253c:	d397      	bcc.n	800246e <spi_read.constprop.10+0x8e>
 800253e:	2300      	movs	r3, #0
 8002540:	f383 8811 	msr	BASEPRI, r3
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));
#if SPI_SUPPORTS_CIRCULAR
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
 8002544:	6873      	ldr	r3, [r6, #4]
 8002546:	781b      	ldrb	r3, [r3, #0]
 8002548:	b12b      	cbz	r3, 8002556 <spi_read.constprop.10+0x176>
 800254a:	4855      	ldr	r0, [pc, #340]	; (80026a0 <spi_read.constprop.10+0x2c0>)
 800254c:	f7fe ff30 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8002550:	4854      	ldr	r0, [pc, #336]	; (80026a4 <spi_read.constprop.10+0x2c4>)
 8002552:	f7fe ff2d 	bl	80013b0 <chSysHalt>
 8002556:	2320      	movs	r3, #32
 8002558:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800255c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800255e:	2b00      	cmp	r3, #0
 8002560:	f47f af4d 	bne.w	80023fe <spi_read.constprop.10+0x1e>
 8002564:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002566:	2b00      	cmp	r3, #0
 8002568:	f47f af49 	bne.w	80023fe <spi_read.constprop.10+0x1e>
#endif

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800256c:	7833      	ldrb	r3, [r6, #0]
  _dbg_enter_lock();
 800256e:	2201      	movs	r2, #1
 8002570:	2b02      	cmp	r3, #2
 8002572:	636a      	str	r2, [r5, #52]	; 0x34
 8002574:	d1e9      	bne.n	800254a <spi_read.constprop.10+0x16a>

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8002576:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800257a:	6ab1      	ldr	r1, [r6, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800257c:	6852      	ldr	r2, [r2, #4]
 800257e:	484a      	ldr	r0, [pc, #296]	; (80026a8 <spi_read.constprop.10+0x2c8>)
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8002580:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8002582:	60d0      	str	r0, [r2, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8002584:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  spiStartReceiveI(spip, n, rxbuf);
 8002588:	2003      	movs	r0, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800258a:	6050      	str	r0, [r2, #4]
 800258c:	7030      	strb	r0, [r6, #0]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800258e:	f8df c128 	ldr.w	ip, [pc, #296]	; 80026b8 <spi_read.constprop.10+0x2d8>
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8002592:	6011      	str	r1, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8002594:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8002596:	f8c3 c00c 	str.w	ip, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800259a:	6058      	str	r0, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800259c:	6019      	str	r1, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800259e:	6811      	ldr	r1, [r2, #0]
  chDbgAssert(*trp == NULL, "not NULL");
 80025a0:	f8d6 c008 	ldr.w	ip, [r6, #8]
 80025a4:	f041 0101 	orr.w	r1, r1, #1
 80025a8:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 80025aa:	681a      	ldr	r2, [r3, #0]
 80025ac:	69a9      	ldr	r1, [r5, #24]
 80025ae:	f042 0201 	orr.w	r2, r2, #1
 80025b2:	601a      	str	r2, [r3, #0]
 80025b4:	f1bc 0f00 	cmp.w	ip, #0
 80025b8:	d1a4      	bne.n	8002504 <spi_read.constprop.10+0x124>
  tp->u.wttrp = trp;
 80025ba:	624f      	str	r7, [r1, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80025bc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  *trp = tp;
 80025be:	60b1      	str	r1, [r6, #8]
 80025c0:	2b00      	cmp	r3, #0
 80025c2:	d1c5      	bne.n	8002550 <spi_read.constprop.10+0x170>
 80025c4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80025c6:	2b00      	cmp	r3, #0
 80025c8:	ddc2      	ble.n	8002550 <spi_read.constprop.10+0x170>
    chSchGoSleepS(newstate);
 80025ca:	f7ff fec9 	bl	8002360 <chSchGoSleepS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80025ce:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  return currp->u.rdymsg;
 80025d0:	69a9      	ldr	r1, [r5, #24]
 80025d2:	2a00      	cmp	r2, #0
 80025d4:	f47f af48 	bne.w	8002468 <spi_read.constprop.10+0x88>
 80025d8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80025da:	2b00      	cmp	r3, #0
 80025dc:	f77f af44 	ble.w	8002468 <spi_read.constprop.10+0x88>
 80025e0:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 80025e2:	636a      	str	r2, [r5, #52]	; 0x34
 80025e4:	42ab      	cmp	r3, r5
 80025e6:	d004      	beq.n	80025f2 <spi_read.constprop.10+0x212>
 80025e8:	688a      	ldr	r2, [r1, #8]
 80025ea:	689b      	ldr	r3, [r3, #8]
 80025ec:	429a      	cmp	r2, r3
 80025ee:	f4ff af3e 	bcc.w	800246e <spi_read.constprop.10+0x8e>
 80025f2:	2300      	movs	r3, #0
 80025f4:	f383 8811 	msr	BASEPRI, r3
 80025f8:	2320      	movs	r3, #32
 80025fa:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80025fe:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002600:	2b00      	cmp	r3, #0
 8002602:	f47f aefc 	bne.w	80023fe <spi_read.constprop.10+0x1e>
 8002606:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8002608:	2900      	cmp	r1, #0
 800260a:	f47f aef8 	bne.w	80023fe <spi_read.constprop.10+0x1e>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800260e:	7832      	ldrb	r2, [r6, #0]
  _dbg_enter_lock();
 8002610:	2301      	movs	r3, #1
 8002612:	2a02      	cmp	r2, #2
 8002614:	636b      	str	r3, [r5, #52]	; 0x34
 8002616:	d002      	beq.n	800261e <spi_read.constprop.10+0x23e>
 8002618:	4824      	ldr	r0, [pc, #144]	; (80026ac <spi_read.constprop.10+0x2cc>)
 800261a:	f7fe fec9 	bl	80013b0 <chSysHalt>
  spiUnselectI(spip);
 800261e:	6870      	ldr	r0, [r6, #4]
 8002620:	682a      	ldr	r2, [r5, #0]
 8002622:	e9d0 0702 	ldrd	r0, r7, [r0, #8]
 8002626:	40bb      	lsls	r3, r7
 8002628:	b29b      	uxth	r3, r3
 800262a:	42aa      	cmp	r2, r5
 800262c:	8303      	strh	r3, [r0, #24]
  _dbg_leave_lock();
 800262e:	6369      	str	r1, [r5, #52]	; 0x34
 8002630:	d005      	beq.n	800263e <spi_read.constprop.10+0x25e>
 8002632:	69a9      	ldr	r1, [r5, #24]
 8002634:	6893      	ldr	r3, [r2, #8]
 8002636:	688a      	ldr	r2, [r1, #8]
 8002638:	429a      	cmp	r2, r3
 800263a:	f4ff af18 	bcc.w	800246e <spi_read.constprop.10+0x8e>
 800263e:	2300      	movs	r3, #0
 8002640:	f383 8811 	msr	BASEPRI, r3
 8002644:	2320      	movs	r3, #32
 8002646:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800264a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800264c:	2b00      	cmp	r3, #0
 800264e:	f47f aed6 	bne.w	80023fe <spi_read.constprop.10+0x1e>
 8002652:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8002654:	2a00      	cmp	r2, #0
 8002656:	f47f aed2 	bne.w	80023fe <spi_read.constprop.10+0x1e>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800265a:	7833      	ldrb	r3, [r6, #0]
  _dbg_enter_lock();
 800265c:	2001      	movs	r0, #1
 800265e:	1e59      	subs	r1, r3, #1
 8002660:	4281      	cmp	r1, r0
 8002662:	6368      	str	r0, [r5, #52]	; 0x34
 8002664:	d92a      	bls.n	80026bc <spi_read.constprop.10+0x2dc>
 8002666:	4812      	ldr	r0, [pc, #72]	; (80026b0 <spi_read.constprop.10+0x2d0>)
 8002668:	f7fe fea2 	bl	80013b0 <chSysHalt>
 800266c:	48000800 	.word	0x48000800
 8002670:	2000159c 	.word	0x2000159c
 8002674:	0800e704 	.word	0x0800e704
 8002678:	200014f8 	.word	0x200014f8
 800267c:	0800e3c0 	.word	0x0800e3c0
 8002680:	0801d9a8 	.word	0x0801d9a8
 8002684:	0800e400 	.word	0x0800e400
 8002688:	0800e72c 	.word	0x0800e72c
 800268c:	0800e1cc 	.word	0x0800e1cc
 8002690:	0800e52c 	.word	0x0800e52c
 8002694:	20001ffc 	.word	0x20001ffc
 8002698:	0800e348 	.word	0x0800e348
 800269c:	20001500 	.word	0x20001500
 80026a0:	0800e540 	.word	0x0800e540
 80026a4:	0800e714 	.word	0x0800e714
 80026a8:	200024b0 	.word	0x200024b0
 80026ac:	0800e428 	.word	0x0800e428
 80026b0:	0800e3e0 	.word	0x0800e3e0
 80026b4:	20002610 	.word	0x20002610
 80026b8:	0800e760 	.word	0x0800e760
  if (spip->state == SPI_READY) {
 80026bc:	2b02      	cmp	r3, #2
 80026be:	d111      	bne.n	80026e4 <spi_read.constprop.10+0x304>
    dmaStreamRelease(spip->dmarx);
 80026c0:	e9d6 3007 	ldrd	r3, r0, [r6, #28]
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 80026c4:	6819      	ldr	r1, [r3, #0]
 80026c6:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 80026ca:	6019      	str	r1, [r3, #0]
    spip->spi->CR1  = 0;
 80026cc:	601a      	str	r2, [r3, #0]
    spip->spi->CR2  = 0;
 80026ce:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 80026d0:	f7ff fa96 	bl	8001c00 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 80026d4:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80026d6:	f7ff fa93 	bl	8001c00 <dmaStreamRelease>
      rccDisableSPI3();
 80026da:	4a10      	ldr	r2, [pc, #64]	; (800271c <spi_read.constprop.10+0x33c>)
 80026dc:	69d3      	ldr	r3, [r2, #28]
 80026de:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80026e2:	61d3      	str	r3, [r2, #28]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80026e4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  spip->config = NULL;
 80026e6:	2100      	movs	r1, #0
  spip->state  = SPI_STOP;
 80026e8:	2301      	movs	r3, #1
  spip->config = NULL;
 80026ea:	6071      	str	r1, [r6, #4]
  spip->state  = SPI_STOP;
 80026ec:	7033      	strb	r3, [r6, #0]
 80026ee:	2a00      	cmp	r2, #0
 80026f0:	f47f aeba 	bne.w	8002468 <spi_read.constprop.10+0x88>
 80026f4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80026f6:	428b      	cmp	r3, r1
 80026f8:	f77f aeb6 	ble.w	8002468 <spi_read.constprop.10+0x88>
 80026fc:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 80026fe:	636a      	str	r2, [r5, #52]	; 0x34
 8002700:	42ab      	cmp	r3, r5
 8002702:	d005      	beq.n	8002710 <spi_read.constprop.10+0x330>
 8002704:	69aa      	ldr	r2, [r5, #24]
 8002706:	689b      	ldr	r3, [r3, #8]
 8002708:	6892      	ldr	r2, [r2, #8]
 800270a:	429a      	cmp	r2, r3
 800270c:	f4ff aeaf 	bcc.w	800246e <spi_read.constprop.10+0x8e>
 8002710:	2300      	movs	r3, #0
 8002712:	f383 8811 	msr	BASEPRI, r3
    spiSend(&SPID3,1,&txbuf);
    spiReceive(&SPID3,3,&rxbuf);
    spiUnselect(&SPID3);
    spiStop(&SPID3);
    palSetPad(GPIOC,cp);
 8002716:	4b02      	ldr	r3, [pc, #8]	; (8002720 <spi_read.constprop.10+0x340>)
 8002718:	831c      	strh	r4, [r3, #24]
}
 800271a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800271c:	40021000 	.word	0x40021000
 8002720:	48000800 	.word	0x48000800
	...

08002730 <chSchWakeupS.constprop.32>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002730:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8002732:	4c21      	ldr	r4, [pc, #132]	; (80027b8 <chSchWakeupS.constprop.32+0x88>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002734:	4605      	mov	r5, r0

  chDbgCheckClassS();
 8002736:	f7fe fe53 	bl	80013e0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800273a:	6823      	ldr	r3, [r4, #0]
  thread_t *otp = currp;
 800273c:	69a6      	ldr	r6, [r4, #24]
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800273e:	42a3      	cmp	r3, r4
 8002740:	68b2      	ldr	r2, [r6, #8]
 8002742:	d002      	beq.n	800274a <chSchWakeupS.constprop.32+0x1a>
 8002744:	689b      	ldr	r3, [r3, #8]
 8002746:	4293      	cmp	r3, r2
 8002748:	d830      	bhi.n	80027ac <chSchWakeupS.constprop.32+0x7c>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800274a:	68ab      	ldr	r3, [r5, #8]
  ntp->u.rdymsg = msg;
 800274c:	2100      	movs	r1, #0
  if (ntp->prio <= otp->prio) {
 800274e:	4293      	cmp	r3, r2
  ntp->u.rdymsg = msg;
 8002750:	6269      	str	r1, [r5, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8002752:	d926      	bls.n	80027a2 <chSchWakeupS.constprop.32+0x72>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 8002754:	4630      	mov	r0, r6
 8002756:	f7fe feeb 	bl	8001530 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800275a:	2201      	movs	r2, #1
 800275c:	f885 2020 	strb.w	r2, [r5, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002760:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    currp = ntp;
 8002762:	61a5      	str	r5, [r4, #24]
 8002764:	07db      	lsls	r3, r3, #31
    otp = chSchReadyI(otp);
 8002766:	4606      	mov	r6, r0
 8002768:	d40f      	bmi.n	800278a <chSchWakeupS.constprop.32+0x5a>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800276a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800276c:	6a40      	ldr	r0, [r0, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800276e:	780b      	ldrb	r3, [r1, #0]
 8002770:	f362 0302 	bfi	r3, r2, #0, #3
 8002774:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002776:	f896 2020 	ldrb.w	r2, [r6, #32]
 800277a:	f362 03c7 	bfi	r3, r2, #3, #5
 800277e:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002780:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002782:	e9c1 3002 	strd	r3, r0, [r1, #8]
    trace_next();
 8002786:	f7fe fdf3 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800278a:	f3ef 8309 	mrs	r3, PSP

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800278e:	69f2      	ldr	r2, [r6, #28]
 8002790:	3b64      	subs	r3, #100	; 0x64
 8002792:	429a      	cmp	r2, r3
 8002794:	d80d      	bhi.n	80027b2 <chSchWakeupS.constprop.32+0x82>
 8002796:	4631      	mov	r1, r6
 8002798:	4628      	mov	r0, r5
  }
}
 800279a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 800279e:	f7fd bd93 	b.w	80002c8 <_port_switch>
    (void) chSchReadyI(ntp);
 80027a2:	4628      	mov	r0, r5
}
 80027a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
 80027a8:	f7fe bec2 	b.w	8001530 <chSchReadyI>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80027ac:	4803      	ldr	r0, [pc, #12]	; (80027bc <chSchWakeupS.constprop.32+0x8c>)
 80027ae:	f7fe fdff 	bl	80013b0 <chSysHalt>
    chSysSwitch(ntp, otp);
 80027b2:	4803      	ldr	r0, [pc, #12]	; (80027c0 <chSchWakeupS.constprop.32+0x90>)
 80027b4:	f7fe fdfc 	bl	80013b0 <chSysHalt>
 80027b8:	2000159c 	.word	0x2000159c
 80027bc:	0800e30c 	.word	0x0800e30c
 80027c0:	0800e71c 	.word	0x0800e71c
	...

080027d0 <spi_write.constprop.11>:
    palClearPad(GPIOC,cp);
 80027d0:	2301      	movs	r3, #1
 80027d2:	fa03 f000 	lsl.w	r0, r3, r0
 80027d6:	4aac      	ldr	r2, [pc, #688]	; (8002a88 <spi_write.constprop.11+0x2b8>)
void spi_write(location,data,cp)
 80027d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    palClearPad(GPIOC,cp);
 80027dc:	b284      	uxth	r4, r0
 80027de:	8354      	strh	r4, [r2, #26]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80027e0:	2220      	movs	r2, #32
 80027e2:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80027e6:	4da9      	ldr	r5, [pc, #676]	; (8002a8c <spi_write.constprop.11+0x2bc>)
 80027e8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80027ea:	b90a      	cbnz	r2, 80027f0 <spi_write.constprop.11+0x20>
 80027ec:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80027ee:	b112      	cbz	r2, 80027f6 <spi_write.constprop.11+0x26>
    chSysHalt("SV#4");
 80027f0:	48a7      	ldr	r0, [pc, #668]	; (8002a90 <spi_write.constprop.11+0x2c0>)
 80027f2:	f7fe fddd 	bl	80013b0 <chSysHalt>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 80027f6:	4ea7      	ldr	r6, [pc, #668]	; (8002a94 <spi_write.constprop.11+0x2c4>)
  _dbg_enter_lock();
 80027f8:	636b      	str	r3, [r5, #52]	; 0x34
 80027fa:	7833      	ldrb	r3, [r6, #0]
 80027fc:	1e59      	subs	r1, r3, #1
 80027fe:	2901      	cmp	r1, #1
 8002800:	d902      	bls.n	8002808 <spi_write.constprop.11+0x38>
 8002802:	48a5      	ldr	r0, [pc, #660]	; (8002a98 <spi_write.constprop.11+0x2c8>)
 8002804:	f7fe fdd4 	bl	80013b0 <chSysHalt>
  spip->config = config;
 8002808:	4fa4      	ldr	r7, [pc, #656]	; (8002a9c <spi_write.constprop.11+0x2cc>)
 800280a:	6077      	str	r7, [r6, #4]
  if (spip->state == SPI_STOP) {
 800280c:	2b01      	cmp	r3, #1
 800280e:	d04a      	beq.n	80028a6 <spi_write.constprop.11+0xd6>
 8002810:	69f3      	ldr	r3, [r6, #28]
 8002812:	f241 7c07 	movw	ip, #5895	; 0x1707
 8002816:	f04f 0e04 	mov.w	lr, #4
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800281a:	e9d6 100a 	ldrd	r1, r0, [r6, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800281e:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8002822:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
  if (spip->config->circular) {
 8002826:	783f      	ldrb	r7, [r7, #0]
 8002828:	2f00      	cmp	r7, #0
 800282a:	d137      	bne.n	800289c <spi_write.constprop.11+0xcc>
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800282c:	f021 0124 	bic.w	r1, r1, #36	; 0x24
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8002830:	f020 0024 	bic.w	r0, r0, #36	; 0x24
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 8002834:	681f      	ldr	r7, [r3, #0]
 8002836:	62f0      	str	r0, [r6, #44]	; 0x2c
 8002838:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 800283c:	62b1      	str	r1, [r6, #40]	; 0x28
 800283e:	601f      	str	r7, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 8002840:	f8c3 e000 	str.w	lr, [r3]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 8002844:	f8c3 c004 	str.w	ip, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 8002848:	6819      	ldr	r1, [r3, #0]
  spip->state = SPI_READY;
 800284a:	2002      	movs	r0, #2
 800284c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8002850:	6019      	str	r1, [r3, #0]
 8002852:	7030      	strb	r0, [r6, #0]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002854:	b9fa      	cbnz	r2, 8002896 <spi_write.constprop.11+0xc6>
 8002856:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002858:	2b00      	cmp	r3, #0
 800285a:	dd1c      	ble.n	8002896 <spi_write.constprop.11+0xc6>
 800285c:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 800285e:	636a      	str	r2, [r5, #52]	; 0x34
 8002860:	42ab      	cmp	r3, r5
 8002862:	d004      	beq.n	800286e <spi_write.constprop.11+0x9e>
 8002864:	69aa      	ldr	r2, [r5, #24]
 8002866:	689b      	ldr	r3, [r3, #8]
 8002868:	6892      	ldr	r2, [r2, #8]
 800286a:	429a      	cmp	r2, r3
 800286c:	d35c      	bcc.n	8002928 <spi_write.constprop.11+0x158>
 800286e:	2300      	movs	r3, #0
 8002870:	f383 8811 	msr	BASEPRI, r3
 8002874:	2320      	movs	r3, #32
 8002876:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800287a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800287c:	2b00      	cmp	r3, #0
 800287e:	d1b7      	bne.n	80027f0 <spi_write.constprop.11+0x20>
 8002880:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002882:	2b00      	cmp	r3, #0
 8002884:	d1b4      	bne.n	80027f0 <spi_write.constprop.11+0x20>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8002886:	7831      	ldrb	r1, [r6, #0]
  _dbg_enter_lock();
 8002888:	2201      	movs	r2, #1
 800288a:	2902      	cmp	r1, #2
 800288c:	636a      	str	r2, [r5, #52]	; 0x34
 800288e:	d04e      	beq.n	800292e <spi_write.constprop.11+0x15e>
 8002890:	4883      	ldr	r0, [pc, #524]	; (8002aa0 <spi_write.constprop.11+0x2d0>)
 8002892:	f7fe fd8d 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8002896:	4883      	ldr	r0, [pc, #524]	; (8002aa4 <spi_write.constprop.11+0x2d4>)
 8002898:	f7fe fd8a 	bl	80013b0 <chSysHalt>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800289c:	f041 0124 	orr.w	r1, r1, #36	; 0x24
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80028a0:	f040 0024 	orr.w	r0, r0, #36	; 0x24
 80028a4:	e7c6      	b.n	8002834 <spi_write.constprop.11+0x64>
      b = dmaStreamAllocate(spip->dmarx,
 80028a6:	4633      	mov	r3, r6
 80028a8:	4a7f      	ldr	r2, [pc, #508]	; (8002aa8 <spi_write.constprop.11+0x2d8>)
 80028aa:	6a30      	ldr	r0, [r6, #32]
 80028ac:	210a      	movs	r1, #10
 80028ae:	f7ff f9ef 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 80028b2:	bbb0      	cbnz	r0, 8002922 <spi_write.constprop.11+0x152>
      b = dmaStreamAllocate(spip->dmatx,
 80028b4:	4633      	mov	r3, r6
 80028b6:	4a7d      	ldr	r2, [pc, #500]	; (8002aac <spi_write.constprop.11+0x2dc>)
 80028b8:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80028ba:	210a      	movs	r1, #10
 80028bc:	f7ff f9e8 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 80028c0:	bb78      	cbnz	r0, 8002922 <spi_write.constprop.11+0x152>
      rccEnableSPI3(true);
 80028c2:	f8df 820c 	ldr.w	r8, [pc, #524]	; 8002ad0 <spi_write.constprop.11+0x300>
  ds = spip->config->cr2 & SPI_CR2_DS;
 80028c6:	6877      	ldr	r7, [r6, #4]
      rccEnableSPI3(true);
 80028c8:	f8d8 c01c 	ldr.w	ip, [r8, #28]
  ds = spip->config->cr2 & SPI_CR2_DS;
 80028cc:	8a78      	ldrh	r0, [r7, #18]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 80028ce:	69f3      	ldr	r3, [r6, #28]
 80028d0:	f8b7 e010 	ldrh.w	lr, [r7, #16]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 80028d4:	e9d6 1208 	ldrd	r1, r2, [r6, #32]
      rccEnableSPI3(true);
 80028d8:	f44c 4c00 	orr.w	ip, ip, #32768	; 0x8000
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 80028dc:	f8d1 a004 	ldr.w	sl, [r1, #4]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 80028e0:	f8d2 9004 	ldr.w	r9, [r2, #4]
 80028e4:	e9d6 120a 	ldrd	r1, r2, [r6, #40]	; 0x28
      rccEnableSPI3(true);
 80028e8:	f8c8 c01c 	str.w	ip, [r8, #28]
 80028ec:	f440 5c80 	orr.w	ip, r0, #4096	; 0x1000
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 80028f0:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 80028f4:	f103 080c 	add.w	r8, r3, #12
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 80028f8:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 80028fc:	f8ca 8008 	str.w	r8, [sl, #8]
 8002900:	f04c 0c07 	orr.w	ip, ip, #7
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8002904:	f8c9 8008 	str.w	r8, [r9, #8]
 8002908:	f04e 0e04 	orr.w	lr, lr, #4
 800290c:	f422 6870 	bic.w	r8, r2, #3840	; 0xf00
 8002910:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
 8002914:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 8002916:	d980      	bls.n	800281a <spi_write.constprop.11+0x4a>
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8002918:	f441 61a0 	orr.w	r1, r1, #1280	; 0x500
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800291c:	f448 60a0 	orr.w	r0, r8, #1280	; 0x500
 8002920:	e781      	b.n	8002826 <spi_write.constprop.11+0x56>
      osalDbgAssert(!b, "stream already allocated");
 8002922:	4863      	ldr	r0, [pc, #396]	; (8002ab0 <spi_write.constprop.11+0x2e0>)
 8002924:	f7fe fd44 	bl	80013b0 <chSysHalt>
 8002928:	4862      	ldr	r0, [pc, #392]	; (8002ab4 <spi_write.constprop.11+0x2e4>)
 800292a:	f7fe fd41 	bl	80013b0 <chSysHalt>
  spiSelectI(spip);
 800292e:	6871      	ldr	r1, [r6, #4]
 8002930:	6828      	ldr	r0, [r5, #0]
 8002932:	e9d1 1702 	ldrd	r1, r7, [r1, #8]
 8002936:	40ba      	lsls	r2, r7
 8002938:	b292      	uxth	r2, r2
 800293a:	42a8      	cmp	r0, r5
 800293c:	834a      	strh	r2, [r1, #26]
  _dbg_leave_lock();
 800293e:	636b      	str	r3, [r5, #52]	; 0x34
 8002940:	d004      	beq.n	800294c <spi_write.constprop.11+0x17c>
 8002942:	69aa      	ldr	r2, [r5, #24]
 8002944:	6883      	ldr	r3, [r0, #8]
 8002946:	6892      	ldr	r2, [r2, #8]
 8002948:	429a      	cmp	r2, r3
 800294a:	d3ed      	bcc.n	8002928 <spi_write.constprop.11+0x158>
 800294c:	2300      	movs	r3, #0
 800294e:	f383 8811 	msr	BASEPRI, r3
    txbuf[0] = location;
 8002952:	f8df e180 	ldr.w	lr, [pc, #384]	; 8002ad4 <spi_write.constprop.11+0x304>
 8002956:	f24d 0380 	movw	r3, #53376	; 0xd080
 800295a:	f8ae 3000 	strh.w	r3, [lr]
 800295e:	2320      	movs	r3, #32
 8002960:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002964:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002966:	2b00      	cmp	r3, #0
 8002968:	f47f af42 	bne.w	80027f0 <spi_write.constprop.11+0x20>
 800296c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800296e:	2b00      	cmp	r3, #0
 8002970:	f47f af3e 	bne.w	80027f0 <spi_write.constprop.11+0x20>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8002974:	7837      	ldrb	r7, [r6, #0]
  _dbg_enter_lock();
 8002976:	2101      	movs	r1, #1
 8002978:	2f02      	cmp	r7, #2
 800297a:	6369      	str	r1, [r5, #52]	; 0x34
 800297c:	d002      	beq.n	8002984 <spi_write.constprop.11+0x1b4>
 800297e:	484e      	ldr	r0, [pc, #312]	; (8002ab8 <spi_write.constprop.11+0x2e8>)
 8002980:	f7fe fd16 	bl	80013b0 <chSysHalt>
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8002984:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8002988:	6af0      	ldr	r0, [r6, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800298a:	6852      	ldr	r2, [r2, #4]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800298c:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800298e:	f8df c148 	ldr.w	ip, [pc, #328]	; 8002ad8 <spi_write.constprop.11+0x308>
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8002992:	f8d6 8028 	ldr.w	r8, [r6, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8002996:	f8c2 c00c 	str.w	ip, [r2, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800299a:	f040 0080 	orr.w	r0, r0, #128	; 0x80
  spiStartSendI(spip, n, txbuf);
 800299e:	f04f 0c03 	mov.w	ip, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80029a2:	6057      	str	r7, [r2, #4]
 80029a4:	f886 c000 	strb.w	ip, [r6]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80029a8:	f8c2 8000 	str.w	r8, [r2]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80029ac:	f8c3 e00c 	str.w	lr, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80029b0:	605f      	str	r7, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80029b2:	6018      	str	r0, [r3, #0]
  dmaStreamEnable(spip->dmarx);
 80029b4:	6810      	ldr	r0, [r2, #0]
  chDbgAssert(*trp == NULL, "not NULL");
 80029b6:	68b7      	ldr	r7, [r6, #8]
 80029b8:	f040 0001 	orr.w	r0, r0, #1
 80029bc:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 80029be:	681a      	ldr	r2, [r3, #0]
 80029c0:	f042 0201 	orr.w	r2, r2, #1
 80029c4:	601a      	str	r2, [r3, #0]
 80029c6:	b117      	cbz	r7, 80029ce <spi_write.constprop.11+0x1fe>
 80029c8:	483c      	ldr	r0, [pc, #240]	; (8002abc <spi_write.constprop.11+0x2ec>)
 80029ca:	f7fe fcf1 	bl	80013b0 <chSysHalt>
 80029ce:	69af      	ldr	r7, [r5, #24]
  tp->u.wttrp = trp;
 80029d0:	483b      	ldr	r0, [pc, #236]	; (8002ac0 <spi_write.constprop.11+0x2f0>)
 80029d2:	6278      	str	r0, [r7, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80029d4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  *trp = tp;
 80029d6:	60b7      	str	r7, [r6, #8]
 80029d8:	2b00      	cmp	r3, #0
 80029da:	d14f      	bne.n	8002a7c <spi_write.constprop.11+0x2ac>
 80029dc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80029de:	2b00      	cmp	r3, #0
 80029e0:	dd4c      	ble.n	8002a7c <spi_write.constprop.11+0x2ac>
  thread_t *tp = tqp->next;
 80029e2:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 80029e4:	f887 c020 	strb.w	ip, [r7, #32]
  tqp->next             = tp->queue.next;
 80029e8:	681a      	ldr	r2, [r3, #0]
 80029ea:	602a      	str	r2, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80029ec:	6055      	str	r5, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 80029ee:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80029f2:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 80029f4:	61ab      	str	r3, [r5, #24]
 80029f6:	07d3      	lsls	r3, r2, #31
 80029f8:	d40e      	bmi.n	8002a18 <spi_write.constprop.11+0x248>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80029fa:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 80029fc:	7813      	ldrb	r3, [r2, #0]
 80029fe:	f361 0302 	bfi	r3, r1, #0, #3
 8002a02:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002a04:	f897 1020 	ldrb.w	r1, [r7, #32]
 8002a08:	f361 03c7 	bfi	r3, r1, #3, #5
 8002a0c:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002a0e:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002a10:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8002a14:	f7fe fcac 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002a18:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8002a1c:	69fa      	ldr	r2, [r7, #28]
 8002a1e:	3b64      	subs	r3, #100	; 0x64
 8002a20:	429a      	cmp	r2, r3
 8002a22:	d82e      	bhi.n	8002a82 <spi_write.constprop.11+0x2b2>
 8002a24:	4639      	mov	r1, r7
 8002a26:	69a8      	ldr	r0, [r5, #24]
 8002a28:	f7fd fc4e 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002a2c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  return currp->u.rdymsg;
 8002a2e:	69a9      	ldr	r1, [r5, #24]
 8002a30:	2a00      	cmp	r2, #0
 8002a32:	f47f af30 	bne.w	8002896 <spi_write.constprop.11+0xc6>
 8002a36:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002a38:	2b00      	cmp	r3, #0
 8002a3a:	f77f af2c 	ble.w	8002896 <spi_write.constprop.11+0xc6>
 8002a3e:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 8002a40:	636a      	str	r2, [r5, #52]	; 0x34
 8002a42:	42ab      	cmp	r3, r5
 8002a44:	d004      	beq.n	8002a50 <spi_write.constprop.11+0x280>
 8002a46:	688a      	ldr	r2, [r1, #8]
 8002a48:	689b      	ldr	r3, [r3, #8]
 8002a4a:	429a      	cmp	r2, r3
 8002a4c:	f4ff af6c 	bcc.w	8002928 <spi_write.constprop.11+0x158>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002a50:	2300      	movs	r3, #0
 8002a52:	f383 8811 	msr	BASEPRI, r3
 8002a56:	2320      	movs	r3, #32
 8002a58:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002a5c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002a5e:	2b00      	cmp	r3, #0
 8002a60:	f47f aec6 	bne.w	80027f0 <spi_write.constprop.11+0x20>
 8002a64:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8002a66:	2900      	cmp	r1, #0
 8002a68:	f47f aec2 	bne.w	80027f0 <spi_write.constprop.11+0x20>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8002a6c:	7832      	ldrb	r2, [r6, #0]
  _dbg_enter_lock();
 8002a6e:	2301      	movs	r3, #1
 8002a70:	2a02      	cmp	r2, #2
 8002a72:	636b      	str	r3, [r5, #52]	; 0x34
 8002a74:	d032      	beq.n	8002adc <spi_write.constprop.11+0x30c>
 8002a76:	4813      	ldr	r0, [pc, #76]	; (8002ac4 <spi_write.constprop.11+0x2f4>)
 8002a78:	f7fe fc9a 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8002a7c:	4812      	ldr	r0, [pc, #72]	; (8002ac8 <spi_write.constprop.11+0x2f8>)
 8002a7e:	f7fe fc97 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8002a82:	4812      	ldr	r0, [pc, #72]	; (8002acc <spi_write.constprop.11+0x2fc>)
 8002a84:	f7fe fc94 	bl	80013b0 <chSysHalt>
 8002a88:	48000800 	.word	0x48000800
 8002a8c:	2000159c 	.word	0x2000159c
 8002a90:	0800e704 	.word	0x0800e704
 8002a94:	200014f8 	.word	0x200014f8
 8002a98:	0800e3c0 	.word	0x0800e3c0
 8002a9c:	0801d9a8 	.word	0x0801d9a8
 8002aa0:	0800e400 	.word	0x0800e400
 8002aa4:	0800e72c 	.word	0x0800e72c
 8002aa8:	08001a41 	.word	0x08001a41
 8002aac:	08001401 	.word	0x08001401
 8002ab0:	0800e40c 	.word	0x0800e40c
 8002ab4:	0800e1cc 	.word	0x0800e1cc
 8002ab8:	0800e52c 	.word	0x0800e52c
 8002abc:	0800e348 	.word	0x0800e348
 8002ac0:	20001500 	.word	0x20001500
 8002ac4:	0800e428 	.word	0x0800e428
 8002ac8:	0800e714 	.word	0x0800e714
 8002acc:	0800e71c 	.word	0x0800e71c
 8002ad0:	40021000 	.word	0x40021000
 8002ad4:	20002610 	.word	0x20002610
 8002ad8:	20001ffc 	.word	0x20001ffc
  spiUnselectI(spip);
 8002adc:	6870      	ldr	r0, [r6, #4]
 8002ade:	682a      	ldr	r2, [r5, #0]
 8002ae0:	e9d0 0702 	ldrd	r0, r7, [r0, #8]
 8002ae4:	40bb      	lsls	r3, r7
 8002ae6:	b29b      	uxth	r3, r3
 8002ae8:	42aa      	cmp	r2, r5
 8002aea:	8303      	strh	r3, [r0, #24]
  _dbg_leave_lock();
 8002aec:	6369      	str	r1, [r5, #52]	; 0x34
 8002aee:	d005      	beq.n	8002afc <spi_write.constprop.11+0x32c>
 8002af0:	69a9      	ldr	r1, [r5, #24]
 8002af2:	6893      	ldr	r3, [r2, #8]
 8002af4:	688a      	ldr	r2, [r1, #8]
 8002af6:	429a      	cmp	r2, r3
 8002af8:	f4ff af16 	bcc.w	8002928 <spi_write.constprop.11+0x158>
 8002afc:	2300      	movs	r3, #0
 8002afe:	f383 8811 	msr	BASEPRI, r3
 8002b02:	2320      	movs	r3, #32
 8002b04:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002b08:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002b0a:	2b00      	cmp	r3, #0
 8002b0c:	f47f ae70 	bne.w	80027f0 <spi_write.constprop.11+0x20>
 8002b10:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8002b12:	2a00      	cmp	r2, #0
 8002b14:	f47f ae6c 	bne.w	80027f0 <spi_write.constprop.11+0x20>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8002b18:	7833      	ldrb	r3, [r6, #0]
  _dbg_enter_lock();
 8002b1a:	2001      	movs	r0, #1
 8002b1c:	1e59      	subs	r1, r3, #1
 8002b1e:	4281      	cmp	r1, r0
 8002b20:	6368      	str	r0, [r5, #52]	; 0x34
 8002b22:	d902      	bls.n	8002b2a <spi_write.constprop.11+0x35a>
 8002b24:	4819      	ldr	r0, [pc, #100]	; (8002b8c <spi_write.constprop.11+0x3bc>)
 8002b26:	f7fe fc43 	bl	80013b0 <chSysHalt>
  if (spip->state == SPI_READY) {
 8002b2a:	2b02      	cmp	r3, #2
 8002b2c:	d111      	bne.n	8002b52 <spi_write.constprop.11+0x382>
    dmaStreamRelease(spip->dmarx);
 8002b2e:	e9d6 3007 	ldrd	r3, r0, [r6, #28]
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 8002b32:	6819      	ldr	r1, [r3, #0]
 8002b34:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8002b38:	6019      	str	r1, [r3, #0]
    spip->spi->CR1  = 0;
 8002b3a:	601a      	str	r2, [r3, #0]
    spip->spi->CR2  = 0;
 8002b3c:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 8002b3e:	f7ff f85f 	bl	8001c00 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 8002b42:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8002b44:	f7ff f85c 	bl	8001c00 <dmaStreamRelease>
      rccDisableSPI3();
 8002b48:	4a11      	ldr	r2, [pc, #68]	; (8002b90 <spi_write.constprop.11+0x3c0>)
 8002b4a:	69d3      	ldr	r3, [r2, #28]
 8002b4c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002b50:	61d3      	str	r3, [r2, #28]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002b52:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  spip->config = NULL;
 8002b54:	2100      	movs	r1, #0
  spip->state  = SPI_STOP;
 8002b56:	2301      	movs	r3, #1
  spip->config = NULL;
 8002b58:	6071      	str	r1, [r6, #4]
  spip->state  = SPI_STOP;
 8002b5a:	7033      	strb	r3, [r6, #0]
 8002b5c:	2a00      	cmp	r2, #0
 8002b5e:	f47f ae9a 	bne.w	8002896 <spi_write.constprop.11+0xc6>
 8002b62:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002b64:	428b      	cmp	r3, r1
 8002b66:	f77f ae96 	ble.w	8002896 <spi_write.constprop.11+0xc6>
 8002b6a:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 8002b6c:	636a      	str	r2, [r5, #52]	; 0x34
 8002b6e:	42ab      	cmp	r3, r5
 8002b70:	d005      	beq.n	8002b7e <spi_write.constprop.11+0x3ae>
 8002b72:	69aa      	ldr	r2, [r5, #24]
 8002b74:	689b      	ldr	r3, [r3, #8]
 8002b76:	6892      	ldr	r2, [r2, #8]
 8002b78:	429a      	cmp	r2, r3
 8002b7a:	f4ff aed5 	bcc.w	8002928 <spi_write.constprop.11+0x158>
 8002b7e:	2300      	movs	r3, #0
 8002b80:	f383 8811 	msr	BASEPRI, r3
    palSetPad(GPIOC,cp);
 8002b84:	4b03      	ldr	r3, [pc, #12]	; (8002b94 <spi_write.constprop.11+0x3c4>)
 8002b86:	831c      	strh	r4, [r3, #24]
}
 8002b88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002b8c:	0800e3e0 	.word	0x0800e3e0
 8002b90:	40021000 	.word	0x40021000
 8002b94:	48000800 	.word	0x48000800
	...

08002ba0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002ba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002ba4:	4c6c      	ldr	r4, [pc, #432]	; (8002d58 <chSchGoSleepTimeoutS+0x1b8>)
 8002ba6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002ba8:	b086      	sub	sp, #24
 8002baa:	2b00      	cmp	r3, #0
 8002bac:	d167      	bne.n	8002c7e <chSchGoSleepTimeoutS+0xde>
 8002bae:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002bb0:	2b00      	cmp	r3, #0
 8002bb2:	dd64      	ble.n	8002c7e <chSchGoSleepTimeoutS+0xde>
  if (TIME_INFINITE != timeout) {
 8002bb4:	1c4e      	adds	r6, r1, #1
 8002bb6:	d068      	beq.n	8002c8a <chSchGoSleepTimeoutS+0xea>
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002bb8:	2900      	cmp	r1, #0
 8002bba:	d063      	beq.n	8002c84 <chSchGoSleepTimeoutS+0xe4>
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002bbc:	4626      	mov	r6, r4
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002bbe:	2901      	cmp	r1, #1
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002bc0:	f856 3f1c 	ldr.w	r3, [r6, #28]!
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002bc4:	f8d4 8018 	ldr.w	r8, [r4, #24]
 8002bc8:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 8002bcc:	4602      	mov	r2, r0
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002bce:	bf08      	it	eq
 8002bd0:	2102      	moveq	r1, #2
  vtp->func = vtfunc;
 8002bd2:	4862      	ldr	r0, [pc, #392]	; (8002d5c <chSchGoSleepTimeoutS+0x1bc>)
 8002bd4:	f8dc 5024 	ldr.w	r5, [ip, #36]	; 0x24
  vtp->par = par;
 8002bd8:	f8cd 8014 	str.w	r8, [sp, #20]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002bdc:	42b3      	cmp	r3, r6
  vtp->func = vtfunc;
 8002bde:	9004      	str	r0, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002be0:	d05e      	beq.n	8002ca0 <chSchGoSleepTimeoutS+0x100>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8002be2:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8002be4:	6898      	ldr	r0, [r3, #8]
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002be6:	1bed      	subs	r5, r5, r7
 8002be8:	1949      	adds	r1, r1, r5

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002bea:	d255      	bcs.n	8002c98 <chSchGoSleepTimeoutS+0xf8>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8002bec:	4281      	cmp	r1, r0
 8002bee:	d36c      	bcc.n	8002cca <chSchGoSleepTimeoutS+0x12a>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002bf0:	4281      	cmp	r1, r0
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8002bf2:	af01      	add	r7, sp, #4
  while (p->delta < delta) {
 8002bf4:	d906      	bls.n	8002c04 <chSchGoSleepTimeoutS+0x64>
    chDbgAssert(p != vtp, "timer already armed");
 8002bf6:	42bb      	cmp	r3, r7
 8002bf8:	d044      	beq.n	8002c84 <chSchGoSleepTimeoutS+0xe4>

    delta -= p->delta;
    p = p->next;
 8002bfa:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 8002bfc:	1a09      	subs	r1, r1, r0
  while (p->delta < delta) {
 8002bfe:	6898      	ldr	r0, [r3, #8]
 8002c00:	4281      	cmp	r1, r0
 8002c02:	d8f8      	bhi.n	8002bf6 <chSchGoSleepTimeoutS+0x56>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8002c04:	6858      	ldr	r0, [r3, #4]
 8002c06:	e9cd 3001 	strd	r3, r0, [sp, #4]
  vtp->prev->next = vtp;
 8002c0a:	6007      	str	r7, [r0, #0]
  p->prev = vtp;
 8002c0c:	605f      	str	r7, [r3, #4]
  vtp->delta = delta;
 8002c0e:	9103      	str	r1, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8002c10:	6898      	ldr	r0, [r3, #8]
 8002c12:	1a41      	subs	r1, r0, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8002c14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  p->delta -= delta;
 8002c18:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8002c1a:	6260      	str	r0, [r4, #36]	; 0x24
  thread_t *tp = tqp->next;
 8002c1c:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8002c1e:	f888 2020 	strb.w	r2, [r8, #32]
  tqp->next             = tp->queue.next;
 8002c22:	681a      	ldr	r2, [r3, #0]
 8002c24:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8002c26:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002c28:	6054      	str	r4, [r2, #4]
 8002c2a:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002c2e:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002c30:	61a3      	str	r3, [r4, #24]
 8002c32:	07d3      	lsls	r3, r2, #31
 8002c34:	d554      	bpl.n	8002ce0 <chSchGoSleepTimeoutS+0x140>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002c36:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8002c3a:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8002c3e:	3b64      	subs	r3, #100	; 0x64
 8002c40:	429a      	cmp	r2, r3
 8002c42:	d84a      	bhi.n	8002cda <chSchGoSleepTimeoutS+0x13a>
 8002c44:	4641      	mov	r1, r8
 8002c46:	69a0      	ldr	r0, [r4, #24]
 8002c48:	f7fd fb3e 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002c4c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c4e:	2b00      	cmp	r3, #0
 8002c50:	db58      	blt.n	8002d04 <chSchGoSleepTimeoutS+0x164>
 8002c52:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002c54:	2b00      	cmp	r3, #0
 8002c56:	dd55      	ble.n	8002d04 <chSchGoSleepTimeoutS+0x164>
    if (chVTIsArmedI(&vt)) {
 8002c58:	9b04      	ldr	r3, [sp, #16]
 8002c5a:	b1c3      	cbz	r3, 8002c8e <chSchGoSleepTimeoutS+0xee>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002c5c:	69e3      	ldr	r3, [r4, #28]
 8002c5e:	9a01      	ldr	r2, [sp, #4]
 8002c60:	42bb      	cmp	r3, r7
 8002c62:	d058      	beq.n	8002d16 <chSchGoSleepTimeoutS+0x176>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002c64:	9902      	ldr	r1, [sp, #8]
 8002c66:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8002c68:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002c6a:	2200      	movs	r2, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002c6c:	42b3      	cmp	r3, r6
    vtp->next->prev = vtp->prev;
 8002c6e:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8002c70:	9204      	str	r2, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002c72:	d00c      	beq.n	8002c8e <chSchGoSleepTimeoutS+0xee>
      vtp->next->delta += vtp->delta;
 8002c74:	689a      	ldr	r2, [r3, #8]
 8002c76:	9903      	ldr	r1, [sp, #12]
 8002c78:	440a      	add	r2, r1
 8002c7a:	609a      	str	r2, [r3, #8]
 8002c7c:	e007      	b.n	8002c8e <chSchGoSleepTimeoutS+0xee>
    chSysHalt("SV#11");
 8002c7e:	4838      	ldr	r0, [pc, #224]	; (8002d60 <chSchGoSleepTimeoutS+0x1c0>)
 8002c80:	f7fe fb96 	bl	80013b0 <chSysHalt>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002c84:	4837      	ldr	r0, [pc, #220]	; (8002d64 <chSchGoSleepTimeoutS+0x1c4>)
 8002c86:	f7fe fb93 	bl	80013b0 <chSysHalt>
    chSchGoSleepS(newstate);
 8002c8a:	f7ff fb69 	bl	8002360 <chSchGoSleepS>
  return currp->u.rdymsg;
 8002c8e:	69a3      	ldr	r3, [r4, #24]
 8002c90:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8002c92:	b006      	add	sp, #24
 8002c94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      p = p->next;
 8002c98:	681b      	ldr	r3, [r3, #0]
      delta -= p->delta;
 8002c9a:	1a09      	subs	r1, r1, r0
 8002c9c:	6898      	ldr	r0, [r3, #8]
 8002c9e:	e7a7      	b.n	8002bf0 <chSchGoSleepTimeoutS+0x50>
      vtp->delta = delay;
 8002ca0:	9103      	str	r1, [sp, #12]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002ca2:	f8dc 000c 	ldr.w	r0, [ip, #12]
      ch.vtlist.lasttime = now;
 8002ca6:	62a5      	str	r5, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 8002ca8:	af01      	add	r7, sp, #4
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8002caa:	f010 0002 	ands.w	r0, r0, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002cae:	e9cd 3301 	strd	r3, r3, [sp, #4]
      ch.vtlist.prev = vtp;
 8002cb2:	e9c4 7707 	strd	r7, r7, [r4, #28]
 8002cb6:	d128      	bne.n	8002d0a <chSchGoSleepTimeoutS+0x16a>
  return systime + (systime_t)interval;
 8002cb8:	440d      	add	r5, r1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002cba:	2302      	movs	r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002cbc:	f8cc 5034 	str.w	r5, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8002cc0:	f8cc 0010 	str.w	r0, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002cc4:	f8cc 300c 	str.w	r3, [ip, #12]
 8002cc8:	e7a8      	b.n	8002c1c <chSchGoSleepTimeoutS+0x7c>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002cca:	f8dc 500c 	ldr.w	r5, [ip, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8002cce:	07ad      	lsls	r5, r5, #30
 8002cd0:	d51e      	bpl.n	8002d10 <chSchGoSleepTimeoutS+0x170>
 8002cd2:	440f      	add	r7, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002cd4:	f8cc 7034 	str.w	r7, [ip, #52]	; 0x34
 8002cd8:	e78a      	b.n	8002bf0 <chSchGoSleepTimeoutS+0x50>
  chSysSwitch(currp, otp);
 8002cda:	4823      	ldr	r0, [pc, #140]	; (8002d68 <chSchGoSleepTimeoutS+0x1c8>)
 8002cdc:	f7fe fb68 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002ce0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002ce2:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002ce6:	7813      	ldrb	r3, [r2, #0]
 8002ce8:	f361 0302 	bfi	r3, r1, #0, #3
 8002cec:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002cee:	f898 1020 	ldrb.w	r1, [r8, #32]
 8002cf2:	f361 03c7 	bfi	r3, r1, #3, #5
 8002cf6:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002cf8:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002cfa:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8002cfe:	f7fe fb37 	bl	8001370 <trace_next>
 8002d02:	e798      	b.n	8002c36 <chSchGoSleepTimeoutS+0x96>
    chSysHalt("SV#10");
 8002d04:	4819      	ldr	r0, [pc, #100]	; (8002d6c <chSchGoSleepTimeoutS+0x1cc>)
 8002d06:	f7fe fb53 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8002d0a:	4819      	ldr	r0, [pc, #100]	; (8002d70 <chSchGoSleepTimeoutS+0x1d0>)
 8002d0c:	f7fe fb50 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8002d10:	4818      	ldr	r0, [pc, #96]	; (8002d74 <chSchGoSleepTimeoutS+0x1d4>)
 8002d12:	f7fe fb4d 	bl	80013b0 <chSysHalt>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8002d16:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002d18:	42b2      	cmp	r2, r6
  ch.vtlist.next = vtp->next;
 8002d1a:	61e2      	str	r2, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8002d1c:	6056      	str	r6, [r2, #4]
  vtp->func = NULL;
 8002d1e:	9304      	str	r3, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002d20:	d016      	beq.n	8002d50 <chSchGoSleepTimeoutS+0x1b0>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8002d22:	6893      	ldr	r3, [r2, #8]
 8002d24:	9803      	ldr	r0, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8002d26:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8002d28:	4403      	add	r3, r0
  return (systime_t)STM32_ST_TIM->CNT;
 8002d2a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002d2e:	6093      	str	r3, [r2, #8]
 8002d30:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8002d32:	1a52      	subs	r2, r2, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8002d34:	4293      	cmp	r3, r2
 8002d36:	d9aa      	bls.n	8002c8e <chSchGoSleepTimeoutS+0xee>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8002d38:	1a98      	subs	r0, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002d3a:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002d3c:	bf98      	it	ls
 8002d3e:	1c93      	addls	r3, r2, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002d40:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8002d44:	440b      	add	r3, r1
 8002d46:	68d1      	ldr	r1, [r2, #12]
 8002d48:	0789      	lsls	r1, r1, #30
 8002d4a:	d5e1      	bpl.n	8002d10 <chSchGoSleepTimeoutS+0x170>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002d4c:	6353      	str	r3, [r2, #52]	; 0x34
 8002d4e:	e79e      	b.n	8002c8e <chSchGoSleepTimeoutS+0xee>
  STM32_ST_TIM->DIER = 0;
 8002d50:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002d54:	60d3      	str	r3, [r2, #12]
 8002d56:	e79a      	b.n	8002c8e <chSchGoSleepTimeoutS+0xee>
 8002d58:	2000159c 	.word	0x2000159c
 8002d5c:	080016d1 	.word	0x080016d1
 8002d60:	0800e714 	.word	0x0800e714
 8002d64:	0800e264 	.word	0x0800e264
 8002d68:	0800e71c 	.word	0x0800e71c
 8002d6c:	0800e70c 	.word	0x0800e70c
 8002d70:	0800e38c 	.word	0x0800e38c
 8002d74:	0800e3cc 	.word	0x0800e3cc
	...

08002d80 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8002d80:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d82:	2320      	movs	r3, #32
 8002d84:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002d88:	4c12      	ldr	r4, [pc, #72]	; (8002dd4 <chThdSleep+0x54>)
 8002d8a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002d8c:	b90b      	cbnz	r3, 8002d92 <chThdSleep+0x12>
 8002d8e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002d90:	b113      	cbz	r3, 8002d98 <chThdSleep+0x18>
    chSysHalt("SV#4");
 8002d92:	4811      	ldr	r0, [pc, #68]	; (8002dd8 <chThdSleep+0x58>)
 8002d94:	f7fe fb0c 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 8002d98:	2301      	movs	r3, #1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002d9a:	4601      	mov	r1, r0
 8002d9c:	2008      	movs	r0, #8
 8002d9e:	6363      	str	r3, [r4, #52]	; 0x34
 8002da0:	f7ff fefe 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002da4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002da6:	b97b      	cbnz	r3, 8002dc8 <chThdSleep+0x48>
 8002da8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002daa:	2a00      	cmp	r2, #0
 8002dac:	dd0c      	ble.n	8002dc8 <chThdSleep+0x48>
 8002dae:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8002db0:	6363      	str	r3, [r4, #52]	; 0x34
 8002db2:	42a2      	cmp	r2, r4
 8002db4:	d004      	beq.n	8002dc0 <chThdSleep+0x40>
 8002db6:	69a1      	ldr	r1, [r4, #24]
 8002db8:	6893      	ldr	r3, [r2, #8]
 8002dba:	688a      	ldr	r2, [r1, #8]
 8002dbc:	429a      	cmp	r2, r3
 8002dbe:	d306      	bcc.n	8002dce <chThdSleep+0x4e>
 8002dc0:	2300      	movs	r3, #0
 8002dc2:	f383 8811 	msr	BASEPRI, r3
}
 8002dc6:	bd10      	pop	{r4, pc}
    chSysHalt("SV#5");
 8002dc8:	4804      	ldr	r0, [pc, #16]	; (8002ddc <chThdSleep+0x5c>)
 8002dca:	f7fe faf1 	bl	80013b0 <chSysHalt>
 8002dce:	4804      	ldr	r0, [pc, #16]	; (8002de0 <chThdSleep+0x60>)
 8002dd0:	f7fe faee 	bl	80013b0 <chSysHalt>
 8002dd4:	2000159c 	.word	0x2000159c
 8002dd8:	0800e704 	.word	0x0800e704
 8002ddc:	0800e72c 	.word	0x0800e72c
 8002de0:	0800e1e4 	.word	0x0800e1e4
	...

08002df0 <Thread1>:
static THD_FUNCTION(Thread1, arg) {
 8002df0:	b580      	push	{r7, lr}
 8002df2:	4caf      	ldr	r4, [pc, #700]	; (80030b0 <Thread1+0x2c0>)
      trigger = palReadPad(GPIOC,6);
 8002df4:	4daf      	ldr	r5, [pc, #700]	; (80030b4 <Thread1+0x2c4>)
  vtp->func = vtfunc;
 8002df6:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 80030dc <Thread1+0x2ec>
	      lifetimeRain += 0.01;
 8002dfa:	a7ab      	add	r7, pc, #684	; (adr r7, 80030a8 <Thread1+0x2b8>)
 8002dfc:	e9d7 6700 	ldrd	r6, r7, [r7]
static THD_FUNCTION(Thread1, arg) {
 8002e00:	b088      	sub	sp, #32
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002e02:	f104 081c 	add.w	r8, r4, #28
      trigger = palReadPad(GPIOC,6);
 8002e06:	692b      	ldr	r3, [r5, #16]
      if (trigger == 0)
 8002e08:	065b      	lsls	r3, r3, #25
 8002e0a:	d523      	bpl.n	8002e54 <Thread1+0x64>
 8002e0c:	2320      	movs	r3, #32
 8002e0e:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e12:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e14:	b90b      	cbnz	r3, 8002e1a <Thread1+0x2a>
 8002e16:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002e18:	b113      	cbz	r3, 8002e20 <Thread1+0x30>
    chSysHalt("SV#4");
 8002e1a:	48a7      	ldr	r0, [pc, #668]	; (80030b8 <Thread1+0x2c8>)
 8002e1c:	f7fe fac8 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 8002e20:	2301      	movs	r3, #1
 8002e22:	2164      	movs	r1, #100	; 0x64
 8002e24:	2008      	movs	r0, #8
 8002e26:	6363      	str	r3, [r4, #52]	; 0x34
 8002e28:	f7ff feba 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e2c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e2e:	2b00      	cmp	r3, #0
 8002e30:	d17b      	bne.n	8002f2a <Thread1+0x13a>
 8002e32:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002e34:	2a00      	cmp	r2, #0
 8002e36:	dd78      	ble.n	8002f2a <Thread1+0x13a>
 8002e38:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8002e3a:	6363      	str	r3, [r4, #52]	; 0x34
 8002e3c:	42a2      	cmp	r2, r4
 8002e3e:	d005      	beq.n	8002e4c <Thread1+0x5c>
 8002e40:	69a1      	ldr	r1, [r4, #24]
 8002e42:	6893      	ldr	r3, [r2, #8]
 8002e44:	688a      	ldr	r2, [r1, #8]
 8002e46:	429a      	cmp	r2, r3
 8002e48:	f0c0 80bc 	bcc.w	8002fc4 <Thread1+0x1d4>
 8002e4c:	2300      	movs	r3, #0
 8002e4e:	f383 8811 	msr	BASEPRI, r3
 8002e52:	e7d8      	b.n	8002e06 <Thread1+0x16>
	      rainHistory[0] += 1;
 8002e54:	4a99      	ldr	r2, [pc, #612]	; (80030bc <Thread1+0x2cc>)
	      lifetimeRain += 0.01;
 8002e56:	f8df a288 	ldr.w	sl, [pc, #648]	; 80030e0 <Thread1+0x2f0>
	      rainHistory[0] += 1;
 8002e5a:	7813      	ldrb	r3, [r2, #0]
	      lifetimeRain += 0.01;
 8002e5c:	f8da 0000 	ldr.w	r0, [sl]
	      rainHistory[0] += 1;
 8002e60:	3301      	adds	r3, #1
 8002e62:	7013      	strb	r3, [r2, #0]
	      lifetimeRain += 0.01;
 8002e64:	f7fd fbb2 	bl	80005cc <__aeabi_f2d>
 8002e68:	463b      	mov	r3, r7
 8002e6a:	4632      	mov	r2, r6
 8002e6c:	f7fd fa50 	bl	8000310 <__adddf3>
 8002e70:	f7fd fedc 	bl	8000c2c <__aeabi_d2f>
 8002e74:	2320      	movs	r3, #32
 8002e76:	f8ca 0000 	str.w	r0, [sl]
 8002e7a:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e7e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e80:	2b00      	cmp	r3, #0
 8002e82:	d1ca      	bne.n	8002e1a <Thread1+0x2a>
 8002e84:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002e86:	2b00      	cmp	r3, #0
 8002e88:	d1c7      	bne.n	8002e1a <Thread1+0x2a>
  _dbg_enter_lock();
 8002e8a:	2301      	movs	r3, #1
 8002e8c:	f640 11c4 	movw	r1, #2500	; 0x9c4
 8002e90:	2008      	movs	r0, #8
 8002e92:	6363      	str	r3, [r4, #52]	; 0x34
 8002e94:	f7ff fe84 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e98:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e9a:	2b00      	cmp	r3, #0
 8002e9c:	d145      	bne.n	8002f2a <Thread1+0x13a>
 8002e9e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002ea0:	2a00      	cmp	r2, #0
 8002ea2:	dd42      	ble.n	8002f2a <Thread1+0x13a>
 8002ea4:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8002ea6:	6363      	str	r3, [r4, #52]	; 0x34
 8002ea8:	42a2      	cmp	r2, r4
 8002eaa:	d005      	beq.n	8002eb8 <Thread1+0xc8>
 8002eac:	69a1      	ldr	r1, [r4, #24]
 8002eae:	6893      	ldr	r3, [r2, #8]
 8002eb0:	688a      	ldr	r2, [r1, #8]
 8002eb2:	429a      	cmp	r2, r3
 8002eb4:	f0c0 8086 	bcc.w	8002fc4 <Thread1+0x1d4>
 8002eb8:	2300      	movs	r3, #0
 8002eba:	f383 8811 	msr	BASEPRI, r3
	      while (palReadPad(GPIOC,6)==0)
 8002ebe:	692b      	ldr	r3, [r5, #16]
 8002ec0:	065a      	lsls	r2, r3, #25
 8002ec2:	d4a3      	bmi.n	8002e0c <Thread1+0x1c>
 8002ec4:	2320      	movs	r3, #32
 8002ec6:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002eca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002ecc:	2b00      	cmp	r3, #0
 8002ece:	d1a4      	bne.n	8002e1a <Thread1+0x2a>
 8002ed0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002ed2:	2a00      	cmp	r2, #0
 8002ed4:	d1a1      	bne.n	8002e1a <Thread1+0x2a>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002ed6:	e9d4 1006 	ldrd	r1, r0, [r4, #24]
  return (systime_t)STM32_ST_TIM->CNT;
 8002eda:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
  _dbg_enter_lock();
 8002ede:	f04f 0e01 	mov.w	lr, #1
 8002ee2:	4540      	cmp	r0, r8
 8002ee4:	f8dc 3024 	ldr.w	r3, [ip, #36]	; 0x24
  vtp->func = vtfunc;
 8002ee8:	f8cd 9018 	str.w	r9, [sp, #24]
 8002eec:	f8c4 e034 	str.w	lr, [r4, #52]	; 0x34
  vtp->par = par;
 8002ef0:	9107      	str	r1, [sp, #28]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002ef2:	d07b      	beq.n	8002fec <Thread1+0x1fc>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8002ef4:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
 8002ef8:	f04f 0a64 	mov.w	sl, #100	; 0x64
  return (sysinterval_t)((systime_t)(end - start));
 8002efc:	eba3 030c 	sub.w	r3, r3, ip
 8002f00:	eb13 030a 	adds.w	r3, r3, sl
 8002f04:	bf28      	it	cs
 8002f06:	4672      	movcs	r2, lr
 8002f08:	f8d0 e008 	ldr.w	lr, [r0, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002f0c:	2a00      	cmp	r2, #0
 8002f0e:	d05f      	beq.n	8002fd0 <Thread1+0x1e0>
      p = p->next;
 8002f10:	6800      	ldr	r0, [r0, #0]
      delta -= p->delta;
 8002f12:	eba3 030e 	sub.w	r3, r3, lr
 8002f16:	f10d 0a0c 	add.w	sl, sp, #12
  while (p->delta < delta) {
 8002f1a:	6882      	ldr	r2, [r0, #8]
 8002f1c:	4293      	cmp	r3, r2
 8002f1e:	d907      	bls.n	8002f30 <Thread1+0x140>
    chDbgAssert(p != vtp, "timer already armed");
 8002f20:	4550      	cmp	r0, sl
 8002f22:	d052      	beq.n	8002fca <Thread1+0x1da>
    p = p->next;
 8002f24:	6800      	ldr	r0, [r0, #0]
    delta -= p->delta;
 8002f26:	1a9b      	subs	r3, r3, r2
 8002f28:	e7f7      	b.n	8002f1a <Thread1+0x12a>
    chSysHalt("SV#5");
 8002f2a:	4865      	ldr	r0, [pc, #404]	; (80030c0 <Thread1+0x2d0>)
 8002f2c:	f7fe fa40 	bl	80013b0 <chSysHalt>
  vtp->prev = vtp->next->prev;
 8002f30:	6842      	ldr	r2, [r0, #4]
 8002f32:	e9cd 0203 	strd	r0, r2, [sp, #12]
  vtp->prev->next = vtp;
 8002f36:	f8c2 a000 	str.w	sl, [r2]
  p->prev = vtp;
 8002f3a:	f8c0 a004 	str.w	sl, [r0, #4]
  vtp->delta = delta;
 8002f3e:	9305      	str	r3, [sp, #20]
  p->delta -= delta;
 8002f40:	6882      	ldr	r2, [r0, #8]
 8002f42:	1ad3      	subs	r3, r2, r3
  ch.vtlist.delta = (sysinterval_t)-1;
 8002f44:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->delta -= delta;
 8002f48:	6083      	str	r3, [r0, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8002f4a:	6262      	str	r2, [r4, #36]	; 0x24
  thread_t *tp = tqp->next;
 8002f4c:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8002f4e:	2208      	movs	r2, #8
 8002f50:	f881 2020 	strb.w	r2, [r1, #32]
  tqp->next             = tp->queue.next;
 8002f54:	681a      	ldr	r2, [r3, #0]
 8002f56:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8002f58:	2001      	movs	r0, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002f5a:	6054      	str	r4, [r2, #4]
 8002f5c:	f883 0020 	strb.w	r0, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002f60:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002f62:	61a3      	str	r3, [r4, #24]
 8002f64:	07d3      	lsls	r3, r2, #31
 8002f66:	d55c      	bpl.n	8003022 <Thread1+0x232>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002f68:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8002f6c:	69ca      	ldr	r2, [r1, #28]
 8002f6e:	3b64      	subs	r3, #100	; 0x64
 8002f70:	429a      	cmp	r2, r3
 8002f72:	d86a      	bhi.n	800304a <Thread1+0x25a>
 8002f74:	69a0      	ldr	r0, [r4, #24]
 8002f76:	f7fd f9a7 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002f7a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002f7c:	2900      	cmp	r1, #0
 8002f7e:	db4d      	blt.n	800301c <Thread1+0x22c>
 8002f80:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002f82:	2b00      	cmp	r3, #0
 8002f84:	dd4a      	ble.n	800301c <Thread1+0x22c>
    if (chVTIsArmedI(&vt)) {
 8002f86:	9b06      	ldr	r3, [sp, #24]
 8002f88:	b17b      	cbz	r3, 8002faa <Thread1+0x1ba>
  if (ch.vtlist.next != vtp) {
 8002f8a:	69e2      	ldr	r2, [r4, #28]
 8002f8c:	9b03      	ldr	r3, [sp, #12]
 8002f8e:	4552      	cmp	r2, sl
 8002f90:	d064      	beq.n	800305c <Thread1+0x26c>
    vtp->prev->next = vtp->next;
 8002f92:	9a04      	ldr	r2, [sp, #16]
 8002f94:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8002f96:	9b03      	ldr	r3, [sp, #12]
    vtp->func = NULL;
 8002f98:	2000      	movs	r0, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002f9a:	4543      	cmp	r3, r8
    vtp->next->prev = vtp->prev;
 8002f9c:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002f9e:	9006      	str	r0, [sp, #24]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002fa0:	d003      	beq.n	8002faa <Thread1+0x1ba>
      vtp->next->delta += vtp->delta;
 8002fa2:	689a      	ldr	r2, [r3, #8]
 8002fa4:	9805      	ldr	r0, [sp, #20]
 8002fa6:	4402      	add	r2, r0
 8002fa8:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
 8002faa:	69a2      	ldr	r2, [r4, #24]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002fac:	2900      	cmp	r1, #0
 8002fae:	d1bc      	bne.n	8002f2a <Thread1+0x13a>
 8002fb0:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8002fb2:	6361      	str	r1, [r4, #52]	; 0x34
 8002fb4:	42a3      	cmp	r3, r4
 8002fb6:	f43f af7f 	beq.w	8002eb8 <Thread1+0xc8>
 8002fba:	6892      	ldr	r2, [r2, #8]
 8002fbc:	689b      	ldr	r3, [r3, #8]
 8002fbe:	429a      	cmp	r2, r3
 8002fc0:	f4bf af7a 	bcs.w	8002eb8 <Thread1+0xc8>
 8002fc4:	483f      	ldr	r0, [pc, #252]	; (80030c4 <Thread1+0x2d4>)
 8002fc6:	f7fe f9f3 	bl	80013b0 <chSysHalt>
    chDbgAssert(p != vtp, "timer already armed");
 8002fca:	483f      	ldr	r0, [pc, #252]	; (80030c8 <Thread1+0x2d8>)
 8002fcc:	f7fe f9f0 	bl	80013b0 <chSysHalt>
    else if (delta < p->delta) {
 8002fd0:	4573      	cmp	r3, lr
 8002fd2:	d2a0      	bcs.n	8002f16 <Thread1+0x126>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002fd4:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8002fd8:	eb0c 0203 	add.w	r2, ip, r3
 8002fdc:	f8de c00c 	ldr.w	ip, [lr, #12]
 8002fe0:	f01c 0f02 	tst.w	ip, #2
 8002fe4:	d037      	beq.n	8003056 <Thread1+0x266>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002fe6:	f8ce 2034 	str.w	r2, [lr, #52]	; 0x34
 8002fea:	e794      	b.n	8002f16 <Thread1+0x126>
      vtp->delta = delay;
 8002fec:	2264      	movs	r2, #100	; 0x64
 8002fee:	9205      	str	r2, [sp, #20]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002ff0:	f8dc 200c 	ldr.w	r2, [ip, #12]
      ch.vtlist.lasttime = now;
 8002ff4:	62a3      	str	r3, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 8002ff6:	f10d 0a0c 	add.w	sl, sp, #12
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8002ffa:	f012 0202 	ands.w	r2, r2, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002ffe:	e9cd 8803 	strd	r8, r8, [sp, #12]
 8003002:	f103 0364 	add.w	r3, r3, #100	; 0x64
      ch.vtlist.prev = vtp;
 8003006:	e9c4 aa07 	strd	sl, sl, [r4, #28]
 800300a:	d121      	bne.n	8003050 <Thread1+0x260>
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800300c:	2002      	movs	r0, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800300e:	f8cc 3034 	str.w	r3, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003012:	f8cc 2010 	str.w	r2, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003016:	f8cc 000c 	str.w	r0, [ip, #12]
 800301a:	e797      	b.n	8002f4c <Thread1+0x15c>
    chSysHalt("SV#10");
 800301c:	482b      	ldr	r0, [pc, #172]	; (80030cc <Thread1+0x2dc>)
 800301e:	f7fe f9c7 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003022:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003024:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003028:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800302a:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800302c:	f360 0302 	bfi	r3, r0, #0, #3
 8003030:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003032:	f891 0020 	ldrb.w	r0, [r1, #32]
 8003036:	f360 03c7 	bfi	r3, r0, #3, #5
 800303a:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800303c:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800303e:	e9c2 3c02 	strd	r3, ip, [r2, #8]
    trace_next();
 8003042:	f7fe f995 	bl	8001370 <trace_next>
 8003046:	9901      	ldr	r1, [sp, #4]
 8003048:	e78e      	b.n	8002f68 <Thread1+0x178>
  chSysSwitch(currp, otp);
 800304a:	4821      	ldr	r0, [pc, #132]	; (80030d0 <Thread1+0x2e0>)
 800304c:	f7fe f9b0 	bl	80013b0 <chSysHalt>
 8003050:	4820      	ldr	r0, [pc, #128]	; (80030d4 <Thread1+0x2e4>)
 8003052:	f7fe f9ad 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8003056:	4820      	ldr	r0, [pc, #128]	; (80030d8 <Thread1+0x2e8>)
 8003058:	f7fe f9aa 	bl	80013b0 <chSysHalt>
  vtp->func = NULL;
 800305c:	2200      	movs	r2, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800305e:	4543      	cmp	r3, r8
  ch.vtlist.next = vtp->next;
 8003060:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003062:	f8c3 8004 	str.w	r8, [r3, #4]
  vtp->func = NULL;
 8003066:	9206      	str	r2, [sp, #24]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003068:	d018      	beq.n	800309c <Thread1+0x2ac>
  ch.vtlist.next->delta += vtp->delta;
 800306a:	6898      	ldr	r0, [r3, #8]
 800306c:	9a05      	ldr	r2, [sp, #20]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 800306e:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8003072:	4402      	add	r2, r0
  return (systime_t)STM32_ST_TIM->CNT;
 8003074:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8003078:	609a      	str	r2, [r3, #8]
 800307a:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800307c:	eba3 030c 	sub.w	r3, r3, ip
  if (nowdelta >= ch.vtlist.next->delta) {
 8003080:	429a      	cmp	r2, r3
 8003082:	d992      	bls.n	8002faa <Thread1+0x1ba>
  delta = ch.vtlist.next->delta - nowdelta;
 8003084:	1ad0      	subs	r0, r2, r3
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003086:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003088:	bf98      	it	ls
 800308a:	1c9a      	addls	r2, r3, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800308c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8003090:	4462      	add	r2, ip
 8003092:	68d8      	ldr	r0, [r3, #12]
 8003094:	0780      	lsls	r0, r0, #30
 8003096:	d5de      	bpl.n	8003056 <Thread1+0x266>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003098:	635a      	str	r2, [r3, #52]	; 0x34
 800309a:	e786      	b.n	8002faa <Thread1+0x1ba>
  STM32_ST_TIM->DIER = 0;
 800309c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80030a0:	60da      	str	r2, [r3, #12]
 80030a2:	e782      	b.n	8002faa <Thread1+0x1ba>
 80030a4:	f3af 8000 	nop.w
 80030a8:	47ae147b 	.word	0x47ae147b
 80030ac:	3f847ae1 	.word	0x3f847ae1
 80030b0:	2000159c 	.word	0x2000159c
 80030b4:	48000800 	.word	0x48000800
 80030b8:	0800e704 	.word	0x0800e704
 80030bc:	20002094 	.word	0x20002094
 80030c0:	0800e72c 	.word	0x0800e72c
 80030c4:	0800e1e4 	.word	0x0800e1e4
 80030c8:	0800e264 	.word	0x0800e264
 80030cc:	0800e70c 	.word	0x0800e70c
 80030d0:	0800e71c 	.word	0x0800e71c
 80030d4:	0800e38c 	.word	0x0800e38c
 80030d8:	0800e3cc 	.word	0x0800e3cc
 80030dc:	080016d1 	.word	0x080016d1
 80030e0:	2000200c 	.word	0x2000200c
	...

080030f0 <_gett>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 80030f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80030f4:	2320      	movs	r3, #32
 80030f6:	b089      	sub	sp, #36	; 0x24
 80030f8:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80030fc:	4cab      	ldr	r4, [pc, #684]	; (80033ac <_gett+0x2bc>)
 80030fe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003100:	b90b      	cbnz	r3, 8003106 <_gett+0x16>
 8003102:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003104:	b113      	cbz	r3, 800310c <_gett+0x1c>
    chSysHalt("SV#4");
 8003106:	48aa      	ldr	r0, [pc, #680]	; (80033b0 <_gett+0x2c0>)
 8003108:	f7fe f952 	bl	80013b0 <chSysHalt>
 800310c:	2901      	cmp	r1, #1
  _dbg_enter_lock();
 800310e:	f04f 0301 	mov.w	r3, #1
 8003112:	4605      	mov	r5, r0
 8003114:	460e      	mov	r6, r1
 8003116:	bf14      	ite	ne
 8003118:	468a      	movne	sl, r1
 800311a:	f04f 0a02 	moveq.w	sl, #2
 800311e:	6363      	str	r3, [r4, #52]	; 0x34
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003120:	f100 070c 	add.w	r7, r0, #12
  otp->state = newstate;
 8003124:	f04f 0904 	mov.w	r9, #4
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003128:	f104 081c 	add.w	r8, r4, #28
  while (iqIsEmptyI(iqp)) {
 800312c:	696a      	ldr	r2, [r5, #20]
 800312e:	2a00      	cmp	r2, #0
 8003130:	d178      	bne.n	8003224 <_gett+0x134>
 8003132:	6b20      	ldr	r0, [r4, #48]	; 0x30
  if (TIME_IMMEDIATE == timeout) {
 8003134:	2e00      	cmp	r6, #0
 8003136:	f000 809c 	beq.w	8003272 <_gett+0x182>
  queue_insert(currp, tqp);
 800313a:	69a2      	ldr	r2, [r4, #24]
  tp->queue.prev             = tqp->prev;
 800313c:	6929      	ldr	r1, [r5, #16]
 800313e:	e9c2 7100 	strd	r7, r1, [r2]
  tp->queue.prev->queue.next = tp;
 8003142:	600a      	str	r2, [r1, #0]
  tqp->prev                  = tp;
 8003144:	612a      	str	r2, [r5, #16]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003146:	bb70      	cbnz	r0, 80031a6 <_gett+0xb6>
 8003148:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800314a:	2a00      	cmp	r2, #0
 800314c:	dd2b      	ble.n	80031a6 <_gett+0xb6>
  if (TIME_INFINITE != timeout) {
 800314e:	1c72      	adds	r2, r6, #1
 8003150:	69a1      	ldr	r1, [r4, #24]
 8003152:	d031      	beq.n	80031b8 <_gett+0xc8>
 8003154:	69e2      	ldr	r2, [r4, #28]
  vtp->func = vtfunc;
 8003156:	4b97      	ldr	r3, [pc, #604]	; (80033b4 <_gett+0x2c4>)
  vtp->par = par;
 8003158:	9107      	str	r1, [sp, #28]
  return (systime_t)STM32_ST_TIM->CNT;
 800315a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800315e:	4542      	cmp	r2, r8
  vtp->func = vtfunc;
 8003160:	9306      	str	r3, [sp, #24]
 8003162:	f8d0 c024 	ldr.w	ip, [r0, #36]	; 0x24
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003166:	f000 80e5 	beq.w	8003334 <_gett+0x244>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800316a:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
 800316e:	f8d2 e008 	ldr.w	lr, [r2, #8]
  return (sysinterval_t)((systime_t)(end - start));
 8003172:	ebac 0c0b 	sub.w	ip, ip, fp
 8003176:	eb1a 0c0c 	adds.w	ip, sl, ip
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 800317a:	d217      	bcs.n	80031ac <_gett+0xbc>
    else if (delta < p->delta) {
 800317c:	45f4      	cmp	ip, lr
 800317e:	f0c0 80f0 	bcc.w	8003362 <_gett+0x272>
  while (p->delta < delta) {
 8003182:	45f4      	cmp	ip, lr
    chDbgAssert(p != vtp, "timer already armed");
 8003184:	f10d 0b0c 	add.w	fp, sp, #12
  while (p->delta < delta) {
 8003188:	d977      	bls.n	800327a <_gett+0x18a>
    chDbgAssert(p != vtp, "timer already armed");
 800318a:	455a      	cmp	r2, fp
 800318c:	d008      	beq.n	80031a0 <_gett+0xb0>
 800318e:	4670      	mov	r0, lr
    p = p->next;
 8003190:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
 8003192:	ebac 0c00 	sub.w	ip, ip, r0
  while (p->delta < delta) {
 8003196:	6890      	ldr	r0, [r2, #8]
 8003198:	4584      	cmp	ip, r0
 800319a:	d96e      	bls.n	800327a <_gett+0x18a>
    chDbgAssert(p != vtp, "timer already armed");
 800319c:	455a      	cmp	r2, fp
 800319e:	d1f7      	bne.n	8003190 <_gett+0xa0>
 80031a0:	4885      	ldr	r0, [pc, #532]	; (80033b8 <_gett+0x2c8>)
 80031a2:	f7fe f905 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 80031a6:	4885      	ldr	r0, [pc, #532]	; (80033bc <_gett+0x2cc>)
 80031a8:	f7fe f902 	bl	80013b0 <chSysHalt>
      p = p->next;
 80031ac:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
 80031ae:	ebac 0c0e 	sub.w	ip, ip, lr
 80031b2:	f8d2 e008 	ldr.w	lr, [r2, #8]
 80031b6:	e7e4      	b.n	8003182 <_gett+0x92>
  thread_t *tp = tqp->next;
 80031b8:	6822      	ldr	r2, [r4, #0]
  otp->state = newstate;
 80031ba:	f881 9020 	strb.w	r9, [r1, #32]
  tqp->next             = tp->queue.next;
 80031be:	6810      	ldr	r0, [r2, #0]
 80031c0:	6020      	str	r0, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 80031c2:	f04f 0c01 	mov.w	ip, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80031c6:	6044      	str	r4, [r0, #4]
 80031c8:	f882 c020 	strb.w	ip, [r2, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80031cc:	8f20      	ldrh	r0, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 80031ce:	61a2      	str	r2, [r4, #24]
 80031d0:	07c2      	lsls	r2, r0, #31
 80031d2:	f140 8098 	bpl.w	8003306 <_gett+0x216>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80031d6:	f3ef 8009 	mrs	r0, PSP
  chSysSwitch(currp, otp);
 80031da:	69ca      	ldr	r2, [r1, #28]
 80031dc:	3864      	subs	r0, #100	; 0x64
 80031de:	4282      	cmp	r2, r0
 80031e0:	f200 808e 	bhi.w	8003300 <_gett+0x210>
 80031e4:	69a0      	ldr	r0, [r4, #24]
 80031e6:	f7fd f86f 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 80031ea:	69a2      	ldr	r2, [r4, #24]
 80031ec:	6a50      	ldr	r0, [r2, #36]	; 0x24
    if (msg < MSG_OK) {
 80031ee:	2800      	cmp	r0, #0
 80031f0:	da9c      	bge.n	800312c <_gett+0x3c>
 80031f2:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80031f6:	f1bc 0f00 	cmp.w	ip, #0
 80031fa:	d137      	bne.n	800326c <_gett+0x17c>
 80031fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80031fe:	2b00      	cmp	r3, #0
 8003200:	dd34      	ble.n	800326c <_gett+0x17c>
 8003202:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8003204:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
 8003208:	42a3      	cmp	r3, r4
 800320a:	d005      	beq.n	8003218 <_gett+0x128>
 800320c:	69a2      	ldr	r2, [r4, #24]
 800320e:	689b      	ldr	r3, [r3, #8]
 8003210:	6892      	ldr	r2, [r2, #8]
 8003212:	429a      	cmp	r2, r3
 8003214:	f0c0 808b 	bcc.w	800332e <_gett+0x23e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003218:	2300      	movs	r3, #0
 800321a:	f383 8811 	msr	BASEPRI, r3
}
 800321e:	b009      	add	sp, #36	; 0x24
 8003220:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  b = *iqp->q_rdptr++;
 8003224:	6a68      	ldr	r0, [r5, #36]	; 0x24
  iqp->q_counter--;
 8003226:	696b      	ldr	r3, [r5, #20]
  if (iqp->q_rdptr >= iqp->q_top) {
 8003228:	69e9      	ldr	r1, [r5, #28]
  b = *iqp->q_rdptr++;
 800322a:	1c42      	adds	r2, r0, #1
  iqp->q_counter--;
 800322c:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800322e:	428a      	cmp	r2, r1
  iqp->q_counter--;
 8003230:	616b      	str	r3, [r5, #20]
  b = *iqp->q_rdptr++;
 8003232:	626a      	str	r2, [r5, #36]	; 0x24
    iqp->q_rdptr = iqp->q_buffer;
 8003234:	bf28      	it	cs
 8003236:	69ab      	ldrcs	r3, [r5, #24]
  b = *iqp->q_rdptr++;
 8003238:	7806      	ldrb	r6, [r0, #0]
    iqp->q_rdptr = iqp->q_buffer;
 800323a:	bf28      	it	cs
 800323c:	626b      	strcs	r3, [r5, #36]	; 0x24
  if (iqp->q_notify != NULL) {
 800323e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8003240:	b10b      	cbz	r3, 8003246 <_gett+0x156>
    iqp->q_notify(iqp);
 8003242:	4638      	mov	r0, r7
 8003244:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003246:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003248:	b983      	cbnz	r3, 800326c <_gett+0x17c>
 800324a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800324c:	2a00      	cmp	r2, #0
 800324e:	dd0d      	ble.n	800326c <_gett+0x17c>
 8003250:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8003252:	6363      	str	r3, [r4, #52]	; 0x34
 8003254:	42a2      	cmp	r2, r4
 8003256:	d004      	beq.n	8003262 <_gett+0x172>
 8003258:	69a1      	ldr	r1, [r4, #24]
 800325a:	6893      	ldr	r3, [r2, #8]
 800325c:	688a      	ldr	r2, [r1, #8]
 800325e:	429a      	cmp	r2, r3
 8003260:	d365      	bcc.n	800332e <_gett+0x23e>
 8003262:	2300      	movs	r3, #0
 8003264:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8003268:	4630      	mov	r0, r6
 800326a:	e7d8      	b.n	800321e <_gett+0x12e>
    chSysHalt("SV#5");
 800326c:	4854      	ldr	r0, [pc, #336]	; (80033c0 <_gett+0x2d0>)
 800326e:	f7fe f89f 	bl	80013b0 <chSysHalt>
 8003272:	4684      	mov	ip, r0
    return MSG_TIMEOUT;
 8003274:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003278:	e7bd      	b.n	80031f6 <_gett+0x106>
  vtp->prev = vtp->next->prev;
 800327a:	6850      	ldr	r0, [r2, #4]
 800327c:	e9cd 2003 	strd	r2, r0, [sp, #12]
  vtp->prev->next = vtp;
 8003280:	f8c0 b000 	str.w	fp, [r0]
  p->prev = vtp;
 8003284:	f8c2 b004 	str.w	fp, [r2, #4]
  vtp->delta = delta;
 8003288:	f8cd c014 	str.w	ip, [sp, #20]
  p->delta -= delta;
 800328c:	6890      	ldr	r0, [r2, #8]
 800328e:	eba0 000c 	sub.w	r0, r0, ip
  ch.vtlist.delta = (sysinterval_t)-1;
 8003292:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  p->delta -= delta;
 8003296:	6090      	str	r0, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8003298:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
  thread_t *tp = tqp->next;
 800329c:	6822      	ldr	r2, [r4, #0]
  otp->state = newstate;
 800329e:	f881 9020 	strb.w	r9, [r1, #32]
  tqp->next             = tp->queue.next;
 80032a2:	6810      	ldr	r0, [r2, #0]
 80032a4:	6020      	str	r0, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 80032a6:	f04f 0c01 	mov.w	ip, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80032aa:	6044      	str	r4, [r0, #4]
 80032ac:	f882 c020 	strb.w	ip, [r2, #32]
 80032b0:	8f20      	ldrh	r0, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 80032b2:	61a2      	str	r2, [r4, #24]
 80032b4:	07c3      	lsls	r3, r0, #31
 80032b6:	d55b      	bpl.n	8003370 <_gett+0x280>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80032b8:	f3ef 8009 	mrs	r0, PSP
  chSysSwitch(currp, otp);
 80032bc:	69ca      	ldr	r2, [r1, #28]
 80032be:	3864      	subs	r0, #100	; 0x64
 80032c0:	4282      	cmp	r2, r0
 80032c2:	d81d      	bhi.n	8003300 <_gett+0x210>
 80032c4:	69a0      	ldr	r0, [r4, #24]
 80032c6:	f7fc ffff 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80032ca:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80032cc:	2a00      	cmp	r2, #0
 80032ce:	db63      	blt.n	8003398 <_gett+0x2a8>
 80032d0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80032d2:	2a00      	cmp	r2, #0
 80032d4:	dd60      	ble.n	8003398 <_gett+0x2a8>
    if (chVTIsArmedI(&vt)) {
 80032d6:	9a06      	ldr	r2, [sp, #24]
 80032d8:	2a00      	cmp	r2, #0
 80032da:	d086      	beq.n	80031ea <_gett+0xfa>
  if (ch.vtlist.next != vtp) {
 80032dc:	69e2      	ldr	r2, [r4, #28]
 80032de:	9803      	ldr	r0, [sp, #12]
 80032e0:	455a      	cmp	r2, fp
 80032e2:	d079      	beq.n	80033d8 <_gett+0x2e8>
    vtp->prev->next = vtp->next;
 80032e4:	9a04      	ldr	r2, [sp, #16]
 80032e6:	6010      	str	r0, [r2, #0]
    vtp->next->prev = vtp->prev;
 80032e8:	9803      	ldr	r0, [sp, #12]
    vtp->func = NULL;
 80032ea:	2100      	movs	r1, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80032ec:	4540      	cmp	r0, r8
    vtp->next->prev = vtp->prev;
 80032ee:	6042      	str	r2, [r0, #4]
    vtp->func = NULL;
 80032f0:	9106      	str	r1, [sp, #24]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80032f2:	f43f af7a 	beq.w	80031ea <_gett+0xfa>
      vtp->next->delta += vtp->delta;
 80032f6:	6882      	ldr	r2, [r0, #8]
 80032f8:	9905      	ldr	r1, [sp, #20]
 80032fa:	440a      	add	r2, r1
 80032fc:	6082      	str	r2, [r0, #8]
 80032fe:	e774      	b.n	80031ea <_gett+0xfa>
  chSysSwitch(currp, otp);
 8003300:	4830      	ldr	r0, [pc, #192]	; (80033c4 <_gett+0x2d4>)
 8003302:	f7fe f855 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003306:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003308:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800330c:	7802      	ldrb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800330e:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003310:	f36c 0202 	bfi	r2, ip, #0, #3
 8003314:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003316:	f891 c020 	ldrb.w	ip, [r1, #32]
 800331a:	f36c 02c7 	bfi	r2, ip, #3, #5
 800331e:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8003320:	69a2      	ldr	r2, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003322:	e9c0 2e02 	strd	r2, lr, [r0, #8]
    trace_next();
 8003326:	f7fe f823 	bl	8001370 <trace_next>
 800332a:	9901      	ldr	r1, [sp, #4]
 800332c:	e753      	b.n	80031d6 <_gett+0xe6>
 800332e:	4826      	ldr	r0, [pc, #152]	; (80033c8 <_gett+0x2d8>)
 8003330:	f7fe f83e 	bl	80013b0 <chSysHalt>
      vtp->delta = delay;
 8003334:	f8cd a014 	str.w	sl, [sp, #20]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003338:	68c2      	ldr	r2, [r0, #12]
      ch.vtlist.lasttime = now;
 800333a:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 800333e:	f10d 0b0c 	add.w	fp, sp, #12
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8003342:	f012 0202 	ands.w	r2, r2, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8003346:	e9cd 8803 	strd	r8, r8, [sp, #12]
      ch.vtlist.prev = vtp;
 800334a:	e9c4 bb07 	strd	fp, fp, [r4, #28]
 800334e:	d126      	bne.n	800339e <_gett+0x2ae>
  return systime + (systime_t)interval;
 8003350:	44d4      	add	ip, sl
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003352:	f04f 0e02 	mov.w	lr, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003356:	f8c0 c034 	str.w	ip, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800335a:	6102      	str	r2, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800335c:	f8c0 e00c 	str.w	lr, [r0, #12]
 8003360:	e79c      	b.n	800329c <_gett+0x1ac>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003362:	68c3      	ldr	r3, [r0, #12]
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8003364:	079b      	lsls	r3, r3, #30
 8003366:	d51d      	bpl.n	80033a4 <_gett+0x2b4>
 8003368:	44e3      	add	fp, ip
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800336a:	f8c0 b034 	str.w	fp, [r0, #52]	; 0x34
 800336e:	e708      	b.n	8003182 <_gett+0x92>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003370:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003372:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003376:	7802      	ldrb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003378:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800337a:	f36c 0202 	bfi	r2, ip, #0, #3
 800337e:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003380:	f891 c020 	ldrb.w	ip, [r1, #32]
 8003384:	f36c 02c7 	bfi	r2, ip, #3, #5
 8003388:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800338a:	69a2      	ldr	r2, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800338c:	e9c0 2e02 	strd	r2, lr, [r0, #8]
    trace_next();
 8003390:	f7fd ffee 	bl	8001370 <trace_next>
 8003394:	9901      	ldr	r1, [sp, #4]
 8003396:	e78f      	b.n	80032b8 <_gett+0x1c8>
    chSysHalt("SV#10");
 8003398:	480c      	ldr	r0, [pc, #48]	; (80033cc <_gett+0x2dc>)
 800339a:	f7fe f809 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800339e:	480c      	ldr	r0, [pc, #48]	; (80033d0 <_gett+0x2e0>)
 80033a0:	f7fe f806 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80033a4:	480b      	ldr	r0, [pc, #44]	; (80033d4 <_gett+0x2e4>)
 80033a6:	f7fe f803 	bl	80013b0 <chSysHalt>
 80033aa:	bf00      	nop
 80033ac:	2000159c 	.word	0x2000159c
 80033b0:	0800e704 	.word	0x0800e704
 80033b4:	080016d1 	.word	0x080016d1
 80033b8:	0800e264 	.word	0x0800e264
 80033bc:	0800e714 	.word	0x0800e714
 80033c0:	0800e72c 	.word	0x0800e72c
 80033c4:	0800e71c 	.word	0x0800e71c
 80033c8:	0800e240 	.word	0x0800e240
 80033cc:	0800e70c 	.word	0x0800e70c
 80033d0:	0800e38c 	.word	0x0800e38c
 80033d4:	0800e3cc 	.word	0x0800e3cc
  vtp->func = NULL;
 80033d8:	2200      	movs	r2, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80033da:	4540      	cmp	r0, r8
  ch.vtlist.next = vtp->next;
 80033dc:	61e0      	str	r0, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80033de:	f8c0 8004 	str.w	r8, [r0, #4]
  vtp->func = NULL;
 80033e2:	9206      	str	r2, [sp, #24]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80033e4:	d019      	beq.n	800341a <_gett+0x32a>
  ch.vtlist.next->delta += vtp->delta;
 80033e6:	9a05      	ldr	r2, [sp, #20]
 80033e8:	6881      	ldr	r1, [r0, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80033ea:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 80033ee:	4411      	add	r1, r2
  return (systime_t)STM32_ST_TIM->CNT;
 80033f0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80033f4:	6081      	str	r1, [r0, #8]
 80033f6:	6a52      	ldr	r2, [r2, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80033f8:	eba2 020c 	sub.w	r2, r2, ip
  if (nowdelta >= ch.vtlist.next->delta) {
 80033fc:	4291      	cmp	r1, r2
 80033fe:	f67f aef4 	bls.w	80031ea <_gett+0xfa>
  delta = ch.vtlist.next->delta - nowdelta;
 8003402:	1a88      	subs	r0, r1, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003404:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003406:	bf98      	it	ls
 8003408:	1c91      	addls	r1, r2, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800340a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 800340e:	4461      	add	r1, ip
 8003410:	68d0      	ldr	r0, [r2, #12]
 8003412:	0780      	lsls	r0, r0, #30
 8003414:	d5c6      	bpl.n	80033a4 <_gett+0x2b4>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003416:	6351      	str	r1, [r2, #52]	; 0x34
 8003418:	e6e7      	b.n	80031ea <_gett+0xfa>
  STM32_ST_TIM->DIER = 0;
 800341a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800341e:	60ca      	str	r2, [r1, #12]
 8003420:	e6e3      	b.n	80031ea <_gett+0xfa>
 8003422:	bf00      	nop
	...

08003430 <_putt>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8003430:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003434:	2320      	movs	r3, #32
 8003436:	b08b      	sub	sp, #44	; 0x2c
 8003438:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800343c:	4cb7      	ldr	r4, [pc, #732]	; (800371c <_putt+0x2ec>)
 800343e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003440:	b90b      	cbnz	r3, 8003446 <_putt+0x16>
 8003442:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003444:	b113      	cbz	r3, 800344c <_putt+0x1c>
    chSysHalt("SV#4");
 8003446:	48b6      	ldr	r0, [pc, #728]	; (8003720 <_putt+0x2f0>)
 8003448:	f7fd ffb2 	bl	80013b0 <chSysHalt>
 800344c:	2a01      	cmp	r2, #1
  _dbg_enter_lock();
 800344e:	f04f 0301 	mov.w	r3, #1
 8003452:	4605      	mov	r5, r0
 8003454:	460e      	mov	r6, r1
 8003456:	bf14      	ite	ne
 8003458:	4691      	movne	r9, r2
 800345a:	f04f 0902 	moveq.w	r9, #2
 800345e:	6363      	str	r3, [r4, #52]	; 0x34
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003460:	f100 0730 	add.w	r7, r0, #48	; 0x30
  otp->state = newstate;
 8003464:	f04f 0b04 	mov.w	fp, #4
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003468:	f104 081c 	add.w	r8, r4, #28
  while (oqIsFullI(oqp)) {
 800346c:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800346e:	2900      	cmp	r1, #0
 8003470:	f040 808c 	bne.w	800358c <_putt+0x15c>
 8003474:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  if (TIME_IMMEDIATE == timeout) {
 8003478:	2a00      	cmp	r2, #0
 800347a:	f000 80ae 	beq.w	80035da <_putt+0x1aa>
  queue_insert(currp, tqp);
 800347e:	69a1      	ldr	r1, [r4, #24]
  tp->queue.prev             = tqp->prev;
 8003480:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8003482:	e9c1 7000 	strd	r7, r0, [r1]
  tp->queue.prev->queue.next = tp;
 8003486:	6001      	str	r1, [r0, #0]
  tqp->prev                  = tp;
 8003488:	6369      	str	r1, [r5, #52]	; 0x34
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800348a:	f1bc 0f00 	cmp.w	ip, #0
 800348e:	d135      	bne.n	80034fc <_putt+0xcc>
 8003490:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003492:	2900      	cmp	r1, #0
 8003494:	dd32      	ble.n	80034fc <_putt+0xcc>
  if (TIME_INFINITE != timeout) {
 8003496:	1c50      	adds	r0, r2, #1
 8003498:	69a1      	ldr	r1, [r4, #24]
 800349a:	d039      	beq.n	8003510 <_putt+0xe0>
 800349c:	f8d4 c01c 	ldr.w	ip, [r4, #28]
  vtp->func = vtfunc;
 80034a0:	4ba0      	ldr	r3, [pc, #640]	; (8003724 <_putt+0x2f4>)
  vtp->par = par;
 80034a2:	9109      	str	r1, [sp, #36]	; 0x24
  return (systime_t)STM32_ST_TIM->CNT;
 80034a4:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80034a8:	45c4      	cmp	ip, r8
  vtp->func = vtfunc;
 80034aa:	9308      	str	r3, [sp, #32]
 80034ac:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80034b0:	f000 8113 	beq.w	80036da <_putt+0x2aa>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80034b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80034b6:	9301      	str	r3, [sp, #4]
  return (sysinterval_t)((systime_t)(end - start));
 80034b8:	ebae 0e03 	sub.w	lr, lr, r3
 80034bc:	eb19 0e0e 	adds.w	lr, r9, lr
 80034c0:	f8dc a008 	ldr.w	sl, [ip, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80034c4:	d21d      	bcs.n	8003502 <_putt+0xd2>
    else if (delta < p->delta) {
 80034c6:	45d6      	cmp	lr, sl
 80034c8:	f0c0 8120 	bcc.w	800370c <_putt+0x2dc>
    chDbgAssert(p != vtp, "timer already armed");
 80034cc:	ab05      	add	r3, sp, #20
  while (p->delta < delta) {
 80034ce:	45d6      	cmp	lr, sl
    chDbgAssert(p != vtp, "timer already armed");
 80034d0:	9301      	str	r3, [sp, #4]
  while (p->delta < delta) {
 80034d2:	f240 8088 	bls.w	80035e6 <_putt+0x1b6>
    chDbgAssert(p != vtp, "timer already armed");
 80034d6:	459c      	cmp	ip, r3
 80034d8:	d00d      	beq.n	80034f6 <_putt+0xc6>
 80034da:	4613      	mov	r3, r2
 80034dc:	4660      	mov	r0, ip
 80034de:	f8dd c004 	ldr.w	ip, [sp, #4]
 80034e2:	4652      	mov	r2, sl
 80034e4:	469a      	mov	sl, r3
    p = p->next;
 80034e6:	6800      	ldr	r0, [r0, #0]
    delta -= p->delta;
 80034e8:	ebae 0e02 	sub.w	lr, lr, r2
  while (p->delta < delta) {
 80034ec:	6882      	ldr	r2, [r0, #8]
 80034ee:	4596      	cmp	lr, r2
 80034f0:	d976      	bls.n	80035e0 <_putt+0x1b0>
    chDbgAssert(p != vtp, "timer already armed");
 80034f2:	4560      	cmp	r0, ip
 80034f4:	d1f7      	bne.n	80034e6 <_putt+0xb6>
 80034f6:	488c      	ldr	r0, [pc, #560]	; (8003728 <_putt+0x2f8>)
 80034f8:	f7fd ff5a 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 80034fc:	488b      	ldr	r0, [pc, #556]	; (800372c <_putt+0x2fc>)
 80034fe:	f7fd ff57 	bl	80013b0 <chSysHalt>
      p = p->next;
 8003502:	f8dc c000 	ldr.w	ip, [ip]
      delta -= p->delta;
 8003506:	ebae 0e0a 	sub.w	lr, lr, sl
 800350a:	f8dc a008 	ldr.w	sl, [ip, #8]
 800350e:	e7dd      	b.n	80034cc <_putt+0x9c>
  thread_t *tp = tqp->next;
 8003510:	6820      	ldr	r0, [r4, #0]
  otp->state = newstate;
 8003512:	f881 b020 	strb.w	fp, [r1, #32]
  tqp->next             = tp->queue.next;
 8003516:	f8d0 c000 	ldr.w	ip, [r0]
 800351a:	f8c4 c000 	str.w	ip, [r4]
  currp->state = CH_STATE_CURRENT;
 800351e:	f04f 0e01 	mov.w	lr, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8003522:	f8cc 4004 	str.w	r4, [ip, #4]
 8003526:	f880 e020 	strb.w	lr, [r0, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800352a:	f8b4 c038 	ldrh.w	ip, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 800352e:	61a0      	str	r0, [r4, #24]
 8003530:	f01c 0f01 	tst.w	ip, #1
 8003534:	f000 80b4 	beq.w	80036a0 <_putt+0x270>
 8003538:	9201      	str	r2, [sp, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800353a:	f3ef 8c09 	mrs	ip, PSP
  chSysSwitch(currp, otp);
 800353e:	69c8      	ldr	r0, [r1, #28]
 8003540:	f1ac 0c64 	sub.w	ip, ip, #100	; 0x64
 8003544:	4560      	cmp	r0, ip
 8003546:	f200 80a8 	bhi.w	800369a <_putt+0x26a>
 800354a:	69a0      	ldr	r0, [r4, #24]
 800354c:	f7fc febc 	bl	80002c8 <_port_switch>
 8003550:	9a01      	ldr	r2, [sp, #4]
  return currp->u.rdymsg;
 8003552:	69a1      	ldr	r1, [r4, #24]
 8003554:	6a48      	ldr	r0, [r1, #36]	; 0x24
    if (msg < MSG_OK) {
 8003556:	2800      	cmp	r0, #0
 8003558:	da88      	bge.n	800346c <_putt+0x3c>
 800355a:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800355e:	f1bc 0f00 	cmp.w	ip, #0
 8003562:	d137      	bne.n	80035d4 <_putt+0x1a4>
 8003564:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003566:	2b00      	cmp	r3, #0
 8003568:	dd34      	ble.n	80035d4 <_putt+0x1a4>
 800356a:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 800356c:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
 8003570:	42a3      	cmp	r3, r4
 8003572:	d005      	beq.n	8003580 <_putt+0x150>
 8003574:	69a2      	ldr	r2, [r4, #24]
 8003576:	689b      	ldr	r3, [r3, #8]
 8003578:	6892      	ldr	r2, [r2, #8]
 800357a:	429a      	cmp	r2, r3
 800357c:	f0c0 80aa 	bcc.w	80036d4 <_putt+0x2a4>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003580:	2300      	movs	r3, #0
 8003582:	f383 8811 	msr	BASEPRI, r3
}
 8003586:	b00b      	add	sp, #44	; 0x2c
 8003588:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  *oqp->q_wrptr++ = b;
 800358c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  oqp->q_counter--;
 800358e:	6bab      	ldr	r3, [r5, #56]	; 0x38
  *oqp->q_wrptr++ = b;
 8003590:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8003592:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8003594:	6469      	str	r1, [r5, #68]	; 0x44
  oqp->q_counter--;
 8003596:	63ab      	str	r3, [r5, #56]	; 0x38
  *oqp->q_wrptr++ = b;
 8003598:	7016      	strb	r6, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800359a:	e9d5 3210 	ldrd	r3, r2, [r5, #64]	; 0x40
 800359e:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80035a0:	bf24      	itt	cs
 80035a2:	6beb      	ldrcs	r3, [r5, #60]	; 0x3c
 80035a4:	646b      	strcs	r3, [r5, #68]	; 0x44
  if (oqp->q_notify != NULL) {
 80035a6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 80035a8:	b10b      	cbz	r3, 80035ae <_putt+0x17e>
    oqp->q_notify(oqp);
 80035aa:	4638      	mov	r0, r7
 80035ac:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80035ae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80035b0:	b983      	cbnz	r3, 80035d4 <_putt+0x1a4>
 80035b2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80035b4:	2a00      	cmp	r2, #0
 80035b6:	dd0d      	ble.n	80035d4 <_putt+0x1a4>
 80035b8:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 80035ba:	6363      	str	r3, [r4, #52]	; 0x34
 80035bc:	42a2      	cmp	r2, r4
 80035be:	d005      	beq.n	80035cc <_putt+0x19c>
 80035c0:	69a1      	ldr	r1, [r4, #24]
 80035c2:	6893      	ldr	r3, [r2, #8]
 80035c4:	688a      	ldr	r2, [r1, #8]
 80035c6:	429a      	cmp	r2, r3
 80035c8:	f0c0 8084 	bcc.w	80036d4 <_putt+0x2a4>
 80035cc:	2000      	movs	r0, #0
 80035ce:	f380 8811 	msr	BASEPRI, r0
 80035d2:	e7d8      	b.n	8003586 <_putt+0x156>
    chSysHalt("SV#5");
 80035d4:	4856      	ldr	r0, [pc, #344]	; (8003730 <_putt+0x300>)
 80035d6:	f7fd feeb 	bl	80013b0 <chSysHalt>
    return MSG_TIMEOUT;
 80035da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80035de:	e7be      	b.n	800355e <_putt+0x12e>
 80035e0:	9b01      	ldr	r3, [sp, #4]
 80035e2:	4684      	mov	ip, r0
 80035e4:	4652      	mov	r2, sl
  vtp->prev = vtp->next->prev;
 80035e6:	f8dc 0004 	ldr.w	r0, [ip, #4]
 80035ea:	e9cd c005 	strd	ip, r0, [sp, #20]
  vtp->prev->next = vtp;
 80035ee:	6003      	str	r3, [r0, #0]
  p->prev = vtp;
 80035f0:	f8cc 3004 	str.w	r3, [ip, #4]
  vtp->delta = delta;
 80035f4:	f8cd e01c 	str.w	lr, [sp, #28]
  p->delta -= delta;
 80035f8:	f8dc 0008 	ldr.w	r0, [ip, #8]
 80035fc:	eba0 000e 	sub.w	r0, r0, lr
  ch.vtlist.delta = (sysinterval_t)-1;
 8003600:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
  p->delta -= delta;
 8003604:	f8cc 0008 	str.w	r0, [ip, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8003608:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
  thread_t *tp = tqp->next;
 800360c:	f8d4 c000 	ldr.w	ip, [r4]
  otp->state = newstate;
 8003610:	f881 b020 	strb.w	fp, [r1, #32]
  tqp->next             = tp->queue.next;
 8003614:	f8dc e000 	ldr.w	lr, [ip]
 8003618:	f8c4 e000 	str.w	lr, [r4]
  currp->state = CH_STATE_CURRENT;
 800361c:	2001      	movs	r0, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800361e:	f8ce 4004 	str.w	r4, [lr, #4]
 8003622:	f88c 0020 	strb.w	r0, [ip, #32]
 8003626:	f8b4 e038 	ldrh.w	lr, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 800362a:	f8c4 c018 	str.w	ip, [r4, #24]
 800362e:	f01e 0f01 	tst.w	lr, #1
 8003632:	f000 8083 	beq.w	800373c <_putt+0x30c>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003636:	f3ef 8c09 	mrs	ip, PSP
  chSysSwitch(currp, otp);
 800363a:	69c8      	ldr	r0, [r1, #28]
 800363c:	f1ac 0c64 	sub.w	ip, ip, #100	; 0x64
 8003640:	4560      	cmp	r0, ip
 8003642:	d82a      	bhi.n	800369a <_putt+0x26a>
 8003644:	69a0      	ldr	r0, [r4, #24]
 8003646:	9202      	str	r2, [sp, #8]
 8003648:	f7fc fe3e 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800364c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800364e:	2900      	cmp	r1, #0
 8003650:	f2c0 808d 	blt.w	800376e <_putt+0x33e>
 8003654:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003656:	9a02      	ldr	r2, [sp, #8]
 8003658:	2900      	cmp	r1, #0
 800365a:	f340 8088 	ble.w	800376e <_putt+0x33e>
    if (chVTIsArmedI(&vt)) {
 800365e:	9908      	ldr	r1, [sp, #32]
 8003660:	2900      	cmp	r1, #0
 8003662:	f43f af76 	beq.w	8003552 <_putt+0x122>
  if (ch.vtlist.next != vtp) {
 8003666:	69e1      	ldr	r1, [r4, #28]
 8003668:	9b01      	ldr	r3, [sp, #4]
 800366a:	f8dd c014 	ldr.w	ip, [sp, #20]
 800366e:	4299      	cmp	r1, r3
 8003670:	f000 8086 	beq.w	8003780 <_putt+0x350>
    vtp->prev->next = vtp->next;
 8003674:	9906      	ldr	r1, [sp, #24]
 8003676:	f8c1 c000 	str.w	ip, [r1]
    vtp->next->prev = vtp->prev;
 800367a:	f8dd c014 	ldr.w	ip, [sp, #20]
    vtp->func = NULL;
 800367e:	2000      	movs	r0, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8003680:	45c4      	cmp	ip, r8
    vtp->next->prev = vtp->prev;
 8003682:	f8cc 1004 	str.w	r1, [ip, #4]
    vtp->func = NULL;
 8003686:	9008      	str	r0, [sp, #32]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8003688:	f43f af63 	beq.w	8003552 <_putt+0x122>
      vtp->next->delta += vtp->delta;
 800368c:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8003690:	9807      	ldr	r0, [sp, #28]
 8003692:	4401      	add	r1, r0
 8003694:	f8cc 1008 	str.w	r1, [ip, #8]
 8003698:	e75b      	b.n	8003552 <_putt+0x122>
  chSysSwitch(currp, otp);
 800369a:	4826      	ldr	r0, [pc, #152]	; (8003734 <_putt+0x304>)
 800369c:	f7fd fe88 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80036a0:	f8d4 c03c 	ldr.w	ip, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80036a4:	f8d1 a024 	ldr.w	sl, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80036a8:	f89c 0000 	ldrb.w	r0, [ip]
 80036ac:	9202      	str	r2, [sp, #8]
 80036ae:	f36e 0002 	bfi	r0, lr, #0, #3
 80036b2:	f88c 0000 	strb.w	r0, [ip]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80036b6:	f891 e020 	ldrb.w	lr, [r1, #32]
 80036ba:	9101      	str	r1, [sp, #4]
 80036bc:	f36e 00c7 	bfi	r0, lr, #3, #5
 80036c0:	f88c 0000 	strb.w	r0, [ip]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80036c4:	69a0      	ldr	r0, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80036c6:	e9cc 0a02 	strd	r0, sl, [ip, #8]
    trace_next();
 80036ca:	f7fd fe51 	bl	8001370 <trace_next>
 80036ce:	e9dd 1201 	ldrd	r1, r2, [sp, #4]
 80036d2:	e731      	b.n	8003538 <_putt+0x108>
 80036d4:	4818      	ldr	r0, [pc, #96]	; (8003738 <_putt+0x308>)
 80036d6:	f7fd fe6b 	bl	80013b0 <chSysHalt>
      vtp->delta = delay;
 80036da:	f8cd 901c 	str.w	r9, [sp, #28]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80036de:	f8d0 c00c 	ldr.w	ip, [r0, #12]
      ch.vtlist.lasttime = now;
 80036e2:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 80036e6:	ab05      	add	r3, sp, #20
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80036e8:	f01c 0c02 	ands.w	ip, ip, #2
 80036ec:	9301      	str	r3, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80036ee:	e9cd 8805 	strd	r8, r8, [sp, #20]
      ch.vtlist.prev = vtp;
 80036f2:	e9c4 3307 	strd	r3, r3, [r4, #28]
 80036f6:	d13d      	bne.n	8003774 <_putt+0x344>
  return systime + (systime_t)interval;
 80036f8:	44ce      	add	lr, r9
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80036fa:	f04f 0a02 	mov.w	sl, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80036fe:	f8c0 e034 	str.w	lr, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003702:	f8c0 c010 	str.w	ip, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003706:	f8c0 a00c 	str.w	sl, [r0, #12]
 800370a:	e77f      	b.n	800360c <_putt+0x1dc>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800370c:	68c3      	ldr	r3, [r0, #12]
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800370e:	079b      	lsls	r3, r3, #30
 8003710:	d533      	bpl.n	800377a <_putt+0x34a>
 8003712:	9b01      	ldr	r3, [sp, #4]
 8003714:	4473      	add	r3, lr
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003716:	6343      	str	r3, [r0, #52]	; 0x34
 8003718:	e6d8      	b.n	80034cc <_putt+0x9c>
 800371a:	bf00      	nop
 800371c:	2000159c 	.word	0x2000159c
 8003720:	0800e704 	.word	0x0800e704
 8003724:	080016d1 	.word	0x080016d1
 8003728:	0800e264 	.word	0x0800e264
 800372c:	0800e714 	.word	0x0800e714
 8003730:	0800e72c 	.word	0x0800e72c
 8003734:	0800e71c 	.word	0x0800e71c
 8003738:	0800e240 	.word	0x0800e240
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800373c:	f8d4 e03c 	ldr.w	lr, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003740:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003742:	f89e c000 	ldrb.w	ip, [lr]
 8003746:	9203      	str	r2, [sp, #12]
 8003748:	f360 0c02 	bfi	ip, r0, #0, #3
 800374c:	f88e c000 	strb.w	ip, [lr]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003750:	f891 0020 	ldrb.w	r0, [r1, #32]
 8003754:	9102      	str	r1, [sp, #8]
 8003756:	f360 0cc7 	bfi	ip, r0, #3, #5
 800375a:	f88e c000 	strb.w	ip, [lr]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800375e:	69a0      	ldr	r0, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003760:	e9ce 0302 	strd	r0, r3, [lr, #8]
    trace_next();
 8003764:	f7fd fe04 	bl	8001370 <trace_next>
 8003768:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 800376c:	e763      	b.n	8003636 <_putt+0x206>
    chSysHalt("SV#10");
 800376e:	481a      	ldr	r0, [pc, #104]	; (80037d8 <_putt+0x3a8>)
 8003770:	f7fd fe1e 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8003774:	4819      	ldr	r0, [pc, #100]	; (80037dc <_putt+0x3ac>)
 8003776:	f7fd fe1b 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800377a:	4819      	ldr	r0, [pc, #100]	; (80037e0 <_putt+0x3b0>)
 800377c:	f7fd fe18 	bl	80013b0 <chSysHalt>
  vtp->func = NULL;
 8003780:	2100      	movs	r1, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003782:	45c4      	cmp	ip, r8
  ch.vtlist.next = vtp->next;
 8003784:	f8c4 c01c 	str.w	ip, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003788:	f8cc 8004 	str.w	r8, [ip, #4]
  vtp->func = NULL;
 800378c:	9108      	str	r1, [sp, #32]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800378e:	d01f      	beq.n	80037d0 <_putt+0x3a0>
  ch.vtlist.next->delta += vtp->delta;
 8003790:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8003794:	9907      	ldr	r1, [sp, #28]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8003796:	f8d4 e028 	ldr.w	lr, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 800379a:	4401      	add	r1, r0
  return (systime_t)STM32_ST_TIM->CNT;
 800379c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80037a0:	f8cc 1008 	str.w	r1, [ip, #8]
 80037a4:	6a40      	ldr	r0, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80037a6:	eba0 000e 	sub.w	r0, r0, lr
  if (nowdelta >= ch.vtlist.next->delta) {
 80037aa:	4281      	cmp	r1, r0
 80037ac:	f67f aed1 	bls.w	8003552 <_putt+0x122>
  delta = ch.vtlist.next->delta - nowdelta;
 80037b0:	eba1 0c00 	sub.w	ip, r1, r0
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80037b4:	f1bc 0f01 	cmp.w	ip, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80037b8:	bf98      	it	ls
 80037ba:	1c81      	addls	r1, r0, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80037bc:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 80037c0:	4471      	add	r1, lr
 80037c2:	f8d0 c00c 	ldr.w	ip, [r0, #12]
 80037c6:	f01c 0f02 	tst.w	ip, #2
 80037ca:	d0d6      	beq.n	800377a <_putt+0x34a>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80037cc:	6341      	str	r1, [r0, #52]	; 0x34
 80037ce:	e6c0      	b.n	8003552 <_putt+0x122>
  STM32_ST_TIM->DIER = 0;
 80037d0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80037d4:	60c1      	str	r1, [r0, #12]
 80037d6:	e6bc      	b.n	8003552 <_putt+0x122>
 80037d8:	0800e70c 	.word	0x0800e70c
 80037dc:	0800e38c 	.word	0x0800e38c
 80037e0:	0800e3cc 	.word	0x0800e3cc
	...

080037f0 <_get>:
static msg_t _get(void *ip) {
 80037f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80037f4:	2320      	movs	r3, #32
 80037f6:	b082      	sub	sp, #8
 80037f8:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80037fc:	4c47      	ldr	r4, [pc, #284]	; (800391c <_get+0x12c>)
 80037fe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003800:	b90b      	cbnz	r3, 8003806 <_get+0x16>
 8003802:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003804:	b113      	cbz	r3, 800380c <_get+0x1c>
    chSysHalt("SV#4");
 8003806:	4846      	ldr	r0, [pc, #280]	; (8003920 <_get+0x130>)
 8003808:	f7fd fdd2 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 800380c:	2601      	movs	r6, #1
 800380e:	4605      	mov	r5, r0
 8003810:	6366      	str	r6, [r4, #52]	; 0x34
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003812:	f100 070c 	add.w	r7, r0, #12
  otp->state = newstate;
 8003816:	f04f 0804 	mov.w	r8, #4
  while (iqIsEmptyI(iqp)) {
 800381a:	696b      	ldr	r3, [r5, #20]
 800381c:	2b00      	cmp	r3, #0
 800381e:	d13f      	bne.n	80038a0 <_get+0xb0>
  queue_insert(currp, tqp);
 8003820:	69a3      	ldr	r3, [r4, #24]
  tp->queue.prev             = tqp->prev;
 8003822:	692a      	ldr	r2, [r5, #16]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003824:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003826:	e9c3 7200 	strd	r7, r2, [r3]
  tp->queue.prev->queue.next = tp;
 800382a:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800382c:	612b      	str	r3, [r5, #16]
 800382e:	2900      	cmp	r1, #0
 8003830:	d130      	bne.n	8003894 <_get+0xa4>
 8003832:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003834:	2b00      	cmp	r3, #0
 8003836:	dd2d      	ble.n	8003894 <_get+0xa4>
  thread_t *otp = currp;
 8003838:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->next;
 800383a:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 800383c:	f881 8020 	strb.w	r8, [r1, #32]
  tqp->next             = tp->queue.next;
 8003840:	681a      	ldr	r2, [r3, #0]
 8003842:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003844:	6054      	str	r4, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8003846:	f883 6020 	strb.w	r6, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800384a:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 800384c:	61a3      	str	r3, [r4, #24]
 800384e:	07d3      	lsls	r3, r2, #31
 8003850:	d54a      	bpl.n	80038e8 <_get+0xf8>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003852:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8003856:	69ca      	ldr	r2, [r1, #28]
 8003858:	3b64      	subs	r3, #100	; 0x64
 800385a:	429a      	cmp	r2, r3
 800385c:	d81d      	bhi.n	800389a <_get+0xaa>
 800385e:	69a0      	ldr	r0, [r4, #24]
 8003860:	f7fc fd32 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 8003864:	69a3      	ldr	r3, [r4, #24]
 8003866:	6a58      	ldr	r0, [r3, #36]	; 0x24
    if (msg < MSG_OK) {
 8003868:	2800      	cmp	r0, #0
 800386a:	dad6      	bge.n	800381a <_get+0x2a>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800386c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800386e:	2a00      	cmp	r2, #0
 8003870:	d14d      	bne.n	800390e <_get+0x11e>
 8003872:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003874:	2900      	cmp	r1, #0
 8003876:	dd4a      	ble.n	800390e <_get+0x11e>
 8003878:	6821      	ldr	r1, [r4, #0]
  _dbg_leave_lock();
 800387a:	6362      	str	r2, [r4, #52]	; 0x34
 800387c:	42a1      	cmp	r1, r4
 800387e:	d003      	beq.n	8003888 <_get+0x98>
 8003880:	689a      	ldr	r2, [r3, #8]
 8003882:	688b      	ldr	r3, [r1, #8]
 8003884:	429a      	cmp	r2, r3
 8003886:	d345      	bcc.n	8003914 <_get+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003888:	2300      	movs	r3, #0
 800388a:	f383 8811 	msr	BASEPRI, r3
}
 800388e:	b002      	add	sp, #8
 8003890:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    chSysHalt("SV#11");
 8003894:	4823      	ldr	r0, [pc, #140]	; (8003924 <_get+0x134>)
 8003896:	f7fd fd8b 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 800389a:	4823      	ldr	r0, [pc, #140]	; (8003928 <_get+0x138>)
 800389c:	f7fd fd88 	bl	80013b0 <chSysHalt>
  b = *iqp->q_rdptr++;
 80038a0:	6a68      	ldr	r0, [r5, #36]	; 0x24
  iqp->q_counter--;
 80038a2:	696b      	ldr	r3, [r5, #20]
  if (iqp->q_rdptr >= iqp->q_top) {
 80038a4:	69e9      	ldr	r1, [r5, #28]
  b = *iqp->q_rdptr++;
 80038a6:	1c42      	adds	r2, r0, #1
  iqp->q_counter--;
 80038a8:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 80038aa:	428a      	cmp	r2, r1
  iqp->q_counter--;
 80038ac:	616b      	str	r3, [r5, #20]
  b = *iqp->q_rdptr++;
 80038ae:	626a      	str	r2, [r5, #36]	; 0x24
    iqp->q_rdptr = iqp->q_buffer;
 80038b0:	bf28      	it	cs
 80038b2:	69ab      	ldrcs	r3, [r5, #24]
  b = *iqp->q_rdptr++;
 80038b4:	7806      	ldrb	r6, [r0, #0]
    iqp->q_rdptr = iqp->q_buffer;
 80038b6:	bf28      	it	cs
 80038b8:	626b      	strcs	r3, [r5, #36]	; 0x24
  if (iqp->q_notify != NULL) {
 80038ba:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80038bc:	b10b      	cbz	r3, 80038c2 <_get+0xd2>
    iqp->q_notify(iqp);
 80038be:	4638      	mov	r0, r7
 80038c0:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80038c2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80038c4:	bb1b      	cbnz	r3, 800390e <_get+0x11e>
 80038c6:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80038c8:	2a00      	cmp	r2, #0
 80038ca:	dd20      	ble.n	800390e <_get+0x11e>
 80038cc:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 80038ce:	6363      	str	r3, [r4, #52]	; 0x34
 80038d0:	42a2      	cmp	r2, r4
 80038d2:	d004      	beq.n	80038de <_get+0xee>
 80038d4:	69a1      	ldr	r1, [r4, #24]
 80038d6:	6893      	ldr	r3, [r2, #8]
 80038d8:	688a      	ldr	r2, [r1, #8]
 80038da:	429a      	cmp	r2, r3
 80038dc:	d31a      	bcc.n	8003914 <_get+0x124>
 80038de:	2300      	movs	r3, #0
 80038e0:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 80038e4:	4630      	mov	r0, r6
 80038e6:	e7d2      	b.n	800388e <_get+0x9e>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80038e8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80038ea:	6a48      	ldr	r0, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80038ec:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80038ee:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80038f0:	f366 0302 	bfi	r3, r6, #0, #3
 80038f4:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80038f6:	f891 c020 	ldrb.w	ip, [r1, #32]
 80038fa:	f36c 03c7 	bfi	r3, ip, #3, #5
 80038fe:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8003900:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003902:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8003906:	f7fd fd33 	bl	8001370 <trace_next>
 800390a:	9901      	ldr	r1, [sp, #4]
 800390c:	e7a1      	b.n	8003852 <_get+0x62>
    chSysHalt("SV#5");
 800390e:	4807      	ldr	r0, [pc, #28]	; (800392c <_get+0x13c>)
 8003910:	f7fd fd4e 	bl	80013b0 <chSysHalt>
 8003914:	4806      	ldr	r0, [pc, #24]	; (8003930 <_get+0x140>)
 8003916:	f7fd fd4b 	bl	80013b0 <chSysHalt>
 800391a:	bf00      	nop
 800391c:	2000159c 	.word	0x2000159c
 8003920:	0800e704 	.word	0x0800e704
 8003924:	0800e714 	.word	0x0800e714
 8003928:	0800e71c 	.word	0x0800e71c
 800392c:	0800e72c 	.word	0x0800e72c
 8003930:	0800e240 	.word	0x0800e240
	...

08003940 <_put>:
static msg_t _put(void *ip, uint8_t b) {
 8003940:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003944:	2320      	movs	r3, #32
 8003946:	b083      	sub	sp, #12
 8003948:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800394c:	4c47      	ldr	r4, [pc, #284]	; (8003a6c <_put+0x12c>)
 800394e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003950:	b90b      	cbnz	r3, 8003956 <_put+0x16>
 8003952:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003954:	b113      	cbz	r3, 800395c <_put+0x1c>
    chSysHalt("SV#4");
 8003956:	4846      	ldr	r0, [pc, #280]	; (8003a70 <_put+0x130>)
 8003958:	f7fd fd2a 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 800395c:	2701      	movs	r7, #1
 800395e:	4605      	mov	r5, r0
 8003960:	460e      	mov	r6, r1
 8003962:	6367      	str	r7, [r4, #52]	; 0x34
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003964:	f100 0830 	add.w	r8, r0, #48	; 0x30
  otp->state = newstate;
 8003968:	f04f 0904 	mov.w	r9, #4
  while (oqIsFullI(oqp)) {
 800396c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800396e:	2b00      	cmp	r3, #0
 8003970:	d13f      	bne.n	80039f2 <_put+0xb2>
 8003972:	69a3      	ldr	r3, [r4, #24]
  tp->queue.prev             = tqp->prev;
 8003974:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003976:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003978:	e9c3 8200 	strd	r8, r2, [r3]
  tp->queue.prev->queue.next = tp;
 800397c:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800397e:	636b      	str	r3, [r5, #52]	; 0x34
 8003980:	2900      	cmp	r1, #0
 8003982:	d130      	bne.n	80039e6 <_put+0xa6>
 8003984:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003986:	2b00      	cmp	r3, #0
 8003988:	dd2d      	ble.n	80039e6 <_put+0xa6>
  thread_t *otp = currp;
 800398a:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->next;
 800398c:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 800398e:	f881 9020 	strb.w	r9, [r1, #32]
  tqp->next             = tp->queue.next;
 8003992:	681a      	ldr	r2, [r3, #0]
 8003994:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003996:	6054      	str	r4, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8003998:	f883 7020 	strb.w	r7, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800399c:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 800399e:	61a3      	str	r3, [r4, #24]
 80039a0:	07d3      	lsls	r3, r2, #31
 80039a2:	d549      	bpl.n	8003a38 <_put+0xf8>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80039a4:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 80039a8:	69cb      	ldr	r3, [r1, #28]
 80039aa:	3a64      	subs	r2, #100	; 0x64
 80039ac:	4293      	cmp	r3, r2
 80039ae:	d81d      	bhi.n	80039ec <_put+0xac>
 80039b0:	69a0      	ldr	r0, [r4, #24]
 80039b2:	f7fc fc89 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 80039b6:	69a3      	ldr	r3, [r4, #24]
 80039b8:	6a58      	ldr	r0, [r3, #36]	; 0x24
    if (msg < MSG_OK) {
 80039ba:	2800      	cmp	r0, #0
 80039bc:	dad6      	bge.n	800396c <_put+0x2c>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80039be:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80039c0:	2a00      	cmp	r2, #0
 80039c2:	d14c      	bne.n	8003a5e <_put+0x11e>
 80039c4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80039c6:	2900      	cmp	r1, #0
 80039c8:	dd49      	ble.n	8003a5e <_put+0x11e>
 80039ca:	6821      	ldr	r1, [r4, #0]
  _dbg_leave_lock();
 80039cc:	6362      	str	r2, [r4, #52]	; 0x34
 80039ce:	42a1      	cmp	r1, r4
 80039d0:	d003      	beq.n	80039da <_put+0x9a>
 80039d2:	689a      	ldr	r2, [r3, #8]
 80039d4:	688b      	ldr	r3, [r1, #8]
 80039d6:	429a      	cmp	r2, r3
 80039d8:	d344      	bcc.n	8003a64 <_put+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80039da:	2300      	movs	r3, #0
 80039dc:	f383 8811 	msr	BASEPRI, r3
}
 80039e0:	b003      	add	sp, #12
 80039e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    chSysHalt("SV#11");
 80039e6:	4823      	ldr	r0, [pc, #140]	; (8003a74 <_put+0x134>)
 80039e8:	f7fd fce2 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 80039ec:	4822      	ldr	r0, [pc, #136]	; (8003a78 <_put+0x138>)
 80039ee:	f7fd fcdf 	bl	80013b0 <chSysHalt>
  *oqp->q_wrptr++ = b;
 80039f2:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  oqp->q_counter--;
 80039f4:	6bab      	ldr	r3, [r5, #56]	; 0x38
  *oqp->q_wrptr++ = b;
 80039f6:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 80039f8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 80039fa:	6469      	str	r1, [r5, #68]	; 0x44
  oqp->q_counter--;
 80039fc:	63ab      	str	r3, [r5, #56]	; 0x38
  *oqp->q_wrptr++ = b;
 80039fe:	7016      	strb	r6, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003a00:	e9d5 3210 	ldrd	r3, r2, [r5, #64]	; 0x40
 8003a04:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8003a06:	bf24      	itt	cs
 8003a08:	6beb      	ldrcs	r3, [r5, #60]	; 0x3c
 8003a0a:	646b      	strcs	r3, [r5, #68]	; 0x44
  if (oqp->q_notify != NULL) {
 8003a0c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 8003a0e:	b10b      	cbz	r3, 8003a14 <_put+0xd4>
    oqp->q_notify(oqp);
 8003a10:	4640      	mov	r0, r8
 8003a12:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003a14:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003a16:	bb13      	cbnz	r3, 8003a5e <_put+0x11e>
 8003a18:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003a1a:	2a00      	cmp	r2, #0
 8003a1c:	dd1f      	ble.n	8003a5e <_put+0x11e>
 8003a1e:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8003a20:	6363      	str	r3, [r4, #52]	; 0x34
 8003a22:	42a2      	cmp	r2, r4
 8003a24:	d004      	beq.n	8003a30 <_put+0xf0>
 8003a26:	69a1      	ldr	r1, [r4, #24]
 8003a28:	6893      	ldr	r3, [r2, #8]
 8003a2a:	688a      	ldr	r2, [r1, #8]
 8003a2c:	429a      	cmp	r2, r3
 8003a2e:	d319      	bcc.n	8003a64 <_put+0x124>
 8003a30:	2000      	movs	r0, #0
 8003a32:	f380 8811 	msr	BASEPRI, r0
 8003a36:	e7d3      	b.n	80039e0 <_put+0xa0>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003a38:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003a3a:	6a48      	ldr	r0, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003a3c:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003a3e:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003a40:	f367 0302 	bfi	r3, r7, #0, #3
 8003a44:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003a46:	f891 c020 	ldrb.w	ip, [r1, #32]
 8003a4a:	f36c 03c7 	bfi	r3, ip, #3, #5
 8003a4e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8003a50:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003a52:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8003a56:	f7fd fc8b 	bl	8001370 <trace_next>
 8003a5a:	9901      	ldr	r1, [sp, #4]
 8003a5c:	e7a2      	b.n	80039a4 <_put+0x64>
    chSysHalt("SV#5");
 8003a5e:	4807      	ldr	r0, [pc, #28]	; (8003a7c <_put+0x13c>)
 8003a60:	f7fd fca6 	bl	80013b0 <chSysHalt>
 8003a64:	4806      	ldr	r0, [pc, #24]	; (8003a80 <_put+0x140>)
 8003a66:	f7fd fca3 	bl	80013b0 <chSysHalt>
 8003a6a:	bf00      	nop
 8003a6c:	2000159c 	.word	0x2000159c
 8003a70:	0800e704 	.word	0x0800e704
 8003a74:	0800e714 	.word	0x0800e714
 8003a78:	0800e71c 	.word	0x0800e71c
 8003a7c:	0800e72c 	.word	0x0800e72c
 8003a80:	0800e240 	.word	0x0800e240
	...

08003a90 <chprintf.constprop.14>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8003a90:	b40e      	push	{r1, r2, r3}
 8003a92:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003a96:	ed2d 8b02 	vpush	{d8}
 8003a9a:	b098      	sub	sp, #96	; 0x60
 8003a9c:	ab23      	add	r3, sp, #140	; 0x8c
 8003a9e:	f8df a26c 	ldr.w	sl, [pc, #620]	; 8003d0c <chprintf.constprop.14+0x27c>
 8003aa2:	f853 6b04 	ldr.w	r6, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8003aa6:	9311      	str	r3, [sp, #68]	; 0x44
  int n = 0;
 8003aa8:	f04f 0b00 	mov.w	fp, #0
 8003aac:	4699      	mov	r9, r3
    c = *fmt++;
 8003aae:	7831      	ldrb	r1, [r6, #0]
 8003ab0:	1c72      	adds	r2, r6, #1
    if (c == 0)
 8003ab2:	b169      	cbz	r1, 8003ad0 <chprintf.constprop.14+0x40>
    if (c != '%') {
 8003ab4:	2925      	cmp	r1, #37	; 0x25
 8003ab6:	d013      	beq.n	8003ae0 <chprintf.constprop.14+0x50>
      streamPut(chp, (uint8_t)c);
 8003ab8:	f8da 3000 	ldr.w	r3, [sl]
 8003abc:	4893      	ldr	r0, [pc, #588]	; (8003d0c <chprintf.constprop.14+0x27c>)
 8003abe:	68db      	ldr	r3, [r3, #12]
    c = *fmt++;
 8003ac0:	4616      	mov	r6, r2
      streamPut(chp, (uint8_t)c);
 8003ac2:	4798      	blx	r3
    c = *fmt++;
 8003ac4:	7831      	ldrb	r1, [r6, #0]
      n++;
 8003ac6:	f10b 0b01 	add.w	fp, fp, #1
    c = *fmt++;
 8003aca:	1c72      	adds	r2, r6, #1
    if (c == 0)
 8003acc:	2900      	cmp	r1, #0
 8003ace:	d1f1      	bne.n	8003ab4 <chprintf.constprop.14+0x24>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8003ad0:	4658      	mov	r0, fp
 8003ad2:	b018      	add	sp, #96	; 0x60
 8003ad4:	ecbd 8b02 	vpop	{d8}
 8003ad8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003adc:	b003      	add	sp, #12
 8003ade:	4770      	bx	lr
    if (*fmt == '-') {
 8003ae0:	7875      	ldrb	r5, [r6, #1]
 8003ae2:	2d2d      	cmp	r5, #45	; 0x2d
 8003ae4:	bf03      	ittte	eq
 8003ae6:	78b5      	ldrbeq	r5, [r6, #2]
      fmt++;
 8003ae8:	1cb2      	addeq	r2, r6, #2
      left_align = TRUE;
 8003aea:	2301      	moveq	r3, #1
    left_align = FALSE;
 8003aec:	2300      	movne	r3, #0
    if (*fmt == '0') {
 8003aee:	2d30      	cmp	r5, #48	; 0x30
    left_align = FALSE;
 8003af0:	9302      	str	r3, [sp, #8]
 8003af2:	bf0c      	ite	eq
 8003af4:	3201      	addeq	r2, #1
    filler = ' ';
 8003af6:	2520      	movne	r5, #32
    width = 0;
 8003af8:	2400      	movs	r4, #0
 8003afa:	e005      	b.n	8003b08 <chprintf.constprop.14+0x78>
        c = va_arg(ap, int);
 8003afc:	f899 3000 	ldrb.w	r3, [r9]
 8003b00:	f109 0904 	add.w	r9, r9, #4
      width = width * 10 + c;
 8003b04:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      c = *fmt++;
 8003b08:	f812 1b01 	ldrb.w	r1, [r2], #1
      if (c >= '0' && c <= '9')
 8003b0c:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8003b10:	b2db      	uxtb	r3, r3
 8003b12:	2b09      	cmp	r3, #9
      width = width * 10 + c;
 8003b14:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
 8003b18:	d9f4      	bls.n	8003b04 <chprintf.constprop.14+0x74>
      else if (c == '*')
 8003b1a:	292a      	cmp	r1, #42	; 0x2a
 8003b1c:	d0ee      	beq.n	8003afc <chprintf.constprop.14+0x6c>
    if (c == '.') {
 8003b1e:	292e      	cmp	r1, #46	; 0x2e
    precision = 0;
 8003b20:	f04f 0700 	mov.w	r7, #0
    if (c == '.') {
 8003b24:	d04a      	beq.n	8003bbc <chprintf.constprop.14+0x12c>
    if (c == 'l' || c == 'L') {
 8003b26:	f001 03df 	and.w	r3, r1, #223	; 0xdf
 8003b2a:	2b4c      	cmp	r3, #76	; 0x4c
 8003b2c:	f102 0601 	add.w	r6, r2, #1
 8003b30:	d050      	beq.n	8003bd4 <chprintf.constprop.14+0x144>
      is_long = (c >= 'A') && (c <= 'Z');
 8003b32:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
    switch (c) {
 8003b36:	f1a1 0044 	sub.w	r0, r1, #68	; 0x44
      is_long = (c >= 'A') && (c <= 'Z');
 8003b3a:	b2db      	uxtb	r3, r3
    switch (c) {
 8003b3c:	2834      	cmp	r0, #52	; 0x34
 8003b3e:	f200 82dd 	bhi.w	80040fc <chprintf.constprop.14+0x66c>
 8003b42:	e8df f010 	tbh	[pc, r0, lsl #1]
 8003b46:	0397      	.short	0x0397
 8003b48:	02db02db 	.word	0x02db02db
 8003b4c:	02db02db 	.word	0x02db02db
 8003b50:	02db0397 	.word	0x02db0397
 8003b54:	02db02db 	.word	0x02db02db
 8003b58:	02db02db 	.word	0x02db02db
 8003b5c:	02db02d8 	.word	0x02db02d8
 8003b60:	02db02db 	.word	0x02db02db
 8003b64:	02db02db 	.word	0x02db02db
 8003b68:	02db0286 	.word	0x02db0286
 8003b6c:	03a102db 	.word	0x03a102db
 8003b70:	02db02db 	.word	0x02db02db
 8003b74:	02db02db 	.word	0x02db02db
 8003b78:	02db02db 	.word	0x02db02db
 8003b7c:	02db02db 	.word	0x02db02db
 8003b80:	02db02db 	.word	0x02db02db
 8003b84:	03970235 	.word	0x03970235
 8003b88:	00aa02db 	.word	0x00aa02db
 8003b8c:	02db02db 	.word	0x02db02db
 8003b90:	02db0397 	.word	0x02db0397
 8003b94:	02db02db 	.word	0x02db02db
 8003b98:	02db02db 	.word	0x02db02db
 8003b9c:	02db02d8 	.word	0x02db02d8
 8003ba0:	02db02db 	.word	0x02db02db
 8003ba4:	02db0088 	.word	0x02db0088
 8003ba8:	02db0286 	.word	0x02db0286
 8003bac:	03a102db 	.word	0x03a102db
          c = va_arg(ap, int);
 8003bb0:	f899 3000 	ldrb.w	r3, [r9]
 8003bb4:	f109 0904 	add.w	r9, r9, #4
        precision += c;
 8003bb8:	eb03 0740 	add.w	r7, r3, r0, lsl #1
        c = *fmt++;
 8003bbc:	f812 1b01 	ldrb.w	r1, [r2], #1
        if (c >= '0' && c <= '9')
 8003bc0:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8003bc4:	b2db      	uxtb	r3, r3
 8003bc6:	2b09      	cmp	r3, #9
        precision *= 10;
 8003bc8:	eb07 0087 	add.w	r0, r7, r7, lsl #2
        if (c >= '0' && c <= '9')
 8003bcc:	d9f4      	bls.n	8003bb8 <chprintf.constprop.14+0x128>
        else if (c == '*')
 8003bce:	292a      	cmp	r1, #42	; 0x2a
 8003bd0:	d0ee      	beq.n	8003bb0 <chprintf.constprop.14+0x120>
 8003bd2:	e7a8      	b.n	8003b26 <chprintf.constprop.14+0x96>
      if (*fmt)
 8003bd4:	7813      	ldrb	r3, [r2, #0]
 8003bd6:	b3db      	cbz	r3, 8003c50 <chprintf.constprop.14+0x1c0>
    switch (c) {
 8003bd8:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
 8003bdc:	2a34      	cmp	r2, #52	; 0x34
 8003bde:	f200 828f 	bhi.w	8004100 <chprintf.constprop.14+0x670>
 8003be2:	e8df f012 	tbh	[pc, r2, lsl #1]
 8003be6:	02b6      	.short	0x02b6
 8003be8:	028d028d 	.word	0x028d028d
 8003bec:	028d028d 	.word	0x028d028d
 8003bf0:	028d02b6 	.word	0x028d02b6
 8003bf4:	028d028d 	.word	0x028d028d
 8003bf8:	028d028d 	.word	0x028d028d
 8003bfc:	028d0289 	.word	0x028d0289
 8003c00:	028d028d 	.word	0x028d028d
 8003c04:	028d028d 	.word	0x028d028d
 8003c08:	028d0237 	.word	0x028d0237
 8003c0c:	02b4028d 	.word	0x02b4028d
 8003c10:	028d028d 	.word	0x028d028d
 8003c14:	028d028d 	.word	0x028d028d
 8003c18:	028d028d 	.word	0x028d028d
 8003c1c:	028d028d 	.word	0x028d028d
 8003c20:	028d028d 	.word	0x028d028d
 8003c24:	02b601e6 	.word	0x02b601e6
 8003c28:	005b028d 	.word	0x005b028d
 8003c2c:	028d028d 	.word	0x028d028d
 8003c30:	028d02b6 	.word	0x028d02b6
 8003c34:	028d028d 	.word	0x028d028d
 8003c38:	028d028d 	.word	0x028d028d
 8003c3c:	028d0289 	.word	0x028d0289
 8003c40:	028d028d 	.word	0x028d028d
 8003c44:	028d0039 	.word	0x028d0039
 8003c48:	028d0237 	.word	0x028d0237
 8003c4c:	02b4028d 	.word	0x02b4028d
      if (*fmt)
 8003c50:	460b      	mov	r3, r1
 8003c52:	4616      	mov	r6, r2
 8003c54:	e7c0      	b.n	8003bd8 <chprintf.constprop.14+0x148>
    switch (c) {
 8003c56:	4616      	mov	r6, r2
      if ((s = va_arg(ap, char *)) == 0)
 8003c58:	f8d9 8000 	ldr.w	r8, [r9]
 8003c5c:	f109 0904 	add.w	r9, r9, #4
 8003c60:	f1b8 0f00 	cmp.w	r8, #0
 8003c64:	f000 831d 	beq.w	80042a2 <chprintf.constprop.14+0x812>
 8003c68:	f898 3000 	ldrb.w	r3, [r8]
 8003c6c:	4641      	mov	r1, r8
      if (precision == 0)
 8003c6e:	2f00      	cmp	r7, #0
 8003c70:	f040 8328 	bne.w	80042c4 <chprintf.constprop.14+0x834>
      for (p = s; *p && (--precision >= 0); p++)
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	f000 837a 	beq.w	800436e <chprintf.constprop.14+0x8de>
 8003c7a:	f647 77fe 	movw	r7, #32766	; 0x7ffe
 8003c7e:	4643      	mov	r3, r8
 8003c80:	e001      	b.n	8003c86 <chprintf.constprop.14+0x1f6>
 8003c82:	3f01      	subs	r7, #1
 8003c84:	d403      	bmi.n	8003c8e <chprintf.constprop.14+0x1fe>
 8003c86:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8003c8a:	2a00      	cmp	r2, #0
 8003c8c:	d1f9      	bne.n	8003c82 <chprintf.constprop.14+0x1f2>
 8003c8e:	1a5b      	subs	r3, r3, r1
 8003c90:	1ae4      	subs	r4, r4, r3
 8003c92:	3b01      	subs	r3, #1
 8003c94:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8003c96:	2520      	movs	r5, #32
 8003c98:	e197      	b.n	8003fca <chprintf.constprop.14+0x53a>
    switch (c) {
 8003c9a:	4616      	mov	r6, r2
      f = (float) va_arg(ap, double);
 8003c9c:	f109 0907 	add.w	r9, r9, #7
 8003ca0:	f029 0907 	bic.w	r9, r9, #7
 8003ca4:	e9d9 0100 	ldrd	r0, r1, [r9]
 8003ca8:	f7fc ffc0 	bl	8000c2c <__aeabi_d2f>
 8003cac:	ee08 0a10 	vmov	s16, r0
      if (f < 0) {
 8003cb0:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8003cb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      f = (float) va_arg(ap, double);
 8003cb8:	f109 0908 	add.w	r9, r9, #8
      if (f < 0) {
 8003cbc:	f100 82e7 	bmi.w	800428e <chprintf.constprop.14+0x7fe>
    p = tmpbuf;
 8003cc0:	ab12      	add	r3, sp, #72	; 0x48
 8003cc2:	9303      	str	r3, [sp, #12]
 8003cc4:	4698      	mov	r8, r3
      p = ftoa(p, f, precision);
 8003cc6:	ee18 0a10 	vmov	r0, s16
 8003cca:	f7fc fc7f 	bl	80005cc <__aeabi_f2d>
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8003cce:	3f01      	subs	r7, #1
 8003cd0:	2f08      	cmp	r7, #8
      p = ftoa(p, f, precision);
 8003cd2:	e9cd 0106 	strd	r0, r1, [sp, #24]
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8003cd6:	f200 82fc 	bhi.w	80042d2 <chprintf.constprop.14+0x842>
 8003cda:	4b0d      	ldr	r3, [pc, #52]	; (8003d10 <chprintf.constprop.14+0x280>)
 8003cdc:	f853 7027 	ldr.w	r7, [r3, r7, lsl #2]
 8003ce0:	4638      	mov	r0, r7
 8003ce2:	f7fc fc51 	bl	8000588 <__aeabi_ui2d>
 8003ce6:	4b0b      	ldr	r3, [pc, #44]	; (8003d14 <chprintf.constprop.14+0x284>)
 8003ce8:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8003cec:	fba3 3707 	umull	r3, r7, r3, r7
 8003cf0:	08fb      	lsrs	r3, r7, #3
 8003cf2:	930c      	str	r3, [sp, #48]	; 0x30
 8003cf4:	461f      	mov	r7, r3
  l = (long)num;
 8003cf6:	eefd 7ac8 	vcvt.s32.f32	s15, s16
  q = p + MAX_FILLER;
 8003cfa:	f108 010b 	add.w	r1, r8, #11
  l = (long)num;
 8003cfe:	edcd 7a01 	vstr	s15, [sp, #4]
  l = num;
 8003d02:	ee17 0a90 	vmov	r0, s15
  q = p + MAX_FILLER;
 8003d06:	460a      	mov	r2, r1
 8003d08:	e007      	b.n	8003d1a <chprintf.constprop.14+0x28a>
 8003d0a:	bf00      	nop
 8003d0c:	200013d8 	.word	0x200013d8
 8003d10:	0801d8f8 	.word	0x0801d8f8
 8003d14:	cccccccd 	.word	0xcccccccd
  } while ((ll /= radix) != 0);
 8003d18:	461a      	mov	r2, r3
    i = (int)(l % radix);
 8003d1a:	4bb6      	ldr	r3, [pc, #728]	; (8003ff4 <chprintf.constprop.14+0x564>)
 8003d1c:	fba3 c300 	umull	ip, r3, r3, r0
 8003d20:	08db      	lsrs	r3, r3, #3
 8003d22:	eb03 0e83 	add.w	lr, r3, r3, lsl #2
 8003d26:	469c      	mov	ip, r3
 8003d28:	eba0 034e 	sub.w	r3, r0, lr, lsl #1
    i += '0';
 8003d2c:	3330      	adds	r3, #48	; 0x30
  } while ((ll /= radix) != 0);
 8003d2e:	4660      	mov	r0, ip
    *--q = i;
 8003d30:	f802 3c01 	strb.w	r3, [r2, #-1]
 8003d34:	1e53      	subs	r3, r2, #1
  } while ((ll /= radix) != 0);
 8003d36:	2800      	cmp	r0, #0
 8003d38:	d1ee      	bne.n	8003d18 <chprintf.constprop.14+0x288>
 8003d3a:	f102 0c03 	add.w	ip, r2, #3
 8003d3e:	f108 0004 	add.w	r0, r8, #4
 8003d42:	4283      	cmp	r3, r0
 8003d44:	bf38      	it	cc
 8003d46:	45e0      	cmpcc	r8, ip
  i = (int)(p + MAX_FILLER - q);
 8003d48:	eba1 0e03 	sub.w	lr, r1, r3
 8003d4c:	9308      	str	r3, [sp, #32]
 8003d4e:	f0c0 82e9 	bcc.w	8004324 <chprintf.constprop.14+0x894>
 8003d52:	f1be 0f0b 	cmp.w	lr, #11
 8003d56:	f240 82e5 	bls.w	8004324 <chprintf.constprop.14+0x894>
 8003d5a:	4259      	negs	r1, r3
 8003d5c:	f001 0103 	and.w	r1, r1, #3
 8003d60:	f10e 30ff 	add.w	r0, lr, #4294967295	; 0xffffffff
 8003d64:	f101 0c03 	add.w	ip, r1, #3
 8003d68:	4584      	cmp	ip, r0
 8003d6a:	900d      	str	r0, [sp, #52]	; 0x34
 8003d6c:	9005      	str	r0, [sp, #20]
 8003d6e:	f200 82f9 	bhi.w	8004364 <chprintf.constprop.14+0x8d4>
 8003d72:	2900      	cmp	r1, #0
 8003d74:	f000 82e4 	beq.w	8004340 <chprintf.constprop.14+0x8b0>
    *p++ = *q++;
 8003d78:	7818      	ldrb	r0, [r3, #0]
 8003d7a:	f888 0000 	strb.w	r0, [r8]
 8003d7e:	2901      	cmp	r1, #1
 8003d80:	f108 0001 	add.w	r0, r8, #1
 8003d84:	9009      	str	r0, [sp, #36]	; 0x24
 8003d86:	d016      	beq.n	8003db6 <chprintf.constprop.14+0x326>
 8003d88:	7858      	ldrb	r0, [r3, #1]
 8003d8a:	f888 0001 	strb.w	r0, [r8, #1]
 8003d8e:	f108 0002 	add.w	r0, r8, #2
 8003d92:	9009      	str	r0, [sp, #36]	; 0x24
 8003d94:	2903      	cmp	r1, #3
  while (--i);
 8003d96:	f1ae 0002 	sub.w	r0, lr, #2
    *p++ = *q++;
 8003d9a:	f102 0201 	add.w	r2, r2, #1
  while (--i);
 8003d9e:	9005      	str	r0, [sp, #20]
 8003da0:	d109      	bne.n	8003db6 <chprintf.constprop.14+0x326>
    *p++ = *q++;
 8003da2:	f108 0003 	add.w	r0, r8, #3
 8003da6:	789a      	ldrb	r2, [r3, #2]
 8003da8:	9009      	str	r0, [sp, #36]	; 0x24
  while (--i);
 8003daa:	f1ae 0003 	sub.w	r0, lr, #3
    *p++ = *q++;
 8003dae:	f888 2002 	strb.w	r2, [r8, #2]
  while (--i);
 8003db2:	9005      	str	r0, [sp, #20]
    *p++ = *q++;
 8003db4:	1cda      	adds	r2, r3, #3
 8003db6:	ebae 0001 	sub.w	r0, lr, r1
 8003dba:	9004      	str	r0, [sp, #16]
 8003dbc:	0880      	lsrs	r0, r0, #2
 8003dbe:	900e      	str	r0, [sp, #56]	; 0x38
  i = (int)(p + MAX_FILLER - q);
 8003dc0:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
 8003dc4:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
 8003dc8:	440b      	add	r3, r1
 8003dca:	2000      	movs	r0, #0
 8003dcc:	4441      	add	r1, r8
 8003dce:	4691      	mov	r9, r2
 8003dd0:	3001      	adds	r0, #1
    *p++ = *q++;
 8003dd2:	f853 2b04 	ldr.w	r2, [r3], #4
 8003dd6:	f841 2b04 	str.w	r2, [r1], #4
 8003dda:	4584      	cmp	ip, r0
 8003ddc:	d8f8      	bhi.n	8003dd0 <chprintf.constprop.14+0x340>
 8003dde:	9b04      	ldr	r3, [sp, #16]
 8003de0:	9809      	ldr	r0, [sp, #36]	; 0x24
 8003de2:	f023 0103 	bic.w	r1, r3, #3
 8003de6:	9b05      	ldr	r3, [sp, #20]
 8003de8:	464a      	mov	r2, r9
 8003dea:	eba3 0c01 	sub.w	ip, r3, r1
 8003dee:	1853      	adds	r3, r2, r1
 8003df0:	9a04      	ldr	r2, [sp, #16]
 8003df2:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
 8003df6:	4291      	cmp	r1, r2
 8003df8:	4408      	add	r0, r1
 8003dfa:	d01a      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
 8003dfc:	781a      	ldrb	r2, [r3, #0]
 8003dfe:	7002      	strb	r2, [r0, #0]
  while (--i);
 8003e00:	f1bc 0f01 	cmp.w	ip, #1
 8003e04:	d015      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
    *p++ = *q++;
 8003e06:	785a      	ldrb	r2, [r3, #1]
 8003e08:	7042      	strb	r2, [r0, #1]
  while (--i);
 8003e0a:	f1bc 0f02 	cmp.w	ip, #2
 8003e0e:	d010      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
    *p++ = *q++;
 8003e10:	789a      	ldrb	r2, [r3, #2]
 8003e12:	7082      	strb	r2, [r0, #2]
  while (--i);
 8003e14:	f1bc 0f03 	cmp.w	ip, #3
 8003e18:	d00b      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
    *p++ = *q++;
 8003e1a:	78da      	ldrb	r2, [r3, #3]
 8003e1c:	70c2      	strb	r2, [r0, #3]
  while (--i);
 8003e1e:	f1bc 0f04 	cmp.w	ip, #4
 8003e22:	d006      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
    *p++ = *q++;
 8003e24:	791a      	ldrb	r2, [r3, #4]
 8003e26:	7102      	strb	r2, [r0, #4]
  while (--i);
 8003e28:	f1bc 0f05 	cmp.w	ip, #5
 8003e2c:	d001      	beq.n	8003e32 <chprintf.constprop.14+0x3a2>
    *p++ = *q++;
 8003e2e:	795b      	ldrb	r3, [r3, #5]
 8003e30:	7143      	strb	r3, [r0, #5]
 8003e32:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  l = (long)((num - l) * precision);
 8003e34:	9801      	ldr	r0, [sp, #4]
  *p++ = '.';
 8003e36:	232e      	movs	r3, #46	; 0x2e
 8003e38:	f808 300e 	strb.w	r3, [r8, lr]
 8003e3c:	4442      	add	r2, r8
 8003e3e:	9201      	str	r2, [sp, #4]
  l = (long)((num - l) * precision);
 8003e40:	f7fc fbb2 	bl	80005a8 <__aeabi_i2d>
 8003e44:	4602      	mov	r2, r0
 8003e46:	460b      	mov	r3, r1
 8003e48:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8003e4c:	f7fc fa5e 	bl	800030c <__aeabi_dsub>
 8003e50:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8003e54:	f7fc fc12 	bl	800067c <__aeabi_dmul>
 8003e58:	f7fc fec0 	bl	8000bdc <__aeabi_d2iz>
  q = p + MAX_FILLER;
 8003e5c:	9b01      	ldr	r3, [sp, #4]
    ll = num;
 8003e5e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  q = p + MAX_FILLER;
 8003e60:	f103 0c0d 	add.w	ip, r3, #13
    ll = num;
 8003e64:	2a00      	cmp	r2, #0
 8003e66:	bf08      	it	eq
 8003e68:	4607      	moveq	r7, r0
  *p++ = '.';
 8003e6a:	3302      	adds	r3, #2
  q = p + MAX_FILLER;
 8003e6c:	4662      	mov	r2, ip
  *p++ = '.';
 8003e6e:	9304      	str	r3, [sp, #16]
 8003e70:	4639      	mov	r1, r7
 8003e72:	e000      	b.n	8003e76 <chprintf.constprop.14+0x3e6>
  } while ((ll /= radix) != 0);
 8003e74:	461a      	mov	r2, r3
    i = (int)(l % radix);
 8003e76:	4b5f      	ldr	r3, [pc, #380]	; (8003ff4 <chprintf.constprop.14+0x564>)
 8003e78:	fba3 7300 	umull	r7, r3, r3, r0
 8003e7c:	08db      	lsrs	r3, r3, #3
 8003e7e:	eb03 0e83 	add.w	lr, r3, r3, lsl #2
 8003e82:	461f      	mov	r7, r3
 8003e84:	eba0 034e 	sub.w	r3, r0, lr, lsl #1
  } while ((ll /= radix) != 0);
 8003e88:	485a      	ldr	r0, [pc, #360]	; (8003ff4 <chprintf.constprop.14+0x564>)
 8003e8a:	fba0 0101 	umull	r0, r1, r0, r1
    i += '0';
 8003e8e:	3330      	adds	r3, #48	; 0x30
  } while ((ll /= radix) != 0);
 8003e90:	08c9      	lsrs	r1, r1, #3
    *--q = i;
 8003e92:	f802 3c01 	strb.w	r3, [r2, #-1]
    l /= radix;
 8003e96:	4638      	mov	r0, r7
    *--q = i;
 8003e98:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
  } while ((ll /= radix) != 0);
 8003e9c:	d1ea      	bne.n	8003e74 <chprintf.constprop.14+0x3e4>
 8003e9e:	9908      	ldr	r1, [sp, #32]
 8003ea0:	eba8 0101 	sub.w	r1, r8, r1
 8003ea4:	f101 000c 	add.w	r0, r1, #12
 8003ea8:	3110      	adds	r1, #16
  i = (int)(p + MAX_FILLER - q);
 8003eaa:	ebac 0e03 	sub.w	lr, ip, r3
 8003eae:	4441      	add	r1, r8
 8003eb0:	eb08 0c00 	add.w	ip, r8, r0
 8003eb4:	1cd7      	adds	r7, r2, #3
 8003eb6:	4299      	cmp	r1, r3
 8003eb8:	bf88      	it	hi
 8003eba:	4567      	cmphi	r7, ip
 8003ebc:	9008      	str	r0, [sp, #32]
 8003ebe:	4670      	mov	r0, lr
 8003ec0:	f200 8224 	bhi.w	800430c <chprintf.constprop.14+0x87c>
 8003ec4:	f1be 0f0b 	cmp.w	lr, #11
 8003ec8:	f240 8220 	bls.w	800430c <chprintf.constprop.14+0x87c>
 8003ecc:	4259      	negs	r1, r3
 8003ece:	f001 0c03 	and.w	ip, r1, #3
 8003ed2:	f10c 0703 	add.w	r7, ip, #3
 8003ed6:	f10e 31ff 	add.w	r1, lr, #4294967295	; 0xffffffff
 8003eda:	428f      	cmp	r7, r1
 8003edc:	9105      	str	r1, [sp, #20]
 8003ede:	f200 823f 	bhi.w	8004360 <chprintf.constprop.14+0x8d0>
 8003ee2:	f1bc 0f00 	cmp.w	ip, #0
 8003ee6:	f000 8235 	beq.w	8004354 <chprintf.constprop.14+0x8c4>
    *p++ = *q++;
 8003eea:	9f01      	ldr	r7, [sp, #4]
 8003eec:	7818      	ldrb	r0, [r3, #0]
 8003eee:	70b8      	strb	r0, [r7, #2]
 8003ef0:	1cf9      	adds	r1, r7, #3
 8003ef2:	f1bc 0f01 	cmp.w	ip, #1
 8003ef6:	9106      	str	r1, [sp, #24]
 8003ef8:	d013      	beq.n	8003f22 <chprintf.constprop.14+0x492>
 8003efa:	1d39      	adds	r1, r7, #4
 8003efc:	7858      	ldrb	r0, [r3, #1]
 8003efe:	9106      	str	r1, [sp, #24]
 8003f00:	f1bc 0f03 	cmp.w	ip, #3
  while (--i);
 8003f04:	f1ae 0102 	sub.w	r1, lr, #2
    *p++ = *q++;
 8003f08:	70f8      	strb	r0, [r7, #3]
 8003f0a:	f102 0201 	add.w	r2, r2, #1
  while (--i);
 8003f0e:	9105      	str	r1, [sp, #20]
 8003f10:	d107      	bne.n	8003f22 <chprintf.constprop.14+0x492>
    *p++ = *q++;
 8003f12:	789a      	ldrb	r2, [r3, #2]
 8003f14:	713a      	strb	r2, [r7, #4]
  while (--i);
 8003f16:	f1ae 0103 	sub.w	r1, lr, #3
    *p++ = *q++;
 8003f1a:	1d7a      	adds	r2, r7, #5
 8003f1c:	9206      	str	r2, [sp, #24]
  while (--i);
 8003f1e:	9105      	str	r1, [sp, #20]
    *p++ = *q++;
 8003f20:	1cda      	adds	r2, r3, #3
 8003f22:	9908      	ldr	r1, [sp, #32]
 8003f24:	4461      	add	r1, ip
 8003f26:	4608      	mov	r0, r1
 8003f28:	ebae 010c 	sub.w	r1, lr, ip
 8003f2c:	9101      	str	r1, [sp, #4]
 8003f2e:	4463      	add	r3, ip
 8003f30:	4440      	add	r0, r8
 8003f32:	ea4f 0c91 	mov.w	ip, r1, lsr #2
  *p++ = '.';
 8003f36:	2100      	movs	r1, #0
 8003f38:	3101      	adds	r1, #1
    *p++ = *q++;
 8003f3a:	f853 7b04 	ldr.w	r7, [r3], #4
 8003f3e:	f840 7b04 	str.w	r7, [r0], #4
 8003f42:	458c      	cmp	ip, r1
 8003f44:	d8f8      	bhi.n	8003f38 <chprintf.constprop.14+0x4a8>
 8003f46:	9b01      	ldr	r3, [sp, #4]
 8003f48:	9806      	ldr	r0, [sp, #24]
 8003f4a:	f023 0103 	bic.w	r1, r3, #3
 8003f4e:	4408      	add	r0, r1
 8003f50:	1853      	adds	r3, r2, r1
 8003f52:	9a01      	ldr	r2, [sp, #4]
 8003f54:	4607      	mov	r7, r0
 8003f56:	9805      	ldr	r0, [sp, #20]
 8003f58:	4291      	cmp	r1, r2
 8003f5a:	eba0 0001 	sub.w	r0, r0, r1
 8003f5e:	d015      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
 8003f60:	781a      	ldrb	r2, [r3, #0]
 8003f62:	703a      	strb	r2, [r7, #0]
  while (--i);
 8003f64:	2801      	cmp	r0, #1
 8003f66:	d011      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
    *p++ = *q++;
 8003f68:	785a      	ldrb	r2, [r3, #1]
 8003f6a:	707a      	strb	r2, [r7, #1]
  while (--i);
 8003f6c:	2802      	cmp	r0, #2
 8003f6e:	d00d      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
    *p++ = *q++;
 8003f70:	789a      	ldrb	r2, [r3, #2]
 8003f72:	70ba      	strb	r2, [r7, #2]
  while (--i);
 8003f74:	2803      	cmp	r0, #3
 8003f76:	d009      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
    *p++ = *q++;
 8003f78:	78da      	ldrb	r2, [r3, #3]
 8003f7a:	70fa      	strb	r2, [r7, #3]
  while (--i);
 8003f7c:	2804      	cmp	r0, #4
 8003f7e:	d005      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
    *p++ = *q++;
 8003f80:	791a      	ldrb	r2, [r3, #4]
 8003f82:	713a      	strb	r2, [r7, #4]
  while (--i);
 8003f84:	2805      	cmp	r0, #5
 8003f86:	d001      	beq.n	8003f8c <chprintf.constprop.14+0x4fc>
    *p++ = *q++;
 8003f88:	795b      	ldrb	r3, [r3, #5]
 8003f8a:	717b      	strb	r3, [r7, #5]
 8003f8c:	9b04      	ldr	r3, [sp, #16]
 8003f8e:	4473      	add	r3, lr
 8003f90:	461a      	mov	r2, r3
 8003f92:	9b03      	ldr	r3, [sp, #12]
 8003f94:	1ad2      	subs	r2, r2, r3
 8003f96:	1aa4      	subs	r4, r4, r2
    if ((width -= i) < 0)
 8003f98:	2c00      	cmp	r4, #0
 8003f9a:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8003f9e:	9201      	str	r2, [sp, #4]
    s = tmpbuf;
 8003fa0:	4698      	mov	r8, r3
    if ((width -= i) < 0)
 8003fa2:	da14      	bge.n	8003fce <chprintf.constprop.14+0x53e>
    while (--i >= 0) {
 8003fa4:	9b01      	ldr	r3, [sp, #4]
 8003fa6:	2b00      	cmp	r3, #0
 8003fa8:	f6ff ad81 	blt.w	8003aae <chprintf.constprop.14+0x1e>
      width = 0;
 8003fac:	2400      	movs	r4, #0
 8003fae:	e032      	b.n	8004016 <chprintf.constprop.14+0x586>
    switch (c) {
 8003fb0:	4616      	mov	r6, r2
      *p++ = va_arg(ap, int);
 8003fb2:	f10d 0860 	add.w	r8, sp, #96	; 0x60
 8003fb6:	f8d9 3000 	ldr.w	r3, [r9]
 8003fba:	f808 3d18 	strb.w	r3, [r8, #-24]!
 8003fbe:	2300      	movs	r3, #0
 8003fc0:	3c01      	subs	r4, #1
 8003fc2:	f109 0904 	add.w	r9, r9, #4
 8003fc6:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8003fc8:	2520      	movs	r5, #32
    if ((width -= i) < 0)
 8003fca:	2c00      	cmp	r4, #0
 8003fcc:	dbea      	blt.n	8003fa4 <chprintf.constprop.14+0x514>
    if (left_align == FALSE)
 8003fce:	9b02      	ldr	r3, [sp, #8]
 8003fd0:	2b00      	cmp	r3, #0
 8003fd2:	f040 80a4 	bne.w	800411e <chprintf.constprop.14+0x68e>
      width = -width;
 8003fd6:	4263      	negs	r3, r4
    if (width < 0) {
 8003fd8:	2c00      	cmp	r4, #0
 8003fda:	f000 809f 	beq.w	800411c <chprintf.constprop.14+0x68c>
      if (*s == '-' && filler == '0') {
 8003fde:	f898 1000 	ldrb.w	r1, [r8]
 8003fe2:	f8da 2000 	ldr.w	r2, [sl]
 8003fe6:	292d      	cmp	r1, #45	; 0x2d
 8003fe8:	68d2      	ldr	r2, [r2, #12]
 8003fea:	f000 809d 	beq.w	8004128 <chprintf.constprop.14+0x698>
 8003fee:	461f      	mov	r7, r3
 8003ff0:	e005      	b.n	8003ffe <chprintf.constprop.14+0x56e>
 8003ff2:	bf00      	nop
 8003ff4:	cccccccd 	.word	0xcccccccd
 8003ff8:	f8da 3000 	ldr.w	r3, [sl]
 8003ffc:	68da      	ldr	r2, [r3, #12]
        streamPut(chp, (uint8_t)filler);
 8003ffe:	4629      	mov	r1, r5
 8004000:	4650      	mov	r0, sl
 8004002:	4790      	blx	r2
      } while (++width != 0);
 8004004:	3701      	adds	r7, #1
 8004006:	d1f7      	bne.n	8003ff8 <chprintf.constprop.14+0x568>
    while (--i >= 0) {
 8004008:	9a01      	ldr	r2, [sp, #4]
 800400a:	2a00      	cmp	r2, #0
 800400c:	463b      	mov	r3, r7
 800400e:	44a3      	add	fp, r4
 8004010:	f6ff ad4d 	blt.w	8003aae <chprintf.constprop.14+0x1e>
 8004014:	461c      	mov	r4, r3
      width = -width;
 8004016:	9f01      	ldr	r7, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
 8004018:	f8da 3000 	ldr.w	r3, [sl]
 800401c:	f818 1b01 	ldrb.w	r1, [r8], #1
 8004020:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8004022:	3f01      	subs	r7, #1
      streamPut(chp, (uint8_t)*s++);
 8004024:	4650      	mov	r0, sl
 8004026:	4798      	blx	r3
    while (--i >= 0) {
 8004028:	1c7b      	adds	r3, r7, #1
 800402a:	d1f5      	bne.n	8004018 <chprintf.constprop.14+0x588>
 800402c:	9b01      	ldr	r3, [sp, #4]
 800402e:	f10b 0b01 	add.w	fp, fp, #1
 8004032:	445b      	add	r3, fp
 8004034:	469b      	mov	fp, r3
    while (width) {
 8004036:	2c00      	cmp	r4, #0
 8004038:	f43f ad39 	beq.w	8003aae <chprintf.constprop.14+0x1e>
 800403c:	4627      	mov	r7, r4
      streamPut(chp, (uint8_t)filler);
 800403e:	f8da 3000 	ldr.w	r3, [sl]
 8004042:	4629      	mov	r1, r5
 8004044:	68db      	ldr	r3, [r3, #12]
 8004046:	4650      	mov	r0, sl
 8004048:	4798      	blx	r3
    while (width) {
 800404a:	3f01      	subs	r7, #1
 800404c:	d1f7      	bne.n	800403e <chprintf.constprop.14+0x5ae>
 800404e:	44a3      	add	fp, r4
 8004050:	e52d      	b.n	8003aae <chprintf.constprop.14+0x1e>
    switch (c) {
 8004052:	4616      	mov	r6, r2
    case 'U':
 8004054:	270a      	movs	r7, #10
  q = p + MAX_FILLER;
 8004056:	f10d 0153 	add.w	r1, sp, #83	; 0x53
 800405a:	f859 2b04 	ldr.w	r2, [r9], #4
 800405e:	460b      	mov	r3, r1
    i = (int)(l % radix);
 8004060:	fbb2 f0f7 	udiv	r0, r2, r7
 8004064:	fb07 2210 	mls	r2, r7, r0, r2
    i += '0';
 8004068:	f102 0c30 	add.w	ip, r2, #48	; 0x30
    if (i > '9')
 800406c:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
      i += 'A' - '0' - 10;
 8004070:	f102 0237 	add.w	r2, r2, #55	; 0x37
    if (i > '9')
 8004074:	dd4c      	ble.n	8004110 <chprintf.constprop.14+0x680>
    *--q = i;
 8004076:	f803 2d01 	strb.w	r2, [r3, #-1]!
  } while ((ll /= radix) != 0);
 800407a:	4602      	mov	r2, r0
 800407c:	2800      	cmp	r0, #0
 800407e:	d1ef      	bne.n	8004060 <chprintf.constprop.14+0x5d0>
  i = (int)(p + MAX_FILLER - q);
 8004080:	af12      	add	r7, sp, #72	; 0x48
 8004082:	1d1a      	adds	r2, r3, #4
 8004084:	a813      	add	r0, sp, #76	; 0x4c
 8004086:	4283      	cmp	r3, r0
 8004088:	bf38      	it	cc
 800408a:	4297      	cmpcc	r7, r2
 800408c:	eba1 0e03 	sub.w	lr, r1, r3
 8004090:	9703      	str	r7, [sp, #12]
 8004092:	f0c0 810d 	bcc.w	80042b0 <chprintf.constprop.14+0x820>
 8004096:	f1be 0f08 	cmp.w	lr, #8
 800409a:	f240 8109 	bls.w	80042b0 <chprintf.constprop.14+0x820>
 800409e:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
 80040a2:	2a02      	cmp	r2, #2
 80040a4:	4638      	mov	r0, r7
 80040a6:	f240 8124 	bls.w	80042f2 <chprintf.constprop.14+0x862>
 80040aa:	ea4f 089e 	mov.w	r8, lr, lsr #2
 80040ae:	461f      	mov	r7, r3
 80040b0:	2100      	movs	r1, #0
 80040b2:	469c      	mov	ip, r3
 80040b4:	3101      	adds	r1, #1
    *p++ = *q++;
 80040b6:	f857 3b04 	ldr.w	r3, [r7], #4
 80040ba:	f840 3b04 	str.w	r3, [r0], #4
 80040be:	4541      	cmp	r1, r8
 80040c0:	d3f8      	bcc.n	80040b4 <chprintf.constprop.14+0x624>
 80040c2:	f02e 0103 	bic.w	r1, lr, #3
 80040c6:	9803      	ldr	r0, [sp, #12]
 80040c8:	4663      	mov	r3, ip
 80040ca:	4571      	cmp	r1, lr
 80040cc:	440b      	add	r3, r1
 80040ce:	4408      	add	r0, r1
 80040d0:	ebae 0701 	sub.w	r7, lr, r1
 80040d4:	d009      	beq.n	80040ea <chprintf.constprop.14+0x65a>
 80040d6:	7819      	ldrb	r1, [r3, #0]
 80040d8:	7001      	strb	r1, [r0, #0]
  while (--i);
 80040da:	2f01      	cmp	r7, #1
 80040dc:	d005      	beq.n	80040ea <chprintf.constprop.14+0x65a>
    *p++ = *q++;
 80040de:	7859      	ldrb	r1, [r3, #1]
 80040e0:	7041      	strb	r1, [r0, #1]
  while (--i);
 80040e2:	2f02      	cmp	r7, #2
 80040e4:	d001      	beq.n	80040ea <chprintf.constprop.14+0x65a>
    *p++ = *q++;
 80040e6:	789b      	ldrb	r3, [r3, #2]
 80040e8:	7083      	strb	r3, [r0, #2]
 80040ea:	eba4 040e 	sub.w	r4, r4, lr
 80040ee:	9201      	str	r2, [sp, #4]
    s = tmpbuf;
 80040f0:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80040f4:	e769      	b.n	8003fca <chprintf.constprop.14+0x53a>
    switch (c) {
 80040f6:	4616      	mov	r6, r2
    case 'O':
 80040f8:	2708      	movs	r7, #8
 80040fa:	e7ac      	b.n	8004056 <chprintf.constprop.14+0x5c6>
    switch (c) {
 80040fc:	4616      	mov	r6, r2
 80040fe:	460b      	mov	r3, r1
      *p++ = c;
 8004100:	f10d 0860 	add.w	r8, sp, #96	; 0x60
 8004104:	3c01      	subs	r4, #1
 8004106:	f808 3d18 	strb.w	r3, [r8, #-24]!
 800410a:	2300      	movs	r3, #0
 800410c:	9301      	str	r3, [sp, #4]
 800410e:	e75c      	b.n	8003fca <chprintf.constprop.14+0x53a>
    *--q = i;
 8004110:	f803 cd01 	strb.w	ip, [r3, #-1]!
  } while ((ll /= radix) != 0);
 8004114:	4602      	mov	r2, r0
 8004116:	2800      	cmp	r0, #0
 8004118:	d1a2      	bne.n	8004060 <chprintf.constprop.14+0x5d0>
 800411a:	e7b1      	b.n	8004080 <chprintf.constprop.14+0x5f0>
      width = -width;
 800411c:	461c      	mov	r4, r3
    while (--i >= 0) {
 800411e:	9b01      	ldr	r3, [sp, #4]
 8004120:	2b00      	cmp	r3, #0
 8004122:	f6bf af78 	bge.w	8004016 <chprintf.constprop.14+0x586>
 8004126:	e786      	b.n	8004036 <chprintf.constprop.14+0x5a6>
      if (*s == '-' && filler == '0') {
 8004128:	2d30      	cmp	r5, #48	; 0x30
 800412a:	f47f af60 	bne.w	8003fee <chprintf.constprop.14+0x55e>
        streamPut(chp, (uint8_t)*s++);
 800412e:	4650      	mov	r0, sl
 8004130:	9302      	str	r3, [sp, #8]
 8004132:	4790      	blx	r2
 8004134:	9b01      	ldr	r3, [sp, #4]
 8004136:	f8da 2000 	ldr.w	r2, [sl]
 800413a:	3b01      	subs	r3, #1
 800413c:	9301      	str	r3, [sp, #4]
 800413e:	9b02      	ldr	r3, [sp, #8]
 8004140:	68d2      	ldr	r2, [r2, #12]
 8004142:	f10b 0b01 	add.w	fp, fp, #1
 8004146:	f108 0801 	add.w	r8, r8, #1
 800414a:	461f      	mov	r7, r3
 800414c:	e757      	b.n	8003ffe <chprintf.constprop.14+0x56e>
    switch (c) {
 800414e:	2710      	movs	r7, #16
 8004150:	e781      	b.n	8004056 <chprintf.constprop.14+0x5c6>
 8004152:	f109 0004 	add.w	r0, r9, #4
        l = va_arg(ap, long);
 8004156:	f8d9 1000 	ldr.w	r1, [r9]
 800415a:	4681      	mov	r9, r0
      if (l < 0) {
 800415c:	2900      	cmp	r1, #0
 800415e:	f2c0 80bf 	blt.w	80042e0 <chprintf.constprop.14+0x850>
    p = tmpbuf;
 8004162:	ab12      	add	r3, sp, #72	; 0x48
 8004164:	9303      	str	r3, [sp, #12]
 8004166:	4698      	mov	r8, r3
  q = p + MAX_FILLER;
 8004168:	f108 070b 	add.w	r7, r8, #11
 800416c:	463a      	mov	r2, r7
 800416e:	e000      	b.n	8004172 <chprintf.constprop.14+0x6e2>
  } while ((ll /= radix) != 0);
 8004170:	461a      	mov	r2, r3
    i = (int)(l % radix);
 8004172:	4b83      	ldr	r3, [pc, #524]	; (8004380 <chprintf.constprop.14+0x8f0>)
 8004174:	fba3 0301 	umull	r0, r3, r3, r1
 8004178:	08db      	lsrs	r3, r3, #3
 800417a:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 800417e:	4618      	mov	r0, r3
 8004180:	eba1 034c 	sub.w	r3, r1, ip, lsl #1
    i += '0';
 8004184:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8004186:	f802 3c01 	strb.w	r3, [r2, #-1]
  } while ((ll /= radix) != 0);
 800418a:	4601      	mov	r1, r0
    *--q = i;
 800418c:	1e53      	subs	r3, r2, #1
  } while ((ll /= radix) != 0);
 800418e:	2800      	cmp	r0, #0
 8004190:	d1ee      	bne.n	8004170 <chprintf.constprop.14+0x6e0>
  i = (int)(p + MAX_FILLER - q);
 8004192:	eba7 0e03 	sub.w	lr, r7, r3
 8004196:	f108 0104 	add.w	r1, r8, #4
 800419a:	1cd7      	adds	r7, r2, #3
 800419c:	428b      	cmp	r3, r1
 800419e:	bf38      	it	cc
 80041a0:	45b8      	cmpcc	r8, r7
 80041a2:	4670      	mov	r0, lr
 80041a4:	f0c0 80a7 	bcc.w	80042f6 <chprintf.constprop.14+0x866>
 80041a8:	f1be 0f0b 	cmp.w	lr, #11
 80041ac:	f240 80a3 	bls.w	80042f6 <chprintf.constprop.14+0x866>
 80041b0:	4259      	negs	r1, r3
 80041b2:	f001 0103 	and.w	r1, r1, #3
 80041b6:	f10e 37ff 	add.w	r7, lr, #4294967295	; 0xffffffff
 80041ba:	f101 0c03 	add.w	ip, r1, #3
 80041be:	45bc      	cmp	ip, r7
 80041c0:	9704      	str	r7, [sp, #16]
 80041c2:	f200 80d2 	bhi.w	800436a <chprintf.constprop.14+0x8da>
 80041c6:	2900      	cmp	r1, #0
 80041c8:	f000 80c0 	beq.w	800434c <chprintf.constprop.14+0x8bc>
    *p++ = *q++;
 80041cc:	7818      	ldrb	r0, [r3, #0]
 80041ce:	f888 0000 	strb.w	r0, [r8]
 80041d2:	2901      	cmp	r1, #1
 80041d4:	f108 0001 	add.w	r0, r8, #1
 80041d8:	9005      	str	r0, [sp, #20]
 80041da:	d016      	beq.n	800420a <chprintf.constprop.14+0x77a>
 80041dc:	7858      	ldrb	r0, [r3, #1]
 80041de:	f888 0001 	strb.w	r0, [r8, #1]
 80041e2:	f108 0002 	add.w	r0, r8, #2
 80041e6:	9005      	str	r0, [sp, #20]
 80041e8:	2903      	cmp	r1, #3
  while (--i);
 80041ea:	f1ae 0002 	sub.w	r0, lr, #2
    *p++ = *q++;
 80041ee:	f102 0201 	add.w	r2, r2, #1
  while (--i);
 80041f2:	9004      	str	r0, [sp, #16]
 80041f4:	d109      	bne.n	800420a <chprintf.constprop.14+0x77a>
    *p++ = *q++;
 80041f6:	f108 0003 	add.w	r0, r8, #3
 80041fa:	789a      	ldrb	r2, [r3, #2]
 80041fc:	9005      	str	r0, [sp, #20]
  while (--i);
 80041fe:	f1ae 0003 	sub.w	r0, lr, #3
    *p++ = *q++;
 8004202:	f888 2002 	strb.w	r2, [r8, #2]
  while (--i);
 8004206:	9004      	str	r0, [sp, #16]
    *p++ = *q++;
 8004208:	1cda      	adds	r2, r3, #3
 800420a:	ebae 0001 	sub.w	r0, lr, r1
 800420e:	9001      	str	r0, [sp, #4]
 8004210:	440b      	add	r3, r1
 8004212:	ea4f 0c90 	mov.w	ip, r0, lsr #2
 8004216:	4441      	add	r1, r8
  i = (int)(p + MAX_FILLER - q);
 8004218:	2000      	movs	r0, #0
 800421a:	3001      	adds	r0, #1
    *p++ = *q++;
 800421c:	f853 7b04 	ldr.w	r7, [r3], #4
 8004220:	f841 7b04 	str.w	r7, [r1], #4
 8004224:	4560      	cmp	r0, ip
 8004226:	d3f8      	bcc.n	800421a <chprintf.constprop.14+0x78a>
 8004228:	9b01      	ldr	r3, [sp, #4]
 800422a:	9805      	ldr	r0, [sp, #20]
 800422c:	f023 0103 	bic.w	r1, r3, #3
 8004230:	4408      	add	r0, r1
 8004232:	1853      	adds	r3, r2, r1
 8004234:	9a01      	ldr	r2, [sp, #4]
 8004236:	4607      	mov	r7, r0
 8004238:	9804      	ldr	r0, [sp, #16]
 800423a:	4291      	cmp	r1, r2
 800423c:	eba0 0001 	sub.w	r0, r0, r1
 8004240:	d015      	beq.n	800426e <chprintf.constprop.14+0x7de>
 8004242:	781a      	ldrb	r2, [r3, #0]
 8004244:	703a      	strb	r2, [r7, #0]
  while (--i);
 8004246:	2801      	cmp	r0, #1
 8004248:	d011      	beq.n	800426e <chprintf.constprop.14+0x7de>
    *p++ = *q++;
 800424a:	785a      	ldrb	r2, [r3, #1]
 800424c:	707a      	strb	r2, [r7, #1]
  while (--i);
 800424e:	2802      	cmp	r0, #2
 8004250:	d00d      	beq.n	800426e <chprintf.constprop.14+0x7de>
    *p++ = *q++;
 8004252:	789a      	ldrb	r2, [r3, #2]
 8004254:	70ba      	strb	r2, [r7, #2]
  while (--i);
 8004256:	2803      	cmp	r0, #3
 8004258:	d009      	beq.n	800426e <chprintf.constprop.14+0x7de>
    *p++ = *q++;
 800425a:	78da      	ldrb	r2, [r3, #3]
 800425c:	70fa      	strb	r2, [r7, #3]
  while (--i);
 800425e:	2804      	cmp	r0, #4
 8004260:	d005      	beq.n	800426e <chprintf.constprop.14+0x7de>
    *p++ = *q++;
 8004262:	791a      	ldrb	r2, [r3, #4]
 8004264:	713a      	strb	r2, [r7, #4]
  while (--i);
 8004266:	2805      	cmp	r0, #5
 8004268:	d001      	beq.n	800426e <chprintf.constprop.14+0x7de>
    *p++ = *q++;
 800426a:	795b      	ldrb	r3, [r3, #5]
 800426c:	717b      	strb	r3, [r7, #5]
 800426e:	eb08 020e 	add.w	r2, r8, lr
 8004272:	e68e      	b.n	8003f92 <chprintf.constprop.14+0x502>
 8004274:	4648      	mov	r0, r9
      if (is_long)
 8004276:	2b19      	cmp	r3, #25
 8004278:	f850 1b04 	ldr.w	r1, [r0], #4
 800427c:	4616      	mov	r6, r2
        l = va_arg(ap, int);
 800427e:	bf88      	it	hi
 8004280:	4681      	movhi	r9, r0
      if (is_long)
 8004282:	f63f af6b 	bhi.w	800415c <chprintf.constprop.14+0x6cc>
 8004286:	e766      	b.n	8004156 <chprintf.constprop.14+0x6c6>
    switch (c) {
 8004288:	4616      	mov	r6, r2
 800428a:	2710      	movs	r7, #16
 800428c:	e6e3      	b.n	8004056 <chprintf.constprop.14+0x5c6>
        *p++ = '-';
 800428e:	232d      	movs	r3, #45	; 0x2d
 8004290:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8004294:	ab12      	add	r3, sp, #72	; 0x48
        f = -f;
 8004296:	eeb1 8a48 	vneg.f32	s16, s16
        *p++ = '-';
 800429a:	f10d 0849 	add.w	r8, sp, #73	; 0x49
 800429e:	9303      	str	r3, [sp, #12]
 80042a0:	e511      	b.n	8003cc6 <chprintf.constprop.14+0x236>
 80042a2:	4938      	ldr	r1, [pc, #224]	; (8004384 <chprintf.constprop.14+0x8f4>)
      if (precision == 0)
 80042a4:	4688      	mov	r8, r1
 80042a6:	2f00      	cmp	r7, #0
 80042a8:	f43f ace7 	beq.w	8003c7a <chprintf.constprop.14+0x1ea>
      for (p = s; *p && (--precision >= 0); p++)
 80042ac:	3f01      	subs	r7, #1
 80042ae:	e4e6      	b.n	8003c7e <chprintf.constprop.14+0x1ee>
 80042b0:	9a03      	ldr	r2, [sp, #12]
    *p++ = *q++;
 80042b2:	f813 0b01 	ldrb.w	r0, [r3], #1
 80042b6:	f802 0b01 	strb.w	r0, [r2], #1
  while (--i);
 80042ba:	428b      	cmp	r3, r1
 80042bc:	d1f9      	bne.n	80042b2 <chprintf.constprop.14+0x822>
 80042be:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
 80042c2:	e712      	b.n	80040ea <chprintf.constprop.14+0x65a>
      for (p = s; *p && (--precision >= 0); p++)
 80042c4:	2b00      	cmp	r3, #0
 80042c6:	d1f1      	bne.n	80042ac <chprintf.constprop.14+0x81c>
 80042c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80042cc:	9301      	str	r3, [sp, #4]
      filler = ' ';
 80042ce:	2520      	movs	r5, #32
 80042d0:	e67b      	b.n	8003fca <chprintf.constprop.14+0x53a>
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80042d2:	ed9f 7b29 	vldr	d7, [pc, #164]	; 8004378 <chprintf.constprop.14+0x8e8>
 80042d6:	4f2c      	ldr	r7, [pc, #176]	; (8004388 <chprintf.constprop.14+0x8f8>)
 80042d8:	970c      	str	r7, [sp, #48]	; 0x30
 80042da:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 80042de:	e50a      	b.n	8003cf6 <chprintf.constprop.14+0x266>
        *p++ = '-';
 80042e0:	232d      	movs	r3, #45	; 0x2d
 80042e2:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 80042e6:	ab12      	add	r3, sp, #72	; 0x48
        l = -l;
 80042e8:	4249      	negs	r1, r1
        *p++ = '-';
 80042ea:	f10d 0849 	add.w	r8, sp, #73	; 0x49
 80042ee:	9303      	str	r3, [sp, #12]
 80042f0:	e73a      	b.n	8004168 <chprintf.constprop.14+0x6d8>
  i = (int)(p + MAX_FILLER - q);
 80042f2:	4677      	mov	r7, lr
 80042f4:	e6ef      	b.n	80040d6 <chprintf.constprop.14+0x646>
 80042f6:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 80042fa:	eb03 000e 	add.w	r0, r3, lr
    *p++ = *q++;
 80042fe:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004302:	f802 1f01 	strb.w	r1, [r2, #1]!
  while (--i);
 8004306:	4298      	cmp	r0, r3
 8004308:	d1f9      	bne.n	80042fe <chprintf.constprop.14+0x86e>
 800430a:	e7b0      	b.n	800426e <chprintf.constprop.14+0x7de>
 800430c:	9a01      	ldr	r2, [sp, #4]
 800430e:	eb03 010e 	add.w	r1, r3, lr
 8004312:	f102 0801 	add.w	r8, r2, #1
    *p++ = *q++;
 8004316:	f813 2b01 	ldrb.w	r2, [r3], #1
 800431a:	f808 2f01 	strb.w	r2, [r8, #1]!
  while (--i);
 800431e:	4299      	cmp	r1, r3
 8004320:	d1f9      	bne.n	8004316 <chprintf.constprop.14+0x886>
 8004322:	e633      	b.n	8003f8c <chprintf.constprop.14+0x4fc>
 8004324:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 8004328:	eb03 000e 	add.w	r0, r3, lr
    *p++ = *q++;
 800432c:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004330:	f802 1f01 	strb.w	r1, [r2, #1]!
  while (--i);
 8004334:	4283      	cmp	r3, r0
 8004336:	d1f9      	bne.n	800432c <chprintf.constprop.14+0x89c>
 8004338:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
 800433c:	930d      	str	r3, [sp, #52]	; 0x34
 800433e:	e578      	b.n	8003e32 <chprintf.constprop.14+0x3a2>
  i = (int)(p + MAX_FILLER - q);
 8004340:	461a      	mov	r2, r3
 8004342:	f8cd e014 	str.w	lr, [sp, #20]
 8004346:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 800434a:	e534      	b.n	8003db6 <chprintf.constprop.14+0x326>
 800434c:	461a      	mov	r2, r3
 800434e:	e9cd e804 	strd	lr, r8, [sp, #16]
 8004352:	e75a      	b.n	800420a <chprintf.constprop.14+0x77a>
  *p++ = '.';
 8004354:	9904      	ldr	r1, [sp, #16]
  i = (int)(p + MAX_FILLER - q);
 8004356:	f8cd e014 	str.w	lr, [sp, #20]
 800435a:	461a      	mov	r2, r3
  *p++ = '.';
 800435c:	9106      	str	r1, [sp, #24]
 800435e:	e5e0      	b.n	8003f22 <chprintf.constprop.14+0x492>
 8004360:	9f04      	ldr	r7, [sp, #16]
 8004362:	e5fd      	b.n	8003f60 <chprintf.constprop.14+0x4d0>
  i = (int)(p + MAX_FILLER - q);
 8004364:	46f4      	mov	ip, lr
 8004366:	4640      	mov	r0, r8
 8004368:	e548      	b.n	8003dfc <chprintf.constprop.14+0x36c>
 800436a:	4647      	mov	r7, r8
 800436c:	e769      	b.n	8004242 <chprintf.constprop.14+0x7b2>
      for (p = s; *p && (--precision >= 0); p++)
 800436e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004372:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8004374:	2520      	movs	r5, #32
 8004376:	e62a      	b.n	8003fce <chprintf.constprop.14+0x53e>
 8004378:	00000000 	.word	0x00000000
 800437c:	41cdcd65 	.word	0x41cdcd65
 8004380:	cccccccd 	.word	0xcccccccd
 8004384:	0800e754 	.word	0x0800e754
 8004388:	05f5e100 	.word	0x05f5e100
 800438c:	00000000 	.word	0x00000000

08004390 <Thread2>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8004390:	4ca9      	ldr	r4, [pc, #676]	; (8004638 <Thread2+0x2a8>)
 8004392:	4aaa      	ldr	r2, [pc, #680]	; (800463c <Thread2+0x2ac>)
 8004394:	69a3      	ldr	r3, [r4, #24]
  chprintf((BaseSequentialStream*)&SD1,"Start Update\r\n");
 8004396:	49aa      	ldr	r1, [pc, #680]	; (8004640 <Thread2+0x2b0>)
 8004398:	48aa      	ldr	r0, [pc, #680]	; (8004644 <Thread2+0x2b4>)
 800439a:	4eab      	ldr	r6, [pc, #684]	; (8004648 <Thread2+0x2b8>)
 800439c:	f8df 82f4 	ldr.w	r8, [pc, #756]	; 8004694 <Thread2+0x304>
      rccDisableSPI2();
 80043a0:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 8004698 <Thread2+0x308>
static THD_FUNCTION(Thread2, arg) {
 80043a4:	b580      	push	{r7, lr}
 80043a6:	619a      	str	r2, [r3, #24]
  chprintf((BaseSequentialStream*)&SD1,"Start Update\r\n");
 80043a8:	f7ff fb72 	bl	8003a90 <chprintf.constprop.14>
 80043ac:	f106 0780 	add.w	r7, r6, #128	; 0x80
    blink = palReadPad(GPIOC,6);
 80043b0:	4ba6      	ldr	r3, [pc, #664]	; (800464c <Thread2+0x2bc>)
 80043b2:	691b      	ldr	r3, [r3, #16]
 80043b4:	2500      	movs	r5, #0
 80043b6:	f003 0a40 	and.w	sl, r3, #64	; 0x40
 80043ba:	f1ba 0f00 	cmp.w	sl, #0
 80043be:	d117      	bne.n	80043f0 <Thread2+0x60>
 80043c0:	48a3      	ldr	r0, [pc, #652]	; (8004650 <Thread2+0x2c0>)
 80043c2:	2280      	movs	r2, #128	; 0x80
 80043c4:	4428      	add	r0, r5
 80043c6:	21ff      	movs	r1, #255	; 0xff
 80043c8:	f005 ff52 	bl	800a270 <memset>
 80043cc:	3d80      	subs	r5, #128	; 0x80
      for (x=0;x<32;x++)
 80043ce:	f515 5f80 	cmn.w	r5, #4096	; 0x1000
 80043d2:	d1f2      	bne.n	80043ba <Thread2+0x2a>
      palSetPad(GPIOB,DC);
 80043d4:	4b9f      	ldr	r3, [pc, #636]	; (8004654 <Thread2+0x2c4>)
 80043d6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80043da:	831a      	strh	r2, [r3, #24]
 80043dc:	2320      	movs	r3, #32
 80043de:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80043e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80043e4:	b90b      	cbnz	r3, 80043ea <Thread2+0x5a>
 80043e6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80043e8:	b18b      	cbz	r3, 800440e <Thread2+0x7e>
    chSysHalt("SV#4");
 80043ea:	489b      	ldr	r0, [pc, #620]	; (8004658 <Thread2+0x2c8>)
 80043ec:	f7fc ffe0 	bl	80013b0 <chSysHalt>
 80043f0:	1b72      	subs	r2, r6, r5
 80043f2:	eb08 0005 	add.w	r0, r8, r5
 80043f6:	eba7 0c05 	sub.w	ip, r7, r5
	      pixel2 = (vbuf[x][y]&0xF0)>>4;
 80043fa:	f812 1f01 	ldrb.w	r1, [r2, #1]!
	      pixel = (vbuf[x][y]&0x0F)<<4;
 80043fe:	010b      	lsls	r3, r1, #4
		  vbuf2[31-x][128-y] = pixel|pixel2;
 8004400:	ea43 1311 	orr.w	r3, r3, r1, lsr #4
	  for (y=0;y<128;y++){
 8004404:	4562      	cmp	r2, ip
		  vbuf2[31-x][128-y] = pixel|pixel2;
 8004406:	f800 3d01 	strb.w	r3, [r0, #-1]!
	  for (y=0;y<128;y++){
 800440a:	d1f6      	bne.n	80043fa <Thread2+0x6a>
 800440c:	e7de      	b.n	80043cc <Thread2+0x3c>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800440e:	4d93      	ldr	r5, [pc, #588]	; (800465c <Thread2+0x2cc>)
 8004410:	782b      	ldrb	r3, [r5, #0]
  _dbg_enter_lock();
 8004412:	2201      	movs	r2, #1
 8004414:	3b01      	subs	r3, #1
 8004416:	4293      	cmp	r3, r2
 8004418:	6362      	str	r2, [r4, #52]	; 0x34
 800441a:	d902      	bls.n	8004422 <Thread2+0x92>
 800441c:	4890      	ldr	r0, [pc, #576]	; (8004660 <Thread2+0x2d0>)
 800441e:	f7fc ffc7 	bl	80013b0 <chSysHalt>
  spip->config = config;
 8004422:	4b90      	ldr	r3, [pc, #576]	; (8004664 <Thread2+0x2d4>)
 8004424:	606b      	str	r3, [r5, #4]
  spi_lld_start(spip);
 8004426:	4628      	mov	r0, r5
 8004428:	f7fd fc9a 	bl	8001d60 <spi_lld_start>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800442c:	6b22      	ldr	r2, [r4, #48]	; 0x30
  spip->state = SPI_READY;
 800442e:	2302      	movs	r3, #2
 8004430:	702b      	strb	r3, [r5, #0]
 8004432:	b9fa      	cbnz	r2, 8004474 <Thread2+0xe4>
 8004434:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004436:	2b00      	cmp	r3, #0
 8004438:	dd1c      	ble.n	8004474 <Thread2+0xe4>
 800443a:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 800443c:	6362      	str	r2, [r4, #52]	; 0x34
 800443e:	42a3      	cmp	r3, r4
 8004440:	d004      	beq.n	800444c <Thread2+0xbc>
 8004442:	69a2      	ldr	r2, [r4, #24]
 8004444:	689b      	ldr	r3, [r3, #8]
 8004446:	6892      	ldr	r2, [r2, #8]
 8004448:	429a      	cmp	r2, r3
 800444a:	d316      	bcc.n	800447a <Thread2+0xea>
 800444c:	2300      	movs	r3, #0
 800444e:	f383 8811 	msr	BASEPRI, r3
 8004452:	2320      	movs	r3, #32
 8004454:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004458:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800445a:	2b00      	cmp	r3, #0
 800445c:	d1c5      	bne.n	80043ea <Thread2+0x5a>
 800445e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8004460:	2900      	cmp	r1, #0
 8004462:	d1c2      	bne.n	80043ea <Thread2+0x5a>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8004464:	782a      	ldrb	r2, [r5, #0]
  _dbg_enter_lock();
 8004466:	2301      	movs	r3, #1
 8004468:	2a02      	cmp	r2, #2
 800446a:	6363      	str	r3, [r4, #52]	; 0x34
 800446c:	d008      	beq.n	8004480 <Thread2+0xf0>
 800446e:	487e      	ldr	r0, [pc, #504]	; (8004668 <Thread2+0x2d8>)
 8004470:	f7fc ff9e 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8004474:	487d      	ldr	r0, [pc, #500]	; (800466c <Thread2+0x2dc>)
 8004476:	f7fc ff9b 	bl	80013b0 <chSysHalt>
 800447a:	487d      	ldr	r0, [pc, #500]	; (8004670 <Thread2+0x2e0>)
 800447c:	f7fc ff98 	bl	80013b0 <chSysHalt>
  spiSelectI(spip);
 8004480:	6868      	ldr	r0, [r5, #4]
 8004482:	6822      	ldr	r2, [r4, #0]
 8004484:	e9d0 0c02 	ldrd	r0, ip, [r0, #8]
 8004488:	fa03 f30c 	lsl.w	r3, r3, ip
 800448c:	b29b      	uxth	r3, r3
 800448e:	42a2      	cmp	r2, r4
 8004490:	8343      	strh	r3, [r0, #26]
  _dbg_leave_lock();
 8004492:	6361      	str	r1, [r4, #52]	; 0x34
 8004494:	d004      	beq.n	80044a0 <Thread2+0x110>
 8004496:	69a3      	ldr	r3, [r4, #24]
 8004498:	6892      	ldr	r2, [r2, #8]
 800449a:	689b      	ldr	r3, [r3, #8]
 800449c:	4293      	cmp	r3, r2
 800449e:	d3ec      	bcc.n	800447a <Thread2+0xea>
 80044a0:	2300      	movs	r3, #0
 80044a2:	f383 8811 	msr	BASEPRI, r3
 80044a6:	2320      	movs	r3, #32
 80044a8:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80044ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80044ae:	2b00      	cmp	r3, #0
 80044b0:	d19b      	bne.n	80043ea <Thread2+0x5a>
 80044b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80044b4:	2b00      	cmp	r3, #0
 80044b6:	d198      	bne.n	80043ea <Thread2+0x5a>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80044b8:	782b      	ldrb	r3, [r5, #0]
  _dbg_enter_lock();
 80044ba:	2101      	movs	r1, #1
 80044bc:	2b02      	cmp	r3, #2
 80044be:	6361      	str	r1, [r4, #52]	; 0x34
 80044c0:	d002      	beq.n	80044c8 <Thread2+0x138>
 80044c2:	486c      	ldr	r0, [pc, #432]	; (8004674 <Thread2+0x2e4>)
 80044c4:	f7fc ff74 	bl	80013b0 <chSysHalt>
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80044c8:	e9d5 2308 	ldrd	r2, r3, [r5, #32]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80044cc:	6852      	ldr	r2, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80044ce:	f8d5 c02c 	ldr.w	ip, [r5, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80044d2:	4869      	ldr	r0, [pc, #420]	; (8004678 <Thread2+0x2e8>)
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80044d4:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80044d6:	f8d5 a028 	ldr.w	sl, [r5, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80044da:	60d0      	str	r0, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80044dc:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
  spiStartSendI(spip, n, txbuf);
 80044e0:	2003      	movs	r0, #3
 80044e2:	f8c2 e004 	str.w	lr, [r2, #4]
 80044e6:	7028      	strb	r0, [r5, #0]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80044e8:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80044ec:	f8c2 a000 	str.w	sl, [r2]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80044f0:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 800469c <Thread2+0x30c>
 80044f4:	f8c3 a00c 	str.w	sl, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80044f8:	f8c3 e004 	str.w	lr, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80044fc:	f8c3 c000 	str.w	ip, [r3]
  dmaStreamEnable(spip->dmarx);
 8004500:	f8d2 e000 	ldr.w	lr, [r2]
  chDbgAssert(*trp == NULL, "not NULL");
 8004504:	f8d5 c008 	ldr.w	ip, [r5, #8]
  return ch.rlist.current;
 8004508:	f8d4 a018 	ldr.w	sl, [r4, #24]
 800450c:	f04e 0e01 	orr.w	lr, lr, #1
 8004510:	f8c2 e000 	str.w	lr, [r2]
  dmaStreamEnable(spip->dmatx);
 8004514:	681a      	ldr	r2, [r3, #0]
 8004516:	f042 0201 	orr.w	r2, r2, #1
 800451a:	601a      	str	r2, [r3, #0]
 800451c:	f1bc 0f00 	cmp.w	ip, #0
 8004520:	d002      	beq.n	8004528 <Thread2+0x198>
 8004522:	4856      	ldr	r0, [pc, #344]	; (800467c <Thread2+0x2ec>)
 8004524:	f7fc ff44 	bl	80013b0 <chSysHalt>
  tp->u.wttrp = trp;
 8004528:	4a55      	ldr	r2, [pc, #340]	; (8004680 <Thread2+0x2f0>)
 800452a:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800452e:	6b23      	ldr	r3, [r4, #48]	; 0x30
  *trp = tp;
 8004530:	f8c5 a008 	str.w	sl, [r5, #8]
 8004534:	2b00      	cmp	r3, #0
 8004536:	d153      	bne.n	80045e0 <Thread2+0x250>
 8004538:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800453a:	2b00      	cmp	r3, #0
 800453c:	dd50      	ble.n	80045e0 <Thread2+0x250>
  thread_t *tp = tqp->next;
 800453e:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8004540:	f88a 0020 	strb.w	r0, [sl, #32]
  tqp->next             = tp->queue.next;
 8004544:	6818      	ldr	r0, [r3, #0]
 8004546:	6020      	str	r0, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004548:	6044      	str	r4, [r0, #4]
  currp->state = CH_STATE_CURRENT;
 800454a:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800454e:	8f20      	ldrh	r0, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8004550:	61a3      	str	r3, [r4, #24]
 8004552:	07c3      	lsls	r3, r0, #31
 8004554:	d40e      	bmi.n	8004574 <Thread2+0x1e4>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004556:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8004558:	7803      	ldrb	r3, [r0, #0]
 800455a:	f361 0302 	bfi	r3, r1, #0, #3
 800455e:	7003      	strb	r3, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004560:	f89a 1020 	ldrb.w	r1, [sl, #32]
 8004564:	f361 03c7 	bfi	r3, r1, #3, #5
 8004568:	7003      	strb	r3, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800456a:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800456c:	e9c0 3202 	strd	r3, r2, [r0, #8]
    trace_next();
 8004570:	f7fc fefe 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004574:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 8004578:	f8da 301c 	ldr.w	r3, [sl, #28]
 800457c:	3a64      	subs	r2, #100	; 0x64
 800457e:	4293      	cmp	r3, r2
 8004580:	d82b      	bhi.n	80045da <Thread2+0x24a>
 8004582:	4651      	mov	r1, sl
 8004584:	69a0      	ldr	r0, [r4, #24]
 8004586:	f7fb fe9f 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800458a:	6b22      	ldr	r2, [r4, #48]	; 0x30
  return currp->u.rdymsg;
 800458c:	69a1      	ldr	r1, [r4, #24]
 800458e:	2a00      	cmp	r2, #0
 8004590:	f47f af70 	bne.w	8004474 <Thread2+0xe4>
 8004594:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004596:	2b00      	cmp	r3, #0
 8004598:	f77f af6c 	ble.w	8004474 <Thread2+0xe4>
 800459c:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 800459e:	6362      	str	r2, [r4, #52]	; 0x34
 80045a0:	42a3      	cmp	r3, r4
 80045a2:	d004      	beq.n	80045ae <Thread2+0x21e>
 80045a4:	688a      	ldr	r2, [r1, #8]
 80045a6:	689b      	ldr	r3, [r3, #8]
 80045a8:	429a      	cmp	r2, r3
 80045aa:	f4ff af66 	bcc.w	800447a <Thread2+0xea>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80045ae:	2300      	movs	r3, #0
 80045b0:	f383 8811 	msr	BASEPRI, r3
 80045b4:	2320      	movs	r3, #32
 80045b6:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80045ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80045bc:	2b00      	cmp	r3, #0
 80045be:	f47f af14 	bne.w	80043ea <Thread2+0x5a>
 80045c2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80045c4:	2900      	cmp	r1, #0
 80045c6:	f47f af10 	bne.w	80043ea <Thread2+0x5a>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80045ca:	782a      	ldrb	r2, [r5, #0]
  _dbg_enter_lock();
 80045cc:	2301      	movs	r3, #1
 80045ce:	2a02      	cmp	r2, #2
 80045d0:	6363      	str	r3, [r4, #52]	; 0x34
 80045d2:	d008      	beq.n	80045e6 <Thread2+0x256>
 80045d4:	482b      	ldr	r0, [pc, #172]	; (8004684 <Thread2+0x2f4>)
 80045d6:	f7fc feeb 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 80045da:	482b      	ldr	r0, [pc, #172]	; (8004688 <Thread2+0x2f8>)
 80045dc:	f7fc fee8 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 80045e0:	482a      	ldr	r0, [pc, #168]	; (800468c <Thread2+0x2fc>)
 80045e2:	f7fc fee5 	bl	80013b0 <chSysHalt>
  spiUnselectI(spip);
 80045e6:	6868      	ldr	r0, [r5, #4]
 80045e8:	6822      	ldr	r2, [r4, #0]
 80045ea:	e9d0 0c02 	ldrd	r0, ip, [r0, #8]
 80045ee:	fa03 f30c 	lsl.w	r3, r3, ip
 80045f2:	b29b      	uxth	r3, r3
 80045f4:	42a2      	cmp	r2, r4
 80045f6:	8303      	strh	r3, [r0, #24]
  _dbg_leave_lock();
 80045f8:	6361      	str	r1, [r4, #52]	; 0x34
 80045fa:	d005      	beq.n	8004608 <Thread2+0x278>
 80045fc:	69a3      	ldr	r3, [r4, #24]
 80045fe:	6892      	ldr	r2, [r2, #8]
 8004600:	689b      	ldr	r3, [r3, #8]
 8004602:	4293      	cmp	r3, r2
 8004604:	f4ff af39 	bcc.w	800447a <Thread2+0xea>
 8004608:	2300      	movs	r3, #0
 800460a:	f383 8811 	msr	BASEPRI, r3
 800460e:	2320      	movs	r3, #32
 8004610:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004614:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004616:	2b00      	cmp	r3, #0
 8004618:	f47f aee7 	bne.w	80043ea <Thread2+0x5a>
 800461c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800461e:	2a00      	cmp	r2, #0
 8004620:	f47f aee3 	bne.w	80043ea <Thread2+0x5a>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8004624:	782b      	ldrb	r3, [r5, #0]
  _dbg_enter_lock();
 8004626:	2001      	movs	r0, #1
 8004628:	1e59      	subs	r1, r3, #1
 800462a:	4281      	cmp	r1, r0
 800462c:	6360      	str	r0, [r4, #52]	; 0x34
 800462e:	d937      	bls.n	80046a0 <Thread2+0x310>
 8004630:	4817      	ldr	r0, [pc, #92]	; (8004690 <Thread2+0x300>)
 8004632:	f7fc febd 	bl	80013b0 <chSysHalt>
 8004636:	bf00      	nop
 8004638:	2000159c 	.word	0x2000159c
 800463c:	0800e110 	.word	0x0800e110
 8004640:	0800e120 	.word	0x0800e120
 8004644:	200013d8 	.word	0x200013d8
 8004648:	20002613 	.word	0x20002613
 800464c:	48000800 	.word	0x48000800
 8004650:	20004595 	.word	0x20004595
 8004654:	48000400 	.word	0x48000400
 8004658:	0800e704 	.word	0x0800e704
 800465c:	200014c8 	.word	0x200014c8
 8004660:	0800e3c0 	.word	0x0800e3c0
 8004664:	0801d9bc 	.word	0x0801d9bc
 8004668:	0800e400 	.word	0x0800e400
 800466c:	0800e72c 	.word	0x0800e72c
 8004670:	0800e1cc 	.word	0x0800e1cc
 8004674:	0800e52c 	.word	0x0800e52c
 8004678:	20001ffc 	.word	0x20001ffc
 800467c:	0800e348 	.word	0x0800e348
 8004680:	200014d0 	.word	0x200014d0
 8004684:	0800e428 	.word	0x0800e428
 8004688:	0800e71c 	.word	0x0800e71c
 800468c:	0800e714 	.word	0x0800e714
 8004690:	0800e3e0 	.word	0x0800e3e0
 8004694:	20004615 	.word	0x20004615
 8004698:	40021000 	.word	0x40021000
 800469c:	20003614 	.word	0x20003614
  if (spip->state == SPI_READY) {
 80046a0:	2b02      	cmp	r3, #2
 80046a2:	d112      	bne.n	80046ca <Thread2+0x33a>
    dmaStreamRelease(spip->dmarx);
 80046a4:	e9d5 3007 	ldrd	r3, r0, [r5, #28]
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 80046a8:	6819      	ldr	r1, [r3, #0]
 80046aa:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 80046ae:	6019      	str	r1, [r3, #0]
    spip->spi->CR1  = 0;
 80046b0:	601a      	str	r2, [r3, #0]
    spip->spi->CR2  = 0;
 80046b2:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 80046b4:	f7fd faa4 	bl	8001c00 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 80046b8:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80046ba:	f7fd faa1 	bl	8001c00 <dmaStreamRelease>
      rccDisableSPI2();
 80046be:	f8d9 301c 	ldr.w	r3, [r9, #28]
 80046c2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80046c6:	f8c9 301c 	str.w	r3, [r9, #28]
  spip->config = NULL;
 80046ca:	2300      	movs	r3, #0
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80046cc:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80046ce:	606b      	str	r3, [r5, #4]
  spip->state  = SPI_STOP;
 80046d0:	2301      	movs	r3, #1
 80046d2:	702b      	strb	r3, [r5, #0]
 80046d4:	2a00      	cmp	r2, #0
 80046d6:	f47f aecd 	bne.w	8004474 <Thread2+0xe4>
 80046da:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80046dc:	2b00      	cmp	r3, #0
 80046de:	f77f aec9 	ble.w	8004474 <Thread2+0xe4>
 80046e2:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 80046e4:	6362      	str	r2, [r4, #52]	; 0x34
 80046e6:	42a3      	cmp	r3, r4
 80046e8:	d005      	beq.n	80046f6 <Thread2+0x366>
 80046ea:	69a2      	ldr	r2, [r4, #24]
 80046ec:	689b      	ldr	r3, [r3, #8]
 80046ee:	6892      	ldr	r2, [r2, #8]
 80046f0:	429a      	cmp	r2, r3
 80046f2:	f4ff aec2 	bcc.w	800447a <Thread2+0xea>
 80046f6:	2300      	movs	r3, #0
 80046f8:	f383 8811 	msr	BASEPRI, r3
 80046fc:	2320      	movs	r3, #32
 80046fe:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004702:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004704:	2b00      	cmp	r3, #0
 8004706:	f47f ae70 	bne.w	80043ea <Thread2+0x5a>
 800470a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800470c:	2b00      	cmp	r3, #0
 800470e:	f47f ae6c 	bne.w	80043ea <Thread2+0x5a>
  _dbg_enter_lock();
 8004712:	2301      	movs	r3, #1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8004714:	210a      	movs	r1, #10
 8004716:	2008      	movs	r0, #8
 8004718:	6363      	str	r3, [r4, #52]	; 0x34
 800471a:	f7fe fa41 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800471e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004720:	2a00      	cmp	r2, #0
 8004722:	f47f aea7 	bne.w	8004474 <Thread2+0xe4>
 8004726:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004728:	2b00      	cmp	r3, #0
 800472a:	f77f aea3 	ble.w	8004474 <Thread2+0xe4>
 800472e:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8004730:	6362      	str	r2, [r4, #52]	; 0x34
 8004732:	42a3      	cmp	r3, r4
 8004734:	d004      	beq.n	8004740 <Thread2+0x3b0>
 8004736:	69a2      	ldr	r2, [r4, #24]
 8004738:	689b      	ldr	r3, [r3, #8]
 800473a:	6892      	ldr	r2, [r2, #8]
 800473c:	429a      	cmp	r2, r3
 800473e:	d303      	bcc.n	8004748 <Thread2+0x3b8>
 8004740:	2300      	movs	r3, #0
 8004742:	f383 8811 	msr	BASEPRI, r3
 8004746:	e633      	b.n	80043b0 <Thread2+0x20>
 8004748:	4801      	ldr	r0, [pc, #4]	; (8004750 <Thread2+0x3c0>)
 800474a:	f7fc fe31 	bl	80013b0 <chSysHalt>
 800474e:	bf00      	nop
 8004750:	0800e1e4 	.word	0x0800e1e4
	...

08004760 <Thread7>:
	}
}


static THD_WORKING_AREA(waThread7, 128);
static THD_FUNCTION(Thread7, arg) {
 8004760:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8004764:	4da6      	ldr	r5, [pc, #664]	; (8004a00 <Thread7+0x2a0>)
 8004766:	4fa7      	ldr	r7, [pc, #668]	; (8004a04 <Thread7+0x2a4>)
    while (TRUE)
	{
	    // the skip is because the way I have it hooked up right now
	    // causes it to read whatever we send.
	    savedvalue = *flash2;
	    currentvalue = lifetimeRain*100;
 8004768:	ed9f 8aa7 	vldr	s16, [pc, #668]	; 8004a08 <Thread7+0x2a8>
	    savedvalue = *flash2;
 800476c:	4ea7      	ldr	r6, [pc, #668]	; (8004a0c <Thread7+0x2ac>)
    if (FLASH->CR & FLASH_CR_LOCK){
 800476e:	4ca8      	ldr	r4, [pc, #672]	; (8004a10 <Thread7+0x2b0>)
	FLASH->KEYR = 0x45670123;
 8004770:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 8004a40 <Thread7+0x2e0>
	FLASH->KEYR = 0xCDEF89AB;
 8004774:	f8df 82cc 	ldr.w	r8, [pc, #716]	; 8004a44 <Thread7+0x2e4>
 8004778:	f8df a2cc 	ldr.w	sl, [pc, #716]	; 8004a48 <Thread7+0x2e8>
static THD_FUNCTION(Thread7, arg) {
 800477c:	b089      	sub	sp, #36	; 0x24
	    currentvalue = lifetimeRain*100;
 800477e:	edd7 7a00 	vldr	s15, [r7]
	    if (currentvalue != savedvalue)
 8004782:	8832      	ldrh	r2, [r6, #0]
	    currentvalue = lifetimeRain*100;
 8004784:	ee67 7a88 	vmul.f32	s15, s15, s16
 8004788:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800478c:	ee17 3a90 	vmov	r3, s15
 8004790:	b29b      	uxth	r3, r3
	    if (currentvalue != savedvalue)
 8004792:	429a      	cmp	r2, r3
 8004794:	d139      	bne.n	800480a <Thread7+0xaa>
 8004796:	2320      	movs	r3, #32
 8004798:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800479c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800479e:	b90b      	cbnz	r3, 80047a4 <Thread7+0x44>
 80047a0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80047a2:	b113      	cbz	r3, 80047aa <Thread7+0x4a>
    chSysHalt("SV#4");
 80047a4:	489b      	ldr	r0, [pc, #620]	; (8004a14 <Thread7+0x2b4>)
 80047a6:	f7fc fe03 	bl	80013b0 <chSysHalt>
  return (systime_t)STM32_ST_TIM->CNT;
 80047aa:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
    chVTDoSetI(&vt, timeout, wakeup, currp);
 80047ae:	e9d5 1006 	ldrd	r1, r0, [r5, #24]
 80047b2:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
 80047b6:	9201      	str	r2, [sp, #4]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80047b8:	4a97      	ldr	r2, [pc, #604]	; (8004a18 <Thread7+0x2b8>)
  vtp->func = vtfunc;
 80047ba:	f8df b290 	ldr.w	fp, [pc, #656]	; 8004a4c <Thread7+0x2ec>
  vtp->par = par;
 80047be:	9107      	str	r1, [sp, #28]
  _dbg_enter_lock();
 80047c0:	f04f 0e01 	mov.w	lr, #1
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80047c4:	4290      	cmp	r0, r2
 80047c6:	f8c5 e034 	str.w	lr, [r5, #52]	; 0x34
  vtp->func = vtfunc;
 80047ca:	f8cd b018 	str.w	fp, [sp, #24]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80047ce:	f000 80a8 	beq.w	8004922 <Thread7+0x1c2>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80047d2:	f8d5 b028 	ldr.w	fp, [r5, #40]	; 0x28
  return (sysinterval_t)((systime_t)(end - start));
 80047d6:	9a01      	ldr	r2, [sp, #4]
 80047d8:	eba2 0c0b 	sub.w	ip, r2, fp
 80047dc:	eb1c 0c0a 	adds.w	ip, ip, sl
 80047e0:	bf28      	it	cs
 80047e2:	4673      	movcs	r3, lr
 80047e4:	f8d0 e008 	ldr.w	lr, [r0, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80047e8:	2b00      	cmp	r3, #0
 80047ea:	d13f      	bne.n	800486c <Thread7+0x10c>
    else if (delta < p->delta) {
 80047ec:	45f4      	cmp	ip, lr
 80047ee:	f0c0 80b1 	bcc.w	8004954 <Thread7+0x1f4>
 80047f2:	f10d 0b0c 	add.w	fp, sp, #12
  while (p->delta < delta) {
 80047f6:	6883      	ldr	r3, [r0, #8]
 80047f8:	459c      	cmp	ip, r3
 80047fa:	d93b      	bls.n	8004874 <Thread7+0x114>
    chDbgAssert(p != vtp, "timer already armed");
 80047fc:	4558      	cmp	r0, fp
 80047fe:	f000 808d 	beq.w	800491c <Thread7+0x1bc>
    p = p->next;
 8004802:	6800      	ldr	r0, [r0, #0]
    delta -= p->delta;
 8004804:	ebac 0c03 	sub.w	ip, ip, r3
 8004808:	e7f5      	b.n	80047f6 <Thread7+0x96>
    if (FLASH->CR & FLASH_CR_LOCK){
 800480a:	6922      	ldr	r2, [r4, #16]
 800480c:	0610      	lsls	r0, r2, #24
	FLASH->KEYR = 0x45670123;
 800480e:	bf44      	itt	mi
 8004810:	f8c4 9004 	strmi.w	r9, [r4, #4]
	FLASH->KEYR = 0xCDEF89AB;
 8004814:	f8c4 8004 	strmi.w	r8, [r4, #4]
    FLASH->CR |= FLASH_CR_PER;             // set page erase
 8004818:	6922      	ldr	r2, [r4, #16]
 800481a:	f042 0202 	orr.w	r2, r2, #2
 800481e:	6122      	str	r2, [r4, #16]
    FLASH->AR = flash;                     // set page to flash
 8004820:	6166      	str	r6, [r4, #20]
    FLASH->CR |= FLASH_CR_STRT;            // start erasing
 8004822:	6922      	ldr	r2, [r4, #16]
 8004824:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004828:	6122      	str	r2, [r4, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 800482a:	68e2      	ldr	r2, [r4, #12]
 800482c:	07d1      	lsls	r1, r2, #31
 800482e:	d4fc      	bmi.n	800482a <Thread7+0xca>
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 8004830:	68e2      	ldr	r2, [r4, #12]
    *flash = value;                        // actually write the value
 8004832:	8033      	strh	r3, [r6, #0]
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 8004834:	f042 0220 	orr.w	r2, r2, #32
 8004838:	60e2      	str	r2, [r4, #12]
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PER)); // found note online that you must
 800483a:	6922      	ldr	r2, [r4, #16]
 800483c:	f022 0202 	bic.w	r2, r2, #2
 8004840:	6122      	str	r2, [r4, #16]
    SET_BIT(FLASH->CR, (FLASH_CR_PG));     // we are already unlocked, trying
 8004842:	6922      	ldr	r2, [r4, #16]
 8004844:	f042 0201 	orr.w	r2, r2, #1
 8004848:	6122      	str	r2, [r4, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 800484a:	68e2      	ldr	r2, [r4, #12]
 800484c:	07d2      	lsls	r2, r2, #31
 800484e:	d4fc      	bmi.n	800484a <Thread7+0xea>
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 8004850:	6922      	ldr	r2, [r4, #16]
		{
		    write_flash(currentvalue,flash2);
		    chprintf((BaseSequentialStream*)&SD1,"!!!writing flash,%d,%d\r\n",currentvalue,*flash2);
 8004852:	4972      	ldr	r1, [pc, #456]	; (8004a1c <Thread7+0x2bc>)
 8004854:	4872      	ldr	r0, [pc, #456]	; (8004a20 <Thread7+0x2c0>)
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 8004856:	f022 0201 	bic.w	r2, r2, #1
 800485a:	6122      	str	r2, [r4, #16]
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 800485c:	68e2      	ldr	r2, [r4, #12]
 800485e:	f042 0220 	orr.w	r2, r2, #32
 8004862:	60e2      	str	r2, [r4, #12]
		    chprintf((BaseSequentialStream*)&SD1,"!!!writing flash,%d,%d\r\n",currentvalue,*flash2);
 8004864:	461a      	mov	r2, r3
 8004866:	f7ff f913 	bl	8003a90 <chprintf.constprop.14>
 800486a:	e794      	b.n	8004796 <Thread7+0x36>
      p = p->next;
 800486c:	6800      	ldr	r0, [r0, #0]
      delta -= p->delta;
 800486e:	ebac 0c0e 	sub.w	ip, ip, lr
 8004872:	e7be      	b.n	80047f2 <Thread7+0x92>
  vtp->prev = vtp->next->prev;
 8004874:	6843      	ldr	r3, [r0, #4]
 8004876:	e9cd 0303 	strd	r0, r3, [sp, #12]
  vtp->prev->next = vtp;
 800487a:	f8c3 b000 	str.w	fp, [r3]
  p->prev = vtp;
 800487e:	f8c0 b004 	str.w	fp, [r0, #4]
  vtp->delta = delta;
 8004882:	f8cd c014 	str.w	ip, [sp, #20]
  p->delta -= delta;
 8004886:	6883      	ldr	r3, [r0, #8]
 8004888:	eba3 030c 	sub.w	r3, r3, ip
  ch.vtlist.delta = (sysinterval_t)-1;
 800488c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  p->delta -= delta;
 8004890:	6083      	str	r3, [r0, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8004892:	f8c5 c024 	str.w	ip, [r5, #36]	; 0x24
  thread_t *tp = tqp->next;
 8004896:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 8004898:	2008      	movs	r0, #8
 800489a:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 800489e:	6818      	ldr	r0, [r3, #0]
 80048a0:	6028      	str	r0, [r5, #0]
  currp->state = CH_STATE_CURRENT;
 80048a2:	f04f 0c01 	mov.w	ip, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80048a6:	6045      	str	r5, [r0, #4]
 80048a8:	f883 c020 	strb.w	ip, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80048ac:	8f28      	ldrh	r0, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 80048ae:	61ab      	str	r3, [r5, #24]
 80048b0:	07c3      	lsls	r3, r0, #31
 80048b2:	d55d      	bpl.n	8004970 <Thread7+0x210>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80048b4:	f3ef 8009 	mrs	r0, PSP
  chSysSwitch(currp, otp);
 80048b8:	69cb      	ldr	r3, [r1, #28]
 80048ba:	3864      	subs	r0, #100	; 0x64
 80048bc:	4283      	cmp	r3, r0
 80048be:	d854      	bhi.n	800496a <Thread7+0x20a>
 80048c0:	69a8      	ldr	r0, [r5, #24]
 80048c2:	f7fb fd01 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80048c6:	6b29      	ldr	r1, [r5, #48]	; 0x30
 80048c8:	2900      	cmp	r1, #0
 80048ca:	db65      	blt.n	8004998 <Thread7+0x238>
 80048cc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80048ce:	2b00      	cmp	r3, #0
 80048d0:	dd62      	ble.n	8004998 <Thread7+0x238>
    if (chVTIsArmedI(&vt)) {
 80048d2:	9b06      	ldr	r3, [sp, #24]
 80048d4:	b19b      	cbz	r3, 80048fe <Thread7+0x19e>
  if (ch.vtlist.next != vtp) {
 80048d6:	69eb      	ldr	r3, [r5, #28]
 80048d8:	9803      	ldr	r0, [sp, #12]
 80048da:	455b      	cmp	r3, fp
 80048dc:	d06b      	beq.n	80049b6 <Thread7+0x256>
    vtp->prev->next = vtp->next;
 80048de:	f8dd c010 	ldr.w	ip, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80048e2:	4a4d      	ldr	r2, [pc, #308]	; (8004a18 <Thread7+0x2b8>)
    vtp->prev->next = vtp->next;
 80048e4:	f8cc 0000 	str.w	r0, [ip]
    vtp->next->prev = vtp->prev;
 80048e8:	9b03      	ldr	r3, [sp, #12]
    vtp->func = NULL;
 80048ea:	2000      	movs	r0, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80048ec:	4293      	cmp	r3, r2
    vtp->next->prev = vtp->prev;
 80048ee:	f8c3 c004 	str.w	ip, [r3, #4]
    vtp->func = NULL;
 80048f2:	9006      	str	r0, [sp, #24]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80048f4:	d003      	beq.n	80048fe <Thread7+0x19e>
      vtp->next->delta += vtp->delta;
 80048f6:	689a      	ldr	r2, [r3, #8]
 80048f8:	9805      	ldr	r0, [sp, #20]
 80048fa:	4402      	add	r2, r0
 80048fc:	609a      	str	r2, [r3, #8]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80048fe:	2900      	cmp	r1, #0
 8004900:	d153      	bne.n	80049aa <Thread7+0x24a>
 8004902:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 8004904:	6369      	str	r1, [r5, #52]	; 0x34
 8004906:	42ab      	cmp	r3, r5
  return currp->u.rdymsg;
 8004908:	69aa      	ldr	r2, [r5, #24]
 800490a:	d003      	beq.n	8004914 <Thread7+0x1b4>
 800490c:	6892      	ldr	r2, [r2, #8]
 800490e:	689b      	ldr	r3, [r3, #8]
 8004910:	429a      	cmp	r2, r3
 8004912:	d34d      	bcc.n	80049b0 <Thread7+0x250>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004914:	2300      	movs	r3, #0
 8004916:	f383 8811 	msr	BASEPRI, r3
 800491a:	e730      	b.n	800477e <Thread7+0x1e>
    chDbgAssert(p != vtp, "timer already armed");
 800491c:	4841      	ldr	r0, [pc, #260]	; (8004a24 <Thread7+0x2c4>)
 800491e:	f7fc fd47 	bl	80013b0 <chSysHalt>
      vtp->delta = delay;
 8004922:	f8cd a014 	str.w	sl, [sp, #20]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004926:	f8dc 300c 	ldr.w	r3, [ip, #12]
      ch.vtlist.lasttime = now;
 800492a:	9a01      	ldr	r2, [sp, #4]
 800492c:	62aa      	str	r2, [r5, #40]	; 0x28
      ch.vtlist.next = vtp;
 800492e:	f10d 0b0c 	add.w	fp, sp, #12
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8004932:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8004936:	e9cd 0003 	strd	r0, r0, [sp, #12]
      ch.vtlist.prev = vtp;
 800493a:	e9c5 bb07 	strd	fp, fp, [r5, #28]
 800493e:	d12e      	bne.n	800499e <Thread7+0x23e>
  return systime + (systime_t)interval;
 8004940:	9a01      	ldr	r2, [sp, #4]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004942:	2002      	movs	r0, #2
 8004944:	4452      	add	r2, sl
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004946:	f8cc 2034 	str.w	r2, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800494a:	f8cc 3010 	str.w	r3, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800494e:	f8cc 000c 	str.w	r0, [ip, #12]
 8004952:	e7a0      	b.n	8004896 <Thread7+0x136>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004954:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 8004958:	f8de 300c 	ldr.w	r3, [lr, #12]
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800495c:	079b      	lsls	r3, r3, #30
 800495e:	d521      	bpl.n	80049a4 <Thread7+0x244>
 8004960:	eb0b 030c 	add.w	r3, fp, ip
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004964:	f8ce 3034 	str.w	r3, [lr, #52]	; 0x34
 8004968:	e743      	b.n	80047f2 <Thread7+0x92>
  chSysSwitch(currp, otp);
 800496a:	482f      	ldr	r0, [pc, #188]	; (8004a28 <Thread7+0x2c8>)
 800496c:	f7fc fd20 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004970:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004972:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004976:	7803      	ldrb	r3, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004978:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800497a:	f36c 0302 	bfi	r3, ip, #0, #3
 800497e:	7003      	strb	r3, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004980:	f891 c020 	ldrb.w	ip, [r1, #32]
 8004984:	f36c 03c7 	bfi	r3, ip, #3, #5
 8004988:	7003      	strb	r3, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800498a:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800498c:	e9c0 3e02 	strd	r3, lr, [r0, #8]
    trace_next();
 8004990:	f7fc fcee 	bl	8001370 <trace_next>
 8004994:	9901      	ldr	r1, [sp, #4]
 8004996:	e78d      	b.n	80048b4 <Thread7+0x154>
    chSysHalt("SV#10");
 8004998:	4824      	ldr	r0, [pc, #144]	; (8004a2c <Thread7+0x2cc>)
 800499a:	f7fc fd09 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800499e:	4824      	ldr	r0, [pc, #144]	; (8004a30 <Thread7+0x2d0>)
 80049a0:	f7fc fd06 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80049a4:	4823      	ldr	r0, [pc, #140]	; (8004a34 <Thread7+0x2d4>)
 80049a6:	f7fc fd03 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 80049aa:	4823      	ldr	r0, [pc, #140]	; (8004a38 <Thread7+0x2d8>)
 80049ac:	f7fc fd00 	bl	80013b0 <chSysHalt>
 80049b0:	4822      	ldr	r0, [pc, #136]	; (8004a3c <Thread7+0x2dc>)
 80049b2:	f7fc fcfd 	bl	80013b0 <chSysHalt>
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80049b6:	4a18      	ldr	r2, [pc, #96]	; (8004a18 <Thread7+0x2b8>)
  ch.vtlist.next = vtp->next;
 80049b8:	61e8      	str	r0, [r5, #28]
  vtp->func = NULL;
 80049ba:	2300      	movs	r3, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80049bc:	4290      	cmp	r0, r2
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80049be:	6042      	str	r2, [r0, #4]
  vtp->func = NULL;
 80049c0:	9306      	str	r3, [sp, #24]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80049c2:	d018      	beq.n	80049f6 <Thread7+0x296>
  ch.vtlist.next->delta += vtp->delta;
 80049c4:	9b05      	ldr	r3, [sp, #20]
 80049c6:	6882      	ldr	r2, [r0, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80049c8:	f8d5 c028 	ldr.w	ip, [r5, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 80049cc:	441a      	add	r2, r3
  return (systime_t)STM32_ST_TIM->CNT;
 80049ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80049d2:	6082      	str	r2, [r0, #8]
 80049d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80049d6:	eba3 030c 	sub.w	r3, r3, ip
  if (nowdelta >= ch.vtlist.next->delta) {
 80049da:	429a      	cmp	r2, r3
 80049dc:	d98f      	bls.n	80048fe <Thread7+0x19e>
  delta = ch.vtlist.next->delta - nowdelta;
 80049de:	1ad0      	subs	r0, r2, r3
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80049e0:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80049e2:	bf98      	it	ls
 80049e4:	1c9a      	addls	r2, r3, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80049e6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 80049ea:	4462      	add	r2, ip
 80049ec:	68d8      	ldr	r0, [r3, #12]
 80049ee:	0780      	lsls	r0, r0, #30
 80049f0:	d5d8      	bpl.n	80049a4 <Thread7+0x244>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80049f2:	635a      	str	r2, [r3, #52]	; 0x34
 80049f4:	e783      	b.n	80048fe <Thread7+0x19e>
  STM32_ST_TIM->DIER = 0;
 80049f6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80049fa:	60d3      	str	r3, [r2, #12]
 80049fc:	e77f      	b.n	80048fe <Thread7+0x19e>
 80049fe:	bf00      	nop
 8004a00:	2000159c 	.word	0x2000159c
 8004a04:	2000200c 	.word	0x2000200c
 8004a08:	42c80000 	.word	0x42c80000
 8004a0c:	0803e800 	.word	0x0803e800
 8004a10:	40022000 	.word	0x40022000
 8004a14:	0800e704 	.word	0x0800e704
 8004a18:	200015b8 	.word	0x200015b8
 8004a1c:	0800e198 	.word	0x0800e198
 8004a20:	200013d8 	.word	0x200013d8
 8004a24:	0800e264 	.word	0x0800e264
 8004a28:	0800e71c 	.word	0x0800e71c
 8004a2c:	0800e70c 	.word	0x0800e70c
 8004a30:	0800e38c 	.word	0x0800e38c
 8004a34:	0800e3cc 	.word	0x0800e3cc
 8004a38:	0800e72c 	.word	0x0800e72c
 8004a3c:	0800e1e4 	.word	0x0800e1e4
 8004a40:	45670123 	.word	0x45670123
 8004a44:	cdef89ab 	.word	0xcdef89ab
 8004a48:	02255100 	.word	0x02255100
 8004a4c:	080016d1 	.word	0x080016d1

08004a50 <Thread6>:
static THD_FUNCTION(Thread6, arg) {
 8004a50:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8004a54:	4ca3      	ldr	r4, [pc, #652]	; (8004ce4 <Thread6+0x294>)
    return (rainTotal/100.0)*6.0;
 8004a56:	4fa4      	ldr	r7, [pc, #656]	; (8004ce8 <Thread6+0x298>)
 8004a58:	f8df 92c0 	ldr.w	r9, [pc, #704]	; 8004d1c <Thread6+0x2cc>
 8004a5c:	4da3      	ldr	r5, [pc, #652]	; (8004cec <Thread6+0x29c>)
    chprintf((BaseSequentialStream*)&SD1,"rainTotal %d \r\n",rainTotal);
 8004a5e:	f8df 82c0 	ldr.w	r8, [pc, #704]	; 8004d20 <Thread6+0x2d0>
static THD_FUNCTION(Thread6, arg) {
 8004a62:	b089      	sub	sp, #36	; 0x24
    return (rainTotal/100.0)*6.0;
 8004a64:	2600      	movs	r6, #0
	rainTotal += rainHistory[x];
 8004a66:	7861      	ldrb	r1, [r4, #1]
 8004a68:	7822      	ldrb	r2, [r4, #0]
 8004a6a:	78a3      	ldrb	r3, [r4, #2]
 8004a6c:	f894 c003 	ldrb.w	ip, [r4, #3]
 8004a70:	7920      	ldrb	r0, [r4, #4]
 8004a72:	f894 a009 	ldrb.w	sl, [r4, #9]
 8004a76:	440a      	add	r2, r1
 8004a78:	4413      	add	r3, r2
 8004a7a:	449c      	add	ip, r3
 8004a7c:	7963      	ldrb	r3, [r4, #5]
 8004a7e:	79a1      	ldrb	r1, [r4, #6]
 8004a80:	79e2      	ldrb	r2, [r4, #7]
 8004a82:	4460      	add	r0, ip
 8004a84:	4403      	add	r3, r0
 8004a86:	4419      	add	r1, r3
 8004a88:	7a23      	ldrb	r3, [r4, #8]
    chprintf((BaseSequentialStream*)&SD1,"rainTotal %d \r\n",rainTotal);
 8004a8a:	4899      	ldr	r0, [pc, #612]	; (8004cf0 <Thread6+0x2a0>)
	rainTotal += rainHistory[x];
 8004a8c:	440a      	add	r2, r1
 8004a8e:	4413      	add	r3, r2
 8004a90:	449a      	add	sl, r3
    chprintf((BaseSequentialStream*)&SD1,"rainTotal %d \r\n",rainTotal);
 8004a92:	4652      	mov	r2, sl
 8004a94:	4641      	mov	r1, r8
 8004a96:	f7fe fffb 	bl	8003a90 <chprintf.constprop.14>
    return (rainTotal/100.0)*6.0;
 8004a9a:	4650      	mov	r0, sl
 8004a9c:	f7fb fd84 	bl	80005a8 <__aeabi_i2d>
 8004aa0:	4632      	mov	r2, r6
 8004aa2:	463b      	mov	r3, r7
 8004aa4:	f7fb ff14 	bl	80008d0 <__aeabi_ddiv>
 8004aa8:	2200      	movs	r2, #0
 8004aaa:	4b92      	ldr	r3, [pc, #584]	; (8004cf4 <Thread6+0x2a4>)
 8004aac:	f7fb fde6 	bl	800067c <__aeabi_dmul>
 8004ab0:	f7fc f8bc 	bl	8000c2c <__aeabi_d2f>
		rainHistory[9-x] = rainHistory[8-x];
 8004ab4:	f894 c008 	ldrb.w	ip, [r4, #8]
 8004ab8:	79a1      	ldrb	r1, [r4, #6]
 8004aba:	7962      	ldrb	r2, [r4, #5]
 8004abc:	7923      	ldrb	r3, [r4, #4]
 8004abe:	f894 e007 	ldrb.w	lr, [r4, #7]
    return (rainTotal/100.0)*6.0;
 8004ac2:	f8c9 0000 	str.w	r0, [r9]
		rainHistory[9-x] = rainHistory[8-x];
 8004ac6:	f884 c009 	strb.w	ip, [r4, #9]
 8004aca:	78a0      	ldrb	r0, [r4, #2]
 8004acc:	f894 c003 	ldrb.w	ip, [r4, #3]
 8004ad0:	71e1      	strb	r1, [r4, #7]
 8004ad2:	71a2      	strb	r2, [r4, #6]
 8004ad4:	7861      	ldrb	r1, [r4, #1]
 8004ad6:	7822      	ldrb	r2, [r4, #0]
 8004ad8:	7163      	strb	r3, [r4, #5]
	    rainHistory[0] = 0;
 8004ada:	2300      	movs	r3, #0
 8004adc:	7023      	strb	r3, [r4, #0]
		rainHistory[9-x] = rainHistory[8-x];
 8004ade:	f884 e008 	strb.w	lr, [r4, #8]
 8004ae2:	f884 c004 	strb.w	ip, [r4, #4]
 8004ae6:	70e0      	strb	r0, [r4, #3]
 8004ae8:	70a1      	strb	r1, [r4, #2]
 8004aea:	7062      	strb	r2, [r4, #1]
 8004aec:	2320      	movs	r3, #32
 8004aee:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004af2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8004af4:	b90b      	cbnz	r3, 8004afa <Thread6+0xaa>
 8004af6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8004af8:	b113      	cbz	r3, 8004b00 <Thread6+0xb0>
    chSysHalt("SV#4");
 8004afa:	487f      	ldr	r0, [pc, #508]	; (8004cf8 <Thread6+0x2a8>)
 8004afc:	f7fc fc58 	bl	80013b0 <chSysHalt>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004b00:	69ea      	ldr	r2, [r5, #28]
 8004b02:	f8df a220 	ldr.w	sl, [pc, #544]	; 8004d24 <Thread6+0x2d4>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8004b06:	69a9      	ldr	r1, [r5, #24]
  vtp->func = vtfunc;
 8004b08:	f8df b21c 	ldr.w	fp, [pc, #540]	; 8004d28 <Thread6+0x2d8>
  return (systime_t)STM32_ST_TIM->CNT;
 8004b0c:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
  _dbg_enter_lock();
 8004b10:	f04f 0e01 	mov.w	lr, #1
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004b14:	4552      	cmp	r2, sl
 8004b16:	f8dc 0024 	ldr.w	r0, [ip, #36]	; 0x24
  vtp->par = par;
 8004b1a:	9107      	str	r1, [sp, #28]
 8004b1c:	f8c5 e034 	str.w	lr, [r5, #52]	; 0x34
  vtp->func = vtfunc;
 8004b20:	f8cd b018 	str.w	fp, [sp, #24]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004b24:	d06b      	beq.n	8004bfe <Thread6+0x1ae>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8004b26:	f8d5 c028 	ldr.w	ip, [r5, #40]	; 0x28
 8004b2a:	f8df b1d4 	ldr.w	fp, [pc, #468]	; 8004d00 <Thread6+0x2b0>
  return (sysinterval_t)((systime_t)(end - start));
 8004b2e:	eba0 000c 	sub.w	r0, r0, ip
 8004b32:	eb10 000b 	adds.w	r0, r0, fp
 8004b36:	bf28      	it	cs
 8004b38:	4673      	movcs	r3, lr
 8004b3a:	f8d2 e008 	ldr.w	lr, [r2, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8004b3e:	b95b      	cbnz	r3, 8004b58 <Thread6+0x108>
    else if (delta < p->delta) {
 8004b40:	4570      	cmp	r0, lr
 8004b42:	d376      	bcc.n	8004c32 <Thread6+0x1e2>
 8004b44:	f10d 0b0c 	add.w	fp, sp, #12
  while (p->delta < delta) {
 8004b48:	6893      	ldr	r3, [r2, #8]
 8004b4a:	4298      	cmp	r0, r3
 8004b4c:	d90b      	bls.n	8004b66 <Thread6+0x116>
    chDbgAssert(p != vtp, "timer already armed");
 8004b4e:	455a      	cmp	r2, fp
 8004b50:	d006      	beq.n	8004b60 <Thread6+0x110>
    p = p->next;
 8004b52:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
 8004b54:	1ac0      	subs	r0, r0, r3
 8004b56:	e7f7      	b.n	8004b48 <Thread6+0xf8>
      p = p->next;
 8004b58:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
 8004b5a:	eba0 000e 	sub.w	r0, r0, lr
 8004b5e:	e7f1      	b.n	8004b44 <Thread6+0xf4>
    chDbgAssert(p != vtp, "timer already armed");
 8004b60:	4866      	ldr	r0, [pc, #408]	; (8004cfc <Thread6+0x2ac>)
 8004b62:	f7fc fc25 	bl	80013b0 <chSysHalt>
  vtp->prev = vtp->next->prev;
 8004b66:	6853      	ldr	r3, [r2, #4]
 8004b68:	e9cd 2303 	strd	r2, r3, [sp, #12]
  vtp->prev->next = vtp;
 8004b6c:	f8c3 b000 	str.w	fp, [r3]
  p->prev = vtp;
 8004b70:	f8c2 b004 	str.w	fp, [r2, #4]
  vtp->delta = delta;
 8004b74:	9005      	str	r0, [sp, #20]
  p->delta -= delta;
 8004b76:	6893      	ldr	r3, [r2, #8]
 8004b78:	1a1b      	subs	r3, r3, r0
  ch.vtlist.delta = (sysinterval_t)-1;
 8004b7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  p->delta -= delta;
 8004b7e:	6093      	str	r3, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8004b80:	6268      	str	r0, [r5, #36]	; 0x24
  thread_t *tp = tqp->next;
 8004b82:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 8004b84:	2208      	movs	r2, #8
 8004b86:	f881 2020 	strb.w	r2, [r1, #32]
  tqp->next             = tp->queue.next;
 8004b8a:	681a      	ldr	r2, [r3, #0]
 8004b8c:	602a      	str	r2, [r5, #0]
  currp->state = CH_STATE_CURRENT;
 8004b8e:	2001      	movs	r0, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8004b90:	6055      	str	r5, [r2, #4]
 8004b92:	f883 0020 	strb.w	r0, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8004b96:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8004b98:	61ab      	str	r3, [r5, #24]
 8004b9a:	07d3      	lsls	r3, r2, #31
 8004b9c:	d55a      	bpl.n	8004c54 <Thread6+0x204>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004b9e:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8004ba2:	69ca      	ldr	r2, [r1, #28]
 8004ba4:	3b64      	subs	r3, #100	; 0x64
 8004ba6:	429a      	cmp	r2, r3
 8004ba8:	d851      	bhi.n	8004c4e <Thread6+0x1fe>
 8004baa:	69a8      	ldr	r0, [r5, #24]
 8004bac:	f7fb fb8c 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004bb0:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8004bb2:	2800      	cmp	r0, #0
 8004bb4:	db48      	blt.n	8004c48 <Thread6+0x1f8>
 8004bb6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8004bb8:	2b00      	cmp	r3, #0
 8004bba:	dd45      	ble.n	8004c48 <Thread6+0x1f8>
    if (chVTIsArmedI(&vt)) {
 8004bbc:	9b06      	ldr	r3, [sp, #24]
 8004bbe:	b17b      	cbz	r3, 8004be0 <Thread6+0x190>
  if (ch.vtlist.next != vtp) {
 8004bc0:	69eb      	ldr	r3, [r5, #28]
 8004bc2:	9a03      	ldr	r2, [sp, #12]
 8004bc4:	455b      	cmp	r3, fp
 8004bc6:	d062      	beq.n	8004c8e <Thread6+0x23e>
    vtp->prev->next = vtp->next;
 8004bc8:	9904      	ldr	r1, [sp, #16]
 8004bca:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8004bcc:	9b03      	ldr	r3, [sp, #12]
    vtp->func = NULL;
 8004bce:	2200      	movs	r2, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004bd0:	4553      	cmp	r3, sl
    vtp->next->prev = vtp->prev;
 8004bd2:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8004bd4:	9206      	str	r2, [sp, #24]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004bd6:	d003      	beq.n	8004be0 <Thread6+0x190>
      vtp->next->delta += vtp->delta;
 8004bd8:	689a      	ldr	r2, [r3, #8]
 8004bda:	9905      	ldr	r1, [sp, #20]
 8004bdc:	440a      	add	r2, r1
 8004bde:	609a      	str	r2, [r3, #8]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004be0:	2800      	cmp	r0, #0
 8004be2:	d151      	bne.n	8004c88 <Thread6+0x238>
 8004be4:	682b      	ldr	r3, [r5, #0]
  _dbg_leave_lock();
 8004be6:	6368      	str	r0, [r5, #52]	; 0x34
 8004be8:	42ab      	cmp	r3, r5
  return currp->u.rdymsg;
 8004bea:	69aa      	ldr	r2, [r5, #24]
 8004bec:	d003      	beq.n	8004bf6 <Thread6+0x1a6>
 8004bee:	6892      	ldr	r2, [r2, #8]
 8004bf0:	689b      	ldr	r3, [r3, #8]
 8004bf2:	429a      	cmp	r2, r3
 8004bf4:	d36f      	bcc.n	8004cd6 <Thread6+0x286>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004bf6:	2300      	movs	r3, #0
 8004bf8:	f383 8811 	msr	BASEPRI, r3
 8004bfc:	e733      	b.n	8004a66 <Thread6+0x16>
      vtp->delta = delay;
 8004bfe:	4b40      	ldr	r3, [pc, #256]	; (8004d00 <Thread6+0x2b0>)
 8004c00:	9305      	str	r3, [sp, #20]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004c02:	f8dc 300c 	ldr.w	r3, [ip, #12]
      ch.vtlist.lasttime = now;
 8004c06:	62a8      	str	r0, [r5, #40]	; 0x28
      ch.vtlist.next = vtp;
 8004c08:	f10d 0b0c 	add.w	fp, sp, #12
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8004c0c:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8004c10:	e9cd 2203 	strd	r2, r2, [sp, #12]
      ch.vtlist.prev = vtp;
 8004c14:	e9c5 bb07 	strd	fp, fp, [r5, #28]
 8004c18:	d130      	bne.n	8004c7c <Thread6+0x22c>
  return systime + (systime_t)interval;
 8004c1a:	f500 2012 	add.w	r0, r0, #598016	; 0x92000
 8004c1e:	f500 60f8 	add.w	r0, r0, #1984	; 0x7c0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004c22:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004c24:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8004c28:	f8cc 3010 	str.w	r3, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004c2c:	f8cc 200c 	str.w	r2, [ip, #12]
 8004c30:	e7a7      	b.n	8004b82 <Thread6+0x132>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004c32:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 8004c36:	f8de 300c 	ldr.w	r3, [lr, #12]
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8004c3a:	079b      	lsls	r3, r3, #30
 8004c3c:	d521      	bpl.n	8004c82 <Thread6+0x232>
 8004c3e:	eb0c 0300 	add.w	r3, ip, r0
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004c42:	f8ce 3034 	str.w	r3, [lr, #52]	; 0x34
 8004c46:	e77d      	b.n	8004b44 <Thread6+0xf4>
    chSysHalt("SV#10");
 8004c48:	482e      	ldr	r0, [pc, #184]	; (8004d04 <Thread6+0x2b4>)
 8004c4a:	f7fc fbb1 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8004c4e:	482e      	ldr	r0, [pc, #184]	; (8004d08 <Thread6+0x2b8>)
 8004c50:	f7fc fbae 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004c54:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004c56:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004c5a:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004c5c:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004c5e:	f360 0302 	bfi	r3, r0, #0, #3
 8004c62:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004c64:	f891 0020 	ldrb.w	r0, [r1, #32]
 8004c68:	f360 03c7 	bfi	r3, r0, #3, #5
 8004c6c:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8004c6e:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004c70:	e9c2 3c02 	strd	r3, ip, [r2, #8]
    trace_next();
 8004c74:	f7fc fb7c 	bl	8001370 <trace_next>
 8004c78:	9901      	ldr	r1, [sp, #4]
 8004c7a:	e790      	b.n	8004b9e <Thread6+0x14e>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8004c7c:	4823      	ldr	r0, [pc, #140]	; (8004d0c <Thread6+0x2bc>)
 8004c7e:	f7fc fb97 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8004c82:	4823      	ldr	r0, [pc, #140]	; (8004d10 <Thread6+0x2c0>)
 8004c84:	f7fc fb94 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8004c88:	4822      	ldr	r0, [pc, #136]	; (8004d14 <Thread6+0x2c4>)
 8004c8a:	f7fc fb91 	bl	80013b0 <chSysHalt>
  vtp->func = NULL;
 8004c8e:	2300      	movs	r3, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004c90:	4552      	cmp	r2, sl
  ch.vtlist.next = vtp->next;
 8004c92:	61ea      	str	r2, [r5, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8004c94:	f8c2 a004 	str.w	sl, [r2, #4]
  vtp->func = NULL;
 8004c98:	9306      	str	r3, [sp, #24]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004c9a:	d01f      	beq.n	8004cdc <Thread6+0x28c>
  ch.vtlist.next->delta += vtp->delta;
 8004c9c:	6891      	ldr	r1, [r2, #8]
 8004c9e:	9b05      	ldr	r3, [sp, #20]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8004ca0:	f8d5 e028 	ldr.w	lr, [r5, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8004ca4:	4419      	add	r1, r3
  return (systime_t)STM32_ST_TIM->CNT;
 8004ca6:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 8004caa:	6091      	str	r1, [r2, #8]
 8004cac:	f8dc 2024 	ldr.w	r2, [ip, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8004cb0:	eba2 020e 	sub.w	r2, r2, lr
  if (nowdelta >= ch.vtlist.next->delta) {
 8004cb4:	4291      	cmp	r1, r2
  ch.vtlist.next->delta += vtp->delta;
 8004cb6:	460b      	mov	r3, r1
  if (nowdelta >= ch.vtlist.next->delta) {
 8004cb8:	d992      	bls.n	8004be0 <Thread6+0x190>
  delta = ch.vtlist.next->delta - nowdelta;
 8004cba:	eba1 0c02 	sub.w	ip, r1, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8004cbe:	f1bc 0f01 	cmp.w	ip, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8004cc2:	bf98      	it	ls
 8004cc4:	1c93      	addls	r3, r2, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004cc6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8004cca:	4473      	add	r3, lr
 8004ccc:	68d1      	ldr	r1, [r2, #12]
 8004cce:	0789      	lsls	r1, r1, #30
 8004cd0:	d5d7      	bpl.n	8004c82 <Thread6+0x232>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004cd2:	6353      	str	r3, [r2, #52]	; 0x34
 8004cd4:	e784      	b.n	8004be0 <Thread6+0x190>
 8004cd6:	4810      	ldr	r0, [pc, #64]	; (8004d18 <Thread6+0x2c8>)
 8004cd8:	f7fc fb6a 	bl	80013b0 <chSysHalt>
  STM32_ST_TIM->DIER = 0;
 8004cdc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8004ce0:	60d3      	str	r3, [r2, #12]
 8004ce2:	e77d      	b.n	8004be0 <Thread6+0x190>
 8004ce4:	20002094 	.word	0x20002094
 8004ce8:	40590000 	.word	0x40590000
 8004cec:	2000159c 	.word	0x2000159c
 8004cf0:	200013d8 	.word	0x200013d8
 8004cf4:	40180000 	.word	0x40180000
 8004cf8:	0800e704 	.word	0x0800e704
 8004cfc:	0800e264 	.word	0x0800e264
 8004d00:	000927c0 	.word	0x000927c0
 8004d04:	0800e70c 	.word	0x0800e70c
 8004d08:	0800e71c 	.word	0x0800e71c
 8004d0c:	0800e38c 	.word	0x0800e38c
 8004d10:	0800e3cc 	.word	0x0800e3cc
 8004d14:	0800e72c 	.word	0x0800e72c
 8004d18:	0800e1e4 	.word	0x0800e1e4
 8004d1c:	200020a0 	.word	0x200020a0
 8004d20:	0800e188 	.word	0x0800e188
 8004d24:	200015b8 	.word	0x200015b8
 8004d28:	080016d1 	.word	0x080016d1
 8004d2c:	00000000 	.word	0x00000000

08004d30 <adcerrorcallback>:
static void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    chprintf((BaseSequentialStream*)&SD1,string);
 8004d34:	4978      	ldr	r1, [pc, #480]	; (8004f18 <adcerrorcallback+0x1e8>)
 8004d36:	4879      	ldr	r0, [pc, #484]	; (8004f1c <adcerrorcallback+0x1ec>)
static void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004d38:	b086      	sub	sp, #24
    chprintf((BaseSequentialStream*)&SD1,string);
 8004d3a:	f7fe fea9 	bl	8003a90 <chprintf.constprop.14>
 8004d3e:	2320      	movs	r3, #32
 8004d40:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004d44:	4c76      	ldr	r4, [pc, #472]	; (8004f20 <adcerrorcallback+0x1f0>)
 8004d46:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004d48:	b90b      	cbnz	r3, 8004d4e <adcerrorcallback+0x1e>
 8004d4a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004d4c:	b113      	cbz	r3, 8004d54 <adcerrorcallback+0x24>
    chSysHalt("SV#4");
 8004d4e:	4875      	ldr	r0, [pc, #468]	; (8004f24 <adcerrorcallback+0x1f4>)
 8004d50:	f7fc fb2e 	bl	80013b0 <chSysHalt>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d54:	4625      	mov	r5, r4
  return (systime_t)STM32_ST_TIM->CNT;
 8004d56:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8004d5a:	f855 2f1c 	ldr.w	r2, [r5, #28]!
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8004d5e:	69a7      	ldr	r7, [r4, #24]
  vtp->func = vtfunc;
 8004d60:	4871      	ldr	r0, [pc, #452]	; (8004f28 <adcerrorcallback+0x1f8>)
 8004d62:	6a4e      	ldr	r6, [r1, #36]	; 0x24
  vtp->par = par;
 8004d64:	9705      	str	r7, [sp, #20]
  _dbg_enter_lock();
 8004d66:	f04f 0c01 	mov.w	ip, #1
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d6a:	42aa      	cmp	r2, r5
 8004d6c:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
  vtp->func = vtfunc;
 8004d70:	9004      	str	r0, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d72:	d06e      	beq.n	8004e52 <adcerrorcallback+0x122>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8004d74:	f8d4 e028 	ldr.w	lr, [r4, #40]	; 0x28
 8004d78:	6891      	ldr	r1, [r2, #8]
 8004d7a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  return (sysinterval_t)((systime_t)(end - start));
 8004d7e:	eba6 060e 	sub.w	r6, r6, lr
 8004d82:	1830      	adds	r0, r6, r0
 8004d84:	bf28      	it	cs
 8004d86:	4663      	movcs	r3, ip
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8004d88:	2b00      	cmp	r3, #0
 8004d8a:	d15b      	bne.n	8004e44 <adcerrorcallback+0x114>
    else if (delta < p->delta) {
 8004d8c:	4288      	cmp	r0, r1
 8004d8e:	d375      	bcc.n	8004e7c <adcerrorcallback+0x14c>
  while (p->delta < delta) {
 8004d90:	4281      	cmp	r1, r0
    chDbgAssert(p != vtp, "timer already armed");
 8004d92:	f10d 0804 	add.w	r8, sp, #4
  while (p->delta < delta) {
 8004d96:	d206      	bcs.n	8004da6 <adcerrorcallback+0x76>
    chDbgAssert(p != vtp, "timer already armed");
 8004d98:	4542      	cmp	r2, r8
 8004d9a:	d057      	beq.n	8004e4c <adcerrorcallback+0x11c>
    p = p->next;
 8004d9c:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
 8004d9e:	1a40      	subs	r0, r0, r1
  while (p->delta < delta) {
 8004da0:	6891      	ldr	r1, [r2, #8]
 8004da2:	4288      	cmp	r0, r1
 8004da4:	d8f8      	bhi.n	8004d98 <adcerrorcallback+0x68>
  vtp->prev = vtp->next->prev;
 8004da6:	6853      	ldr	r3, [r2, #4]
 8004da8:	e9cd 2301 	strd	r2, r3, [sp, #4]
  vtp->prev->next = vtp;
 8004dac:	f8c3 8000 	str.w	r8, [r3]
  p->prev = vtp;
 8004db0:	f8c2 8004 	str.w	r8, [r2, #4]
  vtp->delta = delta;
 8004db4:	9003      	str	r0, [sp, #12]
  p->delta -= delta;
 8004db6:	6893      	ldr	r3, [r2, #8]
 8004db8:	1a18      	subs	r0, r3, r0
  ch.vtlist.delta = (sysinterval_t)-1;
 8004dba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  p->delta -= delta;
 8004dbe:	6090      	str	r0, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8004dc0:	6263      	str	r3, [r4, #36]	; 0x24
  thread_t *tp = tqp->next;
 8004dc2:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8004dc4:	2208      	movs	r2, #8
 8004dc6:	f887 2020 	strb.w	r2, [r7, #32]
  tqp->next             = tp->queue.next;
 8004dca:	681a      	ldr	r2, [r3, #0]
 8004dcc:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8004dce:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8004dd0:	6054      	str	r4, [r2, #4]
 8004dd2:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8004dd6:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8004dd8:	61a3      	str	r3, [r4, #24]
 8004dda:	07d3      	lsls	r3, r2, #31
 8004ddc:	d55a      	bpl.n	8004e94 <adcerrorcallback+0x164>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004dde:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8004de2:	69fa      	ldr	r2, [r7, #28]
 8004de4:	3b64      	subs	r3, #100	; 0x64
 8004de6:	429a      	cmp	r2, r3
 8004de8:	d851      	bhi.n	8004e8e <adcerrorcallback+0x15e>
 8004dea:	4639      	mov	r1, r7
 8004dec:	69a0      	ldr	r0, [r4, #24]
 8004dee:	f7fb fa6b 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004df2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004df4:	2b00      	cmp	r3, #0
 8004df6:	db5e      	blt.n	8004eb6 <adcerrorcallback+0x186>
 8004df8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004dfa:	2a00      	cmp	r2, #0
 8004dfc:	dd5b      	ble.n	8004eb6 <adcerrorcallback+0x186>
    if (chVTIsArmedI(&vt)) {
 8004dfe:	9a04      	ldr	r2, [sp, #16]
 8004e00:	b17a      	cbz	r2, 8004e22 <adcerrorcallback+0xf2>
  if (ch.vtlist.next != vtp) {
 8004e02:	69e2      	ldr	r2, [r4, #28]
 8004e04:	9901      	ldr	r1, [sp, #4]
 8004e06:	4542      	cmp	r2, r8
 8004e08:	d064      	beq.n	8004ed4 <adcerrorcallback+0x1a4>
    vtp->prev->next = vtp->next;
 8004e0a:	9802      	ldr	r0, [sp, #8]
 8004e0c:	6001      	str	r1, [r0, #0]
    vtp->next->prev = vtp->prev;
 8004e0e:	9a01      	ldr	r2, [sp, #4]
    vtp->func = NULL;
 8004e10:	2100      	movs	r1, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004e12:	42aa      	cmp	r2, r5
    vtp->next->prev = vtp->prev;
 8004e14:	6050      	str	r0, [r2, #4]
    vtp->func = NULL;
 8004e16:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004e18:	d003      	beq.n	8004e22 <adcerrorcallback+0xf2>
      vtp->next->delta += vtp->delta;
 8004e1a:	6891      	ldr	r1, [r2, #8]
 8004e1c:	9803      	ldr	r0, [sp, #12]
 8004e1e:	4401      	add	r1, r0
 8004e20:	6091      	str	r1, [r2, #8]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004e22:	2b00      	cmp	r3, #0
 8004e24:	d150      	bne.n	8004ec8 <adcerrorcallback+0x198>
 8004e26:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8004e28:	6363      	str	r3, [r4, #52]	; 0x34
 8004e2a:	42a2      	cmp	r2, r4
  return currp->u.rdymsg;
 8004e2c:	69a3      	ldr	r3, [r4, #24]
 8004e2e:	d003      	beq.n	8004e38 <adcerrorcallback+0x108>
 8004e30:	6899      	ldr	r1, [r3, #8]
 8004e32:	6893      	ldr	r3, [r2, #8]
 8004e34:	4299      	cmp	r1, r3
 8004e36:	d34a      	bcc.n	8004ece <adcerrorcallback+0x19e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e38:	2300      	movs	r3, #0
 8004e3a:	f383 8811 	msr	BASEPRI, r3
}
 8004e3e:	b006      	add	sp, #24
 8004e40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      p = p->next;
 8004e44:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
 8004e46:	1a40      	subs	r0, r0, r1
 8004e48:	6891      	ldr	r1, [r2, #8]
 8004e4a:	e7a1      	b.n	8004d90 <adcerrorcallback+0x60>
    chDbgAssert(p != vtp, "timer already armed");
 8004e4c:	4837      	ldr	r0, [pc, #220]	; (8004f2c <adcerrorcallback+0x1fc>)
 8004e4e:	f7fc faaf 	bl	80013b0 <chSysHalt>
      vtp->delta = delay;
 8004e52:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8004e56:	9303      	str	r3, [sp, #12]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004e58:	68cb      	ldr	r3, [r1, #12]
      ch.vtlist.lasttime = now;
 8004e5a:	62a6      	str	r6, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 8004e5c:	f10d 0804 	add.w	r8, sp, #4
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8004e60:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8004e64:	e9cd 2201 	strd	r2, r2, [sp, #4]
      ch.vtlist.prev = vtp;
 8004e68:	e9c4 8807 	strd	r8, r8, [r4, #28]
 8004e6c:	d126      	bne.n	8004ebc <adcerrorcallback+0x18c>
  return systime + (systime_t)interval;
 8004e6e:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004e72:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004e74:	634e      	str	r6, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8004e76:	610b      	str	r3, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004e78:	60ca      	str	r2, [r1, #12]
 8004e7a:	e7a2      	b.n	8004dc2 <adcerrorcallback+0x92>
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004e7c:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8004e80:	68f3      	ldr	r3, [r6, #12]
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8004e82:	079b      	lsls	r3, r3, #30
 8004e84:	d51d      	bpl.n	8004ec2 <adcerrorcallback+0x192>
 8004e86:	eb0e 0300 	add.w	r3, lr, r0
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004e8a:	6373      	str	r3, [r6, #52]	; 0x34
 8004e8c:	e780      	b.n	8004d90 <adcerrorcallback+0x60>
  chSysSwitch(currp, otp);
 8004e8e:	4828      	ldr	r0, [pc, #160]	; (8004f30 <adcerrorcallback+0x200>)
 8004e90:	f7fc fa8e 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004e94:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004e96:	6a78      	ldr	r0, [r7, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004e98:	7813      	ldrb	r3, [r2, #0]
 8004e9a:	f361 0302 	bfi	r3, r1, #0, #3
 8004e9e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004ea0:	f897 1020 	ldrb.w	r1, [r7, #32]
 8004ea4:	f361 03c7 	bfi	r3, r1, #3, #5
 8004ea8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8004eaa:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004eac:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8004eb0:	f7fc fa5e 	bl	8001370 <trace_next>
 8004eb4:	e793      	b.n	8004dde <adcerrorcallback+0xae>
    chSysHalt("SV#10");
 8004eb6:	481f      	ldr	r0, [pc, #124]	; (8004f34 <adcerrorcallback+0x204>)
 8004eb8:	f7fc fa7a 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8004ebc:	481e      	ldr	r0, [pc, #120]	; (8004f38 <adcerrorcallback+0x208>)
 8004ebe:	f7fc fa77 	bl	80013b0 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8004ec2:	481e      	ldr	r0, [pc, #120]	; (8004f3c <adcerrorcallback+0x20c>)
 8004ec4:	f7fc fa74 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8004ec8:	481d      	ldr	r0, [pc, #116]	; (8004f40 <adcerrorcallback+0x210>)
 8004eca:	f7fc fa71 	bl	80013b0 <chSysHalt>
 8004ece:	481d      	ldr	r0, [pc, #116]	; (8004f44 <adcerrorcallback+0x214>)
 8004ed0:	f7fc fa6e 	bl	80013b0 <chSysHalt>
  vtp->func = NULL;
 8004ed4:	2200      	movs	r2, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004ed6:	42a9      	cmp	r1, r5
  ch.vtlist.next = vtp->next;
 8004ed8:	61e1      	str	r1, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8004eda:	604d      	str	r5, [r1, #4]
  vtp->func = NULL;
 8004edc:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004ede:	d016      	beq.n	8004f0e <adcerrorcallback+0x1de>
  ch.vtlist.next->delta += vtp->delta;
 8004ee0:	688a      	ldr	r2, [r1, #8]
 8004ee2:	9d03      	ldr	r5, [sp, #12]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8004ee4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8004ee6:	442a      	add	r2, r5
  return (systime_t)STM32_ST_TIM->CNT;
 8004ee8:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8004eec:	608a      	str	r2, [r1, #8]
 8004eee:	6a69      	ldr	r1, [r5, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8004ef0:	1a09      	subs	r1, r1, r0
  if (nowdelta >= ch.vtlist.next->delta) {
 8004ef2:	428a      	cmp	r2, r1
 8004ef4:	d995      	bls.n	8004e22 <adcerrorcallback+0xf2>
  delta = ch.vtlist.next->delta - nowdelta;
 8004ef6:	1a55      	subs	r5, r2, r1
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8004ef8:	2d01      	cmp	r5, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8004efa:	bf98      	it	ls
 8004efc:	1c8a      	addls	r2, r1, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004efe:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8004f02:	4402      	add	r2, r0
 8004f04:	68c8      	ldr	r0, [r1, #12]
 8004f06:	0780      	lsls	r0, r0, #30
 8004f08:	d5db      	bpl.n	8004ec2 <adcerrorcallback+0x192>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004f0a:	634a      	str	r2, [r1, #52]	; 0x34
 8004f0c:	e789      	b.n	8004e22 <adcerrorcallback+0xf2>
  STM32_ST_TIM->DIER = 0;
 8004f0e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8004f12:	60ca      	str	r2, [r1, #12]
 8004f14:	e785      	b.n	8004e22 <adcerrorcallback+0xf2>
 8004f16:	bf00      	nop
 8004f18:	6f722121 	.word	0x6f722121
 8004f1c:	200013d8 	.word	0x200013d8
 8004f20:	2000159c 	.word	0x2000159c
 8004f24:	0800e704 	.word	0x0800e704
 8004f28:	080016d1 	.word	0x080016d1
 8004f2c:	0800e264 	.word	0x0800e264
 8004f30:	0800e71c 	.word	0x0800e71c
 8004f34:	0800e70c 	.word	0x0800e70c
 8004f38:	0800e38c 	.word	0x0800e38c
 8004f3c:	0800e3cc 	.word	0x0800e3cc
 8004f40:	0800e72c 	.word	0x0800e72c
 8004f44:	0800e1e4 	.word	0x0800e1e4
	...

08004f50 <oled_draw_string.constprop.13>:
void oled_draw_string(uint8_t x,uint8_t y,char* text)
 8004f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    oled_current_row = (y*16);
 8004f54:	0100      	lsls	r0, r0, #4
 8004f56:	fa5f f880 	uxtb.w	r8, r0
void oled_draw_string(uint8_t x,uint8_t y,char* text)
 8004f5a:	b08b      	sub	sp, #44	; 0x2c
	vbuf[oled_current_row+j][oled_current_column+i] = font[a][j][i];
 8004f5c:	4cc4      	ldr	r4, [pc, #784]	; (8005270 <oled_draw_string.constprop.13+0x320>)
 8004f5e:	4ec5      	ldr	r6, [pc, #788]	; (8005274 <oled_draw_string.constprop.13+0x324>)
void oled_draw_string(uint8_t x,uint8_t y,char* text)
 8004f60:	9101      	str	r1, [sp, #4]
	vbuf[oled_current_row+j][oled_current_column+i] = font[a][j][i];
 8004f62:	f108 0302 	add.w	r3, r8, #2
 8004f66:	01db      	lsls	r3, r3, #7
 8004f68:	f108 0201 	add.w	r2, r8, #1
 8004f6c:	01d2      	lsls	r2, r2, #7
 8004f6e:	9308      	str	r3, [sp, #32]
 8004f70:	18e3      	adds	r3, r4, r3
 8004f72:	9206      	str	r2, [sp, #24]
 8004f74:	9309      	str	r3, [sp, #36]	; 0x24
 8004f76:	18a2      	adds	r2, r4, r2
 8004f78:	ea4f 13c8 	mov.w	r3, r8, lsl #7
 8004f7c:	9207      	str	r2, [sp, #28]
 8004f7e:	9305      	str	r3, [sp, #20]
    oled_current_row = (y*16);
 8004f80:	2502      	movs	r5, #2
  for (j=0;j<(strlen(text));j++)
 8004f82:	f04f 0b00 	mov.w	fp, #0
 8004f86:	4608      	mov	r0, r1
 8004f88:	e169      	b.n	800525e <oled_draw_string.constprop.13+0x30e>
 8004f8a:	9b01      	ldr	r3, [sp, #4]
 8004f8c:	f813 200b 	ldrb.w	r2, [r3, fp]
	vbuf[oled_current_row+j][oled_current_column+i] = font[a][j][i];
 8004f90:	f108 0703 	add.w	r7, r8, #3
 8004f94:	01f8      	lsls	r0, r7, #7
 8004f96:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8004f9a:	9f05      	ldr	r7, [sp, #20]
 8004f9c:	9003      	str	r0, [sp, #12]
 8004f9e:	0152      	lsls	r2, r2, #5
 8004fa0:	eb07 0a05 	add.w	sl, r7, r5
 8004fa4:	1d29      	adds	r1, r5, #4
 8004fa6:	1993      	adds	r3, r2, r6
 8004fa8:	9102      	str	r1, [sp, #8]
 8004faa:	5991      	ldr	r1, [r2, r6]
 8004fac:	f84a 1004 	str.w	r1, [sl, r4]
 8004fb0:	1d28      	adds	r0, r5, #4
 8004fb2:	eb04 0a07 	add.w	sl, r4, r7
 8004fb6:	f893 9004 	ldrb.w	r9, [r3, #4]
 8004fba:	f80a 9000 	strb.w	r9, [sl, r0]
 8004fbe:	1d69      	adds	r1, r5, #5
 8004fc0:	f893 9005 	ldrb.w	r9, [r3, #5]
 8004fc4:	f80a 9001 	strb.w	r9, [sl, r1]
 8004fc8:	4608      	mov	r0, r1
 8004fca:	9906      	ldr	r1, [sp, #24]
 8004fcc:	9000      	str	r0, [sp, #0]
 8004fce:	f102 0a06 	add.w	sl, r2, #6
 8004fd2:	eb01 0905 	add.w	r9, r1, r5
 8004fd6:	9907      	ldr	r1, [sp, #28]
 8004fd8:	f856 a00a 	ldr.w	sl, [r6, sl]
 8004fdc:	f849 a004 	str.w	sl, [r9, r4]
 8004fe0:	460f      	mov	r7, r1
 8004fe2:	f102 0a0c 	add.w	sl, r2, #12
 8004fe6:	1d29      	adds	r1, r5, #4
 8004fe8:	f893 900a 	ldrb.w	r9, [r3, #10]
 8004fec:	f85a a006 	ldr.w	sl, [sl, r6]
 8004ff0:	f807 9001 	strb.w	r9, [r7, r1]
 8004ff4:	9908      	ldr	r1, [sp, #32]
 8004ff6:	f893 900b 	ldrb.w	r9, [r3, #11]
 8004ffa:	f807 9000 	strb.w	r9, [r7, r0]
 8004ffe:	eb01 0905 	add.w	r9, r1, r5
  for (j=0;j<(strlen(text));j++)
 8005002:	f10b 0101 	add.w	r1, fp, #1
	vbuf[oled_current_row+j][oled_current_column+i] = font[a][j][i];
 8005006:	f849 a004 	str.w	sl, [r9, r4]
 800500a:	9f09      	ldr	r7, [sp, #36]	; 0x24
  for (j=0;j<(strlen(text));j++)
 800500c:	9104      	str	r1, [sp, #16]
	vbuf[oled_current_row+j][oled_current_column+i] = font[a][j][i];
 800500e:	f102 0a12 	add.w	sl, r2, #18
 8005012:	1d29      	adds	r1, r5, #4
 8005014:	f893 9010 	ldrb.w	r9, [r3, #16]
 8005018:	f856 a00a 	ldr.w	sl, [r6, sl]
 800501c:	f807 9001 	strb.w	r9, [r7, r1]
 8005020:	f893 9011 	ldrb.w	r9, [r3, #17]
 8005024:	f807 9000 	strb.w	r9, [r7, r0]
 8005028:	4601      	mov	r1, r0
 800502a:	9803      	ldr	r0, [sp, #12]
 800502c:	eb00 0905 	add.w	r9, r0, r5
 8005030:	4420      	add	r0, r4
 8005032:	4607      	mov	r7, r0
 8005034:	f849 a004 	str.w	sl, [r9, r4]
 8005038:	1d28      	adds	r0, r5, #4
 800503a:	f102 0918 	add.w	r9, r2, #24
 800503e:	f893 a016 	ldrb.w	sl, [r3, #22]
 8005042:	f859 9006 	ldr.w	r9, [r9, r6]
 8005046:	f807 a000 	strb.w	sl, [r7, r0]
 800504a:	f108 0e04 	add.w	lr, r8, #4
 800504e:	f893 a017 	ldrb.w	sl, [r3, #23]
 8005052:	f807 a001 	strb.w	sl, [r7, r1]
 8005056:	ea4f 1ece 	mov.w	lr, lr, lsl #7
 800505a:	eb0e 0a05 	add.w	sl, lr, r5
 800505e:	eb04 070e 	add.w	r7, r4, lr
 8005062:	1d28      	adds	r0, r5, #4
 8005064:	f102 0e1e 	add.w	lr, r2, #30
 8005068:	f84a 9004 	str.w	r9, [sl, r4]
 800506c:	f108 0c05 	add.w	ip, r8, #5
 8005070:	f893 901c 	ldrb.w	r9, [r3, #28]
 8005074:	f856 e00e 	ldr.w	lr, [r6, lr]
 8005078:	f807 9000 	strb.w	r9, [r7, r0]
 800507c:	ea4f 1ccc 	mov.w	ip, ip, lsl #7
 8005080:	f893 901d 	ldrb.w	r9, [r3, #29]
 8005084:	f807 9001 	strb.w	r9, [r7, r1]
 8005088:	1d28      	adds	r0, r5, #4
 800508a:	eb0c 0705 	add.w	r7, ip, r5
 800508e:	44a4      	add	ip, r4
 8005090:	f893 b022 	ldrb.w	fp, [r3, #34]	; 0x22
 8005094:	f847 e004 	str.w	lr, [r7, r4]
 8005098:	f108 0a06 	add.w	sl, r8, #6
 800509c:	f80c b000 	strb.w	fp, [ip, r0]
 80050a0:	f893 b023 	ldrb.w	fp, [r3, #35]	; 0x23
 80050a4:	f80c b001 	strb.w	fp, [ip, r1]
 80050a8:	ea4f 1aca 	mov.w	sl, sl, lsl #7
 80050ac:	f102 0b24 	add.w	fp, r2, #36	; 0x24
 80050b0:	eb0a 0c05 	add.w	ip, sl, r5
 80050b4:	f85b b006 	ldr.w	fp, [fp, r6]
 80050b8:	f84c b004 	str.w	fp, [ip, r4]
 80050bc:	44a2      	add	sl, r4
 80050be:	1d28      	adds	r0, r5, #4
 80050c0:	f893 b028 	ldrb.w	fp, [r3, #40]	; 0x28
 80050c4:	f80a b000 	strb.w	fp, [sl, r0]
 80050c8:	f108 0907 	add.w	r9, r8, #7
 80050cc:	f893 b029 	ldrb.w	fp, [r3, #41]	; 0x29
 80050d0:	f80a b001 	strb.w	fp, [sl, r1]
 80050d4:	ea4f 19c9 	mov.w	r9, r9, lsl #7
 80050d8:	f102 0b2a 	add.w	fp, r2, #42	; 0x2a
 80050dc:	eb09 0a05 	add.w	sl, r9, r5
 80050e0:	f856 b00b 	ldr.w	fp, [r6, fp]
 80050e4:	f84a b004 	str.w	fp, [sl, r4]
 80050e8:	44a1      	add	r9, r4
 80050ea:	1d28      	adds	r0, r5, #4
 80050ec:	f893 a02e 	ldrb.w	sl, [r3, #46]	; 0x2e
 80050f0:	f809 a000 	strb.w	sl, [r9, r0]
 80050f4:	f108 0708 	add.w	r7, r8, #8
 80050f8:	f893 a02f 	ldrb.w	sl, [r3, #47]	; 0x2f
 80050fc:	f809 a001 	strb.w	sl, [r9, r1]
 8005100:	01ff      	lsls	r7, r7, #7
 8005102:	f102 0a30 	add.w	sl, r2, #48	; 0x30
 8005106:	eb07 0905 	add.w	r9, r7, r5
 800510a:	f85a a006 	ldr.w	sl, [sl, r6]
 800510e:	f849 a004 	str.w	sl, [r9, r4]
 8005112:	4427      	add	r7, r4
 8005114:	1d28      	adds	r0, r5, #4
 8005116:	f102 0936 	add.w	r9, r2, #54	; 0x36
 800511a:	f893 a034 	ldrb.w	sl, [r3, #52]	; 0x34
 800511e:	f856 9009 	ldr.w	r9, [r6, r9]
 8005122:	f807 a000 	strb.w	sl, [r7, r0]
 8005126:	f108 0e09 	add.w	lr, r8, #9
 800512a:	f893 a035 	ldrb.w	sl, [r3, #53]	; 0x35
 800512e:	f807 a001 	strb.w	sl, [r7, r1]
 8005132:	ea4f 1ece 	mov.w	lr, lr, lsl #7
 8005136:	eb0e 0a05 	add.w	sl, lr, r5
 800513a:	1d28      	adds	r0, r5, #4
 800513c:	44a6      	add	lr, r4
 800513e:	f102 073c 	add.w	r7, r2, #60	; 0x3c
 8005142:	f108 0c0a 	add.w	ip, r8, #10
 8005146:	f84a 9004 	str.w	r9, [sl, r4]
 800514a:	ea4f 1ccc 	mov.w	ip, ip, lsl #7
 800514e:	f893 a03a 	ldrb.w	sl, [r3, #58]	; 0x3a
 8005152:	59bf      	ldr	r7, [r7, r6]
 8005154:	f80e a000 	strb.w	sl, [lr, r0]
 8005158:	eb0c 0b05 	add.w	fp, ip, r5
 800515c:	f893 a03b 	ldrb.w	sl, [r3, #59]	; 0x3b
 8005160:	f80e a001 	strb.w	sl, [lr, r1]
 8005164:	1d28      	adds	r0, r5, #4
 8005166:	eb04 0a0c 	add.w	sl, r4, ip
 800516a:	f84b 7004 	str.w	r7, [fp, r4]
 800516e:	f108 090b 	add.w	r9, r8, #11
 8005172:	f893 7040 	ldrb.w	r7, [r3, #64]	; 0x40
 8005176:	f893 b041 	ldrb.w	fp, [r3, #65]	; 0x41
 800517a:	f80a 7000 	strb.w	r7, [sl, r0]
 800517e:	ea4f 19c9 	mov.w	r9, r9, lsl #7
 8005182:	f80a b001 	strb.w	fp, [sl, r1]
 8005186:	f102 0b42 	add.w	fp, r2, #66	; 0x42
 800518a:	eb09 0a05 	add.w	sl, r9, r5
 800518e:	f856 b00b 	ldr.w	fp, [r6, fp]
 8005192:	f84a b004 	str.w	fp, [sl, r4]
 8005196:	44a1      	add	r9, r4
 8005198:	1d28      	adds	r0, r5, #4
 800519a:	f893 b046 	ldrb.w	fp, [r3, #70]	; 0x46
 800519e:	f809 b000 	strb.w	fp, [r9, r0]
 80051a2:	f108 0e0c 	add.w	lr, r8, #12
 80051a6:	f893 b047 	ldrb.w	fp, [r3, #71]	; 0x47
 80051aa:	f809 b001 	strb.w	fp, [r9, r1]
 80051ae:	ea4f 1ece 	mov.w	lr, lr, lsl #7
 80051b2:	f102 0b48 	add.w	fp, r2, #72	; 0x48
 80051b6:	eb0e 0905 	add.w	r9, lr, r5
 80051ba:	f85b b006 	ldr.w	fp, [fp, r6]
 80051be:	f849 b004 	str.w	fp, [r9, r4]
 80051c2:	44a6      	add	lr, r4
 80051c4:	1d28      	adds	r0, r5, #4
 80051c6:	f893 904c 	ldrb.w	r9, [r3, #76]	; 0x4c
 80051ca:	f80e 9000 	strb.w	r9, [lr, r0]
 80051ce:	f108 0c0d 	add.w	ip, r8, #13
 80051d2:	f893 904d 	ldrb.w	r9, [r3, #77]	; 0x4d
 80051d6:	f80e 9001 	strb.w	r9, [lr, r1]
 80051da:	ea4f 1ccc 	mov.w	ip, ip, lsl #7
 80051de:	f102 094e 	add.w	r9, r2, #78	; 0x4e
 80051e2:	eb0c 0e05 	add.w	lr, ip, r5
 80051e6:	f856 9009 	ldr.w	r9, [r6, r9]
 80051ea:	f84e 9004 	str.w	r9, [lr, r4]
 80051ee:	44a4      	add	ip, r4
 80051f0:	1d28      	adds	r0, r5, #4
 80051f2:	f102 0954 	add.w	r9, r2, #84	; 0x54
 80051f6:	325a      	adds	r2, #90	; 0x5a
 80051f8:	f893 e052 	ldrb.w	lr, [r3, #82]	; 0x52
 80051fc:	58b2      	ldr	r2, [r6, r2]
 80051fe:	f859 9006 	ldr.w	r9, [r9, r6]
 8005202:	f80c e000 	strb.w	lr, [ip, r0]
 8005206:	f108 070e 	add.w	r7, r8, #14
 800520a:	f893 e053 	ldrb.w	lr, [r3, #83]	; 0x53
 800520e:	f80c e001 	strb.w	lr, [ip, r1]
 8005212:	01ff      	lsls	r7, r7, #7
 8005214:	eb07 0c05 	add.w	ip, r7, r5
 8005218:	f108 0a0f 	add.w	sl, r8, #15
 800521c:	4427      	add	r7, r4
 800521e:	1d28      	adds	r0, r5, #4
 8005220:	ea4f 1aca 	mov.w	sl, sl, lsl #7
 8005224:	f84c 9004 	str.w	r9, [ip, r4]
 8005228:	f893 e058 	ldrb.w	lr, [r3, #88]	; 0x58
 800522c:	f807 e000 	strb.w	lr, [r7, r0]
 8005230:	eb0a 0c05 	add.w	ip, sl, r5
 8005234:	f893 e059 	ldrb.w	lr, [r3, #89]	; 0x59
 8005238:	f807 e001 	strb.w	lr, [r7, r1]
 800523c:	44a2      	add	sl, r4
 800523e:	f84c 2004 	str.w	r2, [ip, r4]
 8005242:	9a02      	ldr	r2, [sp, #8]
 8005244:	f893 705e 	ldrb.w	r7, [r3, #94]	; 0x5e
 8005248:	f893 305f 	ldrb.w	r3, [r3, #95]	; 0x5f
 800524c:	f80a 7002 	strb.w	r7, [sl, r2]
 8005250:	3506      	adds	r5, #6
 8005252:	f80a 3001 	strb.w	r3, [sl, r1]
  for (j=0;j<(strlen(text));j++)
 8005256:	f89d b010 	ldrb.w	fp, [sp, #16]
 800525a:	9801      	ldr	r0, [sp, #4]
 800525c:	b2ed      	uxtb	r5, r5
 800525e:	f7fb fdcf 	bl	8000e00 <strlen>
 8005262:	4583      	cmp	fp, r0
 8005264:	f4ff ae91 	bcc.w	8004f8a <oled_draw_string.constprop.13+0x3a>
}
 8005268:	b00b      	add	sp, #44	; 0x2c
 800526a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800526e:	bf00      	nop
 8005270:	20002614 	.word	0x20002614
 8005274:	0800e764 	.word	0x0800e764
	...

08005280 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
 8005280:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005282:	4b05      	ldr	r3, [pc, #20]	; (8005298 <_dbg_check_unlock+0x18>)
 8005284:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005286:	b922      	cbnz	r2, 8005292 <_dbg_check_unlock+0x12>
 8005288:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800528a:	2900      	cmp	r1, #0
 800528c:	dd01      	ble.n	8005292 <_dbg_check_unlock+0x12>
  _dbg_leave_lock();
 800528e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8005290:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 8005292:	4802      	ldr	r0, [pc, #8]	; (800529c <_dbg_check_unlock+0x1c>)
 8005294:	f7fc f88c 	bl	80013b0 <chSysHalt>
 8005298:	2000159c 	.word	0x2000159c
 800529c:	0800e72c 	.word	0x0800e72c

080052a0 <chSysUnlock.lto_priv.75>:
static inline void chSysUnlock(void) {
 80052a0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80052a2:	f7ff ffed 	bl	8005280 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80052a6:	4b08      	ldr	r3, [pc, #32]	; (80052c8 <chSysUnlock.lto_priv.75+0x28>)
 80052a8:	681a      	ldr	r2, [r3, #0]
 80052aa:	429a      	cmp	r2, r3
 80052ac:	d004      	beq.n	80052b8 <chSysUnlock.lto_priv.75+0x18>
 80052ae:	6999      	ldr	r1, [r3, #24]
 80052b0:	6893      	ldr	r3, [r2, #8]
 80052b2:	688a      	ldr	r2, [r1, #8]
 80052b4:	429a      	cmp	r2, r3
 80052b6:	d303      	bcc.n	80052c0 <chSysUnlock.lto_priv.75+0x20>
 80052b8:	2300      	movs	r3, #0
 80052ba:	f383 8811 	msr	BASEPRI, r3
}
 80052be:	bd08      	pop	{r3, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80052c0:	4802      	ldr	r0, [pc, #8]	; (80052cc <chSysUnlock.lto_priv.75+0x2c>)
 80052c2:	f7fc f875 	bl	80013b0 <chSysHalt>
 80052c6:	bf00      	nop
 80052c8:	2000159c 	.word	0x2000159c
 80052cc:	0800e1c0 	.word	0x0800e1c0

080052d0 <_dbg_check_lock>:
void _dbg_check_lock(void) {
 80052d0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80052d2:	4b05      	ldr	r3, [pc, #20]	; (80052e8 <_dbg_check_lock+0x18>)
 80052d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80052d6:	b90a      	cbnz	r2, 80052dc <_dbg_check_lock+0xc>
 80052d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80052da:	b112      	cbz	r2, 80052e2 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 80052dc:	4803      	ldr	r0, [pc, #12]	; (80052ec <_dbg_check_lock+0x1c>)
 80052de:	f7fc f867 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 80052e2:	2201      	movs	r2, #1
 80052e4:	635a      	str	r2, [r3, #52]	; 0x34
}
 80052e6:	bd08      	pop	{r3, pc}
 80052e8:	2000159c 	.word	0x2000159c
 80052ec:	0800e704 	.word	0x0800e704

080052f0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 80052f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80052f4:	b085      	sub	sp, #20
  qnotify_t nfy = oqp->q_notify;
  size_t wr = 0;

  osalDbgCheck(n > 0U);
 80052f6:	2a00      	cmp	r2, #0
 80052f8:	d067      	beq.n	80053ca <oqWriteTimeout+0xda>
 80052fa:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 80052fc:	69c3      	ldr	r3, [r0, #28]
 80052fe:	9301      	str	r3, [sp, #4]
 8005300:	4604      	mov	r4, r0
 8005302:	4688      	mov	r8, r1
 8005304:	4615      	mov	r5, r2
 8005306:	2620      	movs	r6, #32
 8005308:	f386 8811 	msr	BASEPRI, r6
 800530c:	f8df b13c 	ldr.w	fp, [pc, #316]	; 800544c <oqWriteTimeout+0x15c>
  _dbg_check_lock();
 8005310:	f7ff ffde 	bl	80052d0 <_dbg_check_lock>
  size_t wr = 0;
 8005314:	f04f 0900 	mov.w	r9, #0
 8005318:	9602      	str	r6, [sp, #8]
  if (n > oqGetEmptyI(oqp)) {
 800531a:	68a3      	ldr	r3, [r4, #8]
 800531c:	429d      	cmp	r5, r3
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800531e:	e9d4 3004 	ldrd	r3, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 8005322:	bf8c      	ite	hi
 8005324:	68a6      	ldrhi	r6, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 8005326:	462e      	movls	r6, r5
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8005328:	1a1b      	subs	r3, r3, r0
  if (n < s1) {
 800532a:	42b3      	cmp	r3, r6
 800532c:	d850      	bhi.n	80053d0 <oqWriteTimeout+0xe0>
  else if (n > s1) {
 800532e:	d357      	bcc.n	80053e0 <oqWriteTimeout+0xf0>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8005330:	4632      	mov	r2, r6
 8005332:	4641      	mov	r1, r8
 8005334:	f7fb fcca 	bl	8000ccc <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8005338:	68e3      	ldr	r3, [r4, #12]
 800533a:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 800533c:	68a3      	ldr	r3, [r4, #8]
 800533e:	1b9b      	subs	r3, r3, r6
 8005340:	60a3      	str	r3, [r4, #8]

  while (wr < n) {
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8005342:	b33e      	cbz	r6, 8005394 <oqWriteTimeout+0xa4>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8005344:	9b01      	ldr	r3, [sp, #4]
 8005346:	b10b      	cbz	r3, 800534c <oqWriteTimeout+0x5c>
        nfy(oqp);
 8005348:	4620      	mov	r0, r4
 800534a:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800534c:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8005350:	2b00      	cmp	r3, #0
 8005352:	d137      	bne.n	80053c4 <oqWriteTimeout+0xd4>
 8005354:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8005358:	2a00      	cmp	r2, #0
 800535a:	dd33      	ble.n	80053c4 <oqWriteTimeout+0xd4>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800535c:	f8db 2000 	ldr.w	r2, [fp]
  _dbg_leave_lock();
 8005360:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 8005364:	455a      	cmp	r2, fp
 8005366:	d005      	beq.n	8005374 <oqWriteTimeout+0x84>
 8005368:	f8db 1018 	ldr.w	r1, [fp, #24]
 800536c:	6893      	ldr	r3, [r2, #8]
 800536e:	688a      	ldr	r2, [r1, #8]
 8005370:	429a      	cmp	r2, r3
 8005372:	d35f      	bcc.n	8005434 <oqWriteTimeout+0x144>
 8005374:	2300      	movs	r3, #0
 8005376:	f383 8811 	msr	BASEPRI, r3
 800537a:	9b02      	ldr	r3, [sp, #8]
 800537c:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005380:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8005384:	b91b      	cbnz	r3, 800538e <oqWriteTimeout+0x9e>
 8005386:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800538a:	2b00      	cmp	r3, #0
 800538c:	d039      	beq.n	8005402 <oqWriteTimeout+0x112>
    chSysHalt("SV#4");
 800538e:	482b      	ldr	r0, [pc, #172]	; (800543c <oqWriteTimeout+0x14c>)
 8005390:	f7fc f80e 	bl	80013b0 <chSysHalt>
  if (TIME_IMMEDIATE == timeout) {
 8005394:	f1ba 0f00 	cmp.w	sl, #0
 8005398:	d00d      	beq.n	80053b6 <oqWriteTimeout+0xc6>
  queue_insert(currp, tqp);
 800539a:	f8db 3018 	ldr.w	r3, [fp, #24]
  tp->queue.prev             = tqp->prev;
 800539e:	6862      	ldr	r2, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80053a0:	4651      	mov	r1, sl
 80053a2:	e9c3 4200 	strd	r4, r2, [r3]
 80053a6:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 80053a8:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 80053aa:	6063      	str	r3, [r4, #4]
 80053ac:	f7fd fbf8 	bl	8002ba0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 80053b0:	b908      	cbnz	r0, 80053b6 <oqWriteTimeout+0xc6>
  while (wr < n) {
 80053b2:	454d      	cmp	r5, r9
 80053b4:	d8b1      	bhi.n	800531a <oqWriteTimeout+0x2a>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80053b6:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 80053ba:	b91a      	cbnz	r2, 80053c4 <oqWriteTimeout+0xd4>
 80053bc:	f8db 1034 	ldr.w	r1, [fp, #52]	; 0x34
 80053c0:	2900      	cmp	r1, #0
 80053c2:	dc24      	bgt.n	800540e <oqWriteTimeout+0x11e>
    chSysHalt("SV#5");
 80053c4:	481e      	ldr	r0, [pc, #120]	; (8005440 <oqWriteTimeout+0x150>)
 80053c6:	f7fb fff3 	bl	80013b0 <chSysHalt>
  osalDbgCheck(n > 0U);
 80053ca:	481e      	ldr	r0, [pc, #120]	; (8005444 <oqWriteTimeout+0x154>)
 80053cc:	f7fb fff0 	bl	80013b0 <chSysHalt>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80053d0:	4632      	mov	r2, r6
 80053d2:	4641      	mov	r1, r8
 80053d4:	f7fb fc7a 	bl	8000ccc <memcpy>
    oqp->q_wrptr += n;
 80053d8:	6963      	ldr	r3, [r4, #20]
 80053da:	4433      	add	r3, r6
 80053dc:	6163      	str	r3, [r4, #20]
 80053de:	e7ad      	b.n	800533c <oqWriteTimeout+0x4c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80053e0:	461a      	mov	r2, r3
 80053e2:	4641      	mov	r1, r8
    s2 = n - s1;
 80053e4:	1af7      	subs	r7, r6, r3
 80053e6:	9303      	str	r3, [sp, #12]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80053e8:	f7fb fc70 	bl	8000ccc <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 80053ec:	9b03      	ldr	r3, [sp, #12]
 80053ee:	68e0      	ldr	r0, [r4, #12]
 80053f0:	eb08 0103 	add.w	r1, r8, r3
 80053f4:	463a      	mov	r2, r7
 80053f6:	f7fb fc69 	bl	8000ccc <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 80053fa:	68e3      	ldr	r3, [r4, #12]
 80053fc:	441f      	add	r7, r3
 80053fe:	6167      	str	r7, [r4, #20]
 8005400:	e79c      	b.n	800533c <oqWriteTimeout+0x4c>
  _dbg_enter_lock();
 8005402:	2301      	movs	r3, #1
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      wr += done;
 8005404:	44b1      	add	r9, r6
      bp += done;
 8005406:	44b0      	add	r8, r6
 8005408:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 800540c:	e7d1      	b.n	80053b2 <oqWriteTimeout+0xc2>
 800540e:	f8db 1000 	ldr.w	r1, [fp]
  _dbg_leave_lock();
 8005412:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8005416:	4559      	cmp	r1, fp
 8005418:	d005      	beq.n	8005426 <oqWriteTimeout+0x136>
 800541a:	f8db 2018 	ldr.w	r2, [fp, #24]
 800541e:	688b      	ldr	r3, [r1, #8]
 8005420:	6892      	ldr	r2, [r2, #8]
 8005422:	429a      	cmp	r2, r3
 8005424:	d306      	bcc.n	8005434 <oqWriteTimeout+0x144>
 8005426:	2300      	movs	r3, #0
 8005428:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return wr;
}
 800542c:	4648      	mov	r0, r9
 800542e:	b005      	add	sp, #20
 8005430:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005434:	4804      	ldr	r0, [pc, #16]	; (8005448 <oqWriteTimeout+0x158>)
 8005436:	f7fb ffbb 	bl	80013b0 <chSysHalt>
 800543a:	bf00      	nop
 800543c:	0800e704 	.word	0x0800e704
 8005440:	0800e72c 	.word	0x0800e72c
 8005444:	0800e58c 	.word	0x0800e58c
 8005448:	0800e240 	.word	0x0800e240
 800544c:	2000159c 	.word	0x2000159c

08005450 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8005450:	3030      	adds	r0, #48	; 0x30
 8005452:	f7ff bf4d 	b.w	80052f0 <oqWriteTimeout>
 8005456:	bf00      	nop
	...

08005460 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8005460:	3030      	adds	r0, #48	; 0x30
 8005462:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005466:	f7ff bf43 	b.w	80052f0 <oqWriteTimeout>
 800546a:	bf00      	nop
 800546c:	0000      	movs	r0, r0
	...

08005470 <oqWriteTimeout.constprop.60>:
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
 8005470:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005474:	b083      	sub	sp, #12
  osalDbgCheck(n > 0U);
 8005476:	2900      	cmp	r1, #0
 8005478:	d04a      	beq.n	8005510 <oqWriteTimeout.constprop.60+0xa0>
  qnotify_t nfy = oqp->q_notify;
 800547a:	4c67      	ldr	r4, [pc, #412]	; (8005618 <oqWriteTimeout.constprop.60+0x1a8>)
 800547c:	4680      	mov	r8, r0
 800547e:	460e      	mov	r6, r1
 8005480:	2320      	movs	r3, #32
 8005482:	f8d4 a04c 	ldr.w	sl, [r4, #76]	; 0x4c
 8005486:	f383 8811 	msr	BASEPRI, r3
 800548a:	4d64      	ldr	r5, [pc, #400]	; (800561c <oqWriteTimeout.constprop.60+0x1ac>)
  _dbg_check_lock();
 800548c:	f7ff ff20 	bl	80052d0 <_dbg_check_lock>
  size_t wr = 0;
 8005490:	f04f 0900 	mov.w	r9, #0
        nfy(oqp);
 8005494:	f104 0b30 	add.w	fp, r4, #48	; 0x30
 8005498:	9600      	str	r6, [sp, #0]
  if (n > oqGetEmptyI(oqp)) {
 800549a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800549c:	9a00      	ldr	r2, [sp, #0]
 800549e:	429a      	cmp	r2, r3
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80054a0:	e9d4 3010 	ldrd	r3, r0, [r4, #64]	; 0x40
    n = oqGetEmptyI(oqp);
 80054a4:	bf8c      	ite	hi
 80054a6:	6ba7      	ldrhi	r7, [r4, #56]	; 0x38
 80054a8:	4617      	movls	r7, r2
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80054aa:	1a1b      	subs	r3, r3, r0
  if (n < s1) {
 80054ac:	42bb      	cmp	r3, r7
 80054ae:	f200 8088 	bhi.w	80055c2 <oqWriteTimeout.constprop.60+0x152>
  else if (n > s1) {
 80054b2:	d330      	bcc.n	8005516 <oqWriteTimeout.constprop.60+0xa6>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80054b4:	463a      	mov	r2, r7
 80054b6:	4641      	mov	r1, r8
 80054b8:	f7fb fc08 	bl	8000ccc <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80054bc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80054be:	6463      	str	r3, [r4, #68]	; 0x44
  oqp->q_counter -= n;
 80054c0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80054c2:	1bdb      	subs	r3, r3, r7
 80054c4:	63a3      	str	r3, [r4, #56]	; 0x38
    if (done == (size_t)0) {
 80054c6:	2f00      	cmp	r7, #0
 80054c8:	d03a      	beq.n	8005540 <oqWriteTimeout.constprop.60+0xd0>
      if (nfy != NULL) {
 80054ca:	f1ba 0f00 	cmp.w	sl, #0
 80054ce:	d001      	beq.n	80054d4 <oqWriteTimeout.constprop.60+0x64>
        nfy(oqp);
 80054d0:	4658      	mov	r0, fp
 80054d2:	47d0      	blx	sl
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80054d4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80054d6:	2b00      	cmp	r3, #0
 80054d8:	d17b      	bne.n	80055d2 <oqWriteTimeout.constprop.60+0x162>
 80054da:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80054dc:	2a00      	cmp	r2, #0
 80054de:	dd78      	ble.n	80055d2 <oqWriteTimeout.constprop.60+0x162>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80054e0:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 80054e2:	636b      	str	r3, [r5, #52]	; 0x34
 80054e4:	42aa      	cmp	r2, r5
 80054e6:	d005      	beq.n	80054f4 <oqWriteTimeout.constprop.60+0x84>
 80054e8:	69a9      	ldr	r1, [r5, #24]
 80054ea:	6893      	ldr	r3, [r2, #8]
 80054ec:	688a      	ldr	r2, [r1, #8]
 80054ee:	429a      	cmp	r2, r3
 80054f0:	f0c0 808b 	bcc.w	800560a <oqWriteTimeout.constprop.60+0x19a>
 80054f4:	2300      	movs	r3, #0
 80054f6:	f383 8811 	msr	BASEPRI, r3
 80054fa:	2320      	movs	r3, #32
 80054fc:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005500:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005502:	b913      	cbnz	r3, 800550a <oqWriteTimeout.constprop.60+0x9a>
 8005504:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8005506:	2b00      	cmp	r3, #0
 8005508:	d069      	beq.n	80055de <oqWriteTimeout.constprop.60+0x16e>
    chSysHalt("SV#4");
 800550a:	4845      	ldr	r0, [pc, #276]	; (8005620 <oqWriteTimeout.constprop.60+0x1b0>)
 800550c:	f7fb ff50 	bl	80013b0 <chSysHalt>
  osalDbgCheck(n > 0U);
 8005510:	4844      	ldr	r0, [pc, #272]	; (8005624 <oqWriteTimeout.constprop.60+0x1b4>)
 8005512:	f7fb ff4d 	bl	80013b0 <chSysHalt>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8005516:	461a      	mov	r2, r3
 8005518:	4641      	mov	r1, r8
    s2 = n - s1;
 800551a:	1afe      	subs	r6, r7, r3
 800551c:	9301      	str	r3, [sp, #4]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 800551e:	f7fb fbd5 	bl	8000ccc <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8005522:	9b01      	ldr	r3, [sp, #4]
 8005524:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8005526:	eb08 0103 	add.w	r1, r8, r3
 800552a:	4632      	mov	r2, r6
 800552c:	f7fb fbce 	bl	8000ccc <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8005530:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005532:	4433      	add	r3, r6
 8005534:	6463      	str	r3, [r4, #68]	; 0x44
  oqp->q_counter -= n;
 8005536:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005538:	1bdb      	subs	r3, r3, r7
 800553a:	63a3      	str	r3, [r4, #56]	; 0x38
    if (done == (size_t)0) {
 800553c:	2f00      	cmp	r7, #0
 800553e:	d1c4      	bne.n	80054ca <oqWriteTimeout.constprop.60+0x5a>
  queue_insert(currp, tqp);
 8005540:	69ab      	ldr	r3, [r5, #24]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005542:	6b29      	ldr	r1, [r5, #48]	; 0x30
  tp->queue.next             = (thread_t *)tqp;
 8005544:	f8c3 b000 	str.w	fp, [r3]
  tp->queue.prev             = tqp->prev;
 8005548:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800554a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800554c:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800554e:	6363      	str	r3, [r4, #52]	; 0x34
 8005550:	2900      	cmp	r1, #0
 8005552:	d141      	bne.n	80055d8 <oqWriteTimeout.constprop.60+0x168>
 8005554:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8005556:	2b00      	cmp	r3, #0
 8005558:	dd3e      	ble.n	80055d8 <oqWriteTimeout.constprop.60+0x168>
  thread_t *otp = currp;
 800555a:	69af      	ldr	r7, [r5, #24]
  thread_t *tp = tqp->next;
 800555c:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 800555e:	2204      	movs	r2, #4
 8005560:	f887 2020 	strb.w	r2, [r7, #32]
  tqp->next             = tp->queue.next;
 8005564:	681a      	ldr	r2, [r3, #0]
 8005566:	602a      	str	r2, [r5, #0]
  currp->state = CH_STATE_CURRENT;
 8005568:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800556a:	6055      	str	r5, [r2, #4]
 800556c:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005570:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005572:	61ab      	str	r3, [r5, #24]
 8005574:	07d3      	lsls	r3, r2, #31
 8005576:	d537      	bpl.n	80055e8 <oqWriteTimeout.constprop.60+0x178>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005578:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 800557c:	69fa      	ldr	r2, [r7, #28]
 800557e:	3b64      	subs	r3, #100	; 0x64
 8005580:	429a      	cmp	r2, r3
 8005582:	d845      	bhi.n	8005610 <oqWriteTimeout.constprop.60+0x1a0>
 8005584:	4639      	mov	r1, r7
 8005586:	69a8      	ldr	r0, [r5, #24]
 8005588:	f7fa fe9e 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 800558c:	69ab      	ldr	r3, [r5, #24]
      if (msg != MSG_OK) {
 800558e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005590:	b913      	cbnz	r3, 8005598 <oqWriteTimeout.constprop.60+0x128>
  while (wr < n) {
 8005592:	9b00      	ldr	r3, [sp, #0]
 8005594:	454b      	cmp	r3, r9
 8005596:	d880      	bhi.n	800549a <oqWriteTimeout.constprop.60+0x2a>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005598:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800559a:	b9d3      	cbnz	r3, 80055d2 <oqWriteTimeout.constprop.60+0x162>
 800559c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800559e:	2a00      	cmp	r2, #0
 80055a0:	dd17      	ble.n	80055d2 <oqWriteTimeout.constprop.60+0x162>
 80055a2:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 80055a4:	636b      	str	r3, [r5, #52]	; 0x34
 80055a6:	42aa      	cmp	r2, r5
 80055a8:	d004      	beq.n	80055b4 <oqWriteTimeout.constprop.60+0x144>
 80055aa:	69a9      	ldr	r1, [r5, #24]
 80055ac:	6893      	ldr	r3, [r2, #8]
 80055ae:	688a      	ldr	r2, [r1, #8]
 80055b0:	429a      	cmp	r2, r3
 80055b2:	d32a      	bcc.n	800560a <oqWriteTimeout.constprop.60+0x19a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80055b4:	2300      	movs	r3, #0
 80055b6:	f383 8811 	msr	BASEPRI, r3
}
 80055ba:	4648      	mov	r0, r9
 80055bc:	b003      	add	sp, #12
 80055be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80055c2:	463a      	mov	r2, r7
 80055c4:	4641      	mov	r1, r8
 80055c6:	f7fb fb81 	bl	8000ccc <memcpy>
    oqp->q_wrptr += n;
 80055ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80055cc:	443b      	add	r3, r7
 80055ce:	6463      	str	r3, [r4, #68]	; 0x44
 80055d0:	e776      	b.n	80054c0 <oqWriteTimeout.constprop.60+0x50>
    chSysHalt("SV#5");
 80055d2:	4815      	ldr	r0, [pc, #84]	; (8005628 <oqWriteTimeout.constprop.60+0x1b8>)
 80055d4:	f7fb feec 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 80055d8:	4814      	ldr	r0, [pc, #80]	; (800562c <oqWriteTimeout.constprop.60+0x1bc>)
 80055da:	f7fb fee9 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 80055de:	2301      	movs	r3, #1
      wr += done;
 80055e0:	44b9      	add	r9, r7
      bp += done;
 80055e2:	44b8      	add	r8, r7
 80055e4:	636b      	str	r3, [r5, #52]	; 0x34
 80055e6:	e7d4      	b.n	8005592 <oqWriteTimeout.constprop.60+0x122>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80055e8:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80055ea:	6a78      	ldr	r0, [r7, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80055ec:	7813      	ldrb	r3, [r2, #0]
 80055ee:	f361 0302 	bfi	r3, r1, #0, #3
 80055f2:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80055f4:	f897 1020 	ldrb.w	r1, [r7, #32]
 80055f8:	f361 03c7 	bfi	r3, r1, #3, #5
 80055fc:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80055fe:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005600:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8005604:	f7fb feb4 	bl	8001370 <trace_next>
 8005608:	e7b6      	b.n	8005578 <oqWriteTimeout.constprop.60+0x108>
 800560a:	4809      	ldr	r0, [pc, #36]	; (8005630 <oqWriteTimeout.constprop.60+0x1c0>)
 800560c:	f7fb fed0 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8005610:	4808      	ldr	r0, [pc, #32]	; (8005634 <oqWriteTimeout.constprop.60+0x1c4>)
 8005612:	f7fb fecd 	bl	80013b0 <chSysHalt>
 8005616:	bf00      	nop
 8005618:	20001438 	.word	0x20001438
 800561c:	2000159c 	.word	0x2000159c
 8005620:	0800e704 	.word	0x0800e704
 8005624:	0800e58c 	.word	0x0800e58c
 8005628:	0800e72c 	.word	0x0800e72c
 800562c:	0800e714 	.word	0x0800e714
 8005630:	0800e240 	.word	0x0800e240
 8005634:	0800e71c 	.word	0x0800e71c
	...

08005640 <led_write0>:
{
 8005640:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005644:	4606      	mov	r6, r0
 8005646:	2520      	movs	r5, #32
 8005648:	f385 8811 	msr	BASEPRI, r5
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800564c:	4c4f      	ldr	r4, [pc, #316]	; (800578c <led_write0+0x14c>)
  _dbg_check_lock();
 800564e:	f7ff fe3f 	bl	80052d0 <_dbg_check_lock>
 8005652:	7823      	ldrb	r3, [r4, #0]
 8005654:	3b01      	subs	r3, #1
 8005656:	2b01      	cmp	r3, #1
 8005658:	d902      	bls.n	8005660 <led_write0+0x20>
 800565a:	484d      	ldr	r0, [pc, #308]	; (8005790 <led_write0+0x150>)
 800565c:	f7fb fea8 	bl	80013b0 <chSysHalt>
  spip->config = config;
 8005660:	4b4c      	ldr	r3, [pc, #304]	; (8005794 <led_write0+0x154>)
 8005662:	6063      	str	r3, [r4, #4]
  spi_lld_start(spip);
 8005664:	4620      	mov	r0, r4
 8005666:	f7fc fb7b 	bl	8001d60 <spi_lld_start>
  spip->state = SPI_READY;
 800566a:	2302      	movs	r3, #2
 800566c:	7023      	strb	r3, [r4, #0]
  chSysUnlock();
 800566e:	f7fc fe0f 	bl	8002290 <chSysUnlock.lto_priv.76>
 8005672:	f385 8811 	msr	BASEPRI, r5
 8005676:	f7ff fe2b 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800567a:	7823      	ldrb	r3, [r4, #0]
 800567c:	2b02      	cmp	r3, #2
 800567e:	d002      	beq.n	8005686 <led_write0+0x46>
 8005680:	4845      	ldr	r0, [pc, #276]	; (8005798 <led_write0+0x158>)
 8005682:	f7fb fe95 	bl	80013b0 <chSysHalt>
  spiSelectI(spip);
 8005686:	6862      	ldr	r2, [r4, #4]
  txbuf[0] = location;
 8005688:	f8df 812c 	ldr.w	r8, [pc, #300]	; 80057b8 <led_write0+0x178>
 800568c:	e9d2 2302 	ldrd	r2, r3, [r2, #8]
 8005690:	2701      	movs	r7, #1
 8005692:	fa07 f303 	lsl.w	r3, r7, r3
 8005696:	b29b      	uxth	r3, r3
 8005698:	8353      	strh	r3, [r2, #26]
 800569a:	f7fc fdf9 	bl	8002290 <chSysUnlock.lto_priv.76>
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
 800569e:	6863      	ldr	r3, [r4, #4]
 80056a0:	f888 6000 	strb.w	r6, [r8]
 80056a4:	781b      	ldrb	r3, [r3, #0]
 80056a6:	b933      	cbnz	r3, 80056b6 <led_write0+0x76>
 80056a8:	f385 8811 	msr	BASEPRI, r5
 80056ac:	f7ff fe10 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80056b0:	7823      	ldrb	r3, [r4, #0]
 80056b2:	2b02      	cmp	r3, #2
 80056b4:	d002      	beq.n	80056bc <led_write0+0x7c>
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
 80056b6:	4839      	ldr	r0, [pc, #228]	; (800579c <led_write0+0x15c>)
 80056b8:	f7fb fe7a 	bl	80013b0 <chSysHalt>
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80056bc:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80056c0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80056c2:	6852      	ldr	r2, [r2, #4]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80056c4:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80056c6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80056c8:	4e35      	ldr	r6, [pc, #212]	; (80057a0 <led_write0+0x160>)
 80056ca:	60d6      	str	r6, [r2, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80056cc:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  spiStartSendI(spip, n, txbuf);
 80056d0:	f04f 0903 	mov.w	r9, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80056d4:	6057      	str	r7, [r2, #4]
 80056d6:	f884 9000 	strb.w	r9, [r4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80056da:	6010      	str	r0, [r2, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80056dc:	f8c3 800c 	str.w	r8, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80056e0:	605f      	str	r7, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80056e2:	6019      	str	r1, [r3, #0]
  dmaStreamEnable(spip->dmarx);
 80056e4:	6811      	ldr	r1, [r2, #0]
  chDbgAssert(*trp == NULL, "not NULL");
 80056e6:	68a6      	ldr	r6, [r4, #8]
 80056e8:	f041 0101 	orr.w	r1, r1, #1
 80056ec:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 80056ee:	681a      	ldr	r2, [r3, #0]
 80056f0:	f042 0201 	orr.w	r2, r2, #1
 80056f4:	601a      	str	r2, [r3, #0]
 80056f6:	b116      	cbz	r6, 80056fe <led_write0+0xbe>
 80056f8:	482a      	ldr	r0, [pc, #168]	; (80057a4 <led_write0+0x164>)
 80056fa:	f7fb fe59 	bl	80013b0 <chSysHalt>
  return ch.rlist.current;
 80056fe:	4a2a      	ldr	r2, [pc, #168]	; (80057a8 <led_write0+0x168>)
  *trp = tp;
 8005700:	4623      	mov	r3, r4
 8005702:	6992      	ldr	r2, [r2, #24]
 8005704:	f843 2f08 	str.w	r2, [r3, #8]!
  tp->u.wttrp = trp;
 8005708:	6253      	str	r3, [r2, #36]	; 0x24
  chDbgCheckClassS();
 800570a:	f7fb fe69 	bl	80013e0 <chDbgCheckClassS>
    chSchGoSleepS(newstate);
 800570e:	4648      	mov	r0, r9
 8005710:	f7fc fe26 	bl	8002360 <chSchGoSleepS>
 8005714:	f7fc fdbc 	bl	8002290 <chSysUnlock.lto_priv.76>
 8005718:	f385 8811 	msr	BASEPRI, r5
 800571c:	f7ff fdd8 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8005720:	7823      	ldrb	r3, [r4, #0]
 8005722:	2b02      	cmp	r3, #2
 8005724:	d002      	beq.n	800572c <led_write0+0xec>
 8005726:	4821      	ldr	r0, [pc, #132]	; (80057ac <led_write0+0x16c>)
 8005728:	f7fb fe42 	bl	80013b0 <chSysHalt>
  spiUnselectI(spip);
 800572c:	6863      	ldr	r3, [r4, #4]
 800572e:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8005732:	4097      	lsls	r7, r2
 8005734:	b2bf      	uxth	r7, r7
 8005736:	831f      	strh	r7, [r3, #24]
 8005738:	f7fc fdaa 	bl	8002290 <chSysUnlock.lto_priv.76>
 800573c:	f385 8811 	msr	BASEPRI, r5
 8005740:	f7ff fdc6 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8005744:	7823      	ldrb	r3, [r4, #0]
 8005746:	1e5a      	subs	r2, r3, #1
 8005748:	2a01      	cmp	r2, #1
 800574a:	d902      	bls.n	8005752 <led_write0+0x112>
 800574c:	4818      	ldr	r0, [pc, #96]	; (80057b0 <led_write0+0x170>)
 800574e:	f7fb fe2f 	bl	80013b0 <chSysHalt>
  if (spip->state == SPI_READY) {
 8005752:	2b02      	cmp	r3, #2
 8005754:	d007      	beq.n	8005766 <led_write0+0x126>
  spip->state  = SPI_STOP;
 8005756:	2301      	movs	r3, #1
  spip->config = NULL;
 8005758:	2200      	movs	r2, #0
 800575a:	6062      	str	r2, [r4, #4]
  spip->state  = SPI_STOP;
 800575c:	7023      	strb	r3, [r4, #0]
}
 800575e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005762:	f7fc bd95 	b.w	8002290 <chSysUnlock.lto_priv.76>
    dmaStreamRelease(spip->dmarx);
 8005766:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 800576a:	681a      	ldr	r2, [r3, #0]
 800576c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005770:	601a      	str	r2, [r3, #0]
    spip->spi->CR1  = 0;
 8005772:	601e      	str	r6, [r3, #0]
    spip->spi->CR2  = 0;
 8005774:	605e      	str	r6, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 8005776:	f7fc fa43 	bl	8001c00 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800577a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800577c:	f7fc fa40 	bl	8001c00 <dmaStreamRelease>
      rccDisableSPI2();
 8005780:	4a0c      	ldr	r2, [pc, #48]	; (80057b4 <led_write0+0x174>)
 8005782:	69d3      	ldr	r3, [r2, #28]
 8005784:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005788:	61d3      	str	r3, [r2, #28]
 800578a:	e7e4      	b.n	8005756 <led_write0+0x116>
 800578c:	200014c8 	.word	0x200014c8
 8005790:	0800e3c0 	.word	0x0800e3c0
 8005794:	0801d9bc 	.word	0x0801d9bc
 8005798:	0800e400 	.word	0x0800e400
 800579c:	0800e52c 	.word	0x0800e52c
 80057a0:	20001ffc 	.word	0x20001ffc
 80057a4:	0800e348 	.word	0x0800e348
 80057a8:	2000159c 	.word	0x2000159c
 80057ac:	0800e428 	.word	0x0800e428
 80057b0:	0800e3e0 	.word	0x0800e3e0
 80057b4:	40021000 	.word	0x40021000
 80057b8:	20002610 	.word	0x20002610
 80057bc:	00000000 	.word	0x00000000

080057c0 <sdStart>:
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80057c0:	b570      	push	{r4, r5, r6, lr}
 80057c2:	2320      	movs	r3, #32
 80057c4:	4604      	mov	r4, r0
 80057c6:	460d      	mov	r5, r1
 80057c8:	f383 8811 	msr	BASEPRI, r3
 80057cc:	f7ff fd80 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 80057d0:	7a23      	ldrb	r3, [r4, #8]
 80057d2:	1e5a      	subs	r2, r3, #1
 80057d4:	2a01      	cmp	r2, #1
 80057d6:	d902      	bls.n	80057de <sdStart+0x1e>
 80057d8:	4822      	ldr	r0, [pc, #136]	; (8005864 <sdStart+0xa4>)
 80057da:	f7fb fde9 	bl	80013b0 <chSysHalt>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80057de:	2b01      	cmp	r3, #1
 80057e0:	d02e      	beq.n	8005840 <sdStart+0x80>
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80057e2:	e9d5 2101 	ldrd	r2, r1, [r5, #4]
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80057e6:	e9d4 3615 	ldrd	r3, r6, [r4, #84]	; 0x54
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80057ea:	68e8      	ldr	r0, [r5, #12]
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80057ec:	682d      	ldr	r5, [r5, #0]
 80057ee:	fbb6 f6f5 	udiv	r6, r6, r5
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80057f2:	f041 0540 	orr.w	r5, r1, #64	; 0x40
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80057f6:	f442 7196 	orr.w	r1, r2, #300	; 0x12c
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80057fa:	60de      	str	r6, [r3, #12]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80057fc:	f040 0001 	orr.w	r0, r0, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005800:	605d      	str	r5, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005802:	f041 0101 	orr.w	r1, r1, #1
  u->ICR = 0xFFFFFFFFU;
 8005806:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800580a:	6098      	str	r0, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800580c:	6019      	str	r1, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
 800580e:	621d      	str	r5, [r3, #32]
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 8005810:	0553      	lsls	r3, r2, #21
 8005812:	d509      	bpl.n	8005828 <sdStart+0x68>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 8005814:	f012 2210 	ands.w	r2, r2, #268439552	; 0x10001000
 8005818:	d00e      	beq.n	8005838 <sdStart+0x78>
 800581a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800581e:	d103      	bne.n	8005828 <sdStart+0x68>
      sdp->rxmask = 0x3F;
 8005820:	233f      	movs	r3, #63	; 0x3f
 8005822:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
 8005826:	e001      	b.n	800582c <sdStart+0x6c>
    sdp->rxmask = 0xFF;
 8005828:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c
  sdp->state = SD_READY;
 800582c:	2302      	movs	r3, #2
 800582e:	7223      	strb	r3, [r4, #8]
}
 8005830:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8005834:	f7ff bd34 	b.w	80052a0 <chSysUnlock.lto_priv.75>
      sdp->rxmask = 0x7F;
 8005838:	237f      	movs	r3, #127	; 0x7f
 800583a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
 800583e:	e7f5      	b.n	800582c <sdStart+0x6c>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8005840:	4b09      	ldr	r3, [pc, #36]	; (8005868 <sdStart+0xa8>)
 8005842:	429c      	cmp	r4, r3
 8005844:	d008      	beq.n	8005858 <sdStart+0x98>
      rccEnableUSART1(true);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8005846:	4b09      	ldr	r3, [pc, #36]	; (800586c <sdStart+0xac>)
 8005848:	429c      	cmp	r4, r3
 800584a:	d1ca      	bne.n	80057e2 <sdStart+0x22>
      rccEnableUSART2(true);
 800584c:	4a08      	ldr	r2, [pc, #32]	; (8005870 <sdStart+0xb0>)
 800584e:	69d3      	ldr	r3, [r2, #28]
 8005850:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005854:	61d3      	str	r3, [r2, #28]
 8005856:	e7c4      	b.n	80057e2 <sdStart+0x22>
      rccEnableUSART1(true);
 8005858:	4a05      	ldr	r2, [pc, #20]	; (8005870 <sdStart+0xb0>)
 800585a:	6993      	ldr	r3, [r2, #24]
 800585c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005860:	6193      	str	r3, [r2, #24]
 8005862:	e7be      	b.n	80057e2 <sdStart+0x22>
 8005864:	0800e4e8 	.word	0x0800e4e8
 8005868:	200013d8 	.word	0x200013d8
 800586c:	20001438 	.word	0x20001438
 8005870:	40021000 	.word	0x40021000
	...

08005880 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8005880:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005884:	b085      	sub	sp, #20
  osalDbgCheck(n > 0U);
 8005886:	2a00      	cmp	r2, #0
 8005888:	d067      	beq.n	800595a <iqReadTimeout+0xda>
 800588a:	469a      	mov	sl, r3
  qnotify_t nfy = iqp->q_notify;
 800588c:	69c3      	ldr	r3, [r0, #28]
 800588e:	9301      	str	r3, [sp, #4]
 8005890:	4604      	mov	r4, r0
 8005892:	4688      	mov	r8, r1
 8005894:	4615      	mov	r5, r2
 8005896:	2620      	movs	r6, #32
 8005898:	f386 8811 	msr	BASEPRI, r6
 800589c:	f8df b13c 	ldr.w	fp, [pc, #316]	; 80059dc <iqReadTimeout+0x15c>
 80058a0:	f7ff fd16 	bl	80052d0 <_dbg_check_lock>
  size_t rd = 0;
 80058a4:	f04f 0900 	mov.w	r9, #0
 80058a8:	9602      	str	r6, [sp, #8]
  if (n > iqGetFullI(iqp)) {
 80058aa:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80058ac:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 80058ae:	429d      	cmp	r5, r3
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80058b0:	6923      	ldr	r3, [r4, #16]
    n = iqGetFullI(iqp);
 80058b2:	bf8c      	ite	hi
 80058b4:	68a6      	ldrhi	r6, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 80058b6:	462e      	movls	r6, r5
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80058b8:	1a5b      	subs	r3, r3, r1
  if (n < s1) {
 80058ba:	42b3      	cmp	r3, r6
 80058bc:	d850      	bhi.n	8005960 <iqReadTimeout+0xe0>
  else if (n > s1) {
 80058be:	d357      	bcc.n	8005970 <iqReadTimeout+0xf0>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80058c0:	4632      	mov	r2, r6
 80058c2:	4640      	mov	r0, r8
 80058c4:	f7fb fa02 	bl	8000ccc <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80058c8:	68e3      	ldr	r3, [r4, #12]
 80058ca:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 80058cc:	68a3      	ldr	r3, [r4, #8]
 80058ce:	1b9b      	subs	r3, r3, r6
 80058d0:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 80058d2:	b33e      	cbz	r6, 8005924 <iqReadTimeout+0xa4>
      if (nfy != NULL) {
 80058d4:	9b01      	ldr	r3, [sp, #4]
 80058d6:	b10b      	cbz	r3, 80058dc <iqReadTimeout+0x5c>
        nfy(iqp);
 80058d8:	4620      	mov	r0, r4
 80058da:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80058dc:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 80058e0:	2b00      	cmp	r3, #0
 80058e2:	d137      	bne.n	8005954 <iqReadTimeout+0xd4>
 80058e4:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 80058e8:	2a00      	cmp	r2, #0
 80058ea:	dd33      	ble.n	8005954 <iqReadTimeout+0xd4>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80058ec:	f8db 2000 	ldr.w	r2, [fp]
  _dbg_leave_lock();
 80058f0:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 80058f4:	455a      	cmp	r2, fp
 80058f6:	d005      	beq.n	8005904 <iqReadTimeout+0x84>
 80058f8:	f8db 1018 	ldr.w	r1, [fp, #24]
 80058fc:	6893      	ldr	r3, [r2, #8]
 80058fe:	688a      	ldr	r2, [r1, #8]
 8005900:	429a      	cmp	r2, r3
 8005902:	d35f      	bcc.n	80059c4 <iqReadTimeout+0x144>
 8005904:	2300      	movs	r3, #0
 8005906:	f383 8811 	msr	BASEPRI, r3
 800590a:	9b02      	ldr	r3, [sp, #8]
 800590c:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005910:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8005914:	b91b      	cbnz	r3, 800591e <iqReadTimeout+0x9e>
 8005916:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800591a:	2b00      	cmp	r3, #0
 800591c:	d039      	beq.n	8005992 <iqReadTimeout+0x112>
    chSysHalt("SV#4");
 800591e:	482b      	ldr	r0, [pc, #172]	; (80059cc <iqReadTimeout+0x14c>)
 8005920:	f7fb fd46 	bl	80013b0 <chSysHalt>
  if (TIME_IMMEDIATE == timeout) {
 8005924:	f1ba 0f00 	cmp.w	sl, #0
 8005928:	d00d      	beq.n	8005946 <iqReadTimeout+0xc6>
  queue_insert(currp, tqp);
 800592a:	f8db 3018 	ldr.w	r3, [fp, #24]
  tp->queue.prev             = tqp->prev;
 800592e:	6862      	ldr	r2, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005930:	4651      	mov	r1, sl
 8005932:	e9c3 4200 	strd	r4, r2, [r3]
 8005936:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8005938:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800593a:	6063      	str	r3, [r4, #4]
 800593c:	f7fd f930 	bl	8002ba0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 8005940:	b908      	cbnz	r0, 8005946 <iqReadTimeout+0xc6>
  while (rd < n) {
 8005942:	454d      	cmp	r5, r9
 8005944:	d8b1      	bhi.n	80058aa <iqReadTimeout+0x2a>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005946:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 800594a:	b91a      	cbnz	r2, 8005954 <iqReadTimeout+0xd4>
 800594c:	f8db 1034 	ldr.w	r1, [fp, #52]	; 0x34
 8005950:	2900      	cmp	r1, #0
 8005952:	dc24      	bgt.n	800599e <iqReadTimeout+0x11e>
    chSysHalt("SV#5");
 8005954:	481e      	ldr	r0, [pc, #120]	; (80059d0 <iqReadTimeout+0x150>)
 8005956:	f7fb fd2b 	bl	80013b0 <chSysHalt>
  osalDbgCheck(n > 0U);
 800595a:	481e      	ldr	r0, [pc, #120]	; (80059d4 <iqReadTimeout+0x154>)
 800595c:	f7fb fd28 	bl	80013b0 <chSysHalt>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8005960:	4632      	mov	r2, r6
 8005962:	4640      	mov	r0, r8
 8005964:	f7fb f9b2 	bl	8000ccc <memcpy>
    iqp->q_rdptr += n;
 8005968:	69a3      	ldr	r3, [r4, #24]
 800596a:	4433      	add	r3, r6
 800596c:	61a3      	str	r3, [r4, #24]
 800596e:	e7ad      	b.n	80058cc <iqReadTimeout+0x4c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8005970:	461a      	mov	r2, r3
 8005972:	4640      	mov	r0, r8
    s2 = n - s1;
 8005974:	1af7      	subs	r7, r6, r3
 8005976:	9303      	str	r3, [sp, #12]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8005978:	f7fb f9a8 	bl	8000ccc <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 800597c:	9b03      	ldr	r3, [sp, #12]
 800597e:	68e1      	ldr	r1, [r4, #12]
 8005980:	eb08 0003 	add.w	r0, r8, r3
 8005984:	463a      	mov	r2, r7
 8005986:	f7fb f9a1 	bl	8000ccc <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 800598a:	68e3      	ldr	r3, [r4, #12]
 800598c:	441f      	add	r7, r3
 800598e:	61a7      	str	r7, [r4, #24]
 8005990:	e79c      	b.n	80058cc <iqReadTimeout+0x4c>
  _dbg_enter_lock();
 8005992:	2301      	movs	r3, #1
      rd += done;
 8005994:	44b1      	add	r9, r6
      bp += done;
 8005996:	44b0      	add	r8, r6
 8005998:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 800599c:	e7d1      	b.n	8005942 <iqReadTimeout+0xc2>
 800599e:	f8db 1000 	ldr.w	r1, [fp]
  _dbg_leave_lock();
 80059a2:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 80059a6:	4559      	cmp	r1, fp
 80059a8:	d005      	beq.n	80059b6 <iqReadTimeout+0x136>
 80059aa:	f8db 2018 	ldr.w	r2, [fp, #24]
 80059ae:	688b      	ldr	r3, [r1, #8]
 80059b0:	6892      	ldr	r2, [r2, #8]
 80059b2:	429a      	cmp	r2, r3
 80059b4:	d306      	bcc.n	80059c4 <iqReadTimeout+0x144>
 80059b6:	2300      	movs	r3, #0
 80059b8:	f383 8811 	msr	BASEPRI, r3
}
 80059bc:	4648      	mov	r0, r9
 80059be:	b005      	add	sp, #20
 80059c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80059c4:	4804      	ldr	r0, [pc, #16]	; (80059d8 <iqReadTimeout+0x158>)
 80059c6:	f7fb fcf3 	bl	80013b0 <chSysHalt>
 80059ca:	bf00      	nop
 80059cc:	0800e704 	.word	0x0800e704
 80059d0:	0800e72c 	.word	0x0800e72c
 80059d4:	0800e57c 	.word	0x0800e57c
 80059d8:	0800e240 	.word	0x0800e240
 80059dc:	2000159c 	.word	0x2000159c

080059e0 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80059e0:	300c      	adds	r0, #12
 80059e2:	f7ff bf4d 	b.w	8005880 <iqReadTimeout>
 80059e6:	bf00      	nop
	...

080059f0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80059f0:	300c      	adds	r0, #12
 80059f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80059f6:	f7ff bf43 	b.w	8005880 <iqReadTimeout>
 80059fa:	bf00      	nop
 80059fc:	0000      	movs	r0, r0
	...

08005a00 <_sbrk_r>:
caddr_t _sbrk_r(struct _reent *r, int incr)
{
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);
 8005a00:	2900      	cmp	r1, #0
{
 8005a02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(incr >= 0);
 8005a04:	db2d      	blt.n	8005a62 <_sbrk_r+0x62>
 8005a06:	2320      	movs	r3, #32
 8005a08:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005a0c:	4b19      	ldr	r3, [pc, #100]	; (8005a74 <_sbrk_r+0x74>)
 8005a0e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005a10:	b90a      	cbnz	r2, 8005a16 <_sbrk_r+0x16>
 8005a12:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8005a14:	b114      	cbz	r4, 8005a1c <_sbrk_r+0x1c>
    chSysHalt("SV#4");
 8005a16:	4818      	ldr	r0, [pc, #96]	; (8005a78 <_sbrk_r+0x78>)
 8005a18:	f7fb fcca 	bl	80013b0 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8005a1c:	4e17      	ldr	r6, [pc, #92]	; (8005a7c <_sbrk_r+0x7c>)
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8005a1e:	e9d6 7500 	ldrd	r7, r5, [r6]
  size = MEM_ALIGN_NEXT(size, align);
 8005a22:	3103      	adds	r1, #3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8005a24:	1cfa      	adds	r2, r7, #3
  size = MEM_ALIGN_NEXT(size, align);
 8005a26:	f021 0103 	bic.w	r1, r1, #3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8005a2a:	f022 0203 	bic.w	r2, r2, #3
  next = p + size;
 8005a2e:	4411      	add	r1, r2
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8005a30:	42a9      	cmp	r1, r5
 8005a32:	d819      	bhi.n	8005a68 <_sbrk_r+0x68>
 8005a34:	428f      	cmp	r7, r1
 8005a36:	d817      	bhi.n	8005a68 <_sbrk_r+0x68>
  ch_memcore.nextmem = next;
 8005a38:	6031      	str	r1, [r6, #0]
 8005a3a:	6819      	ldr	r1, [r3, #0]
  _dbg_leave_lock();
 8005a3c:	2400      	movs	r4, #0
 8005a3e:	4299      	cmp	r1, r3
 8005a40:	635c      	str	r4, [r3, #52]	; 0x34
 8005a42:	d004      	beq.n	8005a4e <_sbrk_r+0x4e>
 8005a44:	699c      	ldr	r4, [r3, #24]
 8005a46:	688b      	ldr	r3, [r1, #8]
 8005a48:	68a1      	ldr	r1, [r4, #8]
 8005a4a:	4299      	cmp	r1, r3
 8005a4c:	d30e      	bcc.n	8005a6c <_sbrk_r+0x6c>
 8005a4e:	2300      	movs	r3, #0
 8005a50:	f383 8811 	msr	BASEPRI, r3

  p = chCoreAlloc((size_t)incr);
  if (p == NULL) {
 8005a54:	b91a      	cbnz	r2, 8005a5e <_sbrk_r+0x5e>
    __errno_r(r) = ENOMEM;
 8005a56:	230c      	movs	r3, #12
 8005a58:	6003      	str	r3, [r0, #0]
    return (caddr_t)-1;
 8005a5a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8005a5e:	4610      	mov	r0, r2
 8005a60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(incr >= 0);
 8005a62:	4807      	ldr	r0, [pc, #28]	; (8005a80 <_sbrk_r+0x80>)
 8005a64:	f7fb fca4 	bl	80013b0 <chSysHalt>
    return NULL;
 8005a68:	4622      	mov	r2, r4
 8005a6a:	e7e6      	b.n	8005a3a <_sbrk_r+0x3a>
 8005a6c:	4805      	ldr	r0, [pc, #20]	; (8005a84 <_sbrk_r+0x84>)
 8005a6e:	f7fb fc9f 	bl	80013b0 <chSysHalt>
 8005a72:	bf00      	nop
 8005a74:	2000159c 	.word	0x2000159c
 8005a78:	0800e704 	.word	0x0800e704
 8005a7c:	20001fc8 	.word	0x20001fc8
 8005a80:	0800e574 	.word	0x0800e574
 8005a84:	0800e208 	.word	0x0800e208
	...

08005a90 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8005a90:	4a06      	ldr	r2, [pc, #24]	; (8005aac <SVC_Handler+0x1c>)
 8005a92:	6853      	ldr	r3, [r2, #4]
 8005a94:	f023 0301 	bic.w	r3, r3, #1
 8005a98:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005a9a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8005a9e:	3368      	adds	r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8005aa0:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005aa4:	2300      	movs	r3, #0
 8005aa6:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8005aaa:	4770      	bx	lr
 8005aac:	e000ef30 	.word	0xe000ef30

08005ab0 <chThdExit>:
void chThdExit(msg_t msg) {
 8005ab0:	b580      	push	{r7, lr}
 8005ab2:	2320      	movs	r3, #32
 8005ab4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005ab8:	4c33      	ldr	r4, [pc, #204]	; (8005b88 <chThdExit+0xd8>)
 8005aba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005abc:	b90b      	cbnz	r3, 8005ac2 <chThdExit+0x12>
 8005abe:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005ac0:	b111      	cbz	r1, 8005ac8 <chThdExit+0x18>
    chSysHalt("SV#4");
 8005ac2:	4832      	ldr	r0, [pc, #200]	; (8005b8c <chThdExit+0xdc>)
 8005ac4:	f7fb fc74 	bl	80013b0 <chSysHalt>
  thread_t *tp = currp;
 8005ac8:	69a3      	ldr	r3, [r4, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8005aca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8005acc:	f103 0628 	add.w	r6, r3, #40	; 0x28
  _dbg_enter_lock();
 8005ad0:	2501      	movs	r5, #1
 8005ad2:	4296      	cmp	r6, r2
 8005ad4:	6365      	str	r5, [r4, #52]	; 0x34
  tp->u.exitcode = msg;
 8005ad6:	6258      	str	r0, [r3, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8005ad8:	d017      	beq.n	8005b0a <chThdExit+0x5a>
  tlp->next = tp->queue.next;
 8005ada:	6810      	ldr	r0, [r2, #0]
 8005adc:	6298      	str	r0, [r3, #40]	; 0x28
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8005ade:	f892 0020 	ldrb.w	r0, [r2, #32]
 8005ae2:	2800      	cmp	r0, #0
 8005ae4:	d039      	beq.n	8005b5a <chThdExit+0xaa>
 8005ae6:	280f      	cmp	r0, #15
 8005ae8:	d037      	beq.n	8005b5a <chThdExit+0xaa>
  } while (cp->prio >= tp->prio);
 8005aea:	6897      	ldr	r7, [r2, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8005aec:	4826      	ldr	r0, [pc, #152]	; (8005b88 <chThdExit+0xd8>)
  tp->state = CH_STATE_READY;
 8005aee:	f882 1020 	strb.w	r1, [r2, #32]
    cp = cp->queue.next;
 8005af2:	6800      	ldr	r0, [r0, #0]
  } while (cp->prio >= tp->prio);
 8005af4:	6885      	ldr	r5, [r0, #8]
 8005af6:	42bd      	cmp	r5, r7
 8005af8:	d2fb      	bcs.n	8005af2 <chThdExit+0x42>
  tp->queue.prev             = cp->queue.prev;
 8005afa:	6845      	ldr	r5, [r0, #4]
 8005afc:	e9c2 0500 	strd	r0, r5, [r2]
  tp->queue.prev->queue.next = tp;
 8005b00:	602a      	str	r2, [r5, #0]
  cp->queue.prev             = tp;
 8005b02:	6042      	str	r2, [r0, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 8005b04:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005b06:	42b2      	cmp	r2, r6
 8005b08:	d1e7      	bne.n	8005ada <chThdExit+0x2a>
  if ((tp->refs == (trefs_t)0) &&
 8005b0a:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 8005b0e:	b942      	cbnz	r2, 8005b22 <chThdExit+0x72>
 8005b10:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8005b14:	0792      	lsls	r2, r2, #30
 8005b16:	d104      	bne.n	8005b22 <chThdExit+0x72>
    REG_REMOVE(tp);
 8005b18:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
 8005b1c:	6111      	str	r1, [r2, #16]
 8005b1e:	691b      	ldr	r3, [r3, #16]
 8005b20:	615a      	str	r2, [r3, #20]
  thread_t *otp = currp;
 8005b22:	69a5      	ldr	r5, [r4, #24]
  thread_t *tp = tqp->next;
 8005b24:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8005b26:	220f      	movs	r2, #15
 8005b28:	f885 2020 	strb.w	r2, [r5, #32]
  tqp->next             = tp->queue.next;
 8005b2c:	681a      	ldr	r2, [r3, #0]
 8005b2e:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8005b30:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8005b32:	6054      	str	r4, [r2, #4]
 8005b34:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005b38:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005b3a:	61a3      	str	r3, [r4, #24]
 8005b3c:	07d3      	lsls	r3, r2, #31
 8005b3e:	d50f      	bpl.n	8005b60 <chThdExit+0xb0>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005b40:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8005b44:	69ea      	ldr	r2, [r5, #28]
 8005b46:	3b64      	subs	r3, #100	; 0x64
 8005b48:	429a      	cmp	r2, r3
 8005b4a:	d81a      	bhi.n	8005b82 <chThdExit+0xd2>
 8005b4c:	69a0      	ldr	r0, [r4, #24]
 8005b4e:	4629      	mov	r1, r5
 8005b50:	f7fa fbba 	bl	80002c8 <_port_switch>
  chDbgAssert(false, "zombies apocalypse");
 8005b54:	480e      	ldr	r0, [pc, #56]	; (8005b90 <chThdExit+0xe0>)
 8005b56:	f7fb fc2b 	bl	80013b0 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8005b5a:	480e      	ldr	r0, [pc, #56]	; (8005b94 <chThdExit+0xe4>)
 8005b5c:	f7fb fc28 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005b60:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005b62:	6a68      	ldr	r0, [r5, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005b64:	7813      	ldrb	r3, [r2, #0]
 8005b66:	f361 0302 	bfi	r3, r1, #0, #3
 8005b6a:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8005b6c:	f895 1020 	ldrb.w	r1, [r5, #32]
 8005b70:	f361 03c7 	bfi	r3, r1, #3, #5
 8005b74:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8005b76:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005b78:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8005b7c:	f7fb fbf8 	bl	8001370 <trace_next>
 8005b80:	e7de      	b.n	8005b40 <chThdExit+0x90>
  chSysSwitch(currp, otp);
 8005b82:	4805      	ldr	r0, [pc, #20]	; (8005b98 <chThdExit+0xe8>)
 8005b84:	f7fb fc14 	bl	80013b0 <chSysHalt>
 8005b88:	2000159c 	.word	0x2000159c
 8005b8c:	0800e704 	.word	0x0800e704
 8005b90:	0800e33c 	.word	0x0800e33c
 8005b94:	0800e258 	.word	0x0800e258
 8005b98:	0800e71c 	.word	0x0800e71c
 8005b9c:	00000000 	.word	0x00000000

08005ba0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8005ba0:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8005ba2:	4c22      	ldr	r4, [pc, #136]	; (8005c2c <chSchDoReschedule+0x8c>)
  thread_t *tp = tqp->next;
 8005ba4:	6822      	ldr	r2, [r4, #0]
 8005ba6:	69a5      	ldr	r5, [r4, #24]
  tqp->next             = tp->queue.next;
 8005ba8:	6813      	ldr	r3, [r2, #0]
 8005baa:	6023      	str	r3, [r4, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005bac:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8005bae:	605c      	str	r4, [r3, #4]
 8005bb0:	f882 1020 	strb.w	r1, [r2, #32]
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005bb4:	6b21      	ldr	r1, [r4, #48]	; 0x30
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005bb6:	61a2      	str	r2, [r4, #24]
 8005bb8:	2900      	cmp	r1, #0
 8005bba:	db2e      	blt.n	8005c1a <chSchDoReschedule+0x7a>
 8005bbc:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005bbe:	2a00      	cmp	r2, #0
 8005bc0:	dd2b      	ble.n	8005c1a <chSchDoReschedule+0x7a>
  chDbgCheck(tp != NULL);
 8005bc2:	b36d      	cbz	r5, 8005c20 <chSchDoReschedule+0x80>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8005bc4:	f895 2020 	ldrb.w	r2, [r5, #32]
 8005bc8:	b352      	cbz	r2, 8005c20 <chSchDoReschedule+0x80>
 8005bca:	2a0f      	cmp	r2, #15
 8005bcc:	d028      	beq.n	8005c20 <chSchDoReschedule+0x80>
  tp->state = CH_STATE_READY;
 8005bce:	2200      	movs	r2, #0
  } while (cp->prio > tp->prio);
 8005bd0:	68a9      	ldr	r1, [r5, #8]
  tp->state = CH_STATE_READY;
 8005bd2:	f885 2020 	strb.w	r2, [r5, #32]
 8005bd6:	e000      	b.n	8005bda <chSchDoReschedule+0x3a>
 8005bd8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8005bda:	689a      	ldr	r2, [r3, #8]
 8005bdc:	428a      	cmp	r2, r1
 8005bde:	d8fb      	bhi.n	8005bd8 <chSchDoReschedule+0x38>
  tp->queue.prev             = cp->queue.prev;
 8005be0:	685a      	ldr	r2, [r3, #4]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005be2:	8f21      	ldrh	r1, [r4, #56]	; 0x38
 8005be4:	e9c5 3200 	strd	r3, r2, [r5]
  tp->queue.prev->queue.next = tp;
 8005be8:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 8005bea:	605d      	str	r5, [r3, #4]
 8005bec:	07cb      	lsls	r3, r1, #31
 8005bee:	d408      	bmi.n	8005c02 <chSchDoReschedule+0x62>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005bf0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005bf2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005bf4:	2101      	movs	r1, #1
 8005bf6:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8005bf8:	69a1      	ldr	r1, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005bfa:	e9c3 1202 	strd	r1, r2, [r3, #8]
    trace_next();
 8005bfe:	f7fb fbb7 	bl	8001370 <trace_next>
 8005c02:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005c06:	69ea      	ldr	r2, [r5, #28]
 8005c08:	3b64      	subs	r3, #100	; 0x64
 8005c0a:	429a      	cmp	r2, r3
 8005c0c:	d80b      	bhi.n	8005c26 <chSchDoReschedule+0x86>
 8005c0e:	4629      	mov	r1, r5
 8005c10:	69a0      	ldr	r0, [r4, #24]
}
 8005c12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8005c16:	f7fa bb57 	b.w	80002c8 <_port_switch>
    chSysHalt("SV#10");
 8005c1a:	4805      	ldr	r0, [pc, #20]	; (8005c30 <chSchDoReschedule+0x90>)
 8005c1c:	f7fb fbc8 	bl	80013b0 <chSysHalt>
  chDbgCheck(tp != NULL);
 8005c20:	4804      	ldr	r0, [pc, #16]	; (8005c34 <chSchDoReschedule+0x94>)
 8005c22:	f7fb fbc5 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8005c26:	4804      	ldr	r0, [pc, #16]	; (8005c38 <chSchDoReschedule+0x98>)
 8005c28:	f7fb fbc2 	bl	80013b0 <chSysHalt>
 8005c2c:	2000159c 	.word	0x2000159c
 8005c30:	0800e70c 	.word	0x0800e70c
 8005c34:	0800e27c 	.word	0x0800e27c
 8005c38:	0800e71c 	.word	0x0800e71c
 8005c3c:	00000000 	.word	0x00000000

08005c40 <Thread5>:
static THD_FUNCTION(Thread5, arg) {
 8005c40:	b580      	push	{r7, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005c42:	2320      	movs	r3, #32
 8005c44:	b082      	sub	sp, #8
 8005c46:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005c4a:	4c6d      	ldr	r4, [pc, #436]	; (8005e00 <Thread5+0x1c0>)
 8005c4c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c4e:	b90b      	cbnz	r3, 8005c54 <Thread5+0x14>
 8005c50:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005c52:	b113      	cbz	r3, 8005c5a <Thread5+0x1a>
    chSysHalt("SV#4");
 8005c54:	486b      	ldr	r0, [pc, #428]	; (8005e04 <Thread5+0x1c4>)
 8005c56:	f7fb fbab 	bl	80013b0 <chSysHalt>
 8005c5a:	4d6b      	ldr	r5, [pc, #428]	; (8005e08 <Thread5+0x1c8>)
  _dbg_enter_lock();
 8005c5c:	2601      	movs	r6, #1
  tp->queue.next             = (thread_t *)tqp;
 8005c5e:	f105 0720 	add.w	r7, r5, #32
 8005c62:	6366      	str	r6, [r4, #52]	; 0x34
  otp->state = newstate;
 8005c64:	f04f 0804 	mov.w	r8, #4
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005c68:	7d2a      	ldrb	r2, [r5, #20]
 8005c6a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c6c:	2a00      	cmp	r2, #0
 8005c6e:	d12a      	bne.n	8005cc6 <Thread5+0x86>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005c70:	2b00      	cmp	r3, #0
 8005c72:	db6b      	blt.n	8005d4c <Thread5+0x10c>
 8005c74:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005c76:	2a00      	cmp	r2, #0
 8005c78:	dd68      	ble.n	8005d4c <Thread5+0x10c>
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
 8005c7a:	692a      	ldr	r2, [r5, #16]
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8005c7c:	2a00      	cmp	r2, #0
 8005c7e:	f040 8084 	bne.w	8005d8a <Thread5+0x14a>
  queue_insert(currp, tqp);
 8005c82:	69a2      	ldr	r2, [r4, #24]
  tp->queue.prev             = tqp->prev;
 8005c84:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8005c86:	e9c2 7100 	strd	r7, r1, [r2]
  tp->queue.prev->queue.next = tp;
 8005c8a:	600a      	str	r2, [r1, #0]
  tqp->prev                  = tp;
 8005c8c:	626a      	str	r2, [r5, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005c8e:	2b00      	cmp	r3, #0
 8005c90:	d15f      	bne.n	8005d52 <Thread5+0x112>
  thread_t *otp = currp;
 8005c92:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->next;
 8005c94:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8005c96:	f881 8020 	strb.w	r8, [r1, #32]
  tqp->next             = tp->queue.next;
 8005c9a:	681a      	ldr	r2, [r3, #0]
 8005c9c:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005c9e:	6054      	str	r4, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8005ca0:	f883 6020 	strb.w	r6, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005ca4:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005ca6:	61a3      	str	r3, [r4, #24]
 8005ca8:	07d3      	lsls	r3, r2, #31
 8005caa:	d55b      	bpl.n	8005d64 <Thread5+0x124>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005cac:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8005cb0:	69ca      	ldr	r2, [r1, #28]
 8005cb2:	3b64      	subs	r3, #100	; 0x64
 8005cb4:	429a      	cmp	r2, r3
 8005cb6:	d852      	bhi.n	8005d5e <Thread5+0x11e>
 8005cb8:	69a0      	ldr	r0, [r4, #24]
 8005cba:	f7fa fb05 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 8005cbe:	69a3      	ldr	r3, [r4, #24]
      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  } while (rdymsg == MSG_OK);
 8005cc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005cc2:	2b00      	cmp	r3, #0
 8005cc4:	d0d0      	beq.n	8005c68 <Thread5+0x28>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005cc6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cc8:	2b00      	cmp	r3, #0
 8005cca:	d145      	bne.n	8005d58 <Thread5+0x118>
 8005ccc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cce:	2b00      	cmp	r3, #0
 8005cd0:	dd42      	ble.n	8005d58 <Thread5+0x118>
 8005cd2:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8005cd4:	2200      	movs	r2, #0
 8005cd6:	42a3      	cmp	r3, r4
 8005cd8:	6362      	str	r2, [r4, #52]	; 0x34
 8005cda:	d005      	beq.n	8005ce8 <Thread5+0xa8>
 8005cdc:	69a2      	ldr	r2, [r4, #24]
 8005cde:	689b      	ldr	r3, [r3, #8]
 8005ce0:	6892      	ldr	r2, [r2, #8]
 8005ce2:	429a      	cmp	r2, r3
 8005ce4:	f0c0 8085 	bcc.w	8005df2 <Thread5+0x1b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005ce8:	2300      	movs	r3, #0
 8005cea:	f383 8811 	msr	BASEPRI, r3
	    palSetPad(GPIOE,1);
 8005cee:	4b47      	ldr	r3, [pc, #284]	; (8005e0c <Thread5+0x1cc>)
 8005cf0:	2202      	movs	r2, #2
 8005cf2:	831a      	strh	r2, [r3, #24]
 8005cf4:	2320      	movs	r3, #32
 8005cf6:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005cfa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cfc:	2b00      	cmp	r3, #0
 8005cfe:	d1a9      	bne.n	8005c54 <Thread5+0x14>
 8005d00:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005d02:	2b00      	cmp	r3, #0
 8005d04:	d1a6      	bne.n	8005c54 <Thread5+0x14>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8005d06:	2132      	movs	r1, #50	; 0x32
 8005d08:	2008      	movs	r0, #8
  _dbg_enter_lock();
 8005d0a:	6366      	str	r6, [r4, #52]	; 0x34
 8005d0c:	f7fc ff48 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005d10:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8005d12:	bb0a      	cbnz	r2, 8005d58 <Thread5+0x118>
 8005d14:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005d16:	2b00      	cmp	r3, #0
 8005d18:	dd1e      	ble.n	8005d58 <Thread5+0x118>
 8005d1a:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8005d1c:	6362      	str	r2, [r4, #52]	; 0x34
 8005d1e:	42a3      	cmp	r3, r4
 8005d20:	d004      	beq.n	8005d2c <Thread5+0xec>
 8005d22:	69a2      	ldr	r2, [r4, #24]
 8005d24:	689b      	ldr	r3, [r3, #8]
 8005d26:	6892      	ldr	r2, [r2, #8]
 8005d28:	429a      	cmp	r2, r3
 8005d2a:	d365      	bcc.n	8005df8 <Thread5+0x1b8>
 8005d2c:	2300      	movs	r3, #0
 8005d2e:	f383 8811 	msr	BASEPRI, r3
	    palClearPad(GPIOE,1);
 8005d32:	4b36      	ldr	r3, [pc, #216]	; (8005e0c <Thread5+0x1cc>)
 8005d34:	2202      	movs	r2, #2
 8005d36:	835a      	strh	r2, [r3, #26]
 8005d38:	2320      	movs	r3, #32
 8005d3a:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005d3e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005d40:	2b00      	cmp	r3, #0
 8005d42:	d187      	bne.n	8005c54 <Thread5+0x14>
 8005d44:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005d46:	2b00      	cmp	r3, #0
 8005d48:	d184      	bne.n	8005c54 <Thread5+0x14>
 8005d4a:	e78a      	b.n	8005c62 <Thread5+0x22>
    chSysHalt("SV#10");
 8005d4c:	4830      	ldr	r0, [pc, #192]	; (8005e10 <Thread5+0x1d0>)
 8005d4e:	f7fb fb2f 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8005d52:	4830      	ldr	r0, [pc, #192]	; (8005e14 <Thread5+0x1d4>)
 8005d54:	f7fb fb2c 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8005d58:	482f      	ldr	r0, [pc, #188]	; (8005e18 <Thread5+0x1d8>)
 8005d5a:	f7fb fb29 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8005d5e:	482f      	ldr	r0, [pc, #188]	; (8005e1c <Thread5+0x1dc>)
 8005d60:	f7fb fb26 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d64:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005d66:	6a48      	ldr	r0, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d68:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8005d6a:	9101      	str	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d6c:	f366 0302 	bfi	r3, r6, #0, #3
 8005d70:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8005d72:	f891 c020 	ldrb.w	ip, [r1, #32]
 8005d76:	f36c 03c7 	bfi	r3, ip, #3, #5
 8005d7a:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8005d7c:	69a3      	ldr	r3, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005d7e:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8005d82:	f7fb faf5 	bl	8001370 <trace_next>
 8005d86:	9901      	ldr	r1, [sp, #4]
 8005d88:	e790      	b.n	8005cac <Thread5+0x6c>
      *msgp = *mbp->rdptr++;
 8005d8a:	68e9      	ldr	r1, [r5, #12]
      if (mbp->rdptr >= mbp->top) {
 8005d8c:	6868      	ldr	r0, [r5, #4]
      *msgp = *mbp->rdptr++;
 8005d8e:	3104      	adds	r1, #4
      if (mbp->rdptr >= mbp->top) {
 8005d90:	4281      	cmp	r1, r0
      *msgp = *mbp->rdptr++;
 8005d92:	60e9      	str	r1, [r5, #12]
        mbp->rdptr = mbp->buffer;
 8005d94:	bf24      	itt	cs
 8005d96:	6829      	ldrcs	r1, [r5, #0]
 8005d98:	60e9      	strcs	r1, [r5, #12]
  if (queue_notempty(tqp)) {
 8005d9a:	4821      	ldr	r0, [pc, #132]	; (8005e20 <Thread5+0x1e0>)
  return (bool)(tqp->next != (const thread_t *)tqp);
 8005d9c:	69a9      	ldr	r1, [r5, #24]
      mbp->cnt--;
 8005d9e:	3a01      	subs	r2, #1
 8005da0:	4281      	cmp	r1, r0
 8005da2:	612a      	str	r2, [r5, #16]
 8005da4:	d019      	beq.n	8005dda <Thread5+0x19a>
  tqp->next             = tp->queue.next;
 8005da6:	680a      	ldr	r2, [r1, #0]
 8005da8:	61aa      	str	r2, [r5, #24]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005daa:	6050      	str	r0, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8005dac:	f891 2020 	ldrb.w	r2, [r1, #32]
 8005db0:	2a04      	cmp	r2, #4
 8005db2:	d002      	beq.n	8005dba <Thread5+0x17a>
 8005db4:	481b      	ldr	r0, [pc, #108]	; (8005e24 <Thread5+0x1e4>)
 8005db6:	f7fb fafb 	bl	80013b0 <chSysHalt>
  tp->u.rdymsg = msg;
 8005dba:	2000      	movs	r0, #0
  } while (cp->prio >= tp->prio);
 8005dbc:	f8d1 c008 	ldr.w	ip, [r1, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8005dc0:	4a0f      	ldr	r2, [pc, #60]	; (8005e00 <Thread5+0x1c0>)
 8005dc2:	6248      	str	r0, [r1, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8005dc4:	f881 0020 	strb.w	r0, [r1, #32]
    cp = cp->queue.next;
 8005dc8:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8005dca:	6890      	ldr	r0, [r2, #8]
 8005dcc:	4560      	cmp	r0, ip
 8005dce:	d2fb      	bcs.n	8005dc8 <Thread5+0x188>
  tp->queue.prev             = cp->queue.prev;
 8005dd0:	6850      	ldr	r0, [r2, #4]
 8005dd2:	e9c1 2000 	strd	r2, r0, [r1]
  tp->queue.prev->queue.next = tp;
 8005dd6:	6001      	str	r1, [r0, #0]
  cp->queue.prev             = tp;
 8005dd8:	6051      	str	r1, [r2, #4]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005dda:	2b00      	cmp	r3, #0
 8005ddc:	d1b9      	bne.n	8005d52 <Thread5+0x112>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8005dde:	6822      	ldr	r2, [r4, #0]
 8005de0:	69a3      	ldr	r3, [r4, #24]
  if (chSchIsRescRequiredI()) {
 8005de2:	6892      	ldr	r2, [r2, #8]
 8005de4:	689b      	ldr	r3, [r3, #8]
 8005de6:	429a      	cmp	r2, r3
 8005de8:	f67f af73 	bls.w	8005cd2 <Thread5+0x92>
    chSchDoRescheduleAhead();
 8005dec:	f7ff fed8 	bl	8005ba0 <chSchDoReschedule>
 8005df0:	e769      	b.n	8005cc6 <Thread5+0x86>
 8005df2:	480d      	ldr	r0, [pc, #52]	; (8005e28 <Thread5+0x1e8>)
 8005df4:	f7fb fadc 	bl	80013b0 <chSysHalt>
 8005df8:	480c      	ldr	r0, [pc, #48]	; (8005e2c <Thread5+0x1ec>)
 8005dfa:	f7fb fad9 	bl	80013b0 <chSysHalt>
 8005dfe:	bf00      	nop
 8005e00:	2000159c 	.word	0x2000159c
 8005e04:	0800e704 	.word	0x0800e704
 8005e08:	200012e8 	.word	0x200012e8
 8005e0c:	48001000 	.word	0x48001000
 8005e10:	0800e70c 	.word	0x0800e70c
 8005e14:	0800e714 	.word	0x0800e714
 8005e18:	0800e72c 	.word	0x0800e72c
 8005e1c:	0800e71c 	.word	0x0800e71c
 8005e20:	20001300 	.word	0x20001300
 8005e24:	0800e22c 	.word	0x0800e22c
 8005e28:	0800e1fc 	.word	0x0800e1fc
 8005e2c:	0800e1e4 	.word	0x0800e1e4

08005e30 <Thread4>:
static THD_FUNCTION(Thread4, arg) {
 8005e30:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8005e34:	4da1      	ldr	r5, [pc, #644]	; (80060bc <Thread4+0x28c>)
 8005e36:	4ca2      	ldr	r4, [pc, #648]	; (80060c0 <Thread4+0x290>)
	FLASH->KEYR = 0x45670123;
 8005e38:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 80060f0 <Thread4+0x2c0>
			    value = pt100temp5*10.0;
 8005e3c:	f8df 92b4 	ldr.w	r9, [pc, #692]	; 80060f4 <Thread4+0x2c4>
static THD_FUNCTION(Thread4, arg) {
 8005e40:	b08b      	sub	sp, #44	; 0x2c
			    value = pt100temp5*10.0;
 8005e42:	f04f 0800 	mov.w	r8, #0
  tp->queue.next             = (thread_t *)tqp;
 8005e46:	f105 0620 	add.w	r6, r5, #32
 8005e4a:	2320      	movs	r3, #32
 8005e4c:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005e50:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005e52:	b90b      	cbnz	r3, 8005e58 <Thread4+0x28>
 8005e54:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005e56:	b113      	cbz	r3, 8005e5e <Thread4+0x2e>
    chSysHalt("SV#4");
 8005e58:	489a      	ldr	r0, [pc, #616]	; (80060c4 <Thread4+0x294>)
 8005e5a:	f7fb faa9 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 8005e5e:	2301      	movs	r3, #1
 8005e60:	6363      	str	r3, [r4, #52]	; 0x34
  otp->state = newstate;
 8005e62:	f04f 0b04 	mov.w	fp, #4
    if (mbp->reset) {
 8005e66:	7d29      	ldrb	r1, [r5, #20]
 8005e68:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8005e6a:	2900      	cmp	r1, #0
 8005e6c:	d130      	bne.n	8005ed0 <Thread4+0xa0>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005e6e:	2a00      	cmp	r2, #0
 8005e70:	f2c0 8099 	blt.w	8005fa6 <Thread4+0x176>
 8005e74:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005e76:	2900      	cmp	r1, #0
 8005e78:	f340 8095 	ble.w	8005fa6 <Thread4+0x176>
 8005e7c:	6929      	ldr	r1, [r5, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8005e7e:	2900      	cmp	r1, #0
 8005e80:	f040 80b3 	bne.w	8005fea <Thread4+0x1ba>
  queue_insert(currp, tqp);
 8005e84:	69a1      	ldr	r1, [r4, #24]
  tp->queue.prev             = tqp->prev;
 8005e86:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8005e88:	e9c1 6000 	strd	r6, r0, [r1]
  tp->queue.prev->queue.next = tp;
 8005e8c:	6001      	str	r1, [r0, #0]
  tqp->prev                  = tp;
 8005e8e:	6269      	str	r1, [r5, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005e90:	2a00      	cmp	r2, #0
 8005e92:	f040 808b 	bne.w	8005fac <Thread4+0x17c>
  thread_t *otp = currp;
 8005e96:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->next;
 8005e98:	6822      	ldr	r2, [r4, #0]
  otp->state = newstate;
 8005e9a:	f881 b020 	strb.w	fp, [r1, #32]
  tqp->next             = tp->queue.next;
 8005e9e:	6810      	ldr	r0, [r2, #0]
 8005ea0:	6020      	str	r0, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005ea2:	6044      	str	r4, [r0, #4]
  currp->state = CH_STATE_CURRENT;
 8005ea4:	f882 3020 	strb.w	r3, [r2, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005ea8:	8f20      	ldrh	r0, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005eaa:	61a2      	str	r2, [r4, #24]
 8005eac:	07c0      	lsls	r0, r0, #31
 8005eae:	f140 8086 	bpl.w	8005fbe <Thread4+0x18e>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005eb2:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 8005eb6:	69c8      	ldr	r0, [r1, #28]
 8005eb8:	3a64      	subs	r2, #100	; 0x64
 8005eba:	4290      	cmp	r0, r2
 8005ebc:	d87c      	bhi.n	8005fb8 <Thread4+0x188>
 8005ebe:	69a0      	ldr	r0, [r4, #24]
 8005ec0:	9300      	str	r3, [sp, #0]
 8005ec2:	f7fa fa01 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 8005ec6:	69a2      	ldr	r2, [r4, #24]
  } while (rdymsg == MSG_OK);
 8005ec8:	9b00      	ldr	r3, [sp, #0]
 8005eca:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8005ecc:	2a00      	cmp	r2, #0
 8005ece:	d0ca      	beq.n	8005e66 <Thread4+0x36>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005ed0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005ed2:	2b00      	cmp	r3, #0
 8005ed4:	d16d      	bne.n	8005fb2 <Thread4+0x182>
 8005ed6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	dd6a      	ble.n	8005fb2 <Thread4+0x182>
 8005edc:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 8005ede:	2200      	movs	r2, #0
 8005ee0:	42a3      	cmp	r3, r4
 8005ee2:	6362      	str	r2, [r4, #52]	; 0x34
 8005ee4:	d005      	beq.n	8005ef2 <Thread4+0xc2>
 8005ee6:	69a2      	ldr	r2, [r4, #24]
 8005ee8:	689b      	ldr	r3, [r3, #8]
 8005eea:	6892      	ldr	r2, [r2, #8]
 8005eec:	429a      	cmp	r2, r3
 8005eee:	f0c0 80b1 	bcc.w	8006054 <Thread4+0x224>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005ef2:	2300      	movs	r3, #0
 8005ef4:	f383 8811 	msr	BASEPRI, r3
	    memcpy(lcltext,rx_text[rxRow],rxPos);
 8005ef8:	4973      	ldr	r1, [pc, #460]	; (80060c8 <Thread4+0x298>)
	    rxRow = rxRow >> 8;
 8005efa:	123b      	asrs	r3, r7, #8
	    rxPos = rxRow & 0xFF;
 8005efc:	fa5f fb87 	uxtb.w	fp, r7
	    memcpy(lcltext,rx_text[rxRow],rxPos);
 8005f00:	465a      	mov	r2, fp
 8005f02:	eb01 1143 	add.w	r1, r1, r3, lsl #5
 8005f06:	a802      	add	r0, sp, #8
	    rxRow = rxRow >> 8;
 8005f08:	461f      	mov	r7, r3
	    memcpy(lcltext,rx_text[rxRow],rxPos);
 8005f0a:	f7fa fedf 	bl	8000ccc <memcpy>
            if ((lcltext[0] == my_address) &&
 8005f0e:	4b6f      	ldr	r3, [pc, #444]	; (80060cc <Thread4+0x29c>)
 8005f10:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005f14:	781b      	ldrb	r3, [r3, #0]
 8005f16:	4293      	cmp	r3, r2
 8005f18:	d197      	bne.n	8005e4a <Thread4+0x1a>
		(*(uint16_t*)(lcltext+rxPos-2) == CRC16(lcltext,rxPos-2))){
 8005f1a:	ab0a      	add	r3, sp, #40	; 0x28
 8005f1c:	445b      	add	r3, fp
 8005f1e:	f10d 0007 	add.w	r0, sp, #7
 8005f22:	f1ab 0c02 	sub.w	ip, fp, #2
 8005f26:	f833 3c22 	ldrh.w	r3, [r3, #-34]
 8005f2a:	9300      	str	r3, [sp, #0]
      wCRCWord  ^= wCRCTable[nTemp];
 8005f2c:	f8df e1c8 	ldr.w	lr, [pc, #456]	; 80060f8 <Thread4+0x2c8>
 8005f30:	fa10 fc8c 	uxtah	ip, r0, ip
uint16_t wCRCWord = 0xFFFF;
 8005f34:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005f38:	e007      	b.n	8005f4a <Thread4+0x11a>
      nTemp = *nData++ ^ wCRCWord;
 8005f3a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8005f3e:	404b      	eors	r3, r1
      wCRCWord  ^= wCRCTable[nTemp];
 8005f40:	b2db      	uxtb	r3, r3
 8005f42:	f83e 3013 	ldrh.w	r3, [lr, r3, lsl #1]
 8005f46:	ea83 2111 	eor.w	r1, r3, r1, lsr #8
   while (wLength--)
 8005f4a:	4584      	cmp	ip, r0
 8005f4c:	d1f5      	bne.n	8005f3a <Thread4+0x10a>
            if ((lcltext[0] == my_address) &&
 8005f4e:	9b00      	ldr	r3, [sp, #0]
 8005f50:	428b      	cmp	r3, r1
 8005f52:	f47f af7a 	bne.w	8005e4a <Thread4+0x1a>
		command = lcltext[1];		
 8005f56:	f89d 1009 	ldrb.w	r1, [sp, #9]
		palSetPad(GPIOE,0);
 8005f5a:	485d      	ldr	r0, [pc, #372]	; (80060d0 <Thread4+0x2a0>)
		palSetPad(GPIOA,1);
 8005f5c:	f04f 4e90 	mov.w	lr, #1207959552	; 0x48000000
 8005f60:	2302      	movs	r3, #2
		palSetPad(GPIOE,0);
 8005f62:	f04f 0c01 	mov.w	ip, #1
		if (command == 6){
 8005f66:	2906      	cmp	r1, #6
		palSetPad(GPIOA,1);
 8005f68:	f8ae 3018 	strh.w	r3, [lr, #24]
		palSetPad(GPIOE,0);
 8005f6c:	f8a0 c018 	strh.w	ip, [r0, #24]
		if (command == 6){
 8005f70:	f000 80f8 	beq.w	8006164 <Thread4+0x334>
		else if (command == 4)
 8005f74:	2904      	cmp	r1, #4
 8005f76:	d170      	bne.n	800605a <Thread4+0x22a>
			reg = (lcltext[2]<<8)|lcltext[3];
 8005f78:	f89d 100a 	ldrb.w	r1, [sp, #10]
 8005f7c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005f80:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			switch (reg) {
 8005f84:	b21b      	sxth	r3, r3
 8005f86:	3b01      	subs	r3, #1
 8005f88:	2b09      	cmp	r3, #9
 8005f8a:	f200 81d5 	bhi.w	8006338 <Thread4+0x508>
 8005f8e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005f92:	01d1      	.short	0x01d1
 8005f94:	01cd01cf 	.word	0x01cd01cf
 8005f98:	01c901cb 	.word	0x01c901cb
 8005f9c:	0152015e 	.word	0x0152015e
 8005fa0:	01210160 	.word	0x01210160
 8005fa4:	01fa      	.short	0x01fa
    chSysHalt("SV#10");
 8005fa6:	484b      	ldr	r0, [pc, #300]	; (80060d4 <Thread4+0x2a4>)
 8005fa8:	f7fb fa02 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8005fac:	484a      	ldr	r0, [pc, #296]	; (80060d8 <Thread4+0x2a8>)
 8005fae:	f7fb f9ff 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8005fb2:	484a      	ldr	r0, [pc, #296]	; (80060dc <Thread4+0x2ac>)
 8005fb4:	f7fb f9fc 	bl	80013b0 <chSysHalt>
  chSysSwitch(currp, otp);
 8005fb8:	4849      	ldr	r0, [pc, #292]	; (80060e0 <Thread4+0x2b0>)
 8005fba:	f7fb f9f9 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005fbe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005fc0:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005fc4:	7802      	ldrb	r2, [r0, #0]
 8005fc6:	9301      	str	r3, [sp, #4]
 8005fc8:	f363 0202 	bfi	r2, r3, #0, #3
 8005fcc:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8005fce:	f891 e020 	ldrb.w	lr, [r1, #32]
 8005fd2:	9100      	str	r1, [sp, #0]
 8005fd4:	f36e 02c7 	bfi	r2, lr, #3, #5
 8005fd8:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8005fda:	69a2      	ldr	r2, [r4, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005fdc:	e9c0 2c02 	strd	r2, ip, [r0, #8]
    trace_next();
 8005fe0:	f7fb f9c6 	bl	8001370 <trace_next>
 8005fe4:	e9dd 1300 	ldrd	r1, r3, [sp]
 8005fe8:	e763      	b.n	8005eb2 <Thread4+0x82>
      *msgp = *mbp->rdptr++;
 8005fea:	68eb      	ldr	r3, [r5, #12]
      if (mbp->rdptr >= mbp->top) {
 8005fec:	6868      	ldr	r0, [r5, #4]
      *msgp = *mbp->rdptr++;
 8005fee:	681f      	ldr	r7, [r3, #0]
 8005ff0:	3304      	adds	r3, #4
      if (mbp->rdptr >= mbp->top) {
 8005ff2:	4283      	cmp	r3, r0
      *msgp = *mbp->rdptr++;
 8005ff4:	60eb      	str	r3, [r5, #12]
        mbp->rdptr = mbp->buffer;
 8005ff6:	bf24      	itt	cs
 8005ff8:	682b      	ldrcs	r3, [r5, #0]
 8005ffa:	60eb      	strcs	r3, [r5, #12]
  if (queue_notempty(tqp)) {
 8005ffc:	4839      	ldr	r0, [pc, #228]	; (80060e4 <Thread4+0x2b4>)
  return (bool)(tqp->next != (const thread_t *)tqp);
 8005ffe:	69ab      	ldr	r3, [r5, #24]
      mbp->cnt--;
 8006000:	3901      	subs	r1, #1
 8006002:	4283      	cmp	r3, r0
 8006004:	6129      	str	r1, [r5, #16]
 8006006:	d019      	beq.n	800603c <Thread4+0x20c>
  tqp->next             = tp->queue.next;
 8006008:	6819      	ldr	r1, [r3, #0]
 800600a:	61a9      	str	r1, [r5, #24]
  tqp->next->queue.prev = (thread_t *)tqp;
 800600c:	6048      	str	r0, [r1, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800600e:	f893 1020 	ldrb.w	r1, [r3, #32]
 8006012:	2904      	cmp	r1, #4
 8006014:	d002      	beq.n	800601c <Thread4+0x1ec>
 8006016:	4834      	ldr	r0, [pc, #208]	; (80060e8 <Thread4+0x2b8>)
 8006018:	f7fb f9ca 	bl	80013b0 <chSysHalt>
  tp->u.rdymsg = msg;
 800601c:	2000      	movs	r0, #0
  } while (cp->prio >= tp->prio);
 800601e:	f8d3 c008 	ldr.w	ip, [r3, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8006022:	4927      	ldr	r1, [pc, #156]	; (80060c0 <Thread4+0x290>)
 8006024:	6258      	str	r0, [r3, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8006026:	f883 0020 	strb.w	r0, [r3, #32]
    cp = cp->queue.next;
 800602a:	6809      	ldr	r1, [r1, #0]
  } while (cp->prio >= tp->prio);
 800602c:	6888      	ldr	r0, [r1, #8]
 800602e:	4560      	cmp	r0, ip
 8006030:	d2fb      	bcs.n	800602a <Thread4+0x1fa>
  tp->queue.prev             = cp->queue.prev;
 8006032:	6848      	ldr	r0, [r1, #4]
 8006034:	e9c3 1000 	strd	r1, r0, [r3]
  tp->queue.prev->queue.next = tp;
 8006038:	6003      	str	r3, [r0, #0]
  cp->queue.prev             = tp;
 800603a:	604b      	str	r3, [r1, #4]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800603c:	2a00      	cmp	r2, #0
 800603e:	d1b5      	bne.n	8005fac <Thread4+0x17c>
  return firstprio(&ch.rlist.queue) > currp->prio;
 8006040:	6822      	ldr	r2, [r4, #0]
 8006042:	69a3      	ldr	r3, [r4, #24]
  if (chSchIsRescRequiredI()) {
 8006044:	6892      	ldr	r2, [r2, #8]
 8006046:	689b      	ldr	r3, [r3, #8]
 8006048:	429a      	cmp	r2, r3
 800604a:	f67f af47 	bls.w	8005edc <Thread4+0xac>
    chSchDoRescheduleAhead();
 800604e:	f7ff fda7 	bl	8005ba0 <chSchDoReschedule>
 8006052:	e73d      	b.n	8005ed0 <Thread4+0xa0>
 8006054:	4825      	ldr	r0, [pc, #148]	; (80060ec <Thread4+0x2bc>)
 8006056:	f7fb f9ab 	bl	80013b0 <chSysHalt>
		    sdWrite(&SD2,lcltext,rxPos);
 800605a:	4659      	mov	r1, fp
 800605c:	a802      	add	r0, sp, #8
 800605e:	f7ff fa07 	bl	8005470 <oqWriteTimeout.constprop.60>
 8006062:	f8df b098 	ldr.w	fp, [pc, #152]	; 80060fc <Thread4+0x2cc>
  _dbg_enter_lock();
 8006066:	2201      	movs	r2, #1
		while (!(oqIsEmptyI(&(&SD2)->oqueue)))
 8006068:	e9db 1311 	ldrd	r1, r3, [fp, #68]	; 0x44
 800606c:	4299      	cmp	r1, r3
 800606e:	d047      	beq.n	8006100 <Thread4+0x2d0>
 8006070:	2320      	movs	r3, #32
 8006072:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006076:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8006078:	2b00      	cmp	r3, #0
 800607a:	f47f aeed 	bne.w	8005e58 <Thread4+0x28>
 800607e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006080:	2b00      	cmp	r3, #0
 8006082:	f47f aee9 	bne.w	8005e58 <Thread4+0x28>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8006086:	210a      	movs	r1, #10
 8006088:	2008      	movs	r0, #8
  _dbg_enter_lock();
 800608a:	6362      	str	r2, [r4, #52]	; 0x34
 800608c:	9200      	str	r2, [sp, #0]
 800608e:	f7fc fd87 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006092:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8006094:	2900      	cmp	r1, #0
 8006096:	d18c      	bne.n	8005fb2 <Thread4+0x182>
 8006098:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800609a:	2b00      	cmp	r3, #0
 800609c:	dd89      	ble.n	8005fb2 <Thread4+0x182>
 800609e:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 80060a0:	6361      	str	r1, [r4, #52]	; 0x34
 80060a2:	42a3      	cmp	r3, r4
 80060a4:	9a00      	ldr	r2, [sp, #0]
 80060a6:	d005      	beq.n	80060b4 <Thread4+0x284>
 80060a8:	69a1      	ldr	r1, [r4, #24]
 80060aa:	689b      	ldr	r3, [r3, #8]
 80060ac:	6889      	ldr	r1, [r1, #8]
 80060ae:	4299      	cmp	r1, r3
 80060b0:	f0c0 8135 	bcc.w	800631e <Thread4+0x4ee>
 80060b4:	2300      	movs	r3, #0
 80060b6:	f383 8811 	msr	BASEPRI, r3
 80060ba:	e7d5      	b.n	8006068 <Thread4+0x238>
 80060bc:	200012c0 	.word	0x200012c0
 80060c0:	2000159c 	.word	0x2000159c
 80060c4:	0800e704 	.word	0x0800e704
 80060c8:	200020b0 	.word	0x200020b0
 80060cc:	2000207c 	.word	0x2000207c
 80060d0:	48001000 	.word	0x48001000
 80060d4:	0800e70c 	.word	0x0800e70c
 80060d8:	0800e714 	.word	0x0800e714
 80060dc:	0800e72c 	.word	0x0800e72c
 80060e0:	0800e71c 	.word	0x0800e71c
 80060e4:	200012d8 	.word	0x200012d8
 80060e8:	0800e22c 	.word	0x0800e22c
 80060ec:	0800e1fc 	.word	0x0800e1fc
 80060f0:	45670123 	.word	0x45670123
 80060f4:	40240000 	.word	0x40240000
 80060f8:	0801d9f8 	.word	0x0801d9f8
 80060fc:	20001438 	.word	0x20001438
 8006100:	f8db 3038 	ldr.w	r3, [fp, #56]	; 0x38
 8006104:	2b00      	cmp	r3, #0
 8006106:	d0b3      	beq.n	8006070 <Thread4+0x240>
 8006108:	2320      	movs	r3, #32
 800610a:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800610e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8006110:	2b00      	cmp	r3, #0
 8006112:	f47f aea1 	bne.w	8005e58 <Thread4+0x28>
 8006116:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006118:	2b00      	cmp	r3, #0
 800611a:	f47f ae9d 	bne.w	8005e58 <Thread4+0x28>
  _dbg_enter_lock();
 800611e:	2301      	movs	r3, #1
 8006120:	2114      	movs	r1, #20
 8006122:	2008      	movs	r0, #8
 8006124:	6363      	str	r3, [r4, #52]	; 0x34
 8006126:	f7fc fd3b 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800612a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800612c:	2a00      	cmp	r2, #0
 800612e:	f47f af40 	bne.w	8005fb2 <Thread4+0x182>
 8006132:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006134:	2b00      	cmp	r3, #0
 8006136:	f77f af3c 	ble.w	8005fb2 <Thread4+0x182>
 800613a:	6823      	ldr	r3, [r4, #0]
  _dbg_leave_lock();
 800613c:	6362      	str	r2, [r4, #52]	; 0x34
 800613e:	42a3      	cmp	r3, r4
 8006140:	d005      	beq.n	800614e <Thread4+0x31e>
 8006142:	69a2      	ldr	r2, [r4, #24]
 8006144:	689b      	ldr	r3, [r3, #8]
 8006146:	6892      	ldr	r2, [r2, #8]
 8006148:	429a      	cmp	r2, r3
 800614a:	f0c0 80e8 	bcc.w	800631e <Thread4+0x4ee>
 800614e:	2300      	movs	r3, #0
 8006150:	f383 8811 	msr	BASEPRI, r3
		palClearPad(GPIOA,1);
 8006154:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
		palClearPad(GPIOE,0);
 8006158:	4b8c      	ldr	r3, [pc, #560]	; (800638c <Thread4+0x55c>)
		palClearPad(GPIOA,1);
 800615a:	2102      	movs	r1, #2
 800615c:	8351      	strh	r1, [r2, #26]
		palClearPad(GPIOE,0);
 800615e:	2201      	movs	r2, #1
 8006160:	835a      	strh	r2, [r3, #26]
 8006162:	e672      	b.n	8005e4a <Thread4+0x1a>
		    reg = (lcltext[2]<<8)|lcltext[3];
 8006164:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8006168:	f89d 100b 	ldrb.w	r1, [sp, #11]
 800616c:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		    switch (reg){
 8006170:	b209      	sxth	r1, r1
 8006172:	f240 30e9 	movw	r0, #1001	; 0x3e9
 8006176:	4281      	cmp	r1, r0
 8006178:	f000 808d 	beq.w	8006296 <Thread4+0x466>
 800617c:	f240 40d2 	movw	r0, #1234	; 0x4d2
 8006180:	4281      	cmp	r1, r0
 8006182:	d07c      	beq.n	800627e <Thread4+0x44e>
 8006184:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
 8006188:	d06c      	beq.n	8006264 <Thread4+0x434>
      nTemp = *nData++ ^ wCRCWord;
 800618a:	43d2      	mvns	r2, r2
      wCRCWord  ^= wCRCTable[nTemp];
 800618c:	b2d1      	uxtb	r1, r2
 800618e:	4a80      	ldr	r2, [pc, #512]	; (8006390 <Thread4+0x560>)
 8006190:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
 8006194:	f081 00ff 	eor.w	r0, r1, #255	; 0xff
      nTemp = *nData++ ^ wCRCWord;
 8006198:	f080 0186 	eor.w	r1, r0, #134	; 0x86
      wCRCWord  ^= wCRCTable[nTemp];
 800619c:	b2c9      	uxtb	r1, r1
			lcltext[2] = error;
 800619e:	b2db      	uxtb	r3, r3
      wCRCWord  ^= wCRCTable[nTemp];
 80061a0:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
			lcltext[2] = error;
 80061a4:	f88d 300a 	strb.w	r3, [sp, #10]
      wCRCWord  ^= wCRCTable[nTemp];
 80061a8:	ea81 2110 	eor.w	r1, r1, r0, lsr #8
      nTemp = *nData++ ^ wCRCWord;
 80061ac:	404b      	eors	r3, r1
      wCRCWord  ^= wCRCTable[nTemp];
 80061ae:	b2db      	uxtb	r3, r3
			lcltext[1] = 0x86;
 80061b0:	f04f 0c86 	mov.w	ip, #134	; 0x86
      wCRCWord  ^= wCRCTable[nTemp];
 80061b4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
			lcltext[1] = 0x86;
 80061b8:	f88d c009 	strb.w	ip, [sp, #9]
      wCRCWord  ^= wCRCTable[nTemp];
 80061bc:	ea83 2311 	eor.w	r3, r3, r1, lsr #8
			lcltext[5] = 0;
 80061c0:	2200      	movs	r2, #0
			sdWrite(&SD2,lcltext,5);
 80061c2:	a802      	add	r0, sp, #8
 80061c4:	2105      	movs	r1, #5
			*(uint16_t*)(lcltext+3) = CRC16(lcltext,3);
 80061c6:	f8ad 300b 	strh.w	r3, [sp, #11]
			lcltext[5] = 0;
 80061ca:	f88d 200d 	strb.w	r2, [sp, #13]
			sdWrite(&SD2,lcltext,5);
 80061ce:	f7ff f94f 	bl	8005470 <oqWriteTimeout.constprop.60>
 80061d2:	e746      	b.n	8006062 <Thread4+0x232>
			    value = rainRate*100;
 80061d4:	4b6f      	ldr	r3, [pc, #444]	; (8006394 <Thread4+0x564>)
			    value = lifetimeRain*100;
 80061d6:	ed93 7a00 	vldr	s14, [r3]
 80061da:	eddf 7a6f 	vldr	s15, [pc, #444]	; 8006398 <Thread4+0x568>
 80061de:	ee67 7a27 	vmul.f32	s15, s14, s15
 80061e2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80061e6:	ee17 3a90 	vmov	r3, s15
 80061ea:	b218      	sxth	r0, r3
			    lcltext[3] = (value & 0xFF00 ) >> 8;
 80061ec:	ea4f 2c20 	mov.w	ip, r0, asr #8
			    lcltext[1] = 4;
 80061f0:	2104      	movs	r1, #4
			    lcltext[2] = 2;
 80061f2:	2302      	movs	r3, #2
 80061f4:	4a66      	ldr	r2, [pc, #408]	; (8006390 <Thread4+0x560>)
			    lcltext[4] = value & 0xFF ;
 80061f6:	f88d 000c 	strb.w	r0, [sp, #12]
			    lcltext[1] = 4;
 80061fa:	f88d 1009 	strb.w	r1, [sp, #9]
			    lcltext[3] = (value & 0xFF00 ) >> 8;
 80061fe:	f88d c00b 	strb.w	ip, [sp, #11]
			    lcltext[2] = 2;
 8006202:	f88d 300a 	strb.w	r3, [sp, #10]
			    lcltext[4] = value & 0xFF ;
 8006206:	2000      	movs	r0, #0
uint16_t wCRCWord = 0xFFFF;
 8006208:	f64f 71ff 	movw	r1, #65535	; 0xffff
      nTemp = *nData++ ^ wCRCWord;
 800620c:	ab02      	add	r3, sp, #8
 800620e:	5c1b      	ldrb	r3, [r3, r0]
 8006210:	404b      	eors	r3, r1
      wCRCWord  ^= wCRCTable[nTemp];
 8006212:	b2db      	uxtb	r3, r3
 8006214:	3001      	adds	r0, #1
 8006216:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   while (wLength--)
 800621a:	2805      	cmp	r0, #5
      wCRCWord  ^= wCRCTable[nTemp];
 800621c:	ea83 2111 	eor.w	r1, r3, r1, lsr #8
   while (wLength--)
 8006220:	d1f4      	bne.n	800620c <Thread4+0x3dc>
			    lcltext[7] = 0;
 8006222:	2300      	movs	r3, #0
			    *(uint16_t*)(lcltext+5) = CRC16(lcltext,5);
 8006224:	f8ad 100d 	strh.w	r1, [sp, #13]
			    sdWrite(&SD2,lcltext,7);
 8006228:	a802      	add	r0, sp, #8
 800622a:	2107      	movs	r1, #7
			    lcltext[7] = 0;
 800622c:	f88d 300f 	strb.w	r3, [sp, #15]
			    sdWrite(&SD2,lcltext,7);
 8006230:	f7ff f91e 	bl	8005470 <oqWriteTimeout.constprop.60>
 8006234:	e715      	b.n	8006062 <Thread4+0x232>
			    value = pt100temp5*10.0;
 8006236:	4b59      	ldr	r3, [pc, #356]	; (800639c <Thread4+0x56c>)
			    value = windspeed*10.0;
 8006238:	6818      	ldr	r0, [r3, #0]
 800623a:	f7fa f9c7 	bl	80005cc <__aeabi_f2d>
 800623e:	4642      	mov	r2, r8
 8006240:	464b      	mov	r3, r9
 8006242:	f7fa fa1b 	bl	800067c <__aeabi_dmul>
 8006246:	f7fa fcc9 	bl	8000bdc <__aeabi_d2iz>
 800624a:	b200      	sxth	r0, r0
 800624c:	e7ce      	b.n	80061ec <Thread4+0x3bc>
			    value = pt100temp4*10.0;
 800624e:	4b54      	ldr	r3, [pc, #336]	; (80063a0 <Thread4+0x570>)
 8006250:	e7f2      	b.n	8006238 <Thread4+0x408>
			    value = snowoutput;
 8006252:	4b54      	ldr	r3, [pc, #336]	; (80063a4 <Thread4+0x574>)
 8006254:	edd3 7a00 	vldr	s15, [r3]
 8006258:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800625c:	ee17 3a90 	vmov	r3, s15
 8006260:	b218      	sxth	r0, r3
 8006262:	e7c3      	b.n	80061ec <Thread4+0x3bc>
			save_address = (lcltext[4]<<8)|lcltext[5];
 8006264:	4b50      	ldr	r3, [pc, #320]	; (80063a8 <Thread4+0x578>)
 8006266:	f89d 200d 	ldrb.w	r2, [sp, #13]
			chprintf(&SD1,"Hello World - I am now # %d\r\n",save_address);
 800626a:	4950      	ldr	r1, [pc, #320]	; (80063ac <Thread4+0x57c>)
 800626c:	4850      	ldr	r0, [pc, #320]	; (80063b0 <Thread4+0x580>)
			save_address = (lcltext[4]<<8)|lcltext[5];
 800626e:	701a      	strb	r2, [r3, #0]
			chprintf(&SD1,"Hello World - I am now # %d\r\n",save_address);
 8006270:	f7fd fc0e 	bl	8003a90 <chprintf.constprop.14>
			sdWrite(&SD2,lcltext,8);
 8006274:	a802      	add	r0, sp, #8
 8006276:	2108      	movs	r1, #8
 8006278:	f7ff f8fa 	bl	8005470 <oqWriteTimeout.constprop.60>
 800627c:	e6f1      	b.n	8006062 <Thread4+0x232>
			code =  (lcltext[4]<<8)|lcltext[5];
 800627e:	f89d 100c 	ldrb.w	r1, [sp, #12]
 8006282:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8006286:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			if (code==0x1234){
 800628a:	f241 2134 	movw	r1, #4660	; 0x1234
 800628e:	428b      	cmp	r3, r1
 8006290:	d00a      	beq.n	80062a8 <Thread4+0x478>
			    error = 0x04;
 8006292:	2304      	movs	r3, #4
 8006294:	e779      	b.n	800618a <Thread4+0x35a>
			save_baud_rate = (lcltext[4]<<8)|lcltext[5];
 8006296:	4b47      	ldr	r3, [pc, #284]	; (80063b4 <Thread4+0x584>)
 8006298:	f89d 200d 	ldrb.w	r2, [sp, #13]
			chprintf(&SD1,"Hello World - baud_rate # %d\r\n",save_baud_rate);
 800629c:	4946      	ldr	r1, [pc, #280]	; (80063b8 <Thread4+0x588>)
			save_baud_rate = (lcltext[4]<<8)|lcltext[5];
 800629e:	701a      	strb	r2, [r3, #0]
			chprintf(&SD1,"Hello World - baud_rate # %d\r\n",save_baud_rate);
 80062a0:	4843      	ldr	r0, [pc, #268]	; (80063b0 <Thread4+0x580>)
 80062a2:	f7fd fbf5 	bl	8003a90 <chprintf.constprop.14>
 80062a6:	e7e5      	b.n	8006274 <Thread4+0x444>
			    write_flash(((save_baud_rate&0xff)<<8)|(save_address&0xff),flash1);
 80062a8:	4942      	ldr	r1, [pc, #264]	; (80063b4 <Thread4+0x584>)
 80062aa:	4a3f      	ldr	r2, [pc, #252]	; (80063a8 <Thread4+0x578>)
    if (FLASH->CR & FLASH_CR_LOCK){
 80062ac:	4b43      	ldr	r3, [pc, #268]	; (80063bc <Thread4+0x58c>)
			    write_flash(((save_baud_rate&0xff)<<8)|(save_address&0xff),flash1);
 80062ae:	7808      	ldrb	r0, [r1, #0]
 80062b0:	7811      	ldrb	r1, [r2, #0]
    if (FLASH->CR & FLASH_CR_LOCK){
 80062b2:	691a      	ldr	r2, [r3, #16]
 80062b4:	0612      	lsls	r2, r2, #24
			    write_flash(((save_baud_rate&0xff)<<8)|(save_address&0xff),flash1);
 80062b6:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    if (FLASH->CR & FLASH_CR_LOCK){
 80062ba:	d503      	bpl.n	80062c4 <Thread4+0x494>
	FLASH->KEYR = 0xCDEF89AB;
 80062bc:	4a40      	ldr	r2, [pc, #256]	; (80063c0 <Thread4+0x590>)
	FLASH->KEYR = 0x45670123;
 80062be:	f8c3 a004 	str.w	sl, [r3, #4]
	FLASH->KEYR = 0xCDEF89AB;
 80062c2:	605a      	str	r2, [r3, #4]
    FLASH->CR |= FLASH_CR_PER;             // set page erase
 80062c4:	4b3d      	ldr	r3, [pc, #244]	; (80063bc <Thread4+0x58c>)
    FLASH->AR = flash;                     // set page to flash
 80062c6:	483f      	ldr	r0, [pc, #252]	; (80063c4 <Thread4+0x594>)
    FLASH->CR |= FLASH_CR_PER;             // set page erase
 80062c8:	691a      	ldr	r2, [r3, #16]
 80062ca:	f042 0202 	orr.w	r2, r2, #2
 80062ce:	611a      	str	r2, [r3, #16]
    FLASH->AR = flash;                     // set page to flash
 80062d0:	6158      	str	r0, [r3, #20]
    FLASH->CR |= FLASH_CR_STRT;            // start erasing
 80062d2:	691a      	ldr	r2, [r3, #16]
 80062d4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80062d8:	611a      	str	r2, [r3, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80062da:	461a      	mov	r2, r3
 80062dc:	68d0      	ldr	r0, [r2, #12]
 80062de:	07c0      	lsls	r0, r0, #31
 80062e0:	d4fc      	bmi.n	80062dc <Thread4+0x4ac>
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 80062e2:	68da      	ldr	r2, [r3, #12]
    *flash = value;                        // actually write the value
 80062e4:	4837      	ldr	r0, [pc, #220]	; (80063c4 <Thread4+0x594>)
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 80062e6:	f042 0220 	orr.w	r2, r2, #32
 80062ea:	60da      	str	r2, [r3, #12]
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PER)); // found note online that you must
 80062ec:	691a      	ldr	r2, [r3, #16]
    *flash = value;                        // actually write the value
 80062ee:	8001      	strh	r1, [r0, #0]
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PER)); // found note online that you must
 80062f0:	f022 0202 	bic.w	r2, r2, #2
 80062f4:	611a      	str	r2, [r3, #16]
    SET_BIT(FLASH->CR, (FLASH_CR_PG));     // we are already unlocked, trying
 80062f6:	6919      	ldr	r1, [r3, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 80062f8:	4a30      	ldr	r2, [pc, #192]	; (80063bc <Thread4+0x58c>)
    SET_BIT(FLASH->CR, (FLASH_CR_PG));     // we are already unlocked, trying
 80062fa:	f041 0101 	orr.w	r1, r1, #1
 80062fe:	6119      	str	r1, [r3, #16]
    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY); // loop till done
 8006300:	68d3      	ldr	r3, [r2, #12]
 8006302:	07db      	lsls	r3, r3, #31
 8006304:	d4fc      	bmi.n	8006300 <Thread4+0x4d0>
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 8006306:	6913      	ldr	r3, [r2, #16]
			    reset = 1;
 8006308:	492f      	ldr	r1, [pc, #188]	; (80063c8 <Thread4+0x598>)
    CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));  // probably don't need to to this
 800630a:	f023 0301 	bic.w	r3, r3, #1
 800630e:	6113      	str	r3, [r2, #16]
    SET_BIT (FLASH->SR, (FLASH_SR_EOP));   // tech note RM0316 says to clear
 8006310:	68d3      	ldr	r3, [r2, #12]
 8006312:	f043 0320 	orr.w	r3, r3, #32
 8006316:	60d3      	str	r3, [r2, #12]
			    reset = 1;
 8006318:	2301      	movs	r3, #1
 800631a:	700b      	strb	r3, [r1, #0]
 800631c:	e7aa      	b.n	8006274 <Thread4+0x444>
 800631e:	482b      	ldr	r0, [pc, #172]	; (80063cc <Thread4+0x59c>)
 8006320:	f7fb f846 	bl	80013b0 <chSysHalt>
			    value = pt100temp3*10.0;
 8006324:	4b2a      	ldr	r3, [pc, #168]	; (80063d0 <Thread4+0x5a0>)
 8006326:	e787      	b.n	8006238 <Thread4+0x408>
			    value = pt100temp2*10.0;
 8006328:	4b2a      	ldr	r3, [pc, #168]	; (80063d4 <Thread4+0x5a4>)
 800632a:	e785      	b.n	8006238 <Thread4+0x408>
			    value = pt100temp1*10.0;
 800632c:	4b2a      	ldr	r3, [pc, #168]	; (80063d8 <Thread4+0x5a8>)
 800632e:	e783      	b.n	8006238 <Thread4+0x408>
			    value = windspeed*10.0;
 8006330:	4b2a      	ldr	r3, [pc, #168]	; (80063dc <Thread4+0x5ac>)
 8006332:	e781      	b.n	8006238 <Thread4+0x408>
			    value = irradiance3*10.0;
 8006334:	4b2a      	ldr	r3, [pc, #168]	; (80063e0 <Thread4+0x5b0>)
 8006336:	e77f      	b.n	8006238 <Thread4+0x408>
      nTemp = *nData++ ^ wCRCWord;
 8006338:	43d3      	mvns	r3, r2
      wCRCWord  ^= wCRCTable[nTemp];
 800633a:	b2db      	uxtb	r3, r3
 800633c:	4a14      	ldr	r2, [pc, #80]	; (8006390 <Thread4+0x560>)
 800633e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006342:	f083 01ff 	eor.w	r1, r3, #255	; 0xff
      nTemp = *nData++ ^ wCRCWord;
 8006346:	f081 0384 	eor.w	r3, r1, #132	; 0x84
      wCRCWord  ^= wCRCTable[nTemp];
 800634a:	b2db      	uxtb	r3, r3
			    lcltext[1] = 0x84;
 800634c:	f04f 0c84 	mov.w	ip, #132	; 0x84
      wCRCWord  ^= wCRCTable[nTemp];
 8006350:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
			    lcltext[1] = 0x84;
 8006354:	f88d c009 	strb.w	ip, [sp, #9]
      wCRCWord  ^= wCRCTable[nTemp];
 8006358:	ea83 2311 	eor.w	r3, r3, r1, lsr #8
      nTemp = *nData++ ^ wCRCWord;
 800635c:	f083 0102 	eor.w	r1, r3, #2
      wCRCWord  ^= wCRCTable[nTemp];
 8006360:	b2c9      	uxtb	r1, r1
			    lcltext[2] = 0x02;
 8006362:	f04f 0c02 	mov.w	ip, #2
      wCRCWord  ^= wCRCTable[nTemp];
 8006366:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
			    lcltext[2] = 0x02;
 800636a:	f88d c00a 	strb.w	ip, [sp, #10]
      wCRCWord  ^= wCRCTable[nTemp];
 800636e:	ea82 2313 	eor.w	r3, r2, r3, lsr #8
			    sdWrite(&SD2,lcltext,5);
 8006372:	a802      	add	r0, sp, #8
			    lcltext[5] = 0;
 8006374:	2200      	movs	r2, #0
			    sdWrite(&SD2,lcltext,5);
 8006376:	2105      	movs	r1, #5
			    *(uint16_t*)(lcltext+3) = CRC16(lcltext,3);
 8006378:	f8ad 300b 	strh.w	r3, [sp, #11]
			    lcltext[5] = 0;
 800637c:	f88d 200d 	strb.w	r2, [sp, #13]
			    sdWrite(&SD2,lcltext,5);
 8006380:	f7ff f876 	bl	8005470 <oqWriteTimeout.constprop.60>
 8006384:	e66d      	b.n	8006062 <Thread4+0x232>
			    value = lifetimeRain*100;
 8006386:	4b17      	ldr	r3, [pc, #92]	; (80063e4 <Thread4+0x5b4>)
 8006388:	e725      	b.n	80061d6 <Thread4+0x3a6>
 800638a:	bf00      	nop
 800638c:	48001000 	.word	0x48001000
 8006390:	0801d9f8 	.word	0x0801d9f8
 8006394:	200020a0 	.word	0x200020a0
 8006398:	42c80000 	.word	0x42c80000
 800639c:	20002090 	.word	0x20002090
 80063a0:	2000208c 	.word	0x2000208c
 80063a4:	20002508 	.word	0x20002508
 80063a8:	200024c2 	.word	0x200024c2
 80063ac:	0800e148 	.word	0x0800e148
 80063b0:	200013d8 	.word	0x200013d8
 80063b4:	200024c3 	.word	0x200024c3
 80063b8:	0800e168 	.word	0x0800e168
 80063bc:	40022000 	.word	0x40022000
 80063c0:	cdef89ab 	.word	0xcdef89ab
 80063c4:	0803f000 	.word	0x0803f000
 80063c8:	200020a4 	.word	0x200020a4
 80063cc:	0800e1e4 	.word	0x0800e1e4
 80063d0:	20002088 	.word	0x20002088
 80063d4:	20002084 	.word	0x20002084
 80063d8:	20002080 	.word	0x20002080
 80063dc:	20005d48 	.word	0x20005d48
 80063e0:	20002008 	.word	0x20002008
 80063e4:	2000200c 	.word	0x2000200c
	...

080063f0 <Thread3>:
static THD_FUNCTION(Thread3, arg) {
 80063f0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80063f4:	4d31      	ldr	r5, [pc, #196]	; (80064bc <Thread3+0xcc>)
 80063f6:	4c32      	ldr	r4, [pc, #200]	; (80064c0 <Thread3+0xd0>)
 80063f8:	69ab      	ldr	r3, [r5, #24]
 80063fa:	4a32      	ldr	r2, [pc, #200]	; (80064c4 <Thread3+0xd4>)
		  chprintf((BaseSequentialStream*)&SD1,"got char: %x\r\n",b);
 80063fc:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 80064e0 <Thread3+0xf0>
  tp->queue.next             = (thread_t *)tqp;
 8006400:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 80064e4 <Thread3+0xf4>
 8006404:	619a      	str	r2, [r3, #24]
static THD_FUNCTION(Thread3, arg) {
 8006406:	b085      	sub	sp, #20
 8006408:	f104 060c 	add.w	r6, r4, #12
 800640c:	2320      	movs	r3, #32
 800640e:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006412:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8006414:	b90b      	cbnz	r3, 800641a <Thread3+0x2a>
 8006416:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8006418:	b113      	cbz	r3, 8006420 <Thread3+0x30>
    chSysHalt("SV#4");
 800641a:	482b      	ldr	r0, [pc, #172]	; (80064c8 <Thread3+0xd8>)
 800641c:	f7fa ffc8 	bl	80013b0 <chSysHalt>
  _dbg_enter_lock();
 8006420:	2301      	movs	r3, #1
 8006422:	636b      	str	r3, [r5, #52]	; 0x34
 8006424:	e00b      	b.n	800643e <Thread3+0x4e>
  queue_insert(currp, tqp);
 8006426:	69ab      	ldr	r3, [r5, #24]
 8006428:	601e      	str	r6, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800642a:	6922      	ldr	r2, [r4, #16]
 800642c:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800642e:	2114      	movs	r1, #20
  tp->queue.prev->queue.next = tp;
 8006430:	6013      	str	r3, [r2, #0]
 8006432:	2004      	movs	r0, #4
  tqp->prev                  = tp;
 8006434:	6123      	str	r3, [r4, #16]
 8006436:	f7fc fbb3 	bl	8002ba0 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 800643a:	2800      	cmp	r0, #0
 800643c:	db54      	blt.n	80064e8 <Thread3+0xf8>
  while (iqIsEmptyI(iqp)) {
 800643e:	6963      	ldr	r3, [r4, #20]
 8006440:	2b00      	cmp	r3, #0
 8006442:	d0f0      	beq.n	8006426 <Thread3+0x36>
  b = *iqp->q_rdptr++;
 8006444:	6a60      	ldr	r0, [r4, #36]	; 0x24
  iqp->q_counter--;
 8006446:	6963      	ldr	r3, [r4, #20]
  if (iqp->q_rdptr >= iqp->q_top) {
 8006448:	69e1      	ldr	r1, [r4, #28]
  b = *iqp->q_rdptr++;
 800644a:	1c42      	adds	r2, r0, #1
  iqp->q_counter--;
 800644c:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800644e:	428a      	cmp	r2, r1
  iqp->q_counter--;
 8006450:	6163      	str	r3, [r4, #20]
  b = *iqp->q_rdptr++;
 8006452:	6262      	str	r2, [r4, #36]	; 0x24
    iqp->q_rdptr = iqp->q_buffer;
 8006454:	bf28      	it	cs
 8006456:	69a3      	ldrcs	r3, [r4, #24]
  b = *iqp->q_rdptr++;
 8006458:	f890 8000 	ldrb.w	r8, [r0]
    iqp->q_rdptr = iqp->q_buffer;
 800645c:	bf28      	it	cs
 800645e:	6263      	strcs	r3, [r4, #36]	; 0x24
  if (iqp->q_notify != NULL) {
 8006460:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006462:	b10b      	cbz	r3, 8006468 <Thread3+0x78>
    iqp->q_notify(iqp);
 8006464:	4630      	mov	r0, r6
 8006466:	4798      	blx	r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006468:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800646a:	bb1b      	cbnz	r3, 80064b4 <Thread3+0xc4>
 800646c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800646e:	2a00      	cmp	r2, #0
 8006470:	dd20      	ble.n	80064b4 <Thread3+0xc4>
 8006472:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 8006474:	636b      	str	r3, [r5, #52]	; 0x34
 8006476:	42aa      	cmp	r2, r5
 8006478:	d005      	beq.n	8006486 <Thread3+0x96>
 800647a:	69a9      	ldr	r1, [r5, #24]
 800647c:	6893      	ldr	r3, [r2, #8]
 800647e:	688a      	ldr	r2, [r1, #8]
 8006480:	429a      	cmp	r2, r3
 8006482:	f0c0 814a 	bcc.w	800671a <Thread3+0x32a>
 8006486:	2300      	movs	r3, #0
 8006488:	f383 8811 	msr	BASEPRI, r3
	  if ((b!= Q_TIMEOUT) && (rx_queue_pos < 31))
 800648c:	4f0f      	ldr	r7, [pc, #60]	; (80064cc <Thread3+0xdc>)
 800648e:	683b      	ldr	r3, [r7, #0]
 8006490:	2b1e      	cmp	r3, #30
 8006492:	dcbb      	bgt.n	800640c <Thread3+0x1c>
		  chprintf((BaseSequentialStream*)&SD1,"got char: %x\r\n",b);
 8006494:	4642      	mov	r2, r8
 8006496:	4651      	mov	r1, sl
 8006498:	480d      	ldr	r0, [pc, #52]	; (80064d0 <Thread3+0xe0>)
 800649a:	f7fd faf9 	bl	8003a90 <chprintf.constprop.14>
		  rx_text[rx_queue_num][rx_queue_pos++]=b;
 800649e:	4a0d      	ldr	r2, [pc, #52]	; (80064d4 <Thread3+0xe4>)
 80064a0:	4b0d      	ldr	r3, [pc, #52]	; (80064d8 <Thread3+0xe8>)
 80064a2:	6811      	ldr	r1, [r2, #0]
 80064a4:	683a      	ldr	r2, [r7, #0]
 80064a6:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 80064aa:	1c51      	adds	r1, r2, #1
 80064ac:	f803 8002 	strb.w	r8, [r3, r2]
 80064b0:	6039      	str	r1, [r7, #0]
 80064b2:	e7ab      	b.n	800640c <Thread3+0x1c>
    chSysHalt("SV#5");
 80064b4:	4809      	ldr	r0, [pc, #36]	; (80064dc <Thread3+0xec>)
 80064b6:	f7fa ff7b 	bl	80013b0 <chSysHalt>
 80064ba:	bf00      	nop
 80064bc:	2000159c 	.word	0x2000159c
 80064c0:	20001438 	.word	0x20001438
 80064c4:	0800e130 	.word	0x0800e130
 80064c8:	0800e704 	.word	0x0800e704
 80064cc:	200020ac 	.word	0x200020ac
 80064d0:	200013d8 	.word	0x200013d8
 80064d4:	200020a8 	.word	0x200020a8
 80064d8:	200020b0 	.word	0x200020b0
 80064dc:	0800e72c 	.word	0x0800e72c
 80064e0:	0800e138 	.word	0x0800e138
 80064e4:	20001300 	.word	0x20001300
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80064e8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80064ea:	4680      	mov	r8, r0
 80064ec:	2b00      	cmp	r3, #0
 80064ee:	d1e1      	bne.n	80064b4 <Thread3+0xc4>
 80064f0:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80064f2:	2a00      	cmp	r2, #0
 80064f4:	ddde      	ble.n	80064b4 <Thread3+0xc4>
 80064f6:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 80064f8:	636b      	str	r3, [r5, #52]	; 0x34
 80064fa:	42aa      	cmp	r2, r5
 80064fc:	d005      	beq.n	800650a <Thread3+0x11a>
 80064fe:	69a9      	ldr	r1, [r5, #24]
 8006500:	6893      	ldr	r3, [r2, #8]
 8006502:	688a      	ldr	r2, [r1, #8]
 8006504:	429a      	cmp	r2, r3
 8006506:	f0c0 8108 	bcc.w	800671a <Thread3+0x32a>
 800650a:	2200      	movs	r2, #0
 800650c:	f382 8811 	msr	BASEPRI, r2
	  if ((b!= Q_TIMEOUT) && (rx_queue_pos < 31))
 8006510:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8006514:	d1ba      	bne.n	800648c <Thread3+0x9c>
	  if ((b == Q_TIMEOUT) && (rx_queue_pos > 0))
 8006516:	4f9a      	ldr	r7, [pc, #616]	; (8006780 <Thread3+0x390>)
 8006518:	f8d7 8000 	ldr.w	r8, [r7]
 800651c:	f1b8 0f00 	cmp.w	r8, #0
 8006520:	f77f af74 	ble.w	800640c <Thread3+0x1c>
		  rx_text[rx_queue_num][rx_queue_pos] = 0;
 8006524:	f8df 927c 	ldr.w	r9, [pc, #636]	; 80067a4 <Thread3+0x3b4>
 8006528:	4996      	ldr	r1, [pc, #600]	; (8006784 <Thread3+0x394>)
 800652a:	f8d9 3000 	ldr.w	r3, [r9]
 800652e:	eb01 1043 	add.w	r0, r1, r3, lsl #5
 8006532:	2120      	movs	r1, #32
 8006534:	f800 2008 	strb.w	r2, [r0, r8]
 8006538:	f381 8811 	msr	BASEPRI, r1
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800653c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800653e:	2a00      	cmp	r2, #0
 8006540:	f47f af6b 	bne.w	800641a <Thread3+0x2a>
 8006544:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8006546:	2a00      	cmp	r2, #0
 8006548:	f47f af67 	bne.w	800641a <Thread3+0x2a>
  _dbg_enter_lock();
 800654c:	2201      	movs	r2, #1
  otp->state = newstate;
 800654e:	e9cd 2301 	strd	r2, r3, [sp, #4]
 8006552:	636a      	str	r2, [r5, #52]	; 0x34
    if (mbp->reset) {
 8006554:	4b8c      	ldr	r3, [pc, #560]	; (8006788 <Thread3+0x398>)
 8006556:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006558:	7d1b      	ldrb	r3, [r3, #20]
 800655a:	2b00      	cmp	r3, #0
 800655c:	d13a      	bne.n	80065d4 <Thread3+0x1e4>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800655e:	2a00      	cmp	r2, #0
 8006560:	f2c0 80de 	blt.w	8006720 <Thread3+0x330>
 8006564:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8006566:	2b00      	cmp	r3, #0
 8006568:	f340 80da 	ble.w	8006720 <Thread3+0x330>
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800656c:	4986      	ldr	r1, [pc, #536]	; (8006788 <Thread3+0x398>)
 800656e:	e9d1 3000 	ldrd	r3, r0, [r1]
  return mbp->cnt;
 8006572:	6909      	ldr	r1, [r1, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8006574:	eba0 0c03 	sub.w	ip, r0, r3
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8006578:	ebb1 0fac 	cmp.w	r1, ip, asr #2
 800657c:	f040 8116 	bne.w	80067ac <Thread3+0x3bc>
  tp->queue.prev             = tqp->prev;
 8006580:	4881      	ldr	r0, [pc, #516]	; (8006788 <Thread3+0x398>)
  queue_insert(currp, tqp);
 8006582:	69ab      	ldr	r3, [r5, #24]
 8006584:	69c1      	ldr	r1, [r0, #28]
  tp->queue.next             = (thread_t *)tqp;
 8006586:	3018      	adds	r0, #24
  tp->queue.prev             = tqp->prev;
 8006588:	e9c3 0100 	strd	r0, r1, [r3]
  tp->queue.prev->queue.next = tp;
 800658c:	600b      	str	r3, [r1, #0]
  tqp->prev                  = tp;
 800658e:	6043      	str	r3, [r0, #4]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006590:	2a00      	cmp	r2, #0
 8006592:	f040 80cd 	bne.w	8006730 <Thread3+0x340>
  thread_t *otp = currp;
 8006596:	69a9      	ldr	r1, [r5, #24]
  thread_t *tp = tqp->next;
 8006598:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 800659a:	f04f 0204 	mov.w	r2, #4
 800659e:	f881 2020 	strb.w	r2, [r1, #32]
  tqp->next             = tp->queue.next;
 80065a2:	681a      	ldr	r2, [r3, #0]
 80065a4:	602a      	str	r2, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80065a6:	6055      	str	r5, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 80065a8:	9a01      	ldr	r2, [sp, #4]
 80065aa:	f883 2020 	strb.w	r2, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80065ae:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 80065b0:	61ab      	str	r3, [r5, #24]
 80065b2:	07d2      	lsls	r2, r2, #31
 80065b4:	f140 8172 	bpl.w	800689c <Thread3+0x4ac>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80065b8:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 80065bc:	69cb      	ldr	r3, [r1, #28]
 80065be:	3a64      	subs	r2, #100	; 0x64
 80065c0:	4293      	cmp	r3, r2
 80065c2:	f200 8168 	bhi.w	8006896 <Thread3+0x4a6>
 80065c6:	69a8      	ldr	r0, [r5, #24]
 80065c8:	f7f9 fe7e 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 80065cc:	69ab      	ldr	r3, [r5, #24]
  } while (rdymsg == MSG_OK);
 80065ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80065d0:	2b00      	cmp	r3, #0
 80065d2:	d0bf      	beq.n	8006554 <Thread3+0x164>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80065d4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80065d6:	2a00      	cmp	r2, #0
 80065d8:	f47f af6c 	bne.w	80064b4 <Thread3+0xc4>
 80065dc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80065de:	2a00      	cmp	r2, #0
 80065e0:	f77f af68 	ble.w	80064b4 <Thread3+0xc4>
 80065e4:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 80065e6:	2100      	movs	r1, #0
 80065e8:	42aa      	cmp	r2, r5
 80065ea:	6369      	str	r1, [r5, #52]	; 0x34
 80065ec:	d005      	beq.n	80065fa <Thread3+0x20a>
 80065ee:	69a9      	ldr	r1, [r5, #24]
 80065f0:	6892      	ldr	r2, [r2, #8]
 80065f2:	6889      	ldr	r1, [r1, #8]
 80065f4:	4291      	cmp	r1, r2
 80065f6:	f0c0 809e 	bcc.w	8006736 <Thread3+0x346>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80065fa:	2200      	movs	r2, #0
 80065fc:	f382 8811 	msr	BASEPRI, r2
		  chMBPostTimeout(&RxMbx2,(rx_queue_num<<8)|rx_queue_pos,TIME_INFINITE); // let our mailbox know
 8006600:	683a      	ldr	r2, [r7, #0]
 8006602:	f8d9 1000 	ldr.w	r1, [r9]
 8006606:	ea42 2301 	orr.w	r3, r2, r1, lsl #8
 800660a:	9302      	str	r3, [sp, #8]
 800660c:	2220      	movs	r2, #32
 800660e:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006612:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006614:	2a00      	cmp	r2, #0
 8006616:	f47f af00 	bne.w	800641a <Thread3+0x2a>
 800661a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800661c:	2a00      	cmp	r2, #0
 800661e:	f47f aefc 	bne.w	800641a <Thread3+0x2a>
  _dbg_enter_lock();
 8006622:	2201      	movs	r2, #1
 8006624:	f8df 8180 	ldr.w	r8, [pc, #384]	; 80067a8 <Thread3+0x3b8>
 8006628:	636a      	str	r2, [r5, #52]	; 0x34
  currp->state = CH_STATE_CURRENT;
 800662a:	9201      	str	r2, [sp, #4]
    if (mbp->reset) {
 800662c:	f898 3014 	ldrb.w	r3, [r8, #20]
 8006630:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006632:	2b00      	cmp	r3, #0
 8006634:	d149      	bne.n	80066ca <Thread3+0x2da>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006636:	2a00      	cmp	r2, #0
 8006638:	db72      	blt.n	8006720 <Thread3+0x330>
 800663a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800663c:	2b00      	cmp	r3, #0
 800663e:	dd6f      	ble.n	8006720 <Thread3+0x330>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8006640:	e9d8 1000 	ldrd	r1, r0, [r8]
  return mbp->cnt;
 8006644:	f8d8 3010 	ldr.w	r3, [r8, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8006648:	eba0 0c01 	sub.w	ip, r0, r1
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 800664c:	ebb3 0fac 	cmp.w	r3, ip, asr #2
 8006650:	d174      	bne.n	800673c <Thread3+0x34c>
 8006652:	69ab      	ldr	r3, [r5, #24]
  tp->queue.prev             = tqp->prev;
 8006654:	f8d8 101c 	ldr.w	r1, [r8, #28]
 8006658:	e9c3 b100 	strd	fp, r1, [r3]
  tp->queue.prev->queue.next = tp;
 800665c:	600b      	str	r3, [r1, #0]
  tqp->prev                  = tp;
 800665e:	f8c8 301c 	str.w	r3, [r8, #28]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006662:	2a00      	cmp	r2, #0
 8006664:	d164      	bne.n	8006730 <Thread3+0x340>
  thread_t *otp = currp;
 8006666:	69a9      	ldr	r1, [r5, #24]
  thread_t *tp = tqp->next;
 8006668:	682b      	ldr	r3, [r5, #0]
  otp->state = newstate;
 800666a:	f04f 0204 	mov.w	r2, #4
 800666e:	f881 2020 	strb.w	r2, [r1, #32]
  tqp->next             = tp->queue.next;
 8006672:	681a      	ldr	r2, [r3, #0]
 8006674:	602a      	str	r2, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8006676:	6055      	str	r5, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8006678:	9a01      	ldr	r2, [sp, #4]
 800667a:	f883 2020 	strb.w	r2, [r3, #32]
 800667e:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8006680:	61ab      	str	r3, [r5, #24]
 8006682:	07d3      	lsls	r3, r2, #31
 8006684:	d413      	bmi.n	80066ae <Thread3+0x2be>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8006686:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8006688:	9801      	ldr	r0, [sp, #4]
 800668a:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800668c:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8006690:	9103      	str	r1, [sp, #12]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8006692:	f360 0302 	bfi	r3, r0, #0, #3
 8006696:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8006698:	f891 c020 	ldrb.w	ip, [r1, #32]
 800669c:	f36c 03c7 	bfi	r3, ip, #3, #5
 80066a0:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80066a2:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80066a4:	e9c2 3e02 	strd	r3, lr, [r2, #8]
    trace_next();
 80066a8:	f7fa fe62 	bl	8001370 <trace_next>
 80066ac:	9903      	ldr	r1, [sp, #12]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80066ae:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 80066b2:	69ca      	ldr	r2, [r1, #28]
 80066b4:	3b64      	subs	r3, #100	; 0x64
 80066b6:	429a      	cmp	r2, r3
 80066b8:	f200 80ed 	bhi.w	8006896 <Thread3+0x4a6>
 80066bc:	69a8      	ldr	r0, [r5, #24]
 80066be:	f7f9 fe03 	bl	80002c8 <_port_switch>
  return currp->u.rdymsg;
 80066c2:	69ab      	ldr	r3, [r5, #24]
  } while (rdymsg == MSG_OK);
 80066c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80066c6:	2b00      	cmp	r3, #0
 80066c8:	d0b0      	beq.n	800662c <Thread3+0x23c>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80066ca:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80066cc:	2a00      	cmp	r2, #0
 80066ce:	f47f aef1 	bne.w	80064b4 <Thread3+0xc4>
 80066d2:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80066d4:	2a00      	cmp	r2, #0
 80066d6:	f77f aeed 	ble.w	80064b4 <Thread3+0xc4>
 80066da:	682a      	ldr	r2, [r5, #0]
  _dbg_leave_lock();
 80066dc:	2100      	movs	r1, #0
 80066de:	42aa      	cmp	r2, r5
 80066e0:	6369      	str	r1, [r5, #52]	; 0x34
 80066e2:	d004      	beq.n	80066ee <Thread3+0x2fe>
 80066e4:	69a9      	ldr	r1, [r5, #24]
 80066e6:	6892      	ldr	r2, [r2, #8]
 80066e8:	6889      	ldr	r1, [r1, #8]
 80066ea:	4291      	cmp	r1, r2
 80066ec:	d323      	bcc.n	8006736 <Thread3+0x346>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80066ee:	2100      	movs	r1, #0
 80066f0:	f381 8811 	msr	BASEPRI, r1
		  rx_queue_num = (++rx_queue_num)%32;
 80066f4:	f8d9 2000 	ldr.w	r2, [r9]
		  memset(rx_text[rx_queue_num],0,5);
 80066f8:	4b22      	ldr	r3, [pc, #136]	; (8006784 <Thread3+0x394>)
		  rx_queue_pos = 0;
 80066fa:	6039      	str	r1, [r7, #0]
		  rx_queue_num = (++rx_queue_num)%32;
 80066fc:	3201      	adds	r2, #1
 80066fe:	1a88      	subs	r0, r1, r2
 8006700:	f000 001f 	and.w	r0, r0, #31
 8006704:	f002 021f 	and.w	r2, r2, #31
 8006708:	bf58      	it	pl
 800670a:	4242      	negpl	r2, r0
		  memset(rx_text[rx_queue_num],0,5);
 800670c:	0150      	lsls	r0, r2, #5
 800670e:	181f      	adds	r7, r3, r0
 8006710:	5019      	str	r1, [r3, r0]
		  rx_queue_num = (++rx_queue_num)%32;
 8006712:	f8c9 2000 	str.w	r2, [r9]
		  memset(rx_text[rx_queue_num],0,5);
 8006716:	7139      	strb	r1, [r7, #4]
 8006718:	e678      	b.n	800640c <Thread3+0x1c>
 800671a:	481c      	ldr	r0, [pc, #112]	; (800678c <Thread3+0x39c>)
 800671c:	f7fa fe48 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#10");
 8006720:	481b      	ldr	r0, [pc, #108]	; (8006790 <Thread3+0x3a0>)
 8006722:	f7fa fe45 	bl	80013b0 <chSysHalt>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006726:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006728:	b912      	cbnz	r2, 8006730 <Thread3+0x340>
 800672a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800672c:	2a00      	cmp	r2, #0
 800672e:	dc79      	bgt.n	8006824 <Thread3+0x434>
    chSysHalt("SV#11");
 8006730:	4818      	ldr	r0, [pc, #96]	; (8006794 <Thread3+0x3a4>)
 8006732:	f7fa fe3d 	bl	80013b0 <chSysHalt>
 8006736:	4818      	ldr	r0, [pc, #96]	; (8006798 <Thread3+0x3a8>)
 8006738:	f7fa fe3a 	bl	80013b0 <chSysHalt>
      *mbp->wrptr++ = msg;
 800673c:	f8d8 e008 	ldr.w	lr, [r8, #8]
 8006740:	f10e 0c04 	add.w	ip, lr, #4
      if (mbp->wrptr >= mbp->top) {
 8006744:	4560      	cmp	r0, ip
 8006746:	461a      	mov	r2, r3
      *mbp->wrptr++ = msg;
 8006748:	9b02      	ldr	r3, [sp, #8]
 800674a:	f8c8 c008 	str.w	ip, [r8, #8]
  if (queue_notempty(tqp)) {
 800674e:	4813      	ldr	r0, [pc, #76]	; (800679c <Thread3+0x3ac>)
 8006750:	f8ce 3000 	str.w	r3, [lr]
        mbp->wrptr = mbp->buffer;
 8006754:	bf98      	it	ls
 8006756:	f8c8 1008 	strls.w	r1, [r8, #8]
  return (bool)(tqp->next != (const thread_t *)tqp);
 800675a:	f8d8 1020 	ldr.w	r1, [r8, #32]
      mbp->cnt++;
 800675e:	3201      	adds	r2, #1
 8006760:	4281      	cmp	r1, r0
 8006762:	f8c8 2010 	str.w	r2, [r8, #16]
 8006766:	f000 8084 	beq.w	8006872 <Thread3+0x482>
  tqp->next             = tp->queue.next;
 800676a:	680a      	ldr	r2, [r1, #0]
 800676c:	f8c8 2020 	str.w	r2, [r8, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 8006770:	6050      	str	r0, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8006772:	f891 2020 	ldrb.w	r2, [r1, #32]
 8006776:	2a04      	cmp	r2, #4
 8006778:	d05e      	beq.n	8006838 <Thread3+0x448>
 800677a:	4809      	ldr	r0, [pc, #36]	; (80067a0 <Thread3+0x3b0>)
 800677c:	f7fa fe18 	bl	80013b0 <chSysHalt>
 8006780:	200020ac 	.word	0x200020ac
 8006784:	200020b0 	.word	0x200020b0
 8006788:	200012c0 	.word	0x200012c0
 800678c:	0800e240 	.word	0x0800e240
 8006790:	0800e70c 	.word	0x0800e70c
 8006794:	0800e714 	.word	0x0800e714
 8006798:	0800e1fc 	.word	0x0800e1fc
 800679c:	20001308 	.word	0x20001308
 80067a0:	0800e22c 	.word	0x0800e22c
 80067a4:	200020a8 	.word	0x200020a8
 80067a8:	200012e8 	.word	0x200012e8
      *mbp->wrptr++ = msg;
 80067ac:	4a46      	ldr	r2, [pc, #280]	; (80068c8 <Thread3+0x4d8>)
 80067ae:	9301      	str	r3, [sp, #4]
 80067b0:	f8d2 c008 	ldr.w	ip, [r2, #8]
 80067b4:	9b02      	ldr	r3, [sp, #8]
 80067b6:	f10c 0e04 	add.w	lr, ip, #4
		  chMBPostTimeout(&RxMbx,(rx_queue_num<<8)|rx_queue_pos,TIME_INFINITE); // let our mailbox know
 80067ba:	ea48 2203 	orr.w	r2, r8, r3, lsl #8
 80067be:	4b42      	ldr	r3, [pc, #264]	; (80068c8 <Thread3+0x4d8>)
      if (mbp->wrptr >= mbp->top) {
 80067c0:	4570      	cmp	r0, lr
      *mbp->wrptr++ = msg;
 80067c2:	f8c3 e008 	str.w	lr, [r3, #8]
 80067c6:	f8cc 2000 	str.w	r2, [ip]
      if (mbp->wrptr >= mbp->top) {
 80067ca:	d802      	bhi.n	80067d2 <Thread3+0x3e2>
        mbp->wrptr = mbp->buffer;
 80067cc:	461a      	mov	r2, r3
 80067ce:	9b01      	ldr	r3, [sp, #4]
 80067d0:	6093      	str	r3, [r2, #8]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80067d2:	4b3d      	ldr	r3, [pc, #244]	; (80068c8 <Thread3+0x4d8>)
 80067d4:	6a1a      	ldr	r2, [r3, #32]
 80067d6:	f103 0020 	add.w	r0, r3, #32
      mbp->cnt++;
 80067da:	3101      	adds	r1, #1
 80067dc:	4282      	cmp	r2, r0
 80067de:	6119      	str	r1, [r3, #16]
 80067e0:	d0a1      	beq.n	8006726 <Thread3+0x336>
  tqp->next             = tp->queue.next;
 80067e2:	6811      	ldr	r1, [r2, #0]
 80067e4:	6219      	str	r1, [r3, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 80067e6:	6048      	str	r0, [r1, #4]
 80067e8:	f892 1020 	ldrb.w	r1, [r2, #32]
 80067ec:	2904      	cmp	r1, #4
 80067ee:	d1c4      	bne.n	800677a <Thread3+0x38a>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80067f0:	f8d5 c030 	ldr.w	ip, [r5, #48]	; 0x30
  tp->u.rdymsg = msg;
 80067f4:	2100      	movs	r1, #0
 80067f6:	458c      	cmp	ip, r1
 80067f8:	6251      	str	r1, [r2, #36]	; 0x24
 80067fa:	db91      	blt.n	8006720 <Thread3+0x330>
 80067fc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80067fe:	428b      	cmp	r3, r1
 8006800:	dd8e      	ble.n	8006720 <Thread3+0x330>
  } while (cp->prio >= tp->prio);
 8006802:	f8d2 8008 	ldr.w	r8, [r2, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8006806:	4831      	ldr	r0, [pc, #196]	; (80068cc <Thread3+0x4dc>)
  tp->state = CH_STATE_READY;
 8006808:	f882 1020 	strb.w	r1, [r2, #32]
    cp = cp->queue.next;
 800680c:	6800      	ldr	r0, [r0, #0]
  } while (cp->prio >= tp->prio);
 800680e:	6883      	ldr	r3, [r0, #8]
 8006810:	4543      	cmp	r3, r8
 8006812:	d2fb      	bcs.n	800680c <Thread3+0x41c>
  tp->queue.prev             = cp->queue.prev;
 8006814:	6841      	ldr	r1, [r0, #4]
 8006816:	e9c2 0100 	strd	r0, r1, [r2]
  tp->queue.prev->queue.next = tp;
 800681a:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800681c:	6042      	str	r2, [r0, #4]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800681e:	f1bc 0f00 	cmp.w	ip, #0
 8006822:	d185      	bne.n	8006730 <Thread3+0x340>
  return firstprio(&ch.rlist.queue) > currp->prio;
 8006824:	69a9      	ldr	r1, [r5, #24]
 8006826:	682a      	ldr	r2, [r5, #0]
  if (chSchIsRescRequiredI()) {
 8006828:	6889      	ldr	r1, [r1, #8]
 800682a:	6892      	ldr	r2, [r2, #8]
 800682c:	4291      	cmp	r1, r2
 800682e:	f4bf aed9 	bcs.w	80065e4 <Thread3+0x1f4>
    chSchDoRescheduleAhead();
 8006832:	f7ff f9b5 	bl	8005ba0 <chSchDoReschedule>
 8006836:	e6cd      	b.n	80065d4 <Thread3+0x1e4>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006838:	f8d5 c030 	ldr.w	ip, [r5, #48]	; 0x30
 800683c:	2200      	movs	r2, #0
 800683e:	4594      	cmp	ip, r2
 8006840:	624a      	str	r2, [r1, #36]	; 0x24
 8006842:	f6ff af6d 	blt.w	8006720 <Thread3+0x330>
 8006846:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8006848:	4293      	cmp	r3, r2
 800684a:	f77f af69 	ble.w	8006720 <Thread3+0x330>
  } while (cp->prio >= tp->prio);
 800684e:	f8d1 8008 	ldr.w	r8, [r1, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8006852:	481e      	ldr	r0, [pc, #120]	; (80068cc <Thread3+0x4dc>)
  tp->state = CH_STATE_READY;
 8006854:	f881 2020 	strb.w	r2, [r1, #32]
    cp = cp->queue.next;
 8006858:	6800      	ldr	r0, [r0, #0]
  } while (cp->prio >= tp->prio);
 800685a:	6883      	ldr	r3, [r0, #8]
 800685c:	4543      	cmp	r3, r8
 800685e:	d2fb      	bcs.n	8006858 <Thread3+0x468>
  tp->queue.prev             = cp->queue.prev;
 8006860:	6842      	ldr	r2, [r0, #4]
 8006862:	e9c1 0200 	strd	r0, r2, [r1]
  tp->queue.prev->queue.next = tp;
 8006866:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8006868:	6041      	str	r1, [r0, #4]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800686a:	f1bc 0f00 	cmp.w	ip, #0
 800686e:	d008      	beq.n	8006882 <Thread3+0x492>
 8006870:	e75e      	b.n	8006730 <Thread3+0x340>
 8006872:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006874:	2a00      	cmp	r2, #0
 8006876:	f47f af5b 	bne.w	8006730 <Thread3+0x340>
 800687a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800687c:	2a00      	cmp	r2, #0
 800687e:	f77f af57 	ble.w	8006730 <Thread3+0x340>
 8006882:	69a9      	ldr	r1, [r5, #24]
 8006884:	682a      	ldr	r2, [r5, #0]
  if (chSchIsRescRequiredI()) {
 8006886:	6889      	ldr	r1, [r1, #8]
 8006888:	6892      	ldr	r2, [r2, #8]
 800688a:	4291      	cmp	r1, r2
 800688c:	f4bf af25 	bcs.w	80066da <Thread3+0x2ea>
    chSchDoRescheduleAhead();
 8006890:	f7ff f986 	bl	8005ba0 <chSchDoReschedule>
 8006894:	e719      	b.n	80066ca <Thread3+0x2da>
  chSysSwitch(currp, otp);
 8006896:	480e      	ldr	r0, [pc, #56]	; (80068d0 <Thread3+0x4e0>)
 8006898:	f7fa fd8a 	bl	80013b0 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800689c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 800689e:	9801      	ldr	r0, [sp, #4]
 80068a0:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80068a2:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80068a6:	9103      	str	r1, [sp, #12]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80068a8:	f360 0302 	bfi	r3, r0, #0, #3
 80068ac:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80068ae:	f891 c020 	ldrb.w	ip, [r1, #32]
 80068b2:	f36c 03c7 	bfi	r3, ip, #3, #5
 80068b6:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80068b8:	69ab      	ldr	r3, [r5, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80068ba:	e9c2 3e02 	strd	r3, lr, [r2, #8]
    trace_next();
 80068be:	f7fa fd57 	bl	8001370 <trace_next>
 80068c2:	9903      	ldr	r1, [sp, #12]
 80068c4:	e678      	b.n	80065b8 <Thread3+0x1c8>
 80068c6:	bf00      	nop
 80068c8:	200012c0 	.word	0x200012c0
 80068cc:	2000159c 	.word	0x2000159c
 80068d0:	0800e71c 	.word	0x0800e71c
	...

080068e0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80068e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80068e4:	2320      	movs	r3, #32
 80068e6:	b085      	sub	sp, #20
 80068e8:	4607      	mov	r7, r0
 80068ea:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 80068ee:	4ca9      	ldr	r4, [pc, #676]	; (8006b94 <chRegFindThreadByWorkingArea+0x2b4>)
  _dbg_check_lock();
 80068f0:	f7fe fcee 	bl	80052d0 <_dbg_check_lock>
 80068f4:	f8d4 9010 	ldr.w	r9, [r4, #16]
  tp->refs++;
 80068f8:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
 80068fc:	3301      	adds	r3, #1
 80068fe:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22
  _dbg_check_unlock();
 8006902:	f7fe fcbd 	bl	8005280 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006906:	6823      	ldr	r3, [r4, #0]
 8006908:	42a3      	cmp	r3, r4
 800690a:	d004      	beq.n	8006916 <chRegFindThreadByWorkingArea+0x36>
 800690c:	69a2      	ldr	r2, [r4, #24]
 800690e:	689b      	ldr	r3, [r3, #8]
 8006910:	6892      	ldr	r2, [r2, #8]
 8006912:	429a      	cmp	r2, r3
 8006914:	d34f      	bcc.n	80069b6 <chRegFindThreadByWorkingArea+0xd6>
 8006916:	2500      	movs	r5, #0
 8006918:	f385 8811 	msr	BASEPRI, r5
 800691c:	f04f 0820 	mov.w	r8, #32
  _dbg_enter_lock();
 8006920:	2301      	movs	r3, #1
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8006922:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8006926:	4297      	cmp	r7, r2
 8006928:	d048      	beq.n	80069bc <chRegFindThreadByWorkingArea+0xdc>
 800692a:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800692e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006930:	2a00      	cmp	r2, #0
 8006932:	d13d      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
 8006934:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006936:	2a00      	cmp	r2, #0
 8006938:	d13a      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
  ntp = tp->newer;
 800693a:	f8d9 6010 	ldr.w	r6, [r9, #16]
  _dbg_enter_lock();
 800693e:	6363      	str	r3, [r4, #52]	; 0x34
  if (ntp == (thread_t *)&ch.rlist) {
 8006940:	42a6      	cmp	r6, r4
 8006942:	d043      	beq.n	80069cc <chRegFindThreadByWorkingArea+0xec>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8006944:	f896 2022 	ldrb.w	r2, [r6, #34]	; 0x22
 8006948:	2aff      	cmp	r2, #255	; 0xff
 800694a:	d03c      	beq.n	80069c6 <chRegFindThreadByWorkingArea+0xe6>
    ntp->refs++;
 800694c:	3201      	adds	r2, #1
 800694e:	f886 2022 	strb.w	r2, [r6, #34]	; 0x22
 8006952:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8006954:	6365      	str	r5, [r4, #52]	; 0x34
 8006956:	42a2      	cmp	r2, r4
 8006958:	d004      	beq.n	8006964 <chRegFindThreadByWorkingArea+0x84>
 800695a:	69a1      	ldr	r1, [r4, #24]
 800695c:	6892      	ldr	r2, [r2, #8]
 800695e:	6889      	ldr	r1, [r1, #8]
 8006960:	4291      	cmp	r1, r2
 8006962:	d328      	bcc.n	80069b6 <chRegFindThreadByWorkingArea+0xd6>
 8006964:	f385 8811 	msr	BASEPRI, r5
 8006968:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800696c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800696e:	b9fa      	cbnz	r2, 80069b0 <chRegFindThreadByWorkingArea+0xd0>
 8006970:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006972:	b9ea      	cbnz	r2, 80069b0 <chRegFindThreadByWorkingArea+0xd0>
  _dbg_enter_lock();
 8006974:	6363      	str	r3, [r4, #52]	; 0x34
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8006976:	f899 1022 	ldrb.w	r1, [r9, #34]	; 0x22
 800697a:	b349      	cbz	r1, 80069d0 <chRegFindThreadByWorkingArea+0xf0>
  tp->refs--;
 800697c:	3901      	subs	r1, #1
 800697e:	f889 1022 	strb.w	r1, [r9, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8006982:	f8d9 1020 	ldr.w	r1, [r9, #32]
 8006986:	f8d4 c000 	ldr.w	ip, [r4]
 800698a:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 800698e:	290f      	cmp	r1, #15
 8006990:	d021      	beq.n	80069d6 <chRegFindThreadByWorkingArea+0xf6>
 8006992:	45a4      	cmp	ip, r4
  _dbg_leave_lock();
 8006994:	6362      	str	r2, [r4, #52]	; 0x34
 8006996:	d005      	beq.n	80069a4 <chRegFindThreadByWorkingArea+0xc4>
 8006998:	69a1      	ldr	r1, [r4, #24]
 800699a:	f8dc 2008 	ldr.w	r2, [ip, #8]
 800699e:	6889      	ldr	r1, [r1, #8]
 80069a0:	4291      	cmp	r1, r2
 80069a2:	d35b      	bcc.n	8006a5c <chRegFindThreadByWorkingArea+0x17c>
 80069a4:	f385 8811 	msr	BASEPRI, r5
 80069a8:	46b1      	mov	r9, r6
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 80069aa:	2e00      	cmp	r6, #0
 80069ac:	d1b9      	bne.n	8006922 <chRegFindThreadByWorkingArea+0x42>
 80069ae:	e006      	b.n	80069be <chRegFindThreadByWorkingArea+0xde>
    chSysHalt("SV#4");
 80069b0:	4879      	ldr	r0, [pc, #484]	; (8006b98 <chRegFindThreadByWorkingArea+0x2b8>)
 80069b2:	f7fa fcfd 	bl	80013b0 <chSysHalt>
 80069b6:	4879      	ldr	r0, [pc, #484]	; (8006b9c <chRegFindThreadByWorkingArea+0x2bc>)
 80069b8:	f7fa fcfa 	bl	80013b0 <chSysHalt>
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80069bc:	464e      	mov	r6, r9

  return NULL;
}
 80069be:	4630      	mov	r0, r6
 80069c0:	b005      	add	sp, #20
 80069c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80069c6:	4876      	ldr	r0, [pc, #472]	; (8006ba0 <chRegFindThreadByWorkingArea+0x2c0>)
 80069c8:	f7fa fcf2 	bl	80013b0 <chSysHalt>
    ntp = NULL;
 80069cc:	4616      	mov	r6, r2
 80069ce:	e7c0      	b.n	8006952 <chRegFindThreadByWorkingArea+0x72>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80069d0:	4874      	ldr	r0, [pc, #464]	; (8006ba4 <chRegFindThreadByWorkingArea+0x2c4>)
 80069d2:	f7fa fced 	bl	80013b0 <chSysHalt>
    REG_REMOVE(tp);
 80069d6:	e9d9 0104 	ldrd	r0, r1, [r9, #16]
 80069da:	6108      	str	r0, [r1, #16]
 80069dc:	f8d9 0010 	ldr.w	r0, [r9, #16]
 80069e0:	45a4      	cmp	ip, r4
 80069e2:	6141      	str	r1, [r0, #20]
  _dbg_leave_lock();
 80069e4:	6362      	str	r2, [r4, #52]	; 0x34
 80069e6:	d005      	beq.n	80069f4 <chRegFindThreadByWorkingArea+0x114>
 80069e8:	69a2      	ldr	r2, [r4, #24]
 80069ea:	f8dc 1008 	ldr.w	r1, [ip, #8]
 80069ee:	6892      	ldr	r2, [r2, #8]
 80069f0:	428a      	cmp	r2, r1
 80069f2:	d333      	bcc.n	8006a5c <chRegFindThreadByWorkingArea+0x17c>
 80069f4:	f385 8811 	msr	BASEPRI, r5
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80069f8:	f899 1021 	ldrb.w	r1, [r9, #33]	; 0x21
 80069fc:	f001 0103 	and.w	r1, r1, #3
 8006a00:	2901      	cmp	r1, #1
 8006a02:	d02e      	beq.n	8006a62 <chRegFindThreadByWorkingArea+0x182>
 8006a04:	2902      	cmp	r1, #2
 8006a06:	d1cf      	bne.n	80069a8 <chRegFindThreadByWorkingArea+0xc8>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8006a08:	f8d9 c040 	ldr.w	ip, [r9, #64]	; 0x40
 8006a0c:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8006a10:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006a14:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006a16:	2a00      	cmp	r2, #0
 8006a18:	d1ca      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
 8006a1a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006a1c:	2a00      	cmp	r2, #0
 8006a1e:	d1c7      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
  _dbg_enter_lock();
 8006a20:	6363      	str	r3, [r4, #52]	; 0x34
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
 8006a22:	f1bc 0f00 	cmp.w	ip, #0
 8006a26:	d07e      	beq.n	8006b26 <chRegFindThreadByWorkingArea+0x246>
 8006a28:	2900      	cmp	r1, #0
 8006a2a:	d07c      	beq.n	8006b26 <chRegFindThreadByWorkingArea+0x246>

  chDbgAssert(((size_t)objp & MEM_ALIGN_MASK(mp->align)) == 0U,
 8006a2c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8006a30:	3a01      	subs	r2, #1
 8006a32:	ea11 0e02 	ands.w	lr, r1, r2
 8006a36:	d176      	bne.n	8006b26 <chRegFindThreadByWorkingArea+0x246>
 8006a38:	6820      	ldr	r0, [r4, #0]
              "unaligned object");

  php->next = mp->next;
 8006a3a:	f8dc 2000 	ldr.w	r2, [ip]
 8006a3e:	600a      	str	r2, [r1, #0]
 8006a40:	42a0      	cmp	r0, r4
  mp->next = php;
 8006a42:	f8cc 1000 	str.w	r1, [ip]
  _dbg_leave_lock();
 8006a46:	f8c4 e034 	str.w	lr, [r4, #52]	; 0x34
 8006a4a:	d0ab      	beq.n	80069a4 <chRegFindThreadByWorkingArea+0xc4>
 8006a4c:	69a1      	ldr	r1, [r4, #24]
 8006a4e:	6882      	ldr	r2, [r0, #8]
 8006a50:	6889      	ldr	r1, [r1, #8]
 8006a52:	4291      	cmp	r1, r2
 8006a54:	d2a6      	bcs.n	80069a4 <chRegFindThreadByWorkingArea+0xc4>
 8006a56:	4854      	ldr	r0, [pc, #336]	; (8006ba8 <chRegFindThreadByWorkingArea+0x2c8>)
 8006a58:	f7fa fcaa 	bl	80013b0 <chSysHalt>
 8006a5c:	4853      	ldr	r0, [pc, #332]	; (8006bac <chRegFindThreadByWorkingArea+0x2cc>)
 8006a5e:	f7fa fca7 	bl	80013b0 <chSysHalt>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8006a62:	f8d9 901c 	ldr.w	r9, [r9, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8006a66:	f1b9 0f00 	cmp.w	r9, #0
 8006a6a:	d059      	beq.n	8006b20 <chRegFindThreadByWorkingArea+0x240>
 8006a6c:	f019 0f07 	tst.w	r9, #7
 8006a70:	d156      	bne.n	8006b20 <chRegFindThreadByWorkingArea+0x240>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8006a72:	e959 b202 	ldrd	fp, r2, [r9, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8006a76:	3207      	adds	r2, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8006a78:	08d2      	lsrs	r2, r2, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8006a7a:	f849 2c04 	str.w	r2, [r9, #-4]
 8006a7e:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006a82:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006a84:	2a00      	cmp	r2, #0
 8006a86:	d193      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
 8006a88:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006a8a:	2a00      	cmp	r2, #0
 8006a8c:	d190      	bne.n	80069b0 <chRegFindThreadByWorkingArea+0xd0>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 8006a8e:	f11b 020c 	adds.w	r2, fp, #12
  _dbg_enter_lock();
 8006a92:	6361      	str	r1, [r4, #52]	; 0x34
  thread_t *ctp = currp;
 8006a94:	f8d4 a018 	ldr.w	sl, [r4, #24]
  chDbgCheck(mp != NULL);
 8006a98:	9201      	str	r2, [sp, #4]
 8006a9a:	d03e      	beq.n	8006b1a <chRegFindThreadByWorkingArea+0x23a>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8006a9c:	f8db 0014 	ldr.w	r0, [fp, #20]
 8006aa0:	2800      	cmp	r0, #0
 8006aa2:	f000 808b 	beq.w	8006bbc <chRegFindThreadByWorkingArea+0x2dc>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8006aa6:	f8da 1008 	ldr.w	r1, [sl, #8]
 8006aaa:	6882      	ldr	r2, [r0, #8]
 8006aac:	9102      	str	r1, [sp, #8]
 8006aae:	4291      	cmp	r1, r2
 8006ab0:	d914      	bls.n	8006adc <chRegFindThreadByWorkingArea+0x1fc>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8006ab2:	f890 2020 	ldrb.w	r2, [r0, #32]
        tp->prio = ctp->prio;
 8006ab6:	9902      	ldr	r1, [sp, #8]
 8006ab8:	6081      	str	r1, [r0, #8]
        switch (tp->state) {
 8006aba:	2a06      	cmp	r2, #6
 8006abc:	d036      	beq.n	8006b2c <chRegFindThreadByWorkingArea+0x24c>
 8006abe:	2a07      	cmp	r2, #7
 8006ac0:	468e      	mov	lr, r1
 8006ac2:	d04e      	beq.n	8006b62 <chRegFindThreadByWorkingArea+0x282>
 8006ac4:	b952      	cbnz	r2, 8006adc <chRegFindThreadByWorkingArea+0x1fc>
  tp->queue.prev->queue.next = tp->queue.next;
 8006ac6:	e9d0 2100 	ldrd	r2, r1, [r0]
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8006aca:	f880 3020 	strb.w	r3, [r0, #32]
 8006ace:	600a      	str	r2, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8006ad0:	6802      	ldr	r2, [r0, #0]
 8006ad2:	9302      	str	r3, [sp, #8]
 8006ad4:	6051      	str	r1, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8006ad6:	f7fa fd2b 	bl	8001530 <chSchReadyI>
 8006ada:	9b02      	ldr	r3, [sp, #8]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006adc:	9901      	ldr	r1, [sp, #4]
 8006ade:	e004      	b.n	8006aea <chRegFindThreadByWorkingArea+0x20a>
 8006ae0:	6888      	ldr	r0, [r1, #8]
 8006ae2:	f8da 2008 	ldr.w	r2, [sl, #8]
 8006ae6:	4290      	cmp	r0, r2
 8006ae8:	d304      	bcc.n	8006af4 <chRegFindThreadByWorkingArea+0x214>
    cp = cp->queue.next;
 8006aea:	6809      	ldr	r1, [r1, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006aec:	9a01      	ldr	r2, [sp, #4]
 8006aee:	428a      	cmp	r2, r1
 8006af0:	d1f6      	bne.n	8006ae0 <chRegFindThreadByWorkingArea+0x200>
 8006af2:	9901      	ldr	r1, [sp, #4]
  tp->queue.prev             = cp->queue.prev;
 8006af4:	684a      	ldr	r2, [r1, #4]
 8006af6:	9302      	str	r3, [sp, #8]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8006af8:	9b01      	ldr	r3, [sp, #4]
 8006afa:	e9ca 1200 	strd	r1, r2, [sl]
      chSchGoSleepS(CH_STATE_WTMTX);
 8006afe:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8006b00:	f8c2 a000 	str.w	sl, [r2]
  cp->queue.prev             = tp;
 8006b04:	f8c1 a004 	str.w	sl, [r1, #4]
      ctp->u.wtmtxp = mp;
 8006b08:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8006b0c:	f7fb fc28 	bl	8002360 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8006b10:	f8db 2014 	ldr.w	r2, [fp, #20]
 8006b14:	4592      	cmp	sl, r2
 8006b16:	f000 810d 	beq.w	8006d34 <chRegFindThreadByWorkingArea+0x454>
  chDbgCheck(mp != NULL);
 8006b1a:	4825      	ldr	r0, [pc, #148]	; (8006bb0 <chRegFindThreadByWorkingArea+0x2d0>)
 8006b1c:	f7fa fc48 	bl	80013b0 <chSysHalt>
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8006b20:	4824      	ldr	r0, [pc, #144]	; (8006bb4 <chRegFindThreadByWorkingArea+0x2d4>)
 8006b22:	f7fa fc45 	bl	80013b0 <chSysHalt>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8006b26:	4824      	ldr	r0, [pc, #144]	; (8006bb8 <chRegFindThreadByWorkingArea+0x2d8>)
 8006b28:	f7fa fc42 	bl	80013b0 <chSysHalt>
  tp->queue.prev->queue.next = tp->queue.next;
 8006b2c:	e9d0 1200 	ldrd	r1, r2, [r0]
 8006b30:	6011      	str	r1, [r2, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8006b32:	f8d0 c024 	ldr.w	ip, [r0, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8006b36:	6801      	ldr	r1, [r0, #0]
 8006b38:	9003      	str	r0, [sp, #12]
 8006b3a:	604a      	str	r2, [r1, #4]
 8006b3c:	4662      	mov	r2, ip
    cp = cp->queue.next;
 8006b3e:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006b40:	4594      	cmp	ip, r2
 8006b42:	d003      	beq.n	8006b4c <chRegFindThreadByWorkingArea+0x26c>
 8006b44:	6891      	ldr	r1, [r2, #8]
 8006b46:	9802      	ldr	r0, [sp, #8]
 8006b48:	4288      	cmp	r0, r1
 8006b4a:	d9f8      	bls.n	8006b3e <chRegFindThreadByWorkingArea+0x25e>
 8006b4c:	9803      	ldr	r0, [sp, #12]
 8006b4e:	4696      	mov	lr, r2
  tp->queue.prev             = cp->queue.prev;
 8006b50:	6852      	ldr	r2, [r2, #4]
 8006b52:	e9c0 e200 	strd	lr, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8006b56:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8006b58:	f8ce 0004 	str.w	r0, [lr, #4]
          tp = tp->u.wtmtxp->owner;
 8006b5c:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8006b60:	e7a1      	b.n	8006aa6 <chRegFindThreadByWorkingArea+0x1c6>
  tp->queue.prev->queue.next = tp->queue.next;
 8006b62:	e9d0 1c00 	ldrd	r1, ip, [r0]
 8006b66:	f8cc 1000 	str.w	r1, [ip]
  tp->queue.next->queue.prev = tp->queue.prev;
 8006b6a:	6802      	ldr	r2, [r0, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8006b6c:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8006b6e:	9102      	str	r1, [sp, #8]
 8006b70:	f8c2 c004 	str.w	ip, [r2, #4]
 8006b74:	460a      	mov	r2, r1
    cp = cp->queue.next;
 8006b76:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006b78:	9902      	ldr	r1, [sp, #8]
 8006b7a:	4291      	cmp	r1, r2
 8006b7c:	d002      	beq.n	8006b84 <chRegFindThreadByWorkingArea+0x2a4>
 8006b7e:	6891      	ldr	r1, [r2, #8]
 8006b80:	458e      	cmp	lr, r1
 8006b82:	d9f8      	bls.n	8006b76 <chRegFindThreadByWorkingArea+0x296>
 8006b84:	4694      	mov	ip, r2
  tp->queue.prev             = cp->queue.prev;
 8006b86:	6852      	ldr	r2, [r2, #4]
 8006b88:	e9c0 c200 	strd	ip, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8006b8c:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8006b8e:	f8cc 0004 	str.w	r0, [ip, #4]
 8006b92:	e7a3      	b.n	8006adc <chRegFindThreadByWorkingArea+0x1fc>
 8006b94:	2000159c 	.word	0x2000159c
 8006b98:	0800e704 	.word	0x0800e704
 8006b9c:	0800e24c 	.word	0x0800e24c
 8006ba0:	0800e370 	.word	0x0800e370
 8006ba4:	0800e32c 	.word	0x0800e32c
 8006ba8:	0800e214 	.word	0x0800e214
 8006bac:	0800e1e4 	.word	0x0800e1e4
 8006bb0:	0800e270 	.word	0x0800e270
 8006bb4:	0800e2e0 	.word	0x0800e2e0
 8006bb8:	0800e2bc 	.word	0x0800e2bc

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 8006bbc:	f8da 2038 	ldr.w	r2, [sl, #56]	; 0x38
 8006bc0:	e9cb a205 	strd	sl, r2, [fp, #20]
    ctp->mtxlist = mp;
 8006bc4:	9a01      	ldr	r2, [sp, #4]
 8006bc6:	f8ca 2038 	str.w	r2, [sl, #56]	; 0x38
 8006bca:	6821      	ldr	r1, [r4, #0]
  _dbg_leave_lock();
 8006bcc:	6365      	str	r5, [r4, #52]	; 0x34
 8006bce:	42a1      	cmp	r1, r4
 8006bd0:	d005      	beq.n	8006bde <chRegFindThreadByWorkingArea+0x2fe>
 8006bd2:	69a2      	ldr	r2, [r4, #24]
 8006bd4:	6889      	ldr	r1, [r1, #8]
 8006bd6:	6892      	ldr	r2, [r2, #8]
 8006bd8:	428a      	cmp	r2, r1
 8006bda:	f0c0 8096 	bcc.w	8006d0a <chRegFindThreadByWorkingArea+0x42a>
  hp = (heap_header_t *)p - 1U;
 8006bde:	f1a9 0008 	sub.w	r0, r9, #8
  qp = &heapp->header;
 8006be2:	f10b 0c04 	add.w	ip, fp, #4
 8006be6:	f385 8811 	msr	BASEPRI, r5
 8006bea:	4661      	mov	r1, ip

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8006bec:	4288      	cmp	r0, r1
 8006bee:	d305      	bcc.n	8006bfc <chRegFindThreadByWorkingArea+0x31c>
 8006bf0:	684a      	ldr	r2, [r1, #4]
 8006bf2:	3201      	adds	r2, #1
 8006bf4:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8006bf8:	4290      	cmp	r0, r2
 8006bfa:	d391      	bcc.n	8006b20 <chRegFindThreadByWorkingArea+0x240>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8006bfc:	458c      	cmp	ip, r1
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8006bfe:	680a      	ldr	r2, [r1, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8006c00:	d001      	beq.n	8006c06 <chRegFindThreadByWorkingArea+0x326>
 8006c02:	4288      	cmp	r0, r1
 8006c04:	d902      	bls.n	8006c0c <chRegFindThreadByWorkingArea+0x32c>
 8006c06:	b11a      	cbz	r2, 8006c10 <chRegFindThreadByWorkingArea+0x330>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8006c08:	4290      	cmp	r0, r2
 8006c0a:	d301      	bcc.n	8006c10 <chRegFindThreadByWorkingArea+0x330>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8006c0c:	4611      	mov	r1, r2
 8006c0e:	e7ed      	b.n	8006bec <chRegFindThreadByWorkingArea+0x30c>
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8006c10:	f859 cc04 	ldr.w	ip, [r9, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 8006c14:	f849 2c08 	str.w	r2, [r9, #-8]
      H_NEXT(qp) = hp;
 8006c18:	6008      	str	r0, [r1, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8006c1a:	f10c 0c01 	add.w	ip, ip, #1
 8006c1e:	f859 2c08 	ldr.w	r2, [r9, #-8]
 8006c22:	eb00 0ecc 	add.w	lr, r0, ip, lsl #3
 8006c26:	4596      	cmp	lr, r2
 8006c28:	d109      	bne.n	8006c3e <chRegFindThreadByWorkingArea+0x35e>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8006c2a:	f8de e004 	ldr.w	lr, [lr, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8006c2e:	f850 203c 	ldr.w	r2, [r0, ip, lsl #3]
 8006c32:	f849 2c08 	str.w	r2, [r9, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8006c36:	eb0e 020c 	add.w	r2, lr, ip
 8006c3a:	f849 2c04 	str.w	r2, [r9, #-4]
      if ((H_LIMIT(qp) == hp)) {
 8006c3e:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8006c42:	f10c 0201 	add.w	r2, ip, #1
 8006c46:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8006c4a:	4290      	cmp	r0, r2
 8006c4c:	d105      	bne.n	8006c5a <chRegFindThreadByWorkingArea+0x37a>
        H_NEXT(qp) = H_NEXT(hp);
 8006c4e:	e959 0202 	ldrd	r0, r2, [r9, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8006c52:	3201      	adds	r2, #1
 8006c54:	4462      	add	r2, ip
        H_NEXT(qp) = H_NEXT(hp);
 8006c56:	6008      	str	r0, [r1, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8006c58:	604a      	str	r2, [r1, #4]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8006c5a:	69a0      	ldr	r0, [r4, #24]
 8006c5c:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006c60:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006c62:	2a00      	cmp	r2, #0
 8006c64:	f47f aea4 	bne.w	80069b0 <chRegFindThreadByWorkingArea+0xd0>
 8006c68:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
 8006c6c:	f1bc 0f00 	cmp.w	ip, #0
 8006c70:	f47f ae9e 	bne.w	80069b0 <chRegFindThreadByWorkingArea+0xd0>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8006c74:	6b81      	ldr	r1, [r0, #56]	; 0x38
  _dbg_enter_lock();
 8006c76:	6363      	str	r3, [r4, #52]	; 0x34
 8006c78:	b111      	cbz	r1, 8006c80 <chRegFindThreadByWorkingArea+0x3a0>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8006c7a:	688a      	ldr	r2, [r1, #8]
 8006c7c:	4290      	cmp	r0, r2
 8006c7e:	d002      	beq.n	8006c86 <chRegFindThreadByWorkingArea+0x3a6>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8006c80:	4834      	ldr	r0, [pc, #208]	; (8006d54 <chRegFindThreadByWorkingArea+0x474>)
 8006c82:	f7fa fb95 	bl	80013b0 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8006c86:	9a01      	ldr	r2, [sp, #4]
 8006c88:	428a      	cmp	r2, r1
 8006c8a:	d1f9      	bne.n	8006c80 <chRegFindThreadByWorkingArea+0x3a0>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8006c8c:	f8db 200c 	ldr.w	r2, [fp, #12]
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8006c90:	9901      	ldr	r1, [sp, #4]
    ctp->mtxlist = mp->next;
 8006c92:	f8db e018 	ldr.w	lr, [fp, #24]
 8006c96:	f8c0 e038 	str.w	lr, [r0, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
 8006c9a:	4291      	cmp	r1, r2
 8006c9c:	d047      	beq.n	8006d2e <chRegFindThreadByWorkingArea+0x44e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8006c9e:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
 8006ca2:	4671      	mov	r1, lr
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8006ca4:	b151      	cbz	r1, 8006cbc <chRegFindThreadByWorkingArea+0x3dc>
 8006ca6:	f8d1 e000 	ldr.w	lr, [r1]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8006caa:	4571      	cmp	r1, lr
 8006cac:	d004      	beq.n	8006cb8 <chRegFindThreadByWorkingArea+0x3d8>
 8006cae:	f8de e008 	ldr.w	lr, [lr, #8]
 8006cb2:	45f4      	cmp	ip, lr
 8006cb4:	bf38      	it	cc
 8006cb6:	46f4      	movcc	ip, lr
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8006cb8:	68c9      	ldr	r1, [r1, #12]
 8006cba:	e7f3      	b.n	8006ca4 <chRegFindThreadByWorkingArea+0x3c4>
  tqp->next             = tp->queue.next;
 8006cbc:	6811      	ldr	r1, [r2, #0]
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8006cbe:	f8c0 c008 	str.w	ip, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8006cc2:	f8d2 c038 	ldr.w	ip, [r2, #56]	; 0x38
 8006cc6:	9302      	str	r3, [sp, #8]
  tqp->next->queue.prev = (thread_t *)tqp;
 8006cc8:	9b01      	ldr	r3, [sp, #4]
  tqp->next             = tp->queue.next;
 8006cca:	f8cb 100c 	str.w	r1, [fp, #12]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8006cce:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
 8006cd0:	604b      	str	r3, [r1, #4]
      mp->next = tp->mtxlist;
 8006cd2:	e9cb 2c05 	strd	r2, ip, [fp, #20]
      tp->mtxlist = mp;
 8006cd6:	6393      	str	r3, [r2, #56]	; 0x38
      (void) chSchReadyI(tp);
 8006cd8:	f7fa fc2a 	bl	8001530 <chSchReadyI>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006cdc:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006cde:	bb1a      	cbnz	r2, 8006d28 <chRegFindThreadByWorkingArea+0x448>
 8006ce0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006ce2:	9b02      	ldr	r3, [sp, #8]
 8006ce4:	2a00      	cmp	r2, #0
 8006ce6:	dd1f      	ble.n	8006d28 <chRegFindThreadByWorkingArea+0x448>
  return firstprio(&ch.rlist.queue) > currp->prio;
 8006ce8:	6821      	ldr	r1, [r4, #0]
 8006cea:	69a2      	ldr	r2, [r4, #24]
  if (chSchIsRescRequiredI()) {
 8006cec:	6889      	ldr	r1, [r1, #8]
 8006cee:	6892      	ldr	r2, [r2, #8]
 8006cf0:	4291      	cmp	r1, r2
 8006cf2:	d80d      	bhi.n	8006d10 <chRegFindThreadByWorkingArea+0x430>
 8006cf4:	6822      	ldr	r2, [r4, #0]
  _dbg_leave_lock();
 8006cf6:	6365      	str	r5, [r4, #52]	; 0x34
 8006cf8:	42a2      	cmp	r2, r4
 8006cfa:	f43f ae53 	beq.w	80069a4 <chRegFindThreadByWorkingArea+0xc4>
 8006cfe:	69a1      	ldr	r1, [r4, #24]
 8006d00:	6892      	ldr	r2, [r2, #8]
 8006d02:	6889      	ldr	r1, [r1, #8]
 8006d04:	4291      	cmp	r1, r2
 8006d06:	f4bf ae4d 	bcs.w	80069a4 <chRegFindThreadByWorkingArea+0xc4>
 8006d0a:	4813      	ldr	r0, [pc, #76]	; (8006d58 <chRegFindThreadByWorkingArea+0x478>)
 8006d0c:	f7fa fb50 	bl	80013b0 <chSysHalt>
 8006d10:	9301      	str	r3, [sp, #4]
    chSchDoRescheduleAhead();
 8006d12:	f7fe ff45 	bl	8005ba0 <chSchDoReschedule>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006d16:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006d18:	9b01      	ldr	r3, [sp, #4]
 8006d1a:	b912      	cbnz	r2, 8006d22 <chRegFindThreadByWorkingArea+0x442>
 8006d1c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006d1e:	2a00      	cmp	r2, #0
 8006d20:	dce8      	bgt.n	8006cf4 <chRegFindThreadByWorkingArea+0x414>
    chSysHalt("SV#5");
 8006d22:	480e      	ldr	r0, [pc, #56]	; (8006d5c <chRegFindThreadByWorkingArea+0x47c>)
 8006d24:	f7fa fb44 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8006d28:	480d      	ldr	r0, [pc, #52]	; (8006d60 <chRegFindThreadByWorkingArea+0x480>)
 8006d2a:	f7fa fb41 	bl	80013b0 <chSysHalt>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8006d2e:	f8cb c014 	str.w	ip, [fp, #20]
 8006d32:	e7df      	b.n	8006cf4 <chRegFindThreadByWorkingArea+0x414>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8006d34:	f8da 2038 	ldr.w	r2, [sl, #56]	; 0x38
 8006d38:	9b01      	ldr	r3, [sp, #4]
 8006d3a:	4293      	cmp	r3, r2
 8006d3c:	f47f aeed 	bne.w	8006b1a <chRegFindThreadByWorkingArea+0x23a>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006d40:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006d42:	9b02      	ldr	r3, [sp, #8]
 8006d44:	2a00      	cmp	r2, #0
 8006d46:	d1ec      	bne.n	8006d22 <chRegFindThreadByWorkingArea+0x442>
 8006d48:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006d4a:	2a00      	cmp	r2, #0
 8006d4c:	f73f af3d 	bgt.w	8006bca <chRegFindThreadByWorkingArea+0x2ea>
 8006d50:	e7e7      	b.n	8006d22 <chRegFindThreadByWorkingArea+0x442>
 8006d52:	bf00      	nop
 8006d54:	0800e2ec 	.word	0x0800e2ec
 8006d58:	0800e1f0 	.word	0x0800e1f0
 8006d5c:	0800e72c 	.word	0x0800e72c
 8006d60:	0800e714 	.word	0x0800e714
	...

08006d70 <chThdCreateStatic.constprop.26>:
  chDbgCheck((wsp != NULL) &&
 8006d70:	0743      	lsls	r3, r0, #29
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8006d72:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((wsp != NULL) &&
 8006d74:	d105      	bne.n	8006d82 <chThdCreateStatic.constprop.26+0x12>
 8006d76:	4605      	mov	r5, r0
 8006d78:	460c      	mov	r4, r1
 8006d7a:	4616      	mov	r6, r2
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8006d7c:	f7ff fdb0 	bl	80068e0 <chRegFindThreadByWorkingArea>
 8006d80:	b110      	cbz	r0, 8006d88 <chThdCreateStatic.constprop.26+0x18>
  chDbgCheck((wsp != NULL) &&
 8006d82:	481f      	ldr	r0, [pc, #124]	; (8006e00 <chThdCreateStatic.constprop.26+0x90>)
 8006d84:	f7fa fb14 	bl	80013b0 <chSysHalt>
  _thread_memfill((uint8_t *)wsp,
 8006d88:	192a      	adds	r2, r5, r4
  while (startp < endp) {
 8006d8a:	4295      	cmp	r5, r2
 8006d8c:	d204      	bcs.n	8006d98 <chThdCreateStatic.constprop.26+0x28>
 8006d8e:	1b52      	subs	r2, r2, r5
 8006d90:	2155      	movs	r1, #85	; 0x55
 8006d92:	4628      	mov	r0, r5
 8006d94:	f003 fa6c 	bl	800a270 <memset>
 8006d98:	2320      	movs	r3, #32
 8006d9a:	f383 8811 	msr	BASEPRI, r3
  tp = (thread_t *)((uint8_t *)wsp + size -
 8006d9e:	3c48      	subs	r4, #72	; 0x48
 8006da0:	442c      	add	r4, r5
  _dbg_check_lock();
 8006da2:	f7fe fa95 	bl	80052d0 <_dbg_check_lock>
  REG_INSERT(tp);
 8006da6:	4b17      	ldr	r3, [pc, #92]	; (8006e04 <chThdCreateStatic.constprop.26+0x94>)
 8006da8:	6123      	str	r3, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006daa:	f1a4 0264 	sub.w	r2, r4, #100	; 0x64
  REG_INSERT(tp);
 8006dae:	6959      	ldr	r1, [r3, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006db0:	4815      	ldr	r0, [pc, #84]	; (8006e08 <chThdCreateStatic.constprop.26+0x98>)
 8006db2:	60e2      	str	r2, [r4, #12]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8006db4:	2201      	movs	r2, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006db6:	f844 0c04 	str.w	r0, [r4, #-4]
  tp->wabase = (stkalign_t *)wsp;
 8006dba:	61e5      	str	r5, [r4, #28]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8006dbc:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
  tp->state     = CH_STATE_WTSTART;
 8006dc0:	2502      	movs	r5, #2
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006dc2:	2200      	movs	r2, #0
  tp->name      = name;
 8006dc4:	4811      	ldr	r0, [pc, #68]	; (8006e0c <chThdCreateStatic.constprop.26+0x9c>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006dc6:	f844 2c20 	str.w	r2, [r4, #-32]
  tp->state     = CH_STATE_WTSTART;
 8006dca:	8425      	strh	r5, [r4, #32]
  tp->name      = name;
 8006dcc:	61a0      	str	r0, [r4, #24]
  tp->epending  = (eventmask_t)0;
 8006dce:	e9c4 220d 	strd	r2, r2, [r4, #52]	; 0x34
  tp->prio      = prio;
 8006dd2:	2080      	movs	r0, #128	; 0x80
  queue_init(&tp->msgqueue);
 8006dd4:	f104 022c 	add.w	r2, r4, #44	; 0x2c
  list_init(&tp->waiting);
 8006dd8:	f104 0528 	add.w	r5, r4, #40	; 0x28
  REG_INSERT(tp);
 8006ddc:	6161      	str	r1, [r4, #20]
  tp->prio      = prio;
 8006dde:	60a0      	str	r0, [r4, #8]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8006de0:	f844 6c24 	str.w	r6, [r4, #-36]
  tp->realprio  = prio;
 8006de4:	63e0      	str	r0, [r4, #60]	; 0x3c
  REG_INSERT(tp);
 8006de6:	610c      	str	r4, [r1, #16]
  chSchWakeupS(tp, MSG_OK);
 8006de8:	4620      	mov	r0, r4
  tqp->next = (thread_t *)tqp;
 8006dea:	e9c4 520a 	strd	r5, r2, [r4, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8006dee:	6322      	str	r2, [r4, #48]	; 0x30
  REG_INSERT(tp);
 8006df0:	615c      	str	r4, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8006df2:	f7fb fc9d 	bl	8002730 <chSchWakeupS.constprop.32>
  chSysUnlock();
 8006df6:	f7fa fc1b 	bl	8001630 <chSysUnlock.lto_priv.78>
}
 8006dfa:	4620      	mov	r0, r4
 8006dfc:	bd70      	pop	{r4, r5, r6, pc}
 8006dfe:	bf00      	nop
 8006e00:	0800e2f8 	.word	0x0800e2f8
 8006e04:	2000159c 	.word	0x2000159c
 8006e08:	080002e1 	.word	0x080002e1
 8006e0c:	0800e734 	.word	0x0800e734

08006e10 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
 8006e10:	4bca      	ldr	r3, [pc, #808]	; (800713c <main+0x32c>)
  PWR->CR |= PWR_CR_DBP;
 8006e12:	48cb      	ldr	r0, [pc, #812]	; (8007140 <main+0x330>)
  rccResetAHB(~STM32_GPIO_EN_MASK);
 8006e14:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8006e16:	2200      	movs	r2, #0
 8006e18:	f461 01fc 	orn	r1, r1, #8257536	; 0x7e0000
	sdStart(&SD2, &uartCfg3);
    else
	sdStart(&SD2, &uartCfg2);
}

int main(void) {
 8006e1c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8006e20:	6299      	str	r1, [r3, #40]	; 0x28
 8006e22:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8006e24:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006e28:	691c      	ldr	r4, [r3, #16]
 8006e2a:	6119      	str	r1, [r3, #16]
 8006e2c:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8006e2e:	68dc      	ldr	r4, [r3, #12]
 8006e30:	60d9      	str	r1, [r3, #12]
 8006e32:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8006e34:	69d9      	ldr	r1, [r3, #28]
 8006e36:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8006e3a:	61d9      	str	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 8006e3c:	6801      	ldr	r1, [r0, #0]
 8006e3e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8006e42:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8006e44:	6a19      	ldr	r1, [r3, #32]
 8006e46:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8006e4a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8006e4e:	b08d      	sub	sp, #52	; 0x34
 8006e50:	d003      	beq.n	8006e5a <main+0x4a>
    RCC->BDCR = RCC_BDCR_BDRST;
 8006e52:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8006e56:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8006e58:	621a      	str	r2, [r3, #32]
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8006e5a:	4bb8      	ldr	r3, [pc, #736]	; (800713c <main+0x32c>)
 8006e5c:	6a1a      	ldr	r2, [r3, #32]
 8006e5e:	0410      	lsls	r0, r2, #16
 8006e60:	d407      	bmi.n	8006e72 <main+0x62>
    RCC->BDCR |= STM32_RTCSEL;
 8006e62:	6a1a      	ldr	r2, [r3, #32]
 8006e64:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006e68:	621a      	str	r2, [r3, #32]
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8006e6a:	6a1a      	ldr	r2, [r3, #32]
 8006e6c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006e70:	621a      	str	r2, [r3, #32]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8006e72:	48b4      	ldr	r0, [pc, #720]	; (8007144 <main+0x334>)
    _stm32_dma_streams[i].channel->CCR = 0U;
 8006e74:	4eb4      	ldr	r6, [pc, #720]	; (8007148 <main+0x338>)
  dma.streams_mask = 0U;
 8006e76:	4db5      	ldr	r5, [pc, #724]	; (800714c <main+0x33c>)
    _stm32_dma_streams[i].channel->CCR = 0U;
 8006e78:	f8df b304 	ldr.w	fp, [pc, #772]	; 8007180 <main+0x370>
 8006e7c:	f8df a304 	ldr.w	sl, [pc, #772]	; 8007184 <main+0x374>
 8006e80:	f8df 9304 	ldr.w	r9, [pc, #772]	; 8007188 <main+0x378>
 8006e84:	f8df 8304 	ldr.w	r8, [pc, #772]	; 800718c <main+0x37c>
 8006e88:	f8df e304 	ldr.w	lr, [pc, #772]	; 8007190 <main+0x380>
 8006e8c:	f8df c304 	ldr.w	ip, [pc, #772]	; 8007194 <main+0x384>
 8006e90:	4faf      	ldr	r7, [pc, #700]	; (8007150 <main+0x340>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006e92:	4ab0      	ldr	r2, [pc, #704]	; (8007154 <main+0x344>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8006e94:	49a9      	ldr	r1, [pc, #676]	; (800713c <main+0x32c>)

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8006e96:	4cb0      	ldr	r4, [pc, #704]	; (8007158 <main+0x348>)
  dma.streams_mask = 0U;
 8006e98:	2300      	movs	r3, #0
  dma.isr_mask = 0U;
 8006e9a:	e9c5 3300 	strd	r3, r3, [r5]
  DMA1->IFCR = 0xFFFFFFFFU;
 8006e9e:	f5a6 6681 	sub.w	r6, r6, #1032	; 0x408
    _stm32_dma_streams[i].channel->CCR = 0U;
 8006ea2:	f8cb 3000 	str.w	r3, [fp]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8006ea6:	6003      	str	r3, [r0, #0]
 8006ea8:	6083      	str	r3, [r0, #8]
 8006eaa:	6103      	str	r3, [r0, #16]
 8006eac:	6183      	str	r3, [r0, #24]
 8006eae:	6203      	str	r3, [r0, #32]
 8006eb0:	6283      	str	r3, [r0, #40]	; 0x28
 8006eb2:	6303      	str	r3, [r0, #48]	; 0x30
 8006eb4:	6383      	str	r3, [r0, #56]	; 0x38
 8006eb6:	6403      	str	r3, [r0, #64]	; 0x40
 8006eb8:	6483      	str	r3, [r0, #72]	; 0x48
 8006eba:	6503      	str	r3, [r0, #80]	; 0x50
 8006ebc:	6583      	str	r3, [r0, #88]	; 0x58
    _stm32_dma_streams[i].channel->CCR = 0U;
 8006ebe:	f8ca 3000 	str.w	r3, [sl]
 8006ec2:	f8c9 3000 	str.w	r3, [r9]
 8006ec6:	f8c8 3000 	str.w	r3, [r8]
 8006eca:	f8ce 3000 	str.w	r3, [lr]
 8006ece:	f8cc 3000 	str.w	r3, [ip]
 8006ed2:	603b      	str	r3, [r7, #0]
 8006ed4:	f8c6 3408 	str.w	r3, [r6, #1032]	; 0x408
 8006ed8:	f8c6 341c 	str.w	r3, [r6, #1052]	; 0x41c
 8006edc:	f8c6 3430 	str.w	r3, [r6, #1072]	; 0x430
 8006ee0:	f8c6 3444 	str.w	r3, [r6, #1092]	; 0x444
 8006ee4:	f8c6 3458 	str.w	r3, [r6, #1112]	; 0x458
  DMA1->IFCR = 0xFFFFFFFFU;
 8006ee8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8006eec:	2560      	movs	r5, #96	; 0x60
 8006eee:	6077      	str	r7, [r6, #4]
  DMA2->IFCR = 0xFFFFFFFFU;
 8006ef0:	f8c6 7404 	str.w	r7, [r6, #1028]	; 0x404
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006ef4:	2640      	movs	r6, #64	; 0x40
 8006ef6:	f44f 7080 	mov.w	r0, #256	; 0x100
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006efa:	f882 5306 	strb.w	r5, [r2, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006efe:	f44f 7800 	mov.w	r8, #512	; 0x200
 8006f02:	f8c2 6180 	str.w	r6, [r2, #384]	; 0x180
 8006f06:	f44f 6e80 	mov.w	lr, #1024	; 0x400
 8006f0a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f0e:	6016      	str	r6, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f10:	2680      	movs	r6, #128	; 0x80
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f12:	f882 5307 	strb.w	r5, [r2, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f16:	f8c2 6180 	str.w	r6, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f1a:	6016      	str	r6, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f1c:	f882 5308 	strb.w	r5, [r2, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f20:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f24:	6010      	str	r0, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f26:	f882 5309 	strb.w	r5, [r2, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f2a:	f8c2 8180 	str.w	r8, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f2e:	f8c2 8000 	str.w	r8, [r2]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f32:	f882 530a 	strb.w	r5, [r2, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f36:	f8c2 e180 	str.w	lr, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f3a:	f8c2 e000 	str.w	lr, [r2]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f3e:	f882 5317 	strb.w	r5, [r2, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f42:	f8c2 c180 	str.w	ip, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f46:	f8c2 c000 	str.w	ip, [r2]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f4a:	f882 5328 	strb.w	r5, [r2, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f4e:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006f52:	6050      	str	r0, [r2, #4]
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8006f54:	698e      	ldr	r6, [r1, #24]
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8006f56:	4f81      	ldr	r7, [pc, #516]	; (800715c <main+0x34c>)
  adcp->state    = ADC_STOP;
 8006f58:	4d81      	ldr	r5, [pc, #516]	; (8007160 <main+0x350>)
  adcp->config   = NULL;
 8006f5a:	607b      	str	r3, [r7, #4]
 8006f5c:	f046 0601 	orr.w	r6, r6, #1
 8006f60:	618e      	str	r6, [r1, #24]
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8006f62:	6826      	ldr	r6, [r4, #0]
  adcp->samples  = NULL;
 8006f64:	60bb      	str	r3, [r7, #8]
 8006f66:	f046 0620 	orr.w	r6, r6, #32
  ADCD1.adcm    = ADC1;
 8006f6a:	f04f 4ba0 	mov.w	fp, #1342177280	; 0x50000000
 8006f6e:	6026      	str	r6, [r4, #0]
 8006f70:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
  adcp->depth    = 0;
  adcp->grpp     = NULL;
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8006f74:	617b      	str	r3, [r7, #20]
  mp->owner = NULL;
 8006f76:	623b      	str	r3, [r7, #32]
 8006f78:	463e      	mov	r6, r7
  adcp->grpp     = NULL;
 8006f7a:	e9c7 3303 	strd	r3, r3, [r7, #12]
  tqp->next = (thread_t *)tqp;
 8006f7e:	3718      	adds	r7, #24
  tqp->prev = (thread_t *)tqp;
 8006f80:	e9c6 7706 	strd	r7, r7, [r6, #24]
  clkmask = 0;
 8006f84:	4e77      	ldr	r6, [pc, #476]	; (8007164 <main+0x354>)
  adcp->state    = ADC_STOP;
 8006f86:	4878      	ldr	r0, [pc, #480]	; (8007168 <main+0x358>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8006f88:	f8df c20c 	ldr.w	ip, [pc, #524]	; 8007198 <main+0x388>
  ADCD1.adcc = ADC1_2_COMMON;
 8006f8c:	f8df 820c 	ldr.w	r8, [pc, #524]	; 800719c <main+0x38c>
  clkmask = 0;
 8006f90:	6033      	str	r3, [r6, #0]
  ADCD2.adcm    = ADC2;
 8006f92:	f8df a20c 	ldr.w	sl, [pc, #524]	; 80071a0 <main+0x390>
 8006f96:	4e71      	ldr	r6, [pc, #452]	; (800715c <main+0x34c>)
  ADCD3.adcc = ADC3_4_COMMON;
 8006f98:	f8df e208 	ldr.w	lr, [pc, #520]	; 80071a4 <main+0x394>
  ADCD3.adcm    = ADC3;
 8006f9c:	f8df 9208 	ldr.w	r9, [pc, #520]	; 80071a8 <main+0x398>
 8006fa0:	f04f 0b01 	mov.w	fp, #1
  tqp->next = (thread_t *)tqp;
 8006fa4:	f105 0418 	add.w	r4, r5, #24
  ADCD1.dmamode = ADC_DMA_SIZE |
 8006fa8:	f242 578a 	movw	r7, #9610	; 0x258a
 8006fac:	f886 b000 	strb.w	fp, [r6]
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8006fb0:	e9c6 8c0b 	strd	r8, ip, [r6, #44]	; 0x2c
  ADCD2.adcm    = ADC2;
 8006fb4:	e9c5 a80a 	strd	sl, r8, [r5, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
 8006fb8:	f10c 068c 	add.w	r6, ip, #140	; 0x8c
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
 8006fbc:	f10c 0adc 	add.w	sl, ip, #220	; 0xdc
  tqp->prev = (thread_t *)tqp;
 8006fc0:	e9c5 4406 	strd	r4, r4, [r5, #24]
  tqp->next = (thread_t *)tqp;
 8006fc4:	f100 0418 	add.w	r4, r0, #24
 8006fc8:	f880 b000 	strb.w	fp, [r0]
  adcp->grpp     = NULL;
 8006fcc:	e9c0 3303 	strd	r3, r3, [r0, #12]
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
 8006fd0:	632e      	str	r6, [r5, #48]	; 0x30
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
 8006fd2:	f8c0 a030 	str.w	sl, [r0, #48]	; 0x30
  adcp->samples  = NULL;
 8006fd6:	e9c0 3301 	strd	r3, r3, [r0, #4]
  ADCD3.dmamode = ADC_DMA_SIZE |
 8006fda:	6347      	str	r7, [r0, #52]	; 0x34
  ADCD3.adcm    = ADC3;
 8006fdc:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8006fe0:	e9c0 4406 	strd	r4, r4, [r0, #24]
  ADCD3.adcc = ADC3_4_COMMON;
 8006fe4:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
  ADCD1.dmamode = ADC_DMA_SIZE |
 8006fe8:	4e5c      	ldr	r6, [pc, #368]	; (800715c <main+0x34c>)
  adcp->thread   = NULL;
 8006fea:	6143      	str	r3, [r0, #20]
 8006fec:	6203      	str	r3, [r0, #32]
  adcp->state    = ADC_STOP;
 8006fee:	485f      	ldr	r0, [pc, #380]	; (800716c <main+0x35c>)
 8006ff0:	f885 b000 	strb.w	fp, [r5]
  ADCD2.dmamode = ADC_DMA_SIZE |
 8006ff4:	636f      	str	r7, [r5, #52]	; 0x34
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006ff6:	f44f 2a80 	mov.w	sl, #262144	; 0x40000
 8006ffa:	f44f 4900 	mov.w	r9, #32768	; 0x8000
 8006ffe:	f04f 5400 	mov.w	r4, #536870912	; 0x20000000
  adcp->samples  = NULL;
 8007002:	e9c5 3301 	strd	r3, r3, [r5, #4]
  adcp->grpp     = NULL;
 8007006:	e9c5 3303 	strd	r3, r3, [r5, #12]
  adcp->thread   = NULL;
 800700a:	616b      	str	r3, [r5, #20]
 800700c:	622b      	str	r3, [r5, #32]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800700e:	2550      	movs	r5, #80	; 0x50
  ADCD1.dmamode = ADC_DMA_SIZE |
 8007010:	6377      	str	r7, [r6, #52]	; 0x34
  adcp->state    = ADC_STOP;
 8007012:	f880 b000 	strb.w	fp, [r0]
  adcp->samples  = NULL;
 8007016:	e9c0 3301 	strd	r3, r3, [r0, #4]
  adcp->depth    = 0;
 800701a:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 800701c:	6103      	str	r3, [r0, #16]
  adcp->thread   = NULL;
 800701e:	6143      	str	r3, [r0, #20]
 8007020:	f882 5312 	strb.w	r5, [r2, #786]	; 0x312
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007024:	f8c2 a180 	str.w	sl, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007028:	f8c2 a000 	str.w	sl, [r2]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800702c:	f882 532f 	strb.w	r5, [r2, #815]	; 0x32f
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007030:	f8c2 9184 	str.w	r9, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007034:	f8c2 9004 	str.w	r9, [r2, #4]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007038:	f882 533d 	strb.w	r5, [r2, #829]	; 0x33d
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800703c:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007040:	6054      	str	r4, [r2, #4]
  rccEnableADC12(true);
 8007042:	f8d1 9014 	ldr.w	r9, [r1, #20]
  ADCD4.adcm    = ADC4;
 8007046:	4d4a      	ldr	r5, [pc, #296]	; (8007170 <main+0x360>)
  sdp->vmt = &vmt;
 8007048:	4c4a      	ldr	r4, [pc, #296]	; (8007174 <main+0x364>)
  adcp->grpp     = NULL;
 800704a:	4606      	mov	r6, r0
  rccEnableADC12(true);
 800704c:	f049 5980 	orr.w	r9, r9, #268435456	; 0x10000000
 8007050:	6233      	str	r3, [r6, #32]
 8007052:	f8c1 9014 	str.w	r9, [r1, #20]
  rccResetADC12();
 8007056:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
  ADCD4.adcc = ADC3_4_COMMON;
 800705a:	f8c6 e02c 	str.w	lr, [r6, #44]	; 0x2c
  ADC1_2_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 800705e:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
  rccResetADC12();
 8007062:	f049 5980 	orr.w	r9, r9, #268435456	; 0x10000000
 8007066:	f8c1 9028 	str.w	r9, [r1, #40]	; 0x28
 800706a:	628b      	str	r3, [r1, #40]	; 0x28
  ADC1_2_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 800706c:	f8c8 a008 	str.w	sl, [r8, #8]
  rccDisableADC12();
 8007070:	f8d1 8014 	ldr.w	r8, [r1, #20]
  ADCD4.dmamode = ADC_DMA_SIZE |
 8007074:	6377      	str	r7, [r6, #52]	; 0x34
  rccDisableADC12();
 8007076:	f028 5780 	bic.w	r7, r8, #268435456	; 0x10000000
 800707a:	614f      	str	r7, [r1, #20]
  rccEnableADC34(true);
 800707c:	694f      	ldr	r7, [r1, #20]
  ADCD4.adcm    = ADC4;
 800707e:	62b5      	str	r5, [r6, #40]	; 0x28
  rccEnableADC34(true);
 8007080:	f047 5700 	orr.w	r7, r7, #536870912	; 0x20000000
 8007084:	614f      	str	r7, [r1, #20]
  rccResetADC34();
 8007086:	6a8f      	ldr	r7, [r1, #40]	; 0x28
 8007088:	483b      	ldr	r0, [pc, #236]	; (8007178 <main+0x368>)
 800708a:	f8df 9120 	ldr.w	r9, [pc, #288]	; 80071ac <main+0x39c>
  oqp->q_buffer  = bp;
 800708e:	f8df 8120 	ldr.w	r8, [pc, #288]	; 80071b0 <main+0x3a0>
  iqp->q_buffer  = bp;
 8007092:	4d3a      	ldr	r5, [pc, #232]	; (800717c <main+0x36c>)
 8007094:	f047 5700 	orr.w	r7, r7, #536870912	; 0x20000000
 8007098:	628f      	str	r7, [r1, #40]	; 0x28
 800709a:	628b      	str	r3, [r1, #40]	; 0x28
  ADC3_4_COMMON->CCR = STM32_ADC_ADC34_CLOCK_MODE | ADC_DMA_MDMA;
 800709c:	f8ce a008 	str.w	sl, [lr, #8]
  rccDisableADC34();
 80070a0:	694f      	ldr	r7, [r1, #20]
 80070a2:	4686      	mov	lr, r0
 80070a4:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
 80070a8:	614f      	str	r7, [r1, #20]
  tqp->next = (thread_t *)tqp;
 80070aa:	f106 0a18 	add.w	sl, r6, #24
  ADCD4.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC4_DMA_STREAM);
 80070ae:	f10c 07a0 	add.w	r7, ip, #160	; 0xa0
  tqp->prev = (thread_t *)tqp;
 80070b2:	e9c6 aa06 	strd	sl, sl, [r6, #24]
 80070b6:	6337      	str	r7, [r6, #48]	; 0x30
 80070b8:	f84e 9b04 	str.w	r9, [lr], #4
  oqp->q_counter = size;
 80070bc:	f04f 0b10 	mov.w	fp, #16
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80070c0:	f8c0 e004 	str.w	lr, [r0, #4]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80070c4:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80070c8:	f04f 0e20 	mov.w	lr, #32
  iqp->q_counter = 0;
 80070cc:	6143      	str	r3, [r0, #20]
  oqp->q_counter = size;
 80070ce:	f8c0 b038 	str.w	fp, [r0, #56]	; 0x38
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80070d2:	f882 a325 	strb.w	sl, [r2, #805]	; 0x325
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80070d6:	f8c2 e184 	str.w	lr, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80070da:	f8c2 e004 	str.w	lr, [r2, #4]
  oqp->q_buffer  = bp;
 80070de:	f8c0 803c 	str.w	r8, [r0, #60]	; 0x3c
  oqp->q_wrptr   = bp;
 80070e2:	e9c0 8811 	strd	r8, r8, [r0, #68]	; 0x44
  oqp->q_top     = bp + size;
 80070e6:	44d8      	add	r8, fp
 80070e8:	f8c0 8040 	str.w	r8, [r0, #64]	; 0x40
  oqp->q_notify  = onfy;
 80070ec:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 80071b4 <main+0x3a4>
 80070f0:	f8c0 804c 	str.w	r8, [r0, #76]	; 0x4c
  SD1.usart = USART1;
 80070f4:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 80071b8 <main+0x3a8>
 80070f8:	f8c0 8054 	str.w	r8, [r0, #84]	; 0x54
 80070fc:	4626      	mov	r6, r4
  tqp->next = (thread_t *)tqp;
 80070fe:	f100 080c 	add.w	r8, r0, #12
  tqp->prev = (thread_t *)tqp;
 8007102:	e9c0 8803 	strd	r8, r8, [r0, #12]
  tqp->next = (thread_t *)tqp;
 8007106:	f100 0830 	add.w	r8, r0, #48	; 0x30
  iqp->q_buffer  = bp;
 800710a:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 80071bc <main+0x3ac>
 800710e:	f846 9b04 	str.w	r9, [r6], #4
  sdp->state = SD_STOP;
 8007112:	f04f 0701 	mov.w	r7, #1
 8007116:	6185      	str	r5, [r0, #24]
  iqp->q_wrptr   = bp;
 8007118:	e9c0 5508 	strd	r5, r5, [r0, #32]
  tqp->prev = (thread_t *)tqp;
 800711c:	e9c0 880c 	strd	r8, r8, [r0, #48]	; 0x30
  iqp->q_top     = bp + size;
 8007120:	445d      	add	r5, fp
  SD1.clock = STM32_USART1CLK;
 8007122:	f8df 809c 	ldr.w	r8, [pc, #156]	; 80071c0 <main+0x3b0>
  oqp->q_buffer  = bp;
 8007126:	f8df 909c 	ldr.w	r9, [pc, #156]	; 80071c4 <main+0x3b4>
 800712a:	7207      	strb	r7, [r0, #8]
  iqp->q_top     = bp + size;
 800712c:	61c5      	str	r5, [r0, #28]
 800712e:	f8c0 8058 	str.w	r8, [r0, #88]	; 0x58
  iqp->q_link    = link;
 8007132:	e9c0 300a 	strd	r3, r0, [r0, #40]	; 0x28
  oqp->q_link    = link;
 8007136:	6500      	str	r0, [r0, #80]	; 0x50
 8007138:	e046      	b.n	80071c8 <main+0x3b8>
 800713a:	bf00      	nop
 800713c:	40021000 	.word	0x40021000
 8007140:	40007000 	.word	0x40007000
 8007144:	20001534 	.word	0x20001534
 8007148:	40020408 	.word	0x40020408
 800714c:	20001ff4 	.word	0x20001ff4
 8007150:	40020080 	.word	0x40020080
 8007154:	e000e100 	.word	0xe000e100
 8007158:	40010000 	.word	0x40010000
 800715c:	200011e0 	.word	0x200011e0
 8007160:	20001218 	.word	0x20001218
 8007164:	20001fd0 	.word	0x20001fd0
 8007168:	20001250 	.word	0x20001250
 800716c:	20001288 	.word	0x20001288
 8007170:	50000500 	.word	0x50000500
 8007174:	20001438 	.word	0x20001438
 8007178:	200013d8 	.word	0x200013d8
 800717c:	200024c4 	.word	0x200024c4
 8007180:	40020008 	.word	0x40020008
 8007184:	4002001c 	.word	0x4002001c
 8007188:	40020030 	.word	0x40020030
 800718c:	40020044 	.word	0x40020044
 8007190:	40020058 	.word	0x40020058
 8007194:	4002006c 	.word	0x4002006c
 8007198:	0800e5bc 	.word	0x0800e5bc
 800719c:	50000300 	.word	0x50000300
 80071a0:	50000100 	.word	0x50000100
 80071a4:	50000700 	.word	0x50000700
 80071a8:	50000400 	.word	0x50000400
 80071ac:	0801d9d0 	.word	0x0801d9d0
 80071b0:	200024e4 	.word	0x200024e4
 80071b4:	08001291 	.word	0x08001291
 80071b8:	40013800 	.word	0x40013800
 80071bc:	200024d4 	.word	0x200024d4
 80071c0:	0112a880 	.word	0x0112a880
 80071c4:	200024f4 	.word	0x200024f4
  tqp->next = (thread_t *)tqp;
 80071c8:	f104 000c 	add.w	r0, r4, #12
 80071cc:	7227      	strb	r7, [r4, #8]
 80071ce:	6066      	str	r6, [r4, #4]
  tqp->prev = (thread_t *)tqp;
 80071d0:	e9c4 0003 	strd	r0, r0, [r4, #12]
  iqp->q_buffer  = bp;
 80071d4:	f8c4 e018 	str.w	lr, [r4, #24]
  iqp->q_top     = bp + size;
 80071d8:	eb0e 000b 	add.w	r0, lr, fp
  iqp->q_counter = 0;
 80071dc:	6163      	str	r3, [r4, #20]
  iqp->q_rdptr   = bp;
 80071de:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80071e2:	f8c4 e020 	str.w	lr, [r4, #32]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80071e6:	f04f 0e40 	mov.w	lr, #64	; 0x40
  spip->state = SPI_STOP;
 80071ea:	4faf      	ldr	r7, [pc, #700]	; (80074a8 <main+0x698>)
  oqp->q_counter = size;
 80071ec:	f8c4 b038 	str.w	fp, [r4, #56]	; 0x38
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80071f0:	f882 a326 	strb.w	sl, [r2, #806]	; 0x326
  iqp->q_top     = bp + size;
 80071f4:	61e0      	str	r0, [r4, #28]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80071f6:	f8c2 e184 	str.w	lr, [r2, #388]	; 0x184
  iqp->q_notify  = infy;
 80071fa:	62a3      	str	r3, [r4, #40]	; 0x28
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80071fc:	f8c2 e004 	str.w	lr, [r2, #4]
  oqp->q_top     = bp + size;
 8007200:	eb09 0e0b 	add.w	lr, r9, fp
  SD2.clock = STM32_USART2CLK;
 8007204:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58
  oqp->q_notify  = onfy;
 8007208:	f8df 82f0 	ldr.w	r8, [pc, #752]	; 80074fc <main+0x6ec>
 800720c:	4da7      	ldr	r5, [pc, #668]	; (80074ac <main+0x69c>)
  oqp->q_top     = bp + size;
 800720e:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
  oqp->q_notify  = onfy;
 8007212:	f8c4 804c 	str.w	r8, [r4, #76]	; 0x4c
  SPID1.spi       = SPI1;
 8007216:	f8df e2e8 	ldr.w	lr, [pc, #744]	; 8007500 <main+0x6f0>
 800721a:	48a5      	ldr	r0, [pc, #660]	; (80074b0 <main+0x6a0>)
 800721c:	f8c7 e01c 	str.w	lr, [r7, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8007220:	f10c 0814 	add.w	r8, ip, #20
 8007224:	f8c7 8020 	str.w	r8, [r7, #32]
  tqp->next = (thread_t *)tqp;
 8007228:	f107 0e0c 	add.w	lr, r7, #12
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800722c:	f10c 0828 	add.w	r8, ip, #40	; 0x28
  oqp->q_buffer  = bp;
 8007230:	f8c4 903c 	str.w	r9, [r4, #60]	; 0x3c
  oqp->q_wrptr   = bp;
 8007234:	e9c4 9911 	strd	r9, r9, [r4, #68]	; 0x44
 8007238:	f104 0630 	add.w	r6, r4, #48	; 0x30
  SD2.usart = USART2;
 800723c:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 8007504 <main+0x6f4>
  WDGD1.state = WDG_STOP;
 8007240:	f8df a2c4 	ldr.w	sl, [pc, #708]	; 8007508 <main+0x6f8>
 8007244:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
  tqp->prev = (thread_t *)tqp;
 8007248:	e9c7 ee03 	strd	lr, lr, [r7, #12]
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 800724c:	f241 080a 	movw	r8, #4106	; 0x100a
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8007250:	f241 0e18 	movw	lr, #4120	; 0x1018
 8007254:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
 8007258:	e9c4 660c 	strd	r6, r6, [r4, #48]	; 0x30
  tqp->next = (thread_t *)tqp;
 800725c:	f105 090c 	add.w	r9, r5, #12
 8007260:	f04f 0601 	mov.w	r6, #1
 8007264:	e9c7 8e0a 	strd	r8, lr, [r7, #40]	; 0x28
 8007268:	703e      	strb	r6, [r7, #0]
 800726a:	702e      	strb	r6, [r5, #0]
  spip->thread = NULL;
 800726c:	e9c7 3301 	strd	r3, r3, [r7, #4]
 8007270:	617b      	str	r3, [r7, #20]
 8007272:	e9c5 3301 	strd	r3, r3, [r5, #4]
  iqp->q_link    = link;
 8007276:	62e4      	str	r4, [r4, #44]	; 0x2c
  oqp->q_link    = link;
 8007278:	6524      	str	r4, [r4, #80]	; 0x50
 800727a:	f8c5 900c 	str.w	r9, [r5, #12]
  spip->state = SPI_STOP;
 800727e:	7006      	strb	r6, [r0, #0]
 8007280:	f88a 6000 	strb.w	r6, [sl]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8007284:	69cf      	ldr	r7, [r1, #28]
  tqp->prev = (thread_t *)tqp;
 8007286:	f8c5 9010 	str.w	r9, [r5, #16]
 800728a:	f047 0701 	orr.w	r7, r7, #1
 800728e:	61cf      	str	r7, [r1, #28]
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8007290:	e9c5 8e0a 	strd	r8, lr, [r5, #40]	; 0x28

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8007294:	4f87      	ldr	r7, [pc, #540]	; (80074b4 <main+0x6a4>)
 8007296:	616b      	str	r3, [r5, #20]
 8007298:	68b9      	ldr	r1, [r7, #8]
  SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
 800729a:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
 800729e:	f10c 068c 	add.w	r6, ip, #140	; 0x8c
  SPID2.spi       = SPI2;
 80072a2:	f8df e268 	ldr.w	lr, [pc, #616]	; 800750c <main+0x6fc>
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
 80072a6:	6206      	str	r6, [r0, #32]
  SPID2.spi       = SPI2;
 80072a8:	f8c5 e01c 	str.w	lr, [r5, #28]
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 80072ac:	f10c 06a0 	add.w	r6, ip, #160	; 0xa0
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80072b0:	f10c 0e3c 	add.w	lr, ip, #60	; 0x3c
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80072b4:	f10c 0c50 	add.w	ip, ip, #80	; 0x50
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80072b8:	f8c5 e020 	str.w	lr, [r5, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80072bc:	f8c5 c024 	str.w	ip, [r5, #36]	; 0x24
 80072c0:	f041 0901 	orr.w	r9, r1, #1
  SPID3.spi       = SPI3;
 80072c4:	f8df e248 	ldr.w	lr, [pc, #584]	; 8007510 <main+0x700>
  WDGD1.wdg   = IWDG;
 80072c8:	4d7b      	ldr	r5, [pc, #492]	; (80074b8 <main+0x6a8>)
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 80072ca:	6246      	str	r6, [r0, #36]	; 0x24

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80072cc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  SPID3.spi       = SPI3;
 80072d0:	f8c0 e01c 	str.w	lr, [r0, #28]
 80072d4:	f8ca 5008 	str.w	r5, [sl, #8]
  tqp->next = (thread_t *)tqp;
 80072d8:	f8df b238 	ldr.w	fp, [pc, #568]	; 8007514 <main+0x704>
  SPID3.rxdmamode = STM32_DMA_CR_CHSEL(SPI3_RX_DMA_CHANNEL) |
 80072dc:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
 80072e0:	f100 050c 	add.w	r5, r0, #12
 80072e4:	f640 6e0f 	movw	lr, #3599	; 0xe0f
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80072e8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  spip->thread = NULL;
 80072ec:	e9c0 3301 	strd	r3, r3, [r0, #4]
 80072f0:	6143      	str	r3, [r0, #20]
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80072f2:	f8df c224 	ldr.w	ip, [pc, #548]	; 8007518 <main+0x708>
  ST_ENABLE_STOP();
 80072f6:	f8c7 9008 	str.w	r9, [r7, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80072fa:	f8c1 e028 	str.w	lr, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80072fe:	62ce      	str	r6, [r1, #44]	; 0x2c
 8007300:	60c5      	str	r5, [r0, #12]
  STM32_ST_TIM->CCMR1  = 0;
 8007302:	618b      	str	r3, [r1, #24]
  tqp->prev = (thread_t *)tqp;
 8007304:	6105      	str	r5, [r0, #16]
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8007306:	2001      	movs	r0, #1
  STM32_ST_TIM->CCR[0] = 0;
 8007308:	634b      	str	r3, [r1, #52]	; 0x34
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800730a:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
  STM32_ST_TIM->DIER   = 0;
 800730e:	60cb      	str	r3, [r1, #12]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8007310:	f10b 0e1c 	add.w	lr, fp, #28
  STM32_ST_TIM->CR2    = 0;
 8007314:	604b      	str	r3, [r1, #4]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8007316:	f10b 0840 	add.w	r8, fp, #64	; 0x40
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800731a:	6148      	str	r0, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800731c:	6008      	str	r0, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800731e:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8007322:	f882 131c 	strb.w	r1, [r2, #796]	; 0x31c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8007326:	461d      	mov	r5, r3
  ch.vtlist.delta = (sysinterval_t)-1;
 8007328:	f8cb 6024 	str.w	r6, [fp, #36]	; 0x24
  ch.rlist.prio = NOPRIO;
 800732c:	e9cb b301 	strd	fp, r3, [fp, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8007330:	e9cb bb04 	strd	fp, fp, [fp, #16]
  ch.vtlist.lasttime = (systime_t)0;
 8007334:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8007338:	e9cb c80e 	strd	ip, r8, [fp, #56]	; 0x38
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800733c:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8007340:	f8cb e01c 	str.w	lr, [fp, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007344:	6017      	str	r7, [r2, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8007346:	f8cb e020 	str.w	lr, [fp, #32]
  tqp->next = (thread_t *)tqp;
 800734a:	f8cb b000 	str.w	fp, [fp]
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800734e:	3501      	adds	r5, #1
 8007350:	eb0b 1305 	add.w	r3, fp, r5, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8007354:	2d80      	cmp	r5, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8007356:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 800735a:	f36f 0202 	bfc	r2, #0, #3
 800735e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8007362:	d1f4      	bne.n	800734e <main+0x53e>
  ch.dbg.isr_cnt  = (cnt_t)0;
 8007364:	2600      	movs	r6, #0
  tmp->best       = (rtcnt_t)-1;
 8007366:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  tmp->cumulative = (rttime_t)0;
 800736a:	2200      	movs	r2, #0
 800736c:	2300      	movs	r3, #0
  chTMStartMeasurementX(&tm);
 800736e:	a806      	add	r0, sp, #24
  tmp->cumulative = (rttime_t)0;
 8007370:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  tmp->best       = (rtcnt_t)-1;
 8007374:	9106      	str	r1, [sp, #24]
  ch.dbg.lock_cnt = (cnt_t)0;
 8007376:	e9cb 660c 	strd	r6, r6, [fp, #48]	; 0x30
  ch.tm.offset = (rtcnt_t)0;
 800737a:	f8cb 6884 	str.w	r6, [fp, #2180]	; 0x884
  tmp->last       = (rtcnt_t)0;
 800737e:	e9cd 6607 	strd	r6, r6, [sp, #28]
  tmp->n          = (ucnt_t)0;
 8007382:	9609      	str	r6, [sp, #36]	; 0x24
  chTMStartMeasurementX(&tm);
 8007384:	f7f9 ff7c 	bl	8001280 <chTMStartMeasurementX.constprop.27>
  chTMStopMeasurementX(&tm);
 8007388:	a806      	add	r0, sp, #24
 800738a:	f7f9 ffc9 	bl	8001320 <chTMStopMeasurementX>
  default_heap.provider = chCoreAllocAlignedWithOffset;
 800738e:	4a4b      	ldr	r2, [pc, #300]	; (80074bc <main+0x6ac>)
 8007390:	4b4b      	ldr	r3, [pc, #300]	; (80074c0 <main+0x6b0>)
 8007392:	f8df c188 	ldr.w	ip, [pc, #392]	; 800751c <main+0x70c>
  tp->prio      = prio;
 8007396:	f8cb 5848 	str.w	r5, [fp, #2120]	; 0x848
 800739a:	f102 070c 	add.w	r7, r2, #12
  tqp->prev = (thread_t *)tqp;
 800739e:	e9c2 7703 	strd	r7, r7, [r2, #12]
  tp->realprio  = prio;
 80073a2:	f8cb 587c 	str.w	r5, [fp, #2172]	; 0x87c
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80073a6:	f103 0724 	add.w	r7, r3, #36	; 0x24
 80073aa:	f103 0510 	add.w	r5, r3, #16
  H_PAGES(&default_heap.header) = 0;
 80073ae:	e9c2 6601 	strd	r6, r6, [r2, #4]
 80073b2:	6156      	str	r6, [r2, #20]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 80073b4:	f8c2 c000 	str.w	ip, [r2]
 80073b8:	611d      	str	r5, [r3, #16]
 80073ba:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80073be:	f103 053c 	add.w	r5, r3, #60	; 0x3c
 80073c2:	625f      	str	r7, [r3, #36]	; 0x24
  mp->object_size = size;
 80073c4:	f04f 0c14 	mov.w	ip, #20
 80073c8:	f103 0740 	add.w	r7, r3, #64	; 0x40
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80073cc:	493d      	ldr	r1, [pc, #244]	; (80074c4 <main+0x6b4>)
 80073ce:	609e      	str	r6, [r3, #8]
  mp->next = NULL;
 80073d0:	615e      	str	r6, [r3, #20]
 80073d2:	62de      	str	r6, [r3, #44]	; 0x2c
  mp->object_size = size;
 80073d4:	f8c3 c018 	str.w	ip, [r3, #24]
 80073d8:	629a      	str	r2, [r3, #40]	; 0x28
  mp->align = align;
 80073da:	f04f 0c04 	mov.w	ip, #4
  mp->provider = provider;
 80073de:	4a3a      	ldr	r2, [pc, #232]	; (80074c8 <main+0x6b8>)
 80073e0:	63dd      	str	r5, [r3, #60]	; 0x3c
 80073e2:	641f      	str	r7, [r3, #64]	; 0x40
  ch_memcore.nextmem = __heap_base__;
 80073e4:	4839      	ldr	r0, [pc, #228]	; (80074cc <main+0x6bc>)
  tp->flags     = CH_FLAG_MODE_STATIC;
 80073e6:	f88b 6861 	strb.w	r6, [fp, #2145]	; 0x861
  tp->mtxlist   = NULL;
 80073ea:	f8cb 6878 	str.w	r6, [fp, #2168]	; 0x878
  tp->epending  = (eventmask_t)0;
 80073ee:	f8cb 6874 	str.w	r6, [fp, #2164]	; 0x874
 80073f2:	4d37      	ldr	r5, [pc, #220]	; (80074d0 <main+0x6c0>)
  ch_memcore.endmem  = __heap_end__;
 80073f4:	4f37      	ldr	r7, [pc, #220]	; (80074d4 <main+0x6c4>)
  mp->align = align;
 80073f6:	f8c3 c01c 	str.w	ip, [r3, #28]
  mp->object_size = size;
 80073fa:	261c      	movs	r6, #28
 80073fc:	631e      	str	r6, [r3, #48]	; 0x30
  mp->align = align;
 80073fe:	f8c3 c034 	str.w	ip, [r3, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 8007402:	2601      	movs	r6, #1
  mp->provider = provider;
 8007404:	621a      	str	r2, [r3, #32]
 8007406:	639a      	str	r2, [r3, #56]	; 0x38
 8007408:	e9c3 3300 	strd	r3, r3, [r3]
  ch.tm.offset = tm.last;
 800740c:	9a08      	ldr	r2, [sp, #32]
  tp->name      = name;
 800740e:	4b32      	ldr	r3, [pc, #200]	; (80074d8 <main+0x6c8>)
 8007410:	f8cb 2884 	str.w	r2, [fp, #2180]	; 0x884
 8007414:	e9c0 5700 	strd	r5, r7, [r0]
  tp->refs      = (trefs_t)1;
 8007418:	f88b 6862 	strb.w	r6, [fp, #2146]	; 0x862
  tp->name      = name;
 800741c:	f8cb 3858 	str.w	r3, [fp, #2136]	; 0x858
 8007420:	68c8      	ldr	r0, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8007422:	4a2e      	ldr	r2, [pc, #184]	; (80074dc <main+0x6cc>)
  REG_INSERT(tp);
 8007424:	f8db 7014 	ldr.w	r7, [fp, #20]
 8007428:	4b2d      	ldr	r3, [pc, #180]	; (80074e0 <main+0x6d0>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800742a:	4d2e      	ldr	r5, [pc, #184]	; (80074e4 <main+0x6d4>)
 800742c:	f8cb 7854 	str.w	r7, [fp, #2132]	; 0x854
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8007430:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
 8007434:	ea00 000c 	and.w	r0, r0, ip
  reg_value  =  (reg_value                                   |
 8007438:	4302      	orrs	r2, r0
 800743a:	f8cb b850 	str.w	fp, [fp, #2128]	; 0x850
 800743e:	613b      	str	r3, [r7, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8007440:	60ca      	str	r2, [r1, #12]
 8007442:	68e8      	ldr	r0, [r5, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8007444:	4a28      	ldr	r2, [pc, #160]	; (80074e8 <main+0x6d8>)
  currp->state = CH_STATE_CURRENT;
 8007446:	f88b 6860 	strb.w	r6, [fp, #2144]	; 0x860
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800744a:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 800744e:	60e8      	str	r0, [r5, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8007450:	6817      	ldr	r7, [r2, #0]
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8007452:	f8db 0030 	ldr.w	r0, [fp, #48]	; 0x30
 8007456:	f8cb 3014 	str.w	r3, [fp, #20]
 800745a:	4337      	orrs	r7, r6
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800745c:	f8cb 3018 	str.w	r3, [fp, #24]
    currp->wabase = &__main_thread_stack_base__;
 8007460:	4d22      	ldr	r5, [pc, #136]	; (80074ec <main+0x6dc>)
 8007462:	6017      	str	r7, [r2, #0]
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8007464:	2610      	movs	r6, #16
  tlp->next = (thread_t *)tlp;
 8007466:	f103 0728 	add.w	r7, r3, #40	; 0x28
 800746a:	2220      	movs	r2, #32
  tqp->next = (thread_t *)tqp;
 800746c:	332c      	adds	r3, #44	; 0x2c
 800746e:	77ce      	strb	r6, [r1, #31]
  tlp->next = (thread_t *)tlp;
 8007470:	f8cb 7868 	str.w	r7, [fp, #2152]	; 0x868
 8007474:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  tqp->next = (thread_t *)tqp;
 8007478:	f8cb 386c 	str.w	r3, [fp, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 800747c:	f8cb 3870 	str.w	r3, [fp, #2160]	; 0x870
 8007480:	f8cb 585c 	str.w	r5, [fp, #2140]	; 0x85c
 8007484:	b910      	cbnz	r0, 800748c <main+0x67c>
 8007486:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800748a:	b113      	cbz	r3, 8007492 <main+0x682>
    chSysHalt("SV#3");
 800748c:	4818      	ldr	r0, [pc, #96]	; (80074f0 <main+0x6e0>)
 800748e:	f7f9 ff8f 	bl	80013b0 <chSysHalt>
 8007492:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8007496:	b662      	cpsie	i
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8007498:	4816      	ldr	r0, [pc, #88]	; (80074f4 <main+0x6e4>)
 800749a:	f7ff fa21 	bl	80068e0 <chRegFindThreadByWorkingArea>
 800749e:	2800      	cmp	r0, #0
 80074a0:	d03e      	beq.n	8007520 <main+0x710>
 80074a2:	4815      	ldr	r0, [pc, #84]	; (80074f8 <main+0x6e8>)
 80074a4:	f7f9 ff84 	bl	80013b0 <chSysHalt>
 80074a8:	20001498 	.word	0x20001498
 80074ac:	200014c8 	.word	0x200014c8
 80074b0:	200014f8 	.word	0x200014f8
 80074b4:	e0042000 	.word	0xe0042000
 80074b8:	40003000 	.word	0x40003000
 80074bc:	20001fd4 	.word	0x20001fd4
 80074c0:	20001e24 	.word	0x20001e24
 80074c4:	e000ed00 	.word	0xe000ed00
 80074c8:	08001441 	.word	0x08001441
 80074cc:	20001fc8 	.word	0x20001fc8
 80074d0:	20005da8 	.word	0x20005da8
 80074d4:	2000a000 	.word	0x2000a000
 80074d8:	0800e73c 	.word	0x0800e73c
 80074dc:	05fa0300 	.word	0x05fa0300
 80074e0:	20001ddc 	.word	0x20001ddc
 80074e4:	e000edf0 	.word	0xe000edf0
 80074e8:	e0001000 	.word	0xe0001000
 80074ec:	20000400 	.word	0x20000400
 80074f0:	0801d764 	.word	0x0801d764
 80074f4:	20001e68 	.word	0x20001e68
 80074f8:	0800e2b0 	.word	0x0800e2b0
 80074fc:	080012a1 	.word	0x080012a1
 8007500:	40013000 	.word	0x40013000
 8007504:	40004400 	.word	0x40004400
 8007508:	20001528 	.word	0x20001528
 800750c:	40003800 	.word	0x40003800
 8007510:	40003c00 	.word	0x40003c00
 8007514:	2000159c 	.word	0x2000159c
 8007518:	0080fff0 	.word	0x0080fff0
 800751c:	080014a1 	.word	0x080014a1
 8007520:	4d58      	ldr	r5, [pc, #352]	; (8007684 <main+0x874>)
 8007522:	4603      	mov	r3, r0
    *startp++ = v;
 8007524:	2255      	movs	r2, #85	; 0x55
 8007526:	54ea      	strb	r2, [r5, r3]
 8007528:	3301      	adds	r3, #1
  while (startp < endp) {
 800752a:	f5b3 7fb0 	cmp.w	r3, #352	; 0x160
 800752e:	d1fa      	bne.n	8007526 <main+0x716>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007530:	2620      	movs	r6, #32
 8007532:	f386 8811 	msr	BASEPRI, r6
 8007536:	f7fd fecb 	bl	80052d0 <_dbg_check_lock>
  chDbgCheckClassI();
 800753a:	f7f9 ff71 	bl	8001420 <chDbgCheckClassI>
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800753e:	4a52      	ldr	r2, [pc, #328]	; (8007688 <main+0x878>)
 8007540:	4952      	ldr	r1, [pc, #328]	; (800768c <main+0x87c>)
 8007542:	4b53      	ldr	r3, [pc, #332]	; (8007690 <main+0x880>)
 8007544:	f8c5 20f4 	str.w	r2, [r5, #244]	; 0xf4
 8007548:	f8c5 1114 	str.w	r1, [r5, #276]	; 0x114
  tp->state     = CH_STATE_WTSTART;
 800754c:	2202      	movs	r2, #2
  tp->name      = name;
 800754e:	4951      	ldr	r1, [pc, #324]	; (8007694 <main+0x884>)
  REG_INSERT(tp);
 8007550:	f8db 0014 	ldr.w	r0, [fp, #20]
  tp->state     = CH_STATE_WTSTART;
 8007554:	f8a5 2138 	strh.w	r2, [r5, #312]	; 0x138
  tp->name      = name;
 8007558:	f8c5 1130 	str.w	r1, [r5, #304]	; 0x130
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800755c:	2200      	movs	r2, #0
  tp->prio      = prio;
 800755e:	2101      	movs	r1, #1
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8007560:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
 8007564:	f8c5 20f8 	str.w	r2, [r5, #248]	; 0xf8
  tp->mtxlist   = NULL;
 8007568:	f8c5 2150 	str.w	r2, [r5, #336]	; 0x150
  tp->epending  = (eventmask_t)0;
 800756c:	f8c5 214c 	str.w	r2, [r5, #332]	; 0x14c
  tp->prio      = prio;
 8007570:	f8c5 1120 	str.w	r1, [r5, #288]	; 0x120
  REG_INSERT(tp);
 8007574:	f103 0264 	add.w	r2, r3, #100	; 0x64
  tp->realprio  = prio;
 8007578:	f8c5 1154 	str.w	r1, [r5, #340]	; 0x154
  tp->flags     = CH_FLAG_MODE_STATIC;
 800757c:	f885 113a 	strb.w	r1, [r5, #314]	; 0x13a
  tlp->next = (thread_t *)tlp;
 8007580:	f103 018c 	add.w	r1, r3, #140	; 0x8c
  tqp->next = (thread_t *)tqp;
 8007584:	3390      	adds	r3, #144	; 0x90
  REG_INSERT(tp);
 8007586:	f8c5 012c 	str.w	r0, [r5, #300]	; 0x12c
  tp->wabase = tdp->wbase;
 800758a:	f8c5 5134 	str.w	r5, [r5, #308]	; 0x134
  REG_INSERT(tp);
 800758e:	f8c5 b128 	str.w	fp, [r5, #296]	; 0x128
 8007592:	6102      	str	r2, [r0, #16]
 8007594:	f8c5 3144 	str.w	r3, [r5, #324]	; 0x144
  tqp->prev = (thread_t *)tqp;
 8007598:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
  chSchWakeupS(tp, MSG_OK);
 800759c:	4610      	mov	r0, r2
  tlp->next = (thread_t *)tlp;
 800759e:	f8c5 1140 	str.w	r1, [r5, #320]	; 0x140
  REG_INSERT(tp);
 80075a2:	f8cb 2014 	str.w	r2, [fp, #20]
  chSchWakeupS(tp, MSG_OK);
 80075a6:	f7fb f8c3 	bl	8002730 <chSchWakeupS.constprop.32>
  chSysUnlock();
 80075aa:	f7fa f841 	bl	8001630 <chSysUnlock.lto_priv.78>
  halInit();
  chSysInit();
 

  
  palSetPad(GPIOB, 5);
 80075ae:	4b3a      	ldr	r3, [pc, #232]	; (8007698 <main+0x888>)
 80075b0:	831e      	strh	r6, [r3, #24]
 80075b2:	f386 8811 	msr	BASEPRI, r6
 80075b6:	f7fd fe8b 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert((wdgp->state == WDG_STOP) || (wdgp->state == WDG_READY),
 80075ba:	f89a 3000 	ldrb.w	r3, [sl]
 80075be:	3b01      	subs	r3, #1
 80075c0:	2b01      	cmp	r3, #1
 80075c2:	d902      	bls.n	80075ca <main+0x7ba>
 80075c4:	4835      	ldr	r0, [pc, #212]	; (800769c <main+0x88c>)
 80075c6:	f7f9 fef3 	bl	80013b0 <chSysHalt>
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 80075ca:	f8da 3008 	ldr.w	r3, [sl, #8]
  wdgp->config = config;
 80075ce:	4a34      	ldr	r2, [pc, #208]	; (80076a0 <main+0x890>)
 80075d0:	f8ca 2004 	str.w	r2, [sl, #4]
 80075d4:	f64c 41cc 	movw	r1, #52428	; 0xcccc
  wdgp->wdg->KR   = KR_KEY_WRITE;
 80075d8:	f245 5255 	movw	r2, #21845	; 0x5555
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 80075dc:	6019      	str	r1, [r3, #0]
  wdgp->wdg->KR   = KR_KEY_WRITE;
 80075de:	601a      	str	r2, [r3, #0]
  wdgp->wdg->PR   = wdgp->config->pr;
 80075e0:	2104      	movs	r1, #4
  wdgp->wdg->RLR  = wdgp->config->rlr;
 80075e2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  wdgp->wdg->PR   = wdgp->config->pr;
 80075e6:	6059      	str	r1, [r3, #4]
  wdgp->wdg->RLR  = wdgp->config->rlr;
 80075e8:	609a      	str	r2, [r3, #8]
  while (wdgp->wdg->SR != 0)
 80075ea:	68da      	ldr	r2, [r3, #12]
 80075ec:	2a00      	cmp	r2, #0
 80075ee:	d1fc      	bne.n	80075ea <main+0x7da>
  wdgp->wdg->WINR = wdgp->config->winr;
 80075f0:	f640 72ff 	movw	r2, #4095	; 0xfff
 80075f4:	611a      	str	r2, [r3, #16]
  wdgp->state = WDG_READY;
 80075f6:	2302      	movs	r3, #2
 80075f8:	f88a 3000 	strb.w	r3, [sl]
  _dbg_check_unlock();
 80075fc:	f7fd fe40 	bl	8005280 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007600:	f8db 3000 	ldr.w	r3, [fp]
 8007604:	455b      	cmp	r3, fp
 8007606:	d005      	beq.n	8007614 <main+0x804>
 8007608:	f8db 2018 	ldr.w	r2, [fp, #24]
 800760c:	689b      	ldr	r3, [r3, #8]
 800760e:	6892      	ldr	r2, [r2, #8]
 8007610:	429a      	cmp	r2, r3
 8007612:	d334      	bcc.n	800767e <main+0x86e>
 8007614:	2500      	movs	r5, #0
 8007616:	f385 8811 	msr	BASEPRI, r5
  wdgStart(&WDGD1, &wdgcfg);
  wdgReset(&WDGD1);
 800761a:	f7fa fe69 	bl	80022f0 <wdgReset.constprop.34>
  mbp->buffer = buf;
 800761e:	4a21      	ldr	r2, [pc, #132]	; (80076a4 <main+0x894>)
 8007620:	4921      	ldr	r1, [pc, #132]	; (80076a8 <main+0x898>)
 8007622:	4b22      	ldr	r3, [pc, #136]	; (80076ac <main+0x89c>)
 8007624:	4822      	ldr	r0, [pc, #136]	; (80076b0 <main+0x8a0>)
 8007626:	6011      	str	r1, [r2, #0]
  mbp->wrptr  = buf;
 8007628:	e9c2 1102 	strd	r1, r1, [r2, #8]
  mbp->top    = &buf[n];
 800762c:	3164      	adds	r1, #100	; 0x64
  mbp->cnt    = (size_t)0;
 800762e:	6115      	str	r5, [r2, #16]
  mbp->reset  = false;
 8007630:	7515      	strb	r5, [r2, #20]
  mbp->top    = &buf[n];
 8007632:	6051      	str	r1, [r2, #4]
  mbp->cnt    = (size_t)0;
 8007634:	611d      	str	r5, [r3, #16]
  mbp->reset  = false;
 8007636:	751d      	strb	r5, [r3, #20]
  mbp->buffer = buf;
 8007638:	6018      	str	r0, [r3, #0]
  mbp->top    = &buf[n];
 800763a:	f100 0564 	add.w	r5, r0, #100	; 0x64
  mbp->wrptr  = buf;
 800763e:	e9c3 0002 	strd	r0, r0, [r3, #8]
  tqp->next = (thread_t *)tqp;
 8007642:	f102 0118 	add.w	r1, r2, #24
 8007646:	f102 0020 	add.w	r0, r2, #32
  tqp->prev = (thread_t *)tqp;
 800764a:	e9c2 1106 	strd	r1, r1, [r2, #24]
 800764e:	e9c2 0008 	strd	r0, r0, [r2, #32]
  tqp->next = (thread_t *)tqp;
 8007652:	f103 0118 	add.w	r1, r3, #24
 8007656:	f103 0220 	add.w	r2, r3, #32
  mbp->top    = &buf[n];
 800765a:	605d      	str	r5, [r3, #4]
  tqp->prev = (thread_t *)tqp;
 800765c:	e9c3 1106 	strd	r1, r1, [r3, #24]
 8007660:	e9c3 2208 	strd	r2, r2, [r3, #32]
 8007664:	2320      	movs	r3, #32
 8007666:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800766a:	f7fd fe31 	bl	80052d0 <_dbg_check_lock>
void adcStart(ADCDriver *adcp, const ADCConfig *config) {

  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800766e:	4b11      	ldr	r3, [pc, #68]	; (80076b4 <main+0x8a4>)
 8007670:	781b      	ldrb	r3, [r3, #0]
 8007672:	1e5a      	subs	r2, r3, #1
 8007674:	2a01      	cmp	r2, #1
 8007676:	d923      	bls.n	80076c0 <main+0x8b0>
 8007678:	480f      	ldr	r0, [pc, #60]	; (80076b8 <main+0x8a8>)
 800767a:	f7f9 fe99 	bl	80013b0 <chSysHalt>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800767e:	480f      	ldr	r0, [pc, #60]	; (80076bc <main+0x8ac>)
 8007680:	f7f9 fe96 	bl	80013b0 <chSysHalt>
 8007684:	20001e68 	.word	0x20001e68
 8007688:	08001801 	.word	0x08001801
 800768c:	080002e1 	.word	0x080002e1
 8007690:	20001f1c 	.word	0x20001f1c
 8007694:	0801d76c 	.word	0x0801d76c
 8007698:	48000400 	.word	0x48000400
 800769c:	0800e39c 	.word	0x0800e39c
 80076a0:	0801dbf8 	.word	0x0801dbf8
 80076a4:	200012c0 	.word	0x200012c0
 80076a8:	20001310 	.word	0x20001310
 80076ac:	200012e8 	.word	0x200012e8
 80076b0:	20001374 	.word	0x20001374
 80076b4:	200011e0 	.word	0x200011e0
 80076b8:	0800e3b4 	.word	0x0800e3b4
 80076bc:	0800e1d8 	.word	0x0800e1d8
    adcp->config = &default_config;
 80076c0:	4abc      	ldr	r2, [pc, #752]	; (80079b4 <main+0xba4>)
 80076c2:	49bd      	ldr	r1, [pc, #756]	; (80079b8 <main+0xba8>)
 80076c4:	6051      	str	r1, [r2, #4]
  if (adcp->state == ADC_STOP) {
 80076c6:	2b01      	cmp	r3, #1
 80076c8:	f000 8107 	beq.w	80078da <main+0xaca>
                "invalid state");
  adcp->config = config;
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 80076cc:	4ab9      	ldr	r2, [pc, #740]	; (80079b4 <main+0xba4>)
 80076ce:	2302      	movs	r3, #2
 80076d0:	7013      	strb	r3, [r2, #0]
  _dbg_check_unlock();
 80076d2:	f7fd fdd5 	bl	8005280 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80076d6:	f8db 3000 	ldr.w	r3, [fp]
 80076da:	455b      	cmp	r3, fp
 80076dc:	d006      	beq.n	80076ec <main+0x8dc>
 80076de:	f8db 2018 	ldr.w	r2, [fp, #24]
 80076e2:	689b      	ldr	r3, [r3, #8]
 80076e4:	6892      	ldr	r2, [r2, #8]
 80076e6:	429a      	cmp	r2, r3
 80076e8:	f0c0 8127 	bcc.w	800793a <main+0xb2a>
 80076ec:	2700      	movs	r7, #0
 80076ee:	f387 8811 	msr	BASEPRI, r7
  ADC12_COMMON->CCR |= ADC12_CCR_VREFEN;
 80076f2:	4eb2      	ldr	r6, [pc, #712]	; (80079bc <main+0xbac>)
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 80076f4:	4aaf      	ldr	r2, [pc, #700]	; (80079b4 <main+0xba4>)
 80076f6:	68b3      	ldr	r3, [r6, #8]
  ADC34_COMMON->CCR |= ADC34_CCR_VREFEN;
 80076f8:	49b1      	ldr	r1, [pc, #708]	; (80079c0 <main+0xbb0>)
 80076fa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  /*
   * SPI1 I/O pins setup.
   */


  palSetPadMode(GPIOD, 9, PAL_MODE_INPUT_ANALOG);
 80076fc:	48b1      	ldr	r0, [pc, #708]	; (80079c4 <main+0xbb4>)
  
  // Temp SPI

  palSetPadMode(GPIOA, 1, PAL_MODE_OUTPUT_PUSHPULL); // tx/rx

  palSetPadMode(GPIOC, 0, PAL_MODE_OUTPUT_PUSHPULL); // rtd 0
 80076fe:	4db2      	ldr	r5, [pc, #712]	; (80079c8 <main+0xbb8>)
  ADC12_COMMON->CCR |= ADC12_CCR_VREFEN;
 8007700:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8007704:	60b3      	str	r3, [r6, #8]
  ADC34_COMMON->CCR |= ADC34_CCR_VREFEN;
 8007706:	688b      	ldr	r3, [r1, #8]

  



  if (*flash2 == 0xffff)
 8007708:	4eb0      	ldr	r6, [pc, #704]	; (80079cc <main+0xbbc>)
  ADC34_COMMON->CCR |= ADC34_CCR_VREFEN;
 800770a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800770e:	608b      	str	r3, [r1, #8]
 8007710:	6893      	ldr	r3, [r2, #8]
 8007712:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8007716:	6093      	str	r3, [r2, #8]
  palSetPadMode(GPIOD, 9, PAL_MODE_INPUT_ANALOG);
 8007718:	f44f 7100 	mov.w	r1, #512	; 0x200
 800771c:	2203      	movs	r2, #3
 800771e:	f7fa fa07 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, 11, PAL_MODE_INPUT_ANALOG);
 8007722:	2203      	movs	r2, #3
 8007724:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007728:	48a6      	ldr	r0, [pc, #664]	; (80079c4 <main+0xbb4>)
 800772a:	f7fa fa01 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, 12, PAL_MODE_INPUT_ANALOG);
 800772e:	2203      	movs	r2, #3
 8007730:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8007734:	48a3      	ldr	r0, [pc, #652]	; (80079c4 <main+0xbb4>)
 8007736:	f7fa f9fb 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, 13, PAL_MODE_INPUT_ANALOG);
 800773a:	2203      	movs	r2, #3
 800773c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8007740:	48a0      	ldr	r0, [pc, #640]	; (80079c4 <main+0xbb4>)
 8007742:	f7fa f9f5 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 6, PAL_MODE_ALTERNATE(7));    
 8007746:	f240 3282 	movw	r2, #898	; 0x382
 800774a:	2140      	movs	r1, #64	; 0x40
 800774c:	48a0      	ldr	r0, [pc, #640]	; (80079d0 <main+0xbc0>)
 800774e:	f7fa f9ef 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 7, PAL_MODE_ALTERNATE(7));
 8007752:	f240 3282 	movw	r2, #898	; 0x382
 8007756:	2180      	movs	r1, #128	; 0x80
 8007758:	489d      	ldr	r0, [pc, #628]	; (80079d0 <main+0xbc0>)
 800775a:	f7fa f9e9 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
 800775e:	f240 3282 	movw	r2, #898	; 0x382
 8007762:	2104      	movs	r1, #4
 8007764:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007768:	f7fa f9e2 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 800776c:	f240 3282 	movw	r2, #898	; 0x382
 8007770:	2108      	movs	r1, #8
 8007772:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007776:	f7fa f9db 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOE, 0, PAL_MODE_OUTPUT_PUSHPULL);
 800777a:	2201      	movs	r2, #1
 800777c:	4611      	mov	r1, r2
 800777e:	4895      	ldr	r0, [pc, #596]	; (80079d4 <main+0xbc4>)
 8007780:	f7fa f9d6 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOE, 1, PAL_MODE_OUTPUT_PUSHPULL);    
 8007784:	2201      	movs	r2, #1
 8007786:	2102      	movs	r1, #2
 8007788:	4892      	ldr	r0, [pc, #584]	; (80079d4 <main+0xbc4>)
 800778a:	f7fa f9d1 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 1, PAL_MODE_OUTPUT_PUSHPULL); // tx/rx
 800778e:	2201      	movs	r2, #1
 8007790:	2102      	movs	r1, #2
 8007792:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007796:	f7fa f9cb 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 0, PAL_MODE_OUTPUT_PUSHPULL); // rtd 0
 800779a:	2201      	movs	r2, #1
 800779c:	4628      	mov	r0, r5
 800779e:	4611      	mov	r1, r2
 80077a0:	f7fa f9c6 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 1, PAL_MODE_OUTPUT_PUSHPULL); // rtd 1
 80077a4:	2201      	movs	r2, #1
 80077a6:	2102      	movs	r1, #2
 80077a8:	f7fa f9c2 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 2, PAL_MODE_OUTPUT_PUSHPULL); // rtd 2
 80077ac:	2201      	movs	r2, #1
 80077ae:	2104      	movs	r1, #4
 80077b0:	f7fa f9be 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 3, PAL_MODE_OUTPUT_PUSHPULL); // rtd 3 
 80077b4:	2201      	movs	r2, #1
 80077b6:	2108      	movs	r1, #8
 80077b8:	f7fa f9ba 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 4, PAL_MODE_OUTPUT_PUSHPULL); // rtd 4
 80077bc:	2201      	movs	r2, #1
 80077be:	2110      	movs	r1, #16
 80077c0:	f7fa f9b6 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 6, PAL_MODE_INPUT_PULLUP); // raingauge
 80077c4:	2220      	movs	r2, #32
 80077c6:	2140      	movs	r1, #64	; 0x40
 80077c8:	f7fa f9b2 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 7, PAL_MODE_INPUT_PULLUP); // rain enabled
 80077cc:	2220      	movs	r2, #32
 80077ce:	2180      	movs	r1, #128	; 0x80
 80077d0:	f7fa f9ae 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPad(GPIOC,0);
 80077d4:	f04f 0801 	mov.w	r8, #1
  palSetPad(GPIOC,1);
 80077d8:	2302      	movs	r3, #2
  palSetPad(GPIOC,0);
 80077da:	f8a5 8018 	strh.w	r8, [r5, #24]
  palSetPad(GPIOC,2);
 80077de:	2104      	movs	r1, #4
  palSetPad(GPIOC,1);
 80077e0:	832b      	strh	r3, [r5, #24]
  palSetPad(GPIOC,3);
 80077e2:	2208      	movs	r2, #8
  palSetPad(GPIOC,4);
 80077e4:	2310      	movs	r3, #16
  palSetPad(GPIOC,2);
 80077e6:	8329      	strh	r1, [r5, #24]
  palSetPad(GPIOC,3);
 80077e8:	832a      	strh	r2, [r5, #24]
  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(6)); // SPI3 
 80077ea:	f44f 6180 	mov.w	r1, #1024	; 0x400
  palSetPad(GPIOC,4);
 80077ee:	832b      	strh	r3, [r5, #24]
  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(6)); // SPI3 
 80077f0:	f240 3202 	movw	r2, #770	; 0x302
 80077f4:	f7fa f99c 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 11, PAL_MODE_ALTERNATE(6));
 80077f8:	f240 3202 	movw	r2, #770	; 0x302
 80077fc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007800:	f7fa f996 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 12, PAL_MODE_ALTERNATE(6));
 8007804:	f240 3202 	movw	r2, #770	; 0x302
 8007808:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800780c:	f7fa f990 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 11, PAL_MODE_OUTPUT_PUSHPULL);                      // spi2
 8007810:	4642      	mov	r2, r8
 8007812:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007816:	486e      	ldr	r0, [pc, #440]	; (80079d0 <main+0xbc0>)
 8007818:	f7fa f98a 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5)|PAL_STM32_OSPEED_HIGHEST);
 800781c:	f240 229a 	movw	r2, #666	; 0x29a
 8007820:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007824:	486a      	ldr	r0, [pc, #424]	; (80079d0 <main+0xbc0>)
 8007826:	f7fa f983 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5)|PAL_STM32_OSPEED_HIGHEST);
 800782a:	f240 229a 	movw	r2, #666	; 0x29a
 800782e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8007832:	4867      	ldr	r0, [pc, #412]	; (80079d0 <main+0xbc0>)
 8007834:	f7fa f97c 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL);
 8007838:	4642      	mov	r2, r8
 800783a:	2120      	movs	r1, #32
 800783c:	4864      	ldr	r0, [pc, #400]	; (80079d0 <main+0xbc0>)
 800783e:	f7fa f977 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 8, PAL_MODE_INPUT_PULLUP);
 8007842:	2220      	movs	r2, #32
 8007844:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007848:	4861      	ldr	r0, [pc, #388]	; (80079d0 <main+0xbc0>)
 800784a:	f7fa f971 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 9, PAL_MODE_INPUT_PULLUP);
 800784e:	2220      	movs	r2, #32
 8007850:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007854:	485e      	ldr	r0, [pc, #376]	; (80079d0 <main+0xbc0>)
 8007856:	f7fa f96b 	bl	8001b30 <_pal_lld_setgroupmode>
  sdStart(&SD1,&uartCfg);
 800785a:	495f      	ldr	r1, [pc, #380]	; (80079d8 <main+0xbc8>)
 800785c:	485f      	ldr	r0, [pc, #380]	; (80079dc <main+0xbcc>)
 800785e:	f7fd ffaf 	bl	80057c0 <sdStart>
  if (*flash2 == 0xffff)
 8007862:	8832      	ldrh	r2, [r6, #0]
 8007864:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8007868:	429a      	cmp	r2, r3
 800786a:	d107      	bne.n	800787c <main+0xa6c>
      {
	  chprintf((BaseSequentialStream*)&SD1,"!!!writing flash,00\r\n");
 800786c:	495c      	ldr	r1, [pc, #368]	; (80079e0 <main+0xbd0>)
 800786e:	485b      	ldr	r0, [pc, #364]	; (80079dc <main+0xbcc>)
 8007870:	f7fc f90e 	bl	8003a90 <chprintf.constprop.14>
  	  write_flash(0,flash2);
 8007874:	4631      	mov	r1, r6
 8007876:	4638      	mov	r0, r7
 8007878:	f7f9 fd1a 	bl	80012b0 <write_flash>
      }
  
  lifetimeRain = *flash2/100.0;
 800787c:	4b53      	ldr	r3, [pc, #332]	; (80079cc <main+0xbbc>)
  chprintf((BaseSequentialStream*)&SD1,"--------Rain: %d\r\n",*flash2);

  if (*flash1 == 0xffff){
 800787e:	4d59      	ldr	r5, [pc, #356]	; (80079e4 <main+0xbd4>)
  lifetimeRain = *flash2/100.0;
 8007880:	881e      	ldrh	r6, [r3, #0]
 8007882:	4630      	mov	r0, r6
 8007884:	f7f8 fe90 	bl	80005a8 <__aeabi_i2d>
 8007888:	2200      	movs	r2, #0
 800788a:	4b57      	ldr	r3, [pc, #348]	; (80079e8 <main+0xbd8>)
 800788c:	f7f9 f820 	bl	80008d0 <__aeabi_ddiv>
 8007890:	f7f9 f9cc 	bl	8000c2c <__aeabi_d2f>
 8007894:	4b55      	ldr	r3, [pc, #340]	; (80079ec <main+0xbdc>)
  chprintf((BaseSequentialStream*)&SD1,"--------Rain: %d\r\n",*flash2);
 8007896:	4956      	ldr	r1, [pc, #344]	; (80079f0 <main+0xbe0>)
  lifetimeRain = *flash2/100.0;
 8007898:	6018      	str	r0, [r3, #0]
  chprintf((BaseSequentialStream*)&SD1,"--------Rain: %d\r\n",*flash2);
 800789a:	4632      	mov	r2, r6
 800789c:	484f      	ldr	r0, [pc, #316]	; (80079dc <main+0xbcc>)
      my_address = 60; // if flash hasn't been set up yet we default to
 800789e:	4e55      	ldr	r6, [pc, #340]	; (80079f4 <main+0xbe4>)
  chprintf((BaseSequentialStream*)&SD1,"--------Rain: %d\r\n",*flash2);
 80078a0:	f7fc f8f6 	bl	8003a90 <chprintf.constprop.14>
  if (*flash1 == 0xffff){
 80078a4:	882b      	ldrh	r3, [r5, #0]
 80078a6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80078aa:	4293      	cmp	r3, r2
 80078ac:	f000 80be 	beq.w	8007a2c <main+0xc1c>
  else{
      // flash has been written - use those values
      // init saved values in case we only choose to reset
      // just id or just address later.
      my_address = (*flash1) & 0xff;
      save_address = my_address;
 80078b0:	4851      	ldr	r0, [pc, #324]	; (80079f8 <main+0xbe8>)
      baud_rate = ((*flash1) & 0xff00) >> 8;
      save_baud_rate = baud_rate;
 80078b2:	4952      	ldr	r1, [pc, #328]	; (80079fc <main+0xbec>)
      baud_rate = ((*flash1) & 0xff00) >> 8;
 80078b4:	4f52      	ldr	r7, [pc, #328]	; (8007a00 <main+0xbf0>)
      my_address = (*flash1) & 0xff;
 80078b6:	b2da      	uxtb	r2, r3
      baud_rate = ((*flash1) & 0xff00) >> 8;
 80078b8:	0a1b      	lsrs	r3, r3, #8
      my_address = (*flash1) & 0xff;
 80078ba:	7032      	strb	r2, [r6, #0]
      save_address = my_address;
 80078bc:	7002      	strb	r2, [r0, #0]
      save_baud_rate = baud_rate;
 80078be:	700b      	strb	r3, [r1, #0]
      baud_rate = ((*flash1) & 0xff00) >> 8;
 80078c0:	703b      	strb	r3, [r7, #0]
 80078c2:	2320      	movs	r3, #32
 80078c4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80078c8:	f7fd fd02 	bl	80052d0 <_dbg_check_lock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 80078cc:	7a23      	ldrb	r3, [r4, #8]
 80078ce:	1e5a      	subs	r2, r3, #1
 80078d0:	2a01      	cmp	r2, #1
 80078d2:	d947      	bls.n	8007964 <main+0xb54>
 80078d4:	484b      	ldr	r0, [pc, #300]	; (8007a04 <main+0xbf4>)
 80078d6:	f7f9 fd6b 	bl	80013b0 <chSysHalt>
      b = dmaStreamAllocate(adcp->dmastp,
 80078da:	4613      	mov	r3, r2
 80078dc:	2105      	movs	r1, #5
 80078de:	4a4a      	ldr	r2, [pc, #296]	; (8007a08 <main+0xbf8>)
 80078e0:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80078e2:	f7fa f9d5 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 80078e6:	2800      	cmp	r0, #0
 80078e8:	d12a      	bne.n	8007940 <main+0xb30>
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 80078ea:	4f32      	ldr	r7, [pc, #200]	; (80079b4 <main+0xba4>)
      clkmask |= (1 << 0);
 80078ec:	4b47      	ldr	r3, [pc, #284]	; (8007a0c <main+0xbfc>)
    adcp->adcm->DIFSEL = adcp->config->difsel;
 80078ee:	6879      	ldr	r1, [r7, #4]
      clkmask |= (1 << 0);
 80078f0:	681a      	ldr	r2, [r3, #0]
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 80078f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      rccEnableADC12(true);
 80078f4:	4d46      	ldr	r5, [pc, #280]	; (8007a10 <main+0xc00>)
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 80078f6:	685e      	ldr	r6, [r3, #4]
 80078f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
      clkmask |= (1 << 0);
 80078fa:	4f44      	ldr	r7, [pc, #272]	; (8007a0c <main+0xbfc>)
 80078fc:	f042 0201 	orr.w	r2, r2, #1
 8007900:	603a      	str	r2, [r7, #0]
      rccEnableADC12(true);
 8007902:	696a      	ldr	r2, [r5, #20]
 8007904:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007908:	616a      	str	r2, [r5, #20]
    adcp->adcm->DIFSEL = adcp->config->difsel;
 800790a:	680d      	ldr	r5, [r1, #0]
  return DWT->CYCCNT;
 800790c:	4a41      	ldr	r2, [pc, #260]	; (8007a14 <main+0xc04>)
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 800790e:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8007912:	60b1      	str	r1, [r6, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8007914:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    adcp->adcm->DIFSEL = adcp->config->difsel;
 8007918:	f8c3 50b0 	str.w	r5, [r3, #176]	; 0xb0
  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 800791c:	6098      	str	r0, [r3, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 800791e:	6099      	str	r1, [r3, #8]
 8007920:	6850      	ldr	r0, [r2, #4]
 8007922:	6851      	ldr	r1, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 8007924:	1a09      	subs	r1, r1, r0
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8007926:	f5b1 7fb4 	cmp.w	r1, #360	; 0x168
 800792a:	d3fa      	bcc.n	8007922 <main+0xb12>
  osalDbgAssert(adcp->adcm->CR == ADC_CR_ADVREGEN_0, "invalid register state");
 800792c:	689a      	ldr	r2, [r3, #8]
 800792e:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8007932:	d008      	beq.n	8007946 <main+0xb36>
 8007934:	4838      	ldr	r0, [pc, #224]	; (8007a18 <main+0xc08>)
 8007936:	f7f9 fd3b 	bl	80013b0 <chSysHalt>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800793a:	4838      	ldr	r0, [pc, #224]	; (8007a1c <main+0xc0c>)
 800793c:	f7f9 fd38 	bl	80013b0 <chSysHalt>
      osalDbgAssert(!b, "stream already allocated");
 8007940:	4837      	ldr	r0, [pc, #220]	; (8007a20 <main+0xc10>)
 8007942:	f7f9 fd35 	bl	80013b0 <chSysHalt>
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8007946:	689a      	ldr	r2, [r3, #8]
 8007948:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800794c:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 800794e:	689a      	ldr	r2, [r3, #8]
 8007950:	2a00      	cmp	r2, #0
 8007952:	dbfc      	blt.n	800794e <main+0xb3e>
  adcp->adcm->CR |= ADC_CR_ADEN;
 8007954:	689a      	ldr	r2, [r3, #8]
 8007956:	f042 0201 	orr.w	r2, r2, #1
 800795a:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRD) == 0)
 800795c:	681a      	ldr	r2, [r3, #0]
 800795e:	07d1      	lsls	r1, r2, #31
 8007960:	d5fc      	bpl.n	800795c <main+0xb4c>
 8007962:	e6b3      	b.n	80076cc <main+0x8bc>
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {

  if (sdp->state == SD_READY) {
 8007964:	2b02      	cmp	r3, #2
 8007966:	d109      	bne.n	800797c <main+0xb6c>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 8007968:	6d63      	ldr	r3, [r4, #84]	; 0x54
      return;
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccDisableUSART2();
 800796a:	4929      	ldr	r1, [pc, #164]	; (8007a10 <main+0xc00>)
  u->CR1 = 0;
 800796c:	2200      	movs	r2, #0
 800796e:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 8007970:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 8007972:	609a      	str	r2, [r3, #8]
      rccDisableUSART2();
 8007974:	69cb      	ldr	r3, [r1, #28]
 8007976:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800797a:	61cb      	str	r3, [r1, #28]
  sdp->state = SD_STOP;
 800797c:	2301      	movs	r3, #1
 800797e:	7223      	strb	r3, [r4, #8]
  osalDbgCheckClassI();
 8007980:	f7f9 fd4e 	bl	8001420 <chDbgCheckClassI>
  oqp->q_counter = qSizeX(oqp);
 8007984:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
 8007988:	1a9b      	subs	r3, r3, r2
  oqp->q_rdptr = oqp->q_buffer;
 800798a:	64a2      	str	r2, [r4, #72]	; 0x48
  oqp->q_wrptr = oqp->q_buffer;
 800798c:	6462      	str	r2, [r4, #68]	; 0x44
  oqp->q_counter = qSizeX(oqp);
 800798e:	63a3      	str	r3, [r4, #56]	; 0x38
 8007990:	f06f 0501 	mvn.w	r5, #1
  return (bool)(tqp->next != (const thread_t *)tqp);
 8007994:	6b20      	ldr	r0, [r4, #48]	; 0x30
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 8007996:	4b23      	ldr	r3, [pc, #140]	; (8007a24 <main+0xc14>)
 8007998:	4298      	cmp	r0, r3
 800799a:	d05d      	beq.n	8007a58 <main+0xc48>
  tqp->next             = tp->queue.next;
 800799c:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800799e:	4a21      	ldr	r2, [pc, #132]	; (8007a24 <main+0xc14>)
  tqp->next             = tp->queue.next;
 80079a0:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 80079a2:	605a      	str	r2, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80079a4:	f890 3020 	ldrb.w	r3, [r0, #32]
 80079a8:	2b04      	cmp	r3, #4
 80079aa:	d051      	beq.n	8007a50 <main+0xc40>
 80079ac:	481e      	ldr	r0, [pc, #120]	; (8007a28 <main+0xc18>)
 80079ae:	f7f9 fcff 	bl	80013b0 <chSysHalt>
 80079b2:	bf00      	nop
 80079b4:	200011e0 	.word	0x200011e0
 80079b8:	0800e75c 	.word	0x0800e75c
 80079bc:	50000300 	.word	0x50000300
 80079c0:	50000700 	.word	0x50000700
 80079c4:	48000c00 	.word	0x48000c00
 80079c8:	48000800 	.word	0x48000800
 80079cc:	0803e800 	.word	0x0803e800
 80079d0:	48000400 	.word	0x48000400
 80079d4:	48001000 	.word	0x48001000
 80079d8:	20000800 	.word	0x20000800
 80079dc:	200013d8 	.word	0x200013d8
 80079e0:	0801d774 	.word	0x0801d774
 80079e4:	0803f000 	.word	0x0803f000
 80079e8:	40590000 	.word	0x40590000
 80079ec:	2000200c 	.word	0x2000200c
 80079f0:	0801d78c 	.word	0x0801d78c
 80079f4:	2000207c 	.word	0x2000207c
 80079f8:	200024c2 	.word	0x200024c2
 80079fc:	200024c3 	.word	0x200024c3
 8007a00:	20001598 	.word	0x20001598
 8007a04:	0800e508 	.word	0x0800e508
 8007a08:	08002121 	.word	0x08002121
 8007a0c:	20001fd0 	.word	0x20001fd0
 8007a10:	40021000 	.word	0x40021000
 8007a14:	e0001000 	.word	0xe0001000
 8007a18:	0800e448 	.word	0x0800e448
 8007a1c:	0800e1b4 	.word	0x0800e1b4
 8007a20:	0800e510 	.word	0x0800e510
 8007a24:	20001468 	.word	0x20001468
 8007a28:	0800e22c 	.word	0x0800e22c
      baud_rate=0;
 8007a2c:	f04f 0c00 	mov.w	ip, #0
      my_address = 60; // if flash hasn't been set up yet we default to
 8007a30:	233c      	movs	r3, #60	; 0x3c
      baud_rate=0;
 8007a32:	4f16      	ldr	r7, [pc, #88]	; (8007a8c <main+0xc7c>)
      my_address = 60; // if flash hasn't been set up yet we default to
 8007a34:	7033      	strb	r3, [r6, #0]
      chprintf((BaseSequentialStream*)&SD1,"Resetting Flash - I am # %d,%d\r\n",my_address,baud_rate);
 8007a36:	461a      	mov	r2, r3
 8007a38:	4915      	ldr	r1, [pc, #84]	; (8007a90 <main+0xc80>)
 8007a3a:	4816      	ldr	r0, [pc, #88]	; (8007a94 <main+0xc84>)
      baud_rate=0;
 8007a3c:	f887 c000 	strb.w	ip, [r7]
      chprintf((BaseSequentialStream*)&SD1,"Resetting Flash - I am # %d,%d\r\n",my_address,baud_rate);
 8007a40:	4663      	mov	r3, ip
 8007a42:	f7fc f825 	bl	8003a90 <chprintf.constprop.14>
      write_flash((my_address&0xff),flash1);
 8007a46:	4629      	mov	r1, r5
 8007a48:	7830      	ldrb	r0, [r6, #0]
 8007a4a:	f7f9 fc31 	bl	80012b0 <write_flash>
 8007a4e:	e738      	b.n	80078c2 <main+0xab2>
  tp->u.rdymsg = msg;
 8007a50:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8007a52:	f7f9 fd6d 	bl	8001530 <chSchReadyI>
 8007a56:	e79d      	b.n	8007994 <main+0xb84>
  osalDbgCheckClassI();
 8007a58:	f7f9 fce2 	bl	8001420 <chDbgCheckClassI>
  iqp->q_rdptr = iqp->q_buffer;
 8007a5c:	69a3      	ldr	r3, [r4, #24]
 8007a5e:	6263      	str	r3, [r4, #36]	; 0x24
  iqp->q_counter = 0;
 8007a60:	2200      	movs	r2, #0
  iqp->q_wrptr = iqp->q_buffer;
 8007a62:	6223      	str	r3, [r4, #32]
  iqp->q_counter = 0;
 8007a64:	6162      	str	r2, [r4, #20]
  tp->u.rdymsg = msg;
 8007a66:	f06f 0501 	mvn.w	r5, #1
  return (bool)(tqp->next != (const thread_t *)tqp);
 8007a6a:	68e0      	ldr	r0, [r4, #12]
 8007a6c:	4b0a      	ldr	r3, [pc, #40]	; (8007a98 <main+0xc88>)
 8007a6e:	4298      	cmp	r0, r3
 8007a70:	d014      	beq.n	8007a9c <main+0xc8c>
  tqp->next             = tp->queue.next;
 8007a72:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007a74:	4a08      	ldr	r2, [pc, #32]	; (8007a98 <main+0xc88>)
  tqp->next             = tp->queue.next;
 8007a76:	60e3      	str	r3, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007a78:	605a      	str	r2, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8007a7a:	f890 3020 	ldrb.w	r3, [r0, #32]
 8007a7e:	2b04      	cmp	r3, #4
 8007a80:	d194      	bne.n	80079ac <main+0xb9c>
  tp->u.rdymsg = msg;
 8007a82:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8007a84:	f7f9 fd54 	bl	8001530 <chSchReadyI>
 8007a88:	e7ef      	b.n	8007a6a <main+0xc5a>
 8007a8a:	bf00      	nop
 8007a8c:	20001598 	.word	0x20001598
 8007a90:	0801d7a0 	.word	0x0801d7a0
 8007a94:	200013d8 	.word	0x200013d8
 8007a98:	20001444 	.word	0x20001444
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8007a9c:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8007aa0:	2b00      	cmp	r3, #0
 8007aa2:	f040 8163 	bne.w	8007d6c <main+0xf5c>
 8007aa6:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8007aaa:	2b00      	cmp	r3, #0
 8007aac:	f340 815e 	ble.w	8007d6c <main+0xf5c>
  return firstprio(&ch.rlist.queue) > currp->prio;
 8007ab0:	f8db 2000 	ldr.w	r2, [fp]
 8007ab4:	f8db 3018 	ldr.w	r3, [fp, #24]
  if (chSchIsRescRequiredI()) {
 8007ab8:	6892      	ldr	r2, [r2, #8]
 8007aba:	689b      	ldr	r3, [r3, #8]
 8007abc:	429a      	cmp	r2, r3
 8007abe:	d901      	bls.n	8007ac4 <main+0xcb4>
    chSchDoRescheduleAhead();
 8007ac0:	f7fe f86e 	bl	8005ba0 <chSchDoReschedule>
 8007ac4:	f7fd fbec 	bl	80052a0 <chSysUnlock.lto_priv.75>
    if (baud_rate == 1)
 8007ac8:	783c      	ldrb	r4, [r7, #0]
	sdStart(&SD2, &uartCfg2);
 8007aca:	48aa      	ldr	r0, [pc, #680]	; (8007d74 <main+0xf64>)
    if (baud_rate == 1)
 8007acc:	2c01      	cmp	r4, #1
	sdStart(&SD2, &uartCfg3);
 8007ace:	bf0c      	ite	eq
 8007ad0:	49a9      	ldreq	r1, [pc, #676]	; (8007d78 <main+0xf68>)
	sdStart(&SD2, &uartCfg2);
 8007ad2:	49aa      	ldrne	r1, [pc, #680]	; (8007d7c <main+0xf6c>)
 8007ad4:	f7fd fe74 	bl	80057c0 <sdStart>
      



  restart_modbus();
  chprintf((BaseSequentialStream*)&SD1,"Hello World - I am # %d,%d\r\n",my_address,baud_rate);
 8007ad8:	4623      	mov	r3, r4
 8007ada:	7832      	ldrb	r2, [r6, #0]
 8007adc:	49a8      	ldr	r1, [pc, #672]	; (8007d80 <main+0xf70>)
 8007ade:	48a9      	ldr	r0, [pc, #676]	; (8007d84 <main+0xf74>)
  palSetPadMode(GPIOB, DC, PAL_MODE_OUTPUT_PUSHPULL);
 8007ae0:	4ca9      	ldr	r4, [pc, #676]	; (8007d88 <main+0xf78>)
  chprintf((BaseSequentialStream*)&SD1,"Hello World - I am # %d,%d\r\n",my_address,baud_rate);
 8007ae2:	f7fb ffd5 	bl	8003a90 <chprintf.constprop.14>
  palSetPad(GPIOE, 0);     // Enable TX Light
 8007ae6:	4ba9      	ldr	r3, [pc, #676]	; (8007d8c <main+0xf7c>)
 8007ae8:	2501      	movs	r5, #1
  palSetPad(GPIOE, 1);     // Enbale RX Light
 8007aea:	2102      	movs	r1, #2
  palSetPad(GPIOE, 0);     // Enable TX Light
 8007aec:	831d      	strh	r5, [r3, #24]
  palSetPadMode(GPIOB, DC, PAL_MODE_OUTPUT_PUSHPULL);
 8007aee:	462a      	mov	r2, r5
  palSetPad(GPIOE, 1);     // Enbale RX Light
 8007af0:	8319      	strh	r1, [r3, #24]
  palSetPadMode(GPIOB, DC, PAL_MODE_OUTPUT_PUSHPULL);
 8007af2:	4620      	mov	r0, r4
 8007af4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8007af8:	f7fa f81a 	bl	8001b30 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, SPISELECT, PAL_MODE_OUTPUT_PUSHPULL);
 8007afc:	462a      	mov	r2, r5
 8007afe:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007b02:	f7fa f815 	bl	8001b30 <_pal_lld_setgroupmode>
  palClearPad(GPIOB,SPISELECT);
 8007b06:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007b0a:	8363      	strh	r3, [r4, #26]



  init_spi();
  chprintf((BaseSequentialStream*)&SD1,"SPI init\r\n");
 8007b0c:	49a0      	ldr	r1, [pc, #640]	; (8007d90 <main+0xf80>)
 8007b0e:	489d      	ldr	r0, [pc, #628]	; (8007d84 <main+0xf74>)
    palClearPad(GPIOB,DC);
 8007b10:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  chprintf((BaseSequentialStream*)&SD1,"SPI init\r\n");
 8007b14:	f7fb ffbc 	bl	8003a90 <chprintf.constprop.14>
      chprintf(&SD1,"do oled command A\r\n");
 8007b18:	499e      	ldr	r1, [pc, #632]	; (8007d94 <main+0xf84>)
 8007b1a:	489a      	ldr	r0, [pc, #616]	; (8007d84 <main+0xf74>)
 8007b1c:	f7fb ffb8 	bl	8003a90 <chprintf.constprop.14>
    led_write0(data);
 8007b20:	20fd      	movs	r0, #253	; 0xfd
    palClearPad(GPIOB,DC);
 8007b22:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b24:	f7fd fd8c 	bl	8005640 <led_write0>
 8007b28:	2012      	movs	r0, #18
    palClearPad(GPIOB,DC);
 8007b2a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b2c:	f7fd fd88 	bl	8005640 <led_write0>
 8007b30:	20ae      	movs	r0, #174	; 0xae
    palClearPad(GPIOB,DC);
 8007b32:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b34:	f7fd fd84 	bl	8005640 <led_write0>
 8007b38:	2015      	movs	r0, #21
    palClearPad(GPIOB,DC);
 8007b3a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b3c:	f7fd fd80 	bl	8005640 <led_write0>
 8007b40:	2000      	movs	r0, #0
    palClearPad(GPIOB,DC);
 8007b42:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b44:	f7fd fd7c 	bl	8005640 <led_write0>
 8007b48:	207f      	movs	r0, #127	; 0x7f
    palClearPad(GPIOB,DC);
 8007b4a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b4c:	f7fd fd78 	bl	8005640 <led_write0>
 8007b50:	2075      	movs	r0, #117	; 0x75
    palClearPad(GPIOB,DC);
 8007b52:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b54:	f7fd fd74 	bl	8005640 <led_write0>
 8007b58:	2000      	movs	r0, #0
    palClearPad(GPIOB,DC);
 8007b5a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b5c:	f7fd fd70 	bl	8005640 <led_write0>
 8007b60:	201f      	movs	r0, #31
    palClearPad(GPIOB,DC);
 8007b62:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b64:	f7fd fd6c 	bl	8005640 <led_write0>
 8007b68:	2081      	movs	r0, #129	; 0x81
    palClearPad(GPIOB,DC);
 8007b6a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b6c:	f7fd fd68 	bl	8005640 <led_write0>
 8007b70:	2027      	movs	r0, #39	; 0x27
    palClearPad(GPIOB,DC);
 8007b72:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b74:	f7fd fd64 	bl	8005640 <led_write0>
 8007b78:	2087      	movs	r0, #135	; 0x87
    palClearPad(GPIOB,DC);
 8007b7a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b7c:	f7fd fd60 	bl	8005640 <led_write0>
 8007b80:	20a0      	movs	r0, #160	; 0xa0
    palClearPad(GPIOB,DC);
 8007b82:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b84:	f7fd fd5c 	bl	8005640 <led_write0>
 8007b88:	2006      	movs	r0, #6
    palClearPad(GPIOB,DC);
 8007b8a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b8c:	f7fd fd58 	bl	8005640 <led_write0>
 8007b90:	20a1      	movs	r0, #161	; 0xa1
    palClearPad(GPIOB,DC);
 8007b92:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b94:	f7fd fd54 	bl	8005640 <led_write0>
 8007b98:	2000      	movs	r0, #0
    palClearPad(GPIOB,DC);
 8007b9a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007b9c:	f7fd fd50 	bl	8005640 <led_write0>
 8007ba0:	20a2      	movs	r0, #162	; 0xa2
    palClearPad(GPIOB,DC);
 8007ba2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007ba4:	f7fd fd4c 	bl	8005640 <led_write0>
 8007ba8:	2000      	movs	r0, #0
    palClearPad(GPIOB,DC);
 8007baa:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bac:	f7fd fd48 	bl	8005640 <led_write0>
 8007bb0:	20a8      	movs	r0, #168	; 0xa8
    palClearPad(GPIOB,DC);
 8007bb2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bb4:	f7fd fd44 	bl	8005640 <led_write0>
 8007bb8:	201f      	movs	r0, #31
    palClearPad(GPIOB,DC);
 8007bba:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bbc:	f7fd fd40 	bl	8005640 <led_write0>
 8007bc0:	20b1      	movs	r0, #177	; 0xb1
    palClearPad(GPIOB,DC);
 8007bc2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bc4:	f7fd fd3c 	bl	8005640 <led_write0>
 8007bc8:	2071      	movs	r0, #113	; 0x71
    palClearPad(GPIOB,DC);
 8007bca:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bcc:	f7fd fd38 	bl	8005640 <led_write0>
 8007bd0:	20b3      	movs	r0, #179	; 0xb3
    palClearPad(GPIOB,DC);
 8007bd2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bd4:	f7fd fd34 	bl	8005640 <led_write0>
 8007bd8:	20f0      	movs	r0, #240	; 0xf0
    palClearPad(GPIOB,DC);
 8007bda:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bdc:	f7fd fd30 	bl	8005640 <led_write0>
 8007be0:	20b7      	movs	r0, #183	; 0xb7
    palClearPad(GPIOB,DC);
 8007be2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007be4:	f7fd fd2c 	bl	8005640 <led_write0>
 8007be8:	20bb      	movs	r0, #187	; 0xbb
    palClearPad(GPIOB,DC);
 8007bea:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bec:	f7fd fd28 	bl	8005640 <led_write0>
 8007bf0:	2035      	movs	r0, #53	; 0x35
    palClearPad(GPIOB,DC);
 8007bf2:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bf4:	f7fd fd24 	bl	8005640 <led_write0>
 8007bf8:	20ff      	movs	r0, #255	; 0xff
    palClearPad(GPIOB,DC);
 8007bfa:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007bfc:	f7fd fd20 	bl	8005640 <led_write0>
 8007c00:	20bc      	movs	r0, #188	; 0xbc
    palClearPad(GPIOB,DC);
 8007c02:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007c04:	f7fd fd1c 	bl	8005640 <led_write0>
 8007c08:	201f      	movs	r0, #31
    palClearPad(GPIOB,DC);
 8007c0a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007c0c:	f7fd fd18 	bl	8005640 <led_write0>
 8007c10:	20be      	movs	r0, #190	; 0xbe
    palClearPad(GPIOB,DC);
 8007c12:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007c14:	f7fd fd14 	bl	8005640 <led_write0>
 8007c18:	200f      	movs	r0, #15
    palClearPad(GPIOB,DC);
 8007c1a:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007c1c:	f7fd fd10 	bl	8005640 <led_write0>
 8007c20:	20af      	movs	r0, #175	; 0xaf
    palClearPad(GPIOB,DC);
 8007c22:	8365      	strh	r5, [r4, #26]
    led_write0(data);
 8007c24:	f7fd fd0c 	bl	8005640 <led_write0>
  init_oled();
  chprintf((BaseSequentialStream*)&SD1,"OLED init\r\n");
 8007c28:	495b      	ldr	r1, [pc, #364]	; (8007d98 <main+0xf88>)
 8007c2a:	4856      	ldr	r0, [pc, #344]	; (8007d84 <main+0xf74>)
 8007c2c:	f7fb ff30 	bl	8003a90 <chprintf.constprop.14>
  
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 8007c30:	4a5a      	ldr	r2, [pc, #360]	; (8007d9c <main+0xf8c>)
 8007c32:	485b      	ldr	r0, [pc, #364]	; (8007da0 <main+0xf90>)
 8007c34:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007c38:	f7ff f89a 	bl	8006d70 <chThdCreateStatic.constprop.26>
    if (!reset)
 8007c3c:	4b59      	ldr	r3, [pc, #356]	; (8007da4 <main+0xf94>)
 8007c3e:	781b      	ldrb	r3, [r3, #0]
 8007c40:	b90b      	cbnz	r3, 8007c46 <main+0xe36>
	wdgReset(&WDGD1);
 8007c42:	f7fa fb55 	bl	80022f0 <wdgReset.constprop.34>
    memset(&vbuf,0x00,128*32); // I set the clear to be 0x11 instead of 0x00
 8007c46:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007c4a:	2100      	movs	r1, #0
 8007c4c:	4856      	ldr	r0, [pc, #344]	; (8007da8 <main+0xf98>)
 8007c4e:	f002 fb0f 	bl	800a270 <memset>
  oled_draw_string(0,0,"Helios ");
 8007c52:	4956      	ldr	r1, [pc, #344]	; (8007dac <main+0xf9c>)
 8007c54:	2000      	movs	r0, #0
 8007c56:	f7fd f97b 	bl	8004f50 <oled_draw_string.constprop.13>
  if (baud_rate == 1)
 8007c5a:	783b      	ldrb	r3, [r7, #0]
 8007c5c:	7832      	ldrb	r2, [r6, #0]
      sprintf(text,"id=%d    baud=9600 ",my_address);
 8007c5e:	4854      	ldr	r0, [pc, #336]	; (8007db0 <main+0xfa0>)
  if (baud_rate == 1)
 8007c60:	2b01      	cmp	r3, #1
      sprintf(text,"id=%d    baud=19200 ",my_address );
 8007c62:	bf0c      	ite	eq
 8007c64:	4953      	ldreq	r1, [pc, #332]	; (8007db4 <main+0xfa4>)
      sprintf(text,"id=%d    baud=9600 ",my_address);
 8007c66:	4954      	ldrne	r1, [pc, #336]	; (8007db8 <main+0xfa8>)
 8007c68:	f002 fb4c 	bl	800a304 <sprintf>
  oled_draw_string(0,1,text);
 8007c6c:	4950      	ldr	r1, [pc, #320]	; (8007db0 <main+0xfa0>)
 8007c6e:	2001      	movs	r0, #1
 8007c70:	f7fd f96e 	bl	8004f50 <oled_draw_string.constprop.13>

  
  feedWatchdog();
  graphics_init();
  chThdSleepMilliseconds(1000);
 8007c74:	f242 7010 	movw	r0, #10000	; 0x2710
 8007c78:	f7fb f882 	bl	8002d80 <chThdSleep>
  palClearPad(GPIOA, 1);     // Recieve Enable RS485
  palClearPad(GPIOE, 0);     // Disable TX Light
 8007c7c:	4b43      	ldr	r3, [pc, #268]	; (8007d8c <main+0xf7c>)
  palClearPad(GPIOA, 1);     // Recieve Enable RS485
 8007c7e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007c82:	2202      	movs	r2, #2
  palClearPad(GPIOE, 0);     // Disable TX Light
 8007c84:	2101      	movs	r1, #1
  palClearPad(GPIOA, 1);     // Recieve Enable RS485
 8007c86:	8342      	strh	r2, [r0, #26]
  palClearPad(GPIOE, 0);     // Disable TX Light
 8007c88:	8359      	strh	r1, [r3, #26]
  palClearPad(GPIOE, 1);     // Disable RX Light
 8007c8a:	835a      	strh	r2, [r3, #26]
    if (!reset)
 8007c8c:	4b45      	ldr	r3, [pc, #276]	; (8007da4 <main+0xf94>)
 8007c8e:	781b      	ldrb	r3, [r3, #0]
 8007c90:	b90b      	cbnz	r3, 8007c96 <main+0xe86>
	wdgReset(&WDGD1);
 8007c92:	f7fa fb2d 	bl	80022f0 <wdgReset.constprop.34>
  feedWatchdog();
  chThdSleepMilliseconds(1000);
 8007c96:	f242 7010 	movw	r0, #10000	; 0x2710
 8007c9a:	f7fb f871 	bl	8002d80 <chThdSleep>
    if (!reset)
 8007c9e:	4b41      	ldr	r3, [pc, #260]	; (8007da4 <main+0xf94>)
 8007ca0:	781b      	ldrb	r3, [r3, #0]
 8007ca2:	b90b      	cbnz	r3, 8007ca8 <main+0xe98>
	wdgReset(&WDGD1);
 8007ca4:	f7fa fb24 	bl	80022f0 <wdgReset.constprop.34>
  feedWatchdog();


  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8007ca8:	4a44      	ldr	r2, [pc, #272]	; (8007dbc <main+0xfac>)
 8007caa:	4845      	ldr	r0, [pc, #276]	; (8007dc0 <main+0xfb0>)
 8007cac:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007cb0:	f7ff f85e 	bl	8006d70 <chThdCreateStatic.constprop.26>
  chThdCreateStatic(waThread6, sizeof(waThread6), NORMALPRIO, Thread6, NULL);
 8007cb4:	4a43      	ldr	r2, [pc, #268]	; (8007dc4 <main+0xfb4>)
 8007cb6:	4844      	ldr	r0, [pc, #272]	; (8007dc8 <main+0xfb8>)
 8007cb8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007cbc:	f7ff f858 	bl	8006d70 <chThdCreateStatic.constprop.26>
  chThdCreateStatic(waThread7, sizeof(waThread7), NORMALPRIO, Thread7, NULL);
 8007cc0:	4a42      	ldr	r2, [pc, #264]	; (8007dcc <main+0xfbc>)
 8007cc2:	4843      	ldr	r0, [pc, #268]	; (8007dd0 <main+0xfc0>)
 8007cc4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007cc8:	f7ff f852 	bl	8006d70 <chThdCreateStatic.constprop.26>

  chprintf((BaseSequentialStream*)&SD1,"HelloA\r\n")  ;
 8007ccc:	4941      	ldr	r1, [pc, #260]	; (8007dd4 <main+0xfc4>)
 8007cce:	482d      	ldr	r0, [pc, #180]	; (8007d84 <main+0xf74>)
 8007cd0:	f7fb fede 	bl	8003a90 <chprintf.constprop.14>
  chThdCreateStatic(waThread3, sizeof(waThread3), NORMALPRIO, Thread3, NULL);
 8007cd4:	4a40      	ldr	r2, [pc, #256]	; (8007dd8 <main+0xfc8>)
 8007cd6:	4841      	ldr	r0, [pc, #260]	; (8007ddc <main+0xfcc>)
 8007cd8:	f44f 7154 	mov.w	r1, #848	; 0x350
 8007cdc:	f7ff f848 	bl	8006d70 <chThdCreateStatic.constprop.26>
  chprintf((BaseSequentialStream*)&SD1,"HelloB\r\n")  ;
 8007ce0:	493f      	ldr	r1, [pc, #252]	; (8007de0 <main+0xfd0>)
 8007ce2:	4828      	ldr	r0, [pc, #160]	; (8007d84 <main+0xf74>)
 8007ce4:	f7fb fed4 	bl	8003a90 <chprintf.constprop.14>
  chThdCreateStatic(waThread4, sizeof(waThread4), NORMALPRIO, Thread4, NULL);
 8007ce8:	4a3e      	ldr	r2, [pc, #248]	; (8007de4 <main+0xfd4>)
 8007cea:	483f      	ldr	r0, [pc, #252]	; (8007de8 <main+0xfd8>)
 8007cec:	f44f 6115 	mov.w	r1, #2384	; 0x950
 8007cf0:	f7ff f83e 	bl	8006d70 <chThdCreateStatic.constprop.26>
  chprintf((BaseSequentialStream*)&SD1,"HelloC\r\n")  ;
 8007cf4:	493d      	ldr	r1, [pc, #244]	; (8007dec <main+0xfdc>)
 8007cf6:	4823      	ldr	r0, [pc, #140]	; (8007d84 <main+0xf74>)
 8007cf8:	f7fb feca 	bl	8003a90 <chprintf.constprop.14>
  chThdCreateStatic(waThread5, sizeof(waThread5), NORMALPRIO, Thread5, NULL);
 8007cfc:	4a3c      	ldr	r2, [pc, #240]	; (8007df0 <main+0xfe0>)
 8007cfe:	483d      	ldr	r0, [pc, #244]	; (8007df4 <main+0xfe4>)
 8007d00:	f44f 7154 	mov.w	r1, #848	; 0x350
 8007d04:	f7ff f834 	bl	8006d70 <chThdCreateStatic.constprop.26>
  float outsideTemp;
  float internalTemp;

  //Default OPAMP4 CSR 10880000
  
  OPAMP4->CSR = 0X8041;
 8007d08:	4a3b      	ldr	r2, [pc, #236]	; (8007df8 <main+0xfe8>)
 8007d0a:	f248 0141 	movw	r1, #32833	; 0x8041
 8007d0e:	6011      	str	r1, [r2, #0]
  //chprintf(&SD1,"Default OPAMP4 CSR %X\r\n",OPAMP4->CSR);

  irradiance3 = 0;
 8007d10:	4a3a      	ldr	r2, [pc, #232]	; (8007dfc <main+0xfec>)
 8007d12:	2300      	movs	r3, #0
 8007d14:	6013      	str	r3, [r2, #0]
    if (!reset)
 8007d16:	4b23      	ldr	r3, [pc, #140]	; (8007da4 <main+0xf94>)
 8007d18:	781b      	ldrb	r3, [r3, #0]
 8007d1a:	b18b      	cbz	r3, 8007d40 <main+0xf30>

    while (TRUE)
      {
	  feedWatchdog();

	  step = (step +1)%256;
 8007d1c:	4a38      	ldr	r2, [pc, #224]	; (8007e00 <main+0xff0>)
 8007d1e:	8813      	ldrh	r3, [r2, #0]
 8007d20:	3301      	adds	r3, #1
 8007d22:	b2db      	uxtb	r3, r3
 8007d24:	8013      	strh	r3, [r2, #0]
 8007d26:	2320      	movs	r3, #32
 8007d28:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8007d2c:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8007d30:	b91b      	cbnz	r3, 8007d3a <main+0xf2a>
 8007d32:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8007d36:	2b00      	cmp	r3, #0
 8007d38:	d06a      	beq.n	8007e10 <main+0x1000>
    chSysHalt("SV#4");
 8007d3a:	4832      	ldr	r0, [pc, #200]	; (8007e04 <main+0xff4>)
 8007d3c:	f7f9 fb38 	bl	80013b0 <chSysHalt>
 8007d40:	2320      	movs	r3, #32
 8007d42:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8007d46:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8007d4a:	2b00      	cmp	r3, #0
 8007d4c:	d1f5      	bne.n	8007d3a <main+0xf2a>
 8007d4e:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8007d52:	2a00      	cmp	r2, #0
 8007d54:	d1f1      	bne.n	8007d3a <main+0xf2a>
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 8007d56:	f89a 3000 	ldrb.w	r3, [sl]
  _dbg_enter_lock();
 8007d5a:	2101      	movs	r1, #1
 8007d5c:	2b02      	cmp	r3, #2
 8007d5e:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
 8007d62:	f000 80dc 	beq.w	8007f1e <main+0x110e>
 8007d66:	4828      	ldr	r0, [pc, #160]	; (8007e08 <main+0xff8>)
 8007d68:	f7f9 fb22 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#11");
 8007d6c:	4827      	ldr	r0, [pc, #156]	; (8007e0c <main+0xffc>)
 8007d6e:	f7f9 fb1f 	bl	80013b0 <chSysHalt>
 8007d72:	bf00      	nop
 8007d74:	20001438 	.word	0x20001438
 8007d78:	20000820 	.word	0x20000820
 8007d7c:	20000810 	.word	0x20000810
 8007d80:	0801d7c4 	.word	0x0801d7c4
 8007d84:	200013d8 	.word	0x200013d8
 8007d88:	48000400 	.word	0x48000400
 8007d8c:	48001000 	.word	0x48001000
 8007d90:	0801d7e4 	.word	0x0801d7e4
 8007d94:	0801d7f0 	.word	0x0801d7f0
 8007d98:	0801d804 	.word	0x0801d804
 8007d9c:	08004391 	.word	0x08004391
 8007da0:	200047e8 	.word	0x200047e8
 8007da4:	200020a4 	.word	0x200020a4
 8007da8:	20002614 	.word	0x20002614
 8007dac:	0801d810 	.word	0x0801d810
 8007db0:	20002510 	.word	0x20002510
 8007db4:	0801d818 	.word	0x0801d818
 8007db8:	0801d830 	.word	0x0801d830
 8007dbc:	08002df1 	.word	0x08002df1
 8007dc0:	20004618 	.word	0x20004618
 8007dc4:	08004a51 	.word	0x08004a51
 8007dc8:	200059a8 	.word	0x200059a8
 8007dcc:	08004761 	.word	0x08004761
 8007dd0:	20005b78 	.word	0x20005b78
 8007dd4:	0801d844 	.word	0x0801d844
 8007dd8:	080063f1 	.word	0x080063f1
 8007ddc:	200049b8 	.word	0x200049b8
 8007de0:	0801d850 	.word	0x0801d850
 8007de4:	08005e31 	.word	0x08005e31
 8007de8:	20004d08 	.word	0x20004d08
 8007dec:	0801d85c 	.word	0x0801d85c
 8007df0:	08005c41 	.word	0x08005c41
 8007df4:	20005658 	.word	0x20005658
 8007df8:	40010044 	.word	0x40010044
 8007dfc:	20002008 	.word	0x20002008
 8007e00:	2000250c 	.word	0x2000250c
 8007e04:	0800e704 	.word	0x0800e704
 8007e08:	0800e3e8 	.word	0x0800e3e8
 8007e0c:	0800e714 	.word	0x0800e714
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8007e10:	48a8      	ldr	r0, [pc, #672]	; (80080b4 <main+0x12a4>)
 8007e12:	7803      	ldrb	r3, [r0, #0]
  _dbg_enter_lock();
 8007e14:	2101      	movs	r1, #1
 8007e16:	1e5a      	subs	r2, r3, #1
 8007e18:	428a      	cmp	r2, r1
 8007e1a:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
 8007e1e:	f63f ac2b 	bhi.w	8007678 <main+0x868>
    adcp->config = &default_config;
 8007e22:	4aa5      	ldr	r2, [pc, #660]	; (80080b8 <main+0x12a8>)
 8007e24:	6042      	str	r2, [r0, #4]
  if (adcp->state == ADC_STOP) {
 8007e26:	428b      	cmp	r3, r1
 8007e28:	d03c      	beq.n	8007ea4 <main+0x1094>
  adcp->state = ADC_READY;
 8007e2a:	49a2      	ldr	r1, [pc, #648]	; (80080b4 <main+0x12a4>)
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8007e2c:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 8007e30:	2302      	movs	r3, #2
 8007e32:	700b      	strb	r3, [r1, #0]
 8007e34:	bb4a      	cbnz	r2, 8007e8a <main+0x107a>
 8007e36:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8007e3a:	2b00      	cmp	r3, #0
 8007e3c:	dd25      	ble.n	8007e8a <main+0x107a>
 8007e3e:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 8007e42:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8007e46:	455b      	cmp	r3, fp
 8007e48:	d006      	beq.n	8007e58 <main+0x1048>
 8007e4a:	f8db 2018 	ldr.w	r2, [fp, #24]
 8007e4e:	689b      	ldr	r3, [r3, #8]
 8007e50:	6892      	ldr	r2, [r2, #8]
 8007e52:	429a      	cmp	r2, r3
 8007e54:	f4ff ad71 	bcc.w	800793a <main+0xb2a>
 8007e58:	2300      	movs	r3, #0
 8007e5a:	f383 8811 	msr	BASEPRI, r3
 8007e5e:	2320      	movs	r3, #32
 8007e60:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8007e64:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8007e68:	2b00      	cmp	r3, #0
 8007e6a:	f47f af66 	bne.w	8007d3a <main+0xf2a>
 8007e6e:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8007e72:	2b00      	cmp	r3, #0
 8007e74:	f47f af61 	bne.w	8007d3a <main+0xf2a>
                 adcsample_t *samples,
                 size_t depth) {
  msg_t msg;

  osalSysLock();
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8007e78:	4b8e      	ldr	r3, [pc, #568]	; (80080b4 <main+0x12a4>)
 8007e7a:	695b      	ldr	r3, [r3, #20]
  _dbg_enter_lock();
 8007e7c:	2201      	movs	r2, #1
 8007e7e:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8007e82:	b12b      	cbz	r3, 8007e90 <main+0x1080>
 8007e84:	488d      	ldr	r0, [pc, #564]	; (80080bc <main+0x12ac>)
 8007e86:	f7f9 fa93 	bl	80013b0 <chSysHalt>
    chSysHalt("SV#5");
 8007e8a:	488d      	ldr	r0, [pc, #564]	; (80080c0 <main+0x12b0>)
 8007e8c:	f7f9 fa90 	bl	80013b0 <chSysHalt>
  osalDbgAssert((adcp->state == ADC_READY) ||
 8007e90:	4b88      	ldr	r3, [pc, #544]	; (80080b4 <main+0x12a4>)
 8007e92:	781b      	ldrb	r3, [r3, #0]
 8007e94:	2b02      	cmp	r3, #2
 8007e96:	d058      	beq.n	8007f4a <main+0x113a>
 8007e98:	3b04      	subs	r3, #4
 8007e9a:	2b01      	cmp	r3, #1
 8007e9c:	d955      	bls.n	8007f4a <main+0x113a>
 8007e9e:	4889      	ldr	r0, [pc, #548]	; (80080c4 <main+0x12b4>)
 8007ea0:	f7f9 fa86 	bl	80013b0 <chSysHalt>
      b = dmaStreamAllocate(adcp->dmastp,
 8007ea4:	4603      	mov	r3, r0
 8007ea6:	4606      	mov	r6, r0
 8007ea8:	4a87      	ldr	r2, [pc, #540]	; (80080c8 <main+0x12b8>)
 8007eaa:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8007eac:	2105      	movs	r1, #5
 8007eae:	f7f9 feef 	bl	8001c90 <dmaStreamAllocate>
      osalDbgAssert(!b, "stream already allocated");
 8007eb2:	2800      	cmp	r0, #0
 8007eb4:	f47f ad44 	bne.w	8007940 <main+0xb30>
      clkmask |= (1 << 3);
 8007eb8:	4f84      	ldr	r7, [pc, #528]	; (80080cc <main+0x12bc>)
      rccEnableADC34(true);
 8007eba:	4c85      	ldr	r4, [pc, #532]	; (80080d0 <main+0x12c0>)
      clkmask |= (1 << 3);
 8007ebc:	683a      	ldr	r2, [r7, #0]
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8007ebe:	6b33      	ldr	r3, [r6, #48]	; 0x30
    adcp->adcm->DIFSEL = adcp->config->difsel;
 8007ec0:	6871      	ldr	r1, [r6, #4]
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8007ec2:	685d      	ldr	r5, [r3, #4]
 8007ec4:	6ab3      	ldr	r3, [r6, #40]	; 0x28
      clkmask |= (1 << 3);
 8007ec6:	f042 0208 	orr.w	r2, r2, #8
 8007eca:	603a      	str	r2, [r7, #0]
      rccEnableADC34(true);
 8007ecc:	6962      	ldr	r2, [r4, #20]
 8007ece:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007ed2:	6162      	str	r2, [r4, #20]
    adcp->adcm->DIFSEL = adcp->config->difsel;
 8007ed4:	680c      	ldr	r4, [r1, #0]
 8007ed6:	4a7f      	ldr	r2, [pc, #508]	; (80080d4 <main+0x12c4>)
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8007ed8:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8007edc:	60a9      	str	r1, [r5, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8007ede:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    adcp->adcm->DIFSEL = adcp->config->difsel;
 8007ee2:	f8c3 40b0 	str.w	r4, [r3, #176]	; 0xb0
  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 8007ee6:	6098      	str	r0, [r3, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8007ee8:	6099      	str	r1, [r3, #8]
 8007eea:	6850      	ldr	r0, [r2, #4]
 8007eec:	6851      	ldr	r1, [r2, #4]
  return (bool)((cnt - start) < (end - start));
 8007eee:	1a09      	subs	r1, r1, r0
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8007ef0:	f5b1 7fb4 	cmp.w	r1, #360	; 0x168
 8007ef4:	d3fa      	bcc.n	8007eec <main+0x10dc>
  osalDbgAssert(adcp->adcm->CR == ADC_CR_ADVREGEN_0, "invalid register state");
 8007ef6:	689a      	ldr	r2, [r3, #8]
 8007ef8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8007efc:	f47f ad1a 	bne.w	8007934 <main+0xb24>
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8007f00:	689a      	ldr	r2, [r3, #8]
 8007f02:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8007f06:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8007f08:	689a      	ldr	r2, [r3, #8]
 8007f0a:	2a00      	cmp	r2, #0
 8007f0c:	dbfc      	blt.n	8007f08 <main+0x10f8>
  adcp->adcm->CR |= ADC_CR_ADEN;
 8007f0e:	689a      	ldr	r2, [r3, #8]
 8007f10:	f042 0201 	orr.w	r2, r2, #1
 8007f14:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRD) == 0)
 8007f16:	681a      	ldr	r2, [r3, #0]
 8007f18:	07d2      	lsls	r2, r2, #31
 8007f1a:	d5fc      	bpl.n	8007f16 <main+0x1106>
 8007f1c:	e785      	b.n	8007e2a <main+0x101a>
 8007f1e:	f8db 3000 	ldr.w	r3, [fp]
  wdgp->wdg->KR = KR_KEY_RELOAD;
 8007f22:	f8da 1008 	ldr.w	r1, [sl, #8]
 8007f26:	f64a 20aa 	movw	r0, #43690	; 0xaaaa
 8007f2a:	455b      	cmp	r3, fp
 8007f2c:	6008      	str	r0, [r1, #0]
  _dbg_leave_lock();
 8007f2e:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8007f32:	d006      	beq.n	8007f42 <main+0x1132>
 8007f34:	f8db 2018 	ldr.w	r2, [fp, #24]
 8007f38:	689b      	ldr	r3, [r3, #8]
 8007f3a:	6892      	ldr	r2, [r2, #8]
 8007f3c:	429a      	cmp	r2, r3
 8007f3e:	f4ff ab9e 	bcc.w	800767e <main+0x86e>
 8007f42:	2300      	movs	r3, #0
 8007f44:	f383 8811 	msr	BASEPRI, r3
 8007f48:	e6e8      	b.n	8007d1c <main+0xf0c>
  adc_lld_start_conversion(adcp);
 8007f4a:	485a      	ldr	r0, [pc, #360]	; (80080b4 <main+0x12a4>)
  adcp->grpp     = grpp;
 8007f4c:	4b62      	ldr	r3, [pc, #392]	; (80080d8 <main+0x12c8>)
  adcp->samples  = samples;
 8007f4e:	4f63      	ldr	r7, [pc, #396]	; (80080dc <main+0x12cc>)
 8007f50:	6087      	str	r7, [r0, #8]
  adcp->state    = ADC_ACTIVE;
 8007f52:	4604      	mov	r4, r0
  adcp->depth    = depth;
 8007f54:	2501      	movs	r5, #1
  adcp->state    = ADC_ACTIVE;
 8007f56:	f04f 0803 	mov.w	r8, #3
  adcp->grpp     = grpp;
 8007f5a:	e9c0 5303 	strd	r5, r3, [r0, #12]
  adcp->state    = ADC_ACTIVE;
 8007f5e:	f880 8000 	strb.w	r8, [r0]
  adc_lld_start_conversion(adcp);
 8007f62:	f7f9 ffbd 	bl	8001ee0 <adc_lld_start_conversion>
  chDbgAssert(*trp == NULL, "not NULL");
 8007f66:	6963      	ldr	r3, [r4, #20]
  return ch.rlist.current;
 8007f68:	f8db 4018 	ldr.w	r4, [fp, #24]
 8007f6c:	b113      	cbz	r3, 8007f74 <main+0x1164>
 8007f6e:	485c      	ldr	r0, [pc, #368]	; (80080e0 <main+0x12d0>)
 8007f70:	f7f9 fa1e 	bl	80013b0 <chSysHalt>
  tp->u.wttrp = trp;
 8007f74:	495b      	ldr	r1, [pc, #364]	; (80080e4 <main+0x12d4>)
 8007f76:	6261      	str	r1, [r4, #36]	; 0x24
  *trp = tp;
 8007f78:	f1a1 0214 	sub.w	r2, r1, #20
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8007f7c:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8007f80:	6154      	str	r4, [r2, #20]
 8007f82:	2b00      	cmp	r3, #0
 8007f84:	f47f aef2 	bne.w	8007d6c <main+0xf5c>
 8007f88:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8007f8c:	2b00      	cmp	r3, #0
 8007f8e:	f77f aeed 	ble.w	8007d6c <main+0xf5c>
  thread_t *tp = tqp->next;
 8007f92:	f8db 3000 	ldr.w	r3, [fp]
  otp->state = newstate;
 8007f96:	f884 8020 	strb.w	r8, [r4, #32]
  tqp->next             = tp->queue.next;
 8007f9a:	681a      	ldr	r2, [r3, #0]
 8007f9c:	f8cb 2000 	str.w	r2, [fp]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007fa0:	f8c2 b004 	str.w	fp, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8007fa4:	f883 5020 	strb.w	r5, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8007fa8:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8007fac:	f8cb 3018 	str.w	r3, [fp, #24]
 8007fb0:	07d3      	lsls	r3, r2, #31
 8007fb2:	d410      	bmi.n	8007fd6 <main+0x11c6>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8007fb4:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
 8007fb8:	7813      	ldrb	r3, [r2, #0]
 8007fba:	f365 0302 	bfi	r3, r5, #0, #3
 8007fbe:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8007fc0:	f894 0020 	ldrb.w	r0, [r4, #32]
 8007fc4:	f360 03c7 	bfi	r3, r0, #3, #5
 8007fc8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8007fca:	f8db 3018 	ldr.w	r3, [fp, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8007fce:	e9c2 3102 	strd	r3, r1, [r2, #8]
    trace_next();
 8007fd2:	f7f9 f9cd 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8007fd6:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8007fda:	69e2      	ldr	r2, [r4, #28]
 8007fdc:	3b64      	subs	r3, #100	; 0x64
 8007fde:	429a      	cmp	r2, r3
 8007fe0:	f200 8544 	bhi.w	8008a6c <main+0x1c5c>
 8007fe4:	4621      	mov	r1, r4
 8007fe6:	f8db 0018 	ldr.w	r0, [fp, #24]
 8007fea:	f7f8 f96d 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8007fee:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
  return currp->u.rdymsg;
 8007ff2:	f8db 1018 	ldr.w	r1, [fp, #24]
 8007ff6:	2a00      	cmp	r2, #0
 8007ff8:	f47f af47 	bne.w	8007e8a <main+0x107a>
 8007ffc:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8008000:	2b00      	cmp	r3, #0
 8008002:	f77f af42 	ble.w	8007e8a <main+0x107a>
 8008006:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 800800a:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 800800e:	455b      	cmp	r3, fp
 8008010:	d004      	beq.n	800801c <main+0x120c>
 8008012:	688a      	ldr	r2, [r1, #8]
 8008014:	689b      	ldr	r3, [r3, #8]
 8008016:	429a      	cmp	r2, r3
 8008018:	f4ff ac8f 	bcc.w	800793a <main+0xb2a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800801c:	2300      	movs	r3, #0
 800801e:	f383 8811 	msr	BASEPRI, r3
 8008022:	2320      	movs	r3, #32
 8008024:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008028:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 800802c:	2b00      	cmp	r3, #0
 800802e:	f47f ae84 	bne.w	8007d3a <main+0xf2a>
 8008032:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8008036:	2b00      	cmp	r3, #0
 8008038:	f47f ae7f 	bne.w	8007d3a <main+0xf2a>
  _dbg_enter_lock();
 800803c:	2301      	movs	r3, #1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800803e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8008042:	2008      	movs	r0, #8
 8008044:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 8008048:	f7fa fdaa 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800804c:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 8008050:	2a00      	cmp	r2, #0
 8008052:	f47f af1a 	bne.w	8007e8a <main+0x107a>
 8008056:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800805a:	2b00      	cmp	r3, #0
 800805c:	f77f af15 	ble.w	8007e8a <main+0x107a>
 8008060:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 8008064:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8008068:	455b      	cmp	r3, fp
 800806a:	d005      	beq.n	8008078 <main+0x1268>
 800806c:	f8db 2018 	ldr.w	r2, [fp, #24]
 8008070:	689b      	ldr	r3, [r3, #8]
 8008072:	6892      	ldr	r2, [r2, #8]
 8008074:	429a      	cmp	r2, r3
 8008076:	d31a      	bcc.n	80080ae <main+0x129e>
 8008078:	2300      	movs	r3, #0
 800807a:	f383 8811 	msr	BASEPRI, r3
 800807e:	2320      	movs	r3, #32
 8008080:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008084:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8008088:	2b00      	cmp	r3, #0
 800808a:	f47f ae56 	bne.w	8007d3a <main+0xf2a>
 800808e:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8008092:	2b00      	cmp	r3, #0
 8008094:	f47f ae51 	bne.w	8007d3a <main+0xf2a>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8008098:	4b06      	ldr	r3, [pc, #24]	; (80080b4 <main+0x12a4>)
 800809a:	781b      	ldrb	r3, [r3, #0]
  _dbg_enter_lock();
 800809c:	2101      	movs	r1, #1
 800809e:	1e5a      	subs	r2, r3, #1
 80080a0:	428a      	cmp	r2, r1
 80080a2:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
 80080a6:	d923      	bls.n	80080f0 <main+0x12e0>
 80080a8:	480f      	ldr	r0, [pc, #60]	; (80080e8 <main+0x12d8>)
 80080aa:	f7f9 f981 	bl	80013b0 <chSysHalt>
 80080ae:	480f      	ldr	r0, [pc, #60]	; (80080ec <main+0x12dc>)
 80080b0:	f7f9 f97e 	bl	80013b0 <chSysHalt>
 80080b4:	20001288 	.word	0x20001288
 80080b8:	0800e75c 	.word	0x0800e75c
 80080bc:	0800e48c 	.word	0x0800e48c
 80080c0:	0800e72c 	.word	0x0800e72c
 80080c4:	0800e434 	.word	0x0800e434
 80080c8:	08002121 	.word	0x08002121
 80080cc:	20001fd0 	.word	0x20001fd0
 80080d0:	40021000 	.word	0x40021000
 80080d4:	e0001000 	.word	0xe0001000
 80080d8:	0800e6d8 	.word	0x0800e6d8
 80080dc:	200024b8 	.word	0x200024b8
 80080e0:	0800e348 	.word	0x0800e348
 80080e4:	2000129c 	.word	0x2000129c
 80080e8:	0800e3d8 	.word	0x0800e3d8
 80080ec:	0800e1e4 	.word	0x0800e1e4
  if (adcp->state == ADC_READY) {
 80080f0:	2b02      	cmp	r3, #2
 80080f2:	f000 8481 	beq.w	80089f8 <main+0x1be8>
  adcp->config = NULL;
 80080f6:	49d2      	ldr	r1, [pc, #840]	; (8008440 <main+0x1630>)
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80080f8:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 80080fc:	2300      	movs	r3, #0
 80080fe:	604b      	str	r3, [r1, #4]
  adcp->state  = ADC_STOP;
 8008100:	2301      	movs	r3, #1
 8008102:	700b      	strb	r3, [r1, #0]
 8008104:	2a00      	cmp	r2, #0
 8008106:	f47f aec0 	bne.w	8007e8a <main+0x107a>
 800810a:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800810e:	2b00      	cmp	r3, #0
 8008110:	f77f aebb 	ble.w	8007e8a <main+0x107a>
 8008114:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 8008118:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 800811c:	455b      	cmp	r3, fp
 800811e:	d006      	beq.n	800812e <main+0x131e>
 8008120:	f8db 2018 	ldr.w	r2, [fp, #24]
 8008124:	689b      	ldr	r3, [r3, #8]
 8008126:	6892      	ldr	r2, [r2, #8]
 8008128:	429a      	cmp	r2, r3
 800812a:	f4ff ac06 	bcc.w	800793a <main+0xb2a>
 800812e:	2300      	movs	r3, #0
 8008130:	f383 8811 	msr	BASEPRI, r3
    if (!reset)
 8008134:	4bc3      	ldr	r3, [pc, #780]	; (8008444 <main+0x1634>)
 8008136:	781b      	ldrb	r3, [r3, #0]
 8008138:	2b00      	cmp	r3, #0
 800813a:	f000 8431 	beq.w	80089a0 <main+0x1b90>
	  //chprintf((BaseSequentialStream*)&SD1,"ADC4 %d %d %d %d %d\r\n",samples2[0],samples2[1],samples2[2],samples2[3],samples2[4]);


	  

	  VDD = 3.3 * (*(uint16_t*)0x1FFFF7BA) / (samples2[1] * 1.0);
 800813e:	4bc2      	ldr	r3, [pc, #776]	; (8008448 <main+0x1638>)

	  irradiance2 = calc_volts(VDD,samples2[3])/(8*.0002);
 8008140:	f8df 8330 	ldr.w	r8, [pc, #816]	; 8008474 <main+0x1664>
	  VDD = 3.3 * (*(uint16_t*)0x1FFFF7BA) / (samples2[1] * 1.0);
 8008144:	8818      	ldrh	r0, [r3, #0]
 8008146:	f7f8 fa2f 	bl	80005a8 <__aeabi_i2d>
 800814a:	a3af      	add	r3, pc, #700	; (adr r3, 8008408 <main+0x15f8>)
 800814c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008150:	f7f8 fa94 	bl	800067c <__aeabi_dmul>
 8008154:	4604      	mov	r4, r0
 8008156:	8878      	ldrh	r0, [r7, #2]
 8008158:	460d      	mov	r5, r1
 800815a:	f7f8 fa25 	bl	80005a8 <__aeabi_i2d>
 800815e:	4602      	mov	r2, r0
 8008160:	460b      	mov	r3, r1
 8008162:	4620      	mov	r0, r4
 8008164:	4629      	mov	r1, r5
 8008166:	f7f8 fbb3 	bl	80008d0 <__aeabi_ddiv>
 800816a:	f7f8 fd5f 	bl	8000c2c <__aeabi_d2f>
    return (rawread/4095.0)*vdd;
 800816e:	f7f8 fa2d 	bl	80005cc <__aeabi_f2d>
 8008172:	4604      	mov	r4, r0
 8008174:	88f8      	ldrh	r0, [r7, #6]
 8008176:	460d      	mov	r5, r1
 8008178:	f7f8 fa16 	bl	80005a8 <__aeabi_i2d>
 800817c:	a3a4      	add	r3, pc, #656	; (adr r3, 8008410 <main+0x1600>)
 800817e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008182:	f7f8 fba5 	bl	80008d0 <__aeabi_ddiv>
 8008186:	4622      	mov	r2, r4
 8008188:	462b      	mov	r3, r5
 800818a:	f7f8 fa77 	bl	800067c <__aeabi_dmul>
 800818e:	f7f8 fd4d 	bl	8000c2c <__aeabi_d2f>
	  irradiance2 = calc_volts(VDD,samples2[3])/(8*.0002);
 8008192:	f7f8 fa1b 	bl	80005cc <__aeabi_f2d>
 8008196:	a3a0      	add	r3, pc, #640	; (adr r3, 8008418 <main+0x1608>)
 8008198:	e9d3 2300 	ldrd	r2, r3, [r3]
 800819c:	f7f8 fb98 	bl	80008d0 <__aeabi_ddiv>
 80081a0:	f7f8 fd44 	bl	8000c2c <__aeabi_d2f>
 80081a4:	2320      	movs	r3, #32
 80081a6:	f8c8 0000 	str.w	r0, [r8]
 80081aa:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80081ae:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 80081b2:	2b00      	cmp	r3, #0
 80081b4:	f47f adc1 	bne.w	8007d3a <main+0xf2a>
 80081b8:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80081bc:	2b00      	cmp	r3, #0
 80081be:	f47f adbc 	bne.w	8007d3a <main+0xf2a>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 80081c2:	49a2      	ldr	r1, [pc, #648]	; (800844c <main+0x163c>)
 80081c4:	694b      	ldr	r3, [r1, #20]
  _dbg_enter_lock();
 80081c6:	2201      	movs	r2, #1
 80081c8:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 80081cc:	2b00      	cmp	r3, #0
 80081ce:	f47f ae59 	bne.w	8007e84 <main+0x1074>
  osalDbgAssert((adcp->state == ADC_READY) ||
 80081d2:	780b      	ldrb	r3, [r1, #0]
 80081d4:	2b02      	cmp	r3, #2
 80081d6:	d003      	beq.n	80081e0 <main+0x13d0>
 80081d8:	3b04      	subs	r3, #4
 80081da:	4293      	cmp	r3, r2
 80081dc:	f63f ae5f 	bhi.w	8007e9e <main+0x108e>
  adc_lld_start_conversion(adcp);
 80081e0:	489a      	ldr	r0, [pc, #616]	; (800844c <main+0x163c>)
  adcp->samples  = samples;
 80081e2:	4b9b      	ldr	r3, [pc, #620]	; (8008450 <main+0x1640>)
  adcp->grpp     = grpp;
 80081e4:	499b      	ldr	r1, [pc, #620]	; (8008454 <main+0x1644>)
  adcp->samples  = samples;
 80081e6:	6083      	str	r3, [r0, #8]
 80081e8:	4606      	mov	r6, r0
  adcp->depth    = depth;
 80081ea:	2201      	movs	r2, #1
  adcp->state    = ADC_ACTIVE;
 80081ec:	2303      	movs	r3, #3
  adcp->grpp     = grpp;
 80081ee:	6101      	str	r1, [r0, #16]
  adcp->depth    = depth;
 80081f0:	60c2      	str	r2, [r0, #12]
 80081f2:	9205      	str	r2, [sp, #20]
  adcp->state    = ADC_ACTIVE;
 80081f4:	7003      	strb	r3, [r0, #0]
 80081f6:	9302      	str	r3, [sp, #8]
  adc_lld_start_conversion(adcp);
 80081f8:	f7f9 fe72 	bl	8001ee0 <adc_lld_start_conversion>
  chDbgAssert(*trp == NULL, "not NULL");
 80081fc:	6971      	ldr	r1, [r6, #20]
  return ch.rlist.current;
 80081fe:	f8db 9018 	ldr.w	r9, [fp, #24]
 8008202:	2900      	cmp	r1, #0
 8008204:	f47f aeb3 	bne.w	8007f6e <main+0x115e>
  tp->u.wttrp = trp;
 8008208:	f106 0014 	add.w	r0, r6, #20
 800820c:	f8c9 0024 	str.w	r0, [r9, #36]	; 0x24
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8008210:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
  *trp = tp;
 8008214:	f8c6 9014 	str.w	r9, [r6, #20]
 8008218:	2900      	cmp	r1, #0
 800821a:	f47f ada7 	bne.w	8007d6c <main+0xf5c>
 800821e:	f8db 1034 	ldr.w	r1, [fp, #52]	; 0x34
 8008222:	2900      	cmp	r1, #0
 8008224:	f77f ada2 	ble.w	8007d6c <main+0xf5c>
  thread_t *tp = tqp->next;
 8008228:	f8db 1000 	ldr.w	r1, [fp]
  otp->state = newstate;
 800822c:	9b02      	ldr	r3, [sp, #8]
 800822e:	f889 3020 	strb.w	r3, [r9, #32]
  tqp->next             = tp->queue.next;
 8008232:	680b      	ldr	r3, [r1, #0]
  currp->state = CH_STATE_CURRENT;
 8008234:	9a05      	ldr	r2, [sp, #20]
  tqp->next->queue.prev = (thread_t *)tqp;
 8008236:	f8c3 b004 	str.w	fp, [r3, #4]
 800823a:	f881 2020 	strb.w	r2, [r1, #32]
  tqp->next             = tp->queue.next;
 800823e:	f8cb 3000 	str.w	r3, [fp]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8008242:	f8bb 3038 	ldrh.w	r3, [fp, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8008246:	f8cb 1018 	str.w	r1, [fp, #24]
 800824a:	07d9      	lsls	r1, r3, #31
 800824c:	d410      	bmi.n	8008270 <main+0x1460>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800824e:	f8db 103c 	ldr.w	r1, [fp, #60]	; 0x3c
 8008252:	780b      	ldrb	r3, [r1, #0]
 8008254:	f362 0302 	bfi	r3, r2, #0, #3
 8008258:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800825a:	f899 2020 	ldrb.w	r2, [r9, #32]
 800825e:	f362 03c7 	bfi	r3, r2, #3, #5
 8008262:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8008264:	f8db 3018 	ldr.w	r3, [fp, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8008268:	e9c1 3002 	strd	r3, r0, [r1, #8]
    trace_next();
 800826c:	f7f9 f880 	bl	8001370 <trace_next>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008270:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8008274:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8008278:	3b64      	subs	r3, #100	; 0x64
 800827a:	429a      	cmp	r2, r3
 800827c:	f200 83f6 	bhi.w	8008a6c <main+0x1c5c>
 8008280:	4649      	mov	r1, r9
 8008282:	f8db 0018 	ldr.w	r0, [fp, #24]
 8008286:	f7f8 f81f 	bl	80002c8 <_port_switch>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800828a:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
  return currp->u.rdymsg;
 800828e:	f8db 1018 	ldr.w	r1, [fp, #24]
 8008292:	2a00      	cmp	r2, #0
 8008294:	f47f adf9 	bne.w	8007e8a <main+0x107a>
 8008298:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800829c:	2b00      	cmp	r3, #0
 800829e:	f77f adf4 	ble.w	8007e8a <main+0x107a>
 80082a2:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 80082a6:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 80082aa:	455b      	cmp	r3, fp
 80082ac:	d004      	beq.n	80082b8 <main+0x14a8>
 80082ae:	688a      	ldr	r2, [r1, #8]
 80082b0:	689b      	ldr	r3, [r3, #8]
 80082b2:	429a      	cmp	r2, r3
 80082b4:	f4ff ab41 	bcc.w	800793a <main+0xb2a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80082b8:	2300      	movs	r3, #0
 80082ba:	f383 8811 	msr	BASEPRI, r3
 80082be:	2320      	movs	r3, #32
 80082c0:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80082c4:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 80082c8:	2b00      	cmp	r3, #0
 80082ca:	f47f ad36 	bne.w	8007d3a <main+0xf2a>
 80082ce:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80082d2:	2b00      	cmp	r3, #0
 80082d4:	f47f ad31 	bne.w	8007d3a <main+0xf2a>
  _dbg_enter_lock();
 80082d8:	2301      	movs	r3, #1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80082da:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80082de:	2008      	movs	r0, #8
 80082e0:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 80082e4:	f7fa fc5c 	bl	8002ba0 <chSchGoSleepTimeoutS>
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80082e8:	f8db 2030 	ldr.w	r2, [fp, #48]	; 0x30
 80082ec:	2a00      	cmp	r2, #0
 80082ee:	f47f adcc 	bne.w	8007e8a <main+0x107a>
 80082f2:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80082f6:	2b00      	cmp	r3, #0
 80082f8:	f77f adc7 	ble.w	8007e8a <main+0x107a>
 80082fc:	f8db 3000 	ldr.w	r3, [fp]
  _dbg_leave_lock();
 8008300:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8008304:	455b      	cmp	r3, fp
 8008306:	d006      	beq.n	8008316 <main+0x1506>
 8008308:	f8db 2018 	ldr.w	r2, [fp, #24]
 800830c:	689b      	ldr	r3, [r3, #8]
 800830e:	6892      	ldr	r2, [r2, #8]
 8008310:	429a      	cmp	r2, r3
 8008312:	f4ff aecc 	bcc.w	80080ae <main+0x129e>
 8008316:	2300      	movs	r3, #0
 8008318:	f383 8811 	msr	BASEPRI, r3
    if (!reset)
 800831c:	4b49      	ldr	r3, [pc, #292]	; (8008444 <main+0x1634>)
 800831e:	781b      	ldrb	r3, [r3, #0]
 8008320:	2b00      	cmp	r3, #0
 8008322:	f000 8449 	beq.w	8008bb8 <main+0x1da8>
	  adcConvert(&ADCD1, &adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
	  chThdSleepMilliseconds(100);
	  feedWatchdog();
	  internalTemp = calc_temp(VDD,samples1[0]);
	  //chprintf((BaseSequentialStream*)&SD1,"ADC1 %d %d %d\r\n",samples1[0],samples1[1],samples1[2]);
	  chprintf((BaseSequentialStream*)&SD1,"Rain: %.2f Rate:%.2f\r\n",lifetimeRain,rainRate);
 8008326:	4b4c      	ldr	r3, [pc, #304]	; (8008458 <main+0x1648>)
 8008328:	6818      	ldr	r0, [r3, #0]
 800832a:	f7f8 f94f 	bl	80005cc <__aeabi_f2d>
 800832e:	4602      	mov	r2, r0
 8008330:	460b      	mov	r3, r1
 8008332:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8008336:	4b49      	ldr	r3, [pc, #292]	; (800845c <main+0x164c>)
 8008338:	6818      	ldr	r0, [r3, #0]
 800833a:	f7f8 f947 	bl	80005cc <__aeabi_f2d>
 800833e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008342:	e9cd 0100 	strd	r0, r1, [sp]
 8008346:	4946      	ldr	r1, [pc, #280]	; (8008460 <main+0x1650>)
 8008348:	4846      	ldr	r0, [pc, #280]	; (8008464 <main+0x1654>)
 800834a:	f7fb fba1 	bl	8003a90 <chprintf.constprop.14>
    return (rawread/4095.0)*vdd;
 800834e:	8938      	ldrh	r0, [r7, #8]
 8008350:	f7f8 f92a 	bl	80005a8 <__aeabi_i2d>
 8008354:	a32e      	add	r3, pc, #184	; (adr r3, 8008410 <main+0x1600>)
 8008356:	e9d3 2300 	ldrd	r2, r3, [r3]
 800835a:	f7f8 fab9 	bl	80008d0 <__aeabi_ddiv>
 800835e:	4622      	mov	r2, r4
 8008360:	462b      	mov	r3, r5
 8008362:	f7f8 f98b 	bl	800067c <__aeabi_dmul>
 8008366:	f7f8 fc61 	bl	8000c2c <__aeabi_d2f>


	  irradiance = calc_volts(VDD,samples2[4]);
	  if (irradiance < .01)
 800836a:	f7f8 f92f 	bl	80005cc <__aeabi_f2d>
 800836e:	a32c      	add	r3, pc, #176	; (adr r3, 8008420 <main+0x1610>)
 8008370:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008374:	f7f8 fbf4 	bl	8000b60 <__aeabi_dcmplt>
 8008378:	2800      	cmp	r0, #0
 800837a:	f040 83d7 	bne.w	8008b2c <main+0x1d1c>
	      irradiance = 0;
	  else
	      irradiance = irradiance2;
 800837e:	f8d8 8000 	ldr.w	r8, [r8]
 8008382:	4b39      	ldr	r3, [pc, #228]	; (8008468 <main+0x1658>)
	  irradiance3 = irradiance3*.9 + irradiance*.1;    
 8008384:	4e39      	ldr	r6, [pc, #228]	; (800846c <main+0x165c>)
 8008386:	f8c3 8000 	str.w	r8, [r3]
 800838a:	6830      	ldr	r0, [r6, #0]
	  amps = (calc_volts(VDD,samples2[2])/120.0);
 800838c:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 8008478 <main+0x1668>
	  irradiance3 = irradiance3*.9 + irradiance*.1;    
 8008390:	f7f8 f91c 	bl	80005cc <__aeabi_f2d>
 8008394:	a324      	add	r3, pc, #144	; (adr r3, 8008428 <main+0x1618>)
 8008396:	e9d3 2300 	ldrd	r2, r3, [r3]
 800839a:	f7f8 f96f 	bl	800067c <__aeabi_dmul>
 800839e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80083a2:	4640      	mov	r0, r8
 80083a4:	f7f8 f912 	bl	80005cc <__aeabi_f2d>
 80083a8:	a321      	add	r3, pc, #132	; (adr r3, 8008430 <main+0x1620>)
 80083aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083ae:	f7f8 f965 	bl	800067c <__aeabi_dmul>
 80083b2:	4602      	mov	r2, r0
 80083b4:	460b      	mov	r3, r1
 80083b6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80083ba:	f7f7 ffa9 	bl	8000310 <__adddf3>
 80083be:	f7f8 fc35 	bl	8000c2c <__aeabi_d2f>
 80083c2:	6030      	str	r0, [r6, #0]
    return (rawread/4095.0)*vdd;
 80083c4:	88b8      	ldrh	r0, [r7, #4]
 80083c6:	f7f8 f8ef 	bl	80005a8 <__aeabi_i2d>
 80083ca:	a311      	add	r3, pc, #68	; (adr r3, 8008410 <main+0x1600>)
 80083cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083d0:	f7f8 fa7e 	bl	80008d0 <__aeabi_ddiv>
 80083d4:	4622      	mov	r2, r4
 80083d6:	462b      	mov	r3, r5
 80083d8:	f7f8 f950 	bl	800067c <__aeabi_dmul>
 80083dc:	f7f8 fc26 	bl	8000c2c <__aeabi_d2f>
	  amps = (calc_volts(VDD,samples2[2])/120.0);
 80083e0:	ed9f 7a23 	vldr	s14, [pc, #140]	; 8008470 <main+0x1660>
 80083e4:	ee07 0a90 	vmov	s15, r0
 80083e8:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80083ec:	edc9 7a00 	vstr	s15, [r9]
	  windspeed = (amps-0.004)*(50.0/.016);
 80083f0:	ee17 0a90 	vmov	r0, s15
 80083f4:	f7f8 f8ea 	bl	80005cc <__aeabi_f2d>
 80083f8:	a30f      	add	r3, pc, #60	; (adr r3, 8008438 <main+0x1628>)
 80083fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083fe:	f7f7 ff85 	bl	800030c <__aeabi_dsub>
 8008402:	e03b      	b.n	800847c <main+0x166c>
 8008404:	f3af 8000 	nop.w
 8008408:	66666666 	.word	0x66666666
 800840c:	400a6666 	.word	0x400a6666
 8008410:	00000000 	.word	0x00000000
 8008414:	40affe00 	.word	0x40affe00
 8008418:	eb1c432d 	.word	0xeb1c432d
 800841c:	3f5a36e2 	.word	0x3f5a36e2
 8008420:	47ae147b 	.word	0x47ae147b
 8008424:	3f847ae1 	.word	0x3f847ae1
 8008428:	cccccccd 	.word	0xcccccccd
 800842c:	3feccccc 	.word	0x3feccccc
 8008430:	9999999a 	.word	0x9999999a
 8008434:	3fb99999 	.word	0x3fb99999
 8008438:	d2f1a9fc 	.word	0xd2f1a9fc
 800843c:	3f70624d 	.word	0x3f70624d
 8008440:	20001288 	.word	0x20001288
 8008444:	200020a4 	.word	0x200020a4
 8008448:	1ffff7ba 	.word	0x1ffff7ba
 800844c:	200011e0 	.word	0x200011e0
 8008450:	200024b4 	.word	0x200024b4
 8008454:	0800e6ac 	.word	0x0800e6ac
 8008458:	2000200c 	.word	0x2000200c
 800845c:	200020a0 	.word	0x200020a0
 8008460:	0801d868 	.word	0x0801d868
 8008464:	200013d8 	.word	0x200013d8
 8008468:	20002000 	.word	0x20002000
 800846c:	20002008 	.word	0x20002008
 8008470:	42f00000 	.word	0x42f00000
 8008474:	20002004 	.word	0x20002004
 8008478:	20001594 	.word	0x20001594
 800847c:	a3f8      	add	r3, pc, #992	; (adr r3, 8008860 <main+0x1a50>)
 800847e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008482:	f7f8 f8fb 	bl	800067c <__aeabi_dmul>
 8008486:	f7f8 fbd1 	bl	8000c2c <__aeabi_d2f>
 800848a:	ee08 0a10 	vmov	s16, r0
    return (rawread/4095.0)*vdd;
 800848e:	8838      	ldrh	r0, [r7, #0]
 8008490:	f7f8 f88a 	bl	80005a8 <__aeabi_i2d>
 8008494:	a3f4      	add	r3, pc, #976	; (adr r3, 8008868 <main+0x1a58>)
 8008496:	e9d3 2300 	ldrd	r2, r3, [r3]
 800849a:	f7f8 fa19 	bl	80008d0 <__aeabi_ddiv>
 800849e:	462b      	mov	r3, r5
 80084a0:	4622      	mov	r2, r4
 80084a2:	f7f8 f8eb 	bl	800067c <__aeabi_dmul>
 80084a6:	f7f8 fbc1 	bl	8000c2c <__aeabi_d2f>
	  opamp4 = calc_volts(VDD,samples2[3]);
	  snow = calc_volts(VDD,samples2[0]);
	  if (windspeed < 0.5)
 80084aa:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    return (rawread/4095.0)*vdd;
 80084ae:	4bdc      	ldr	r3, [pc, #880]	; (8008820 <main+0x1a10>)
	  if (windspeed < 0.5)
 80084b0:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80084b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    return (rawread/4095.0)*vdd;
 80084b8:	6018      	str	r0, [r3, #0]
	  if (windspeed < 0.5)
 80084ba:	f100 8335 	bmi.w	8008b28 <main+0x1d18>
	      windspeed = 0;
	  else
	      windspeed = windspeed*2.237;
 80084be:	ee18 0a10 	vmov	r0, s16
 80084c2:	f7f8 f883 	bl	80005cc <__aeabi_f2d>
 80084c6:	a3cc      	add	r3, pc, #816	; (adr r3, 80087f8 <main+0x19e8>)
 80084c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80084cc:	f7f8 f8d6 	bl	800067c <__aeabi_dmul>
 80084d0:	f7f8 fbac 	bl	8000c2c <__aeabi_d2f>
 80084d4:	f8df 8398 	ldr.w	r8, [pc, #920]	; 8008870 <main+0x1a60>
    hsb = rxbuf[1];
 80084d8:	4cd2      	ldr	r4, [pc, #840]	; (8008824 <main+0x1a14>)
 80084da:	f8c8 0000 	str.w	r0, [r8]
    spi_write(0x80,0xd0,device); // three wire
 80084de:	2000      	movs	r0, #0
 80084e0:	f7fa f976 	bl	80027d0 <spi_write.constprop.11>
    spi_read(0x0,device);
 80084e4:	2000      	movs	r0, #0
 80084e6:	f7f9 ff7b 	bl	80023e0 <spi_read.constprop.10>
    result = (hsb << 8) + lsb;
 80084ea:	7862      	ldrb	r2, [r4, #1]
 80084ec:	78a3      	ldrb	r3, [r4, #2]
    pt100temp = z2 + (z3 * result);
 80084ee:	ed9f 8ace 	vldr	s16, [pc, #824]	; 8008828 <main+0x1a18>
 80084f2:	eddf 8ace 	vldr	s17, [pc, #824]	; 800882c <main+0x1a1c>
	  windspeedout = windspeed;
          //chprintf((BaseSequentialStream*)&SD1,"irr: %.2f  inside: %.2f ,vdd: %.2f windV: %.4f %.2fmph  snow %.2fv \r\n",irradiance3,internalTemp,VDD,amps,windspeed,snow);
	  
	  pt100temp1 = get_temp(0);
 80084f6:	4fce      	ldr	r7, [pc, #824]	; (8008830 <main+0x1a20>)
	  pt100temp2 = get_temp(1);
	  pt100temp3 = get_temp(2);
	  pt100temp4 = get_temp(3);
	  pt100temp5 = get_temp(4);
	  sprintf(metrics[0],"Irr: %5.0f",irradiance3);
 80084f8:	4dce      	ldr	r5, [pc, #824]	; (8008834 <main+0x1a24>)
    result = (hsb << 8) + lsb;
 80084fa:	eb03 2002 	add.w	r0, r3, r2, lsl #8
    result = (result*430.0) / 32768.0;	  
 80084fe:	ee07 0a90 	vmov	s15, r0
 8008502:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008506:	ee17 0a90 	vmov	r0, s15
 800850a:	f7f8 f85f 	bl	80005cc <__aeabi_f2d>
 800850e:	a3bc      	add	r3, pc, #752	; (adr r3, 8008800 <main+0x19f0>)
 8008510:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008514:	f7f8 f8b2 	bl	800067c <__aeabi_dmul>
 8008518:	2200      	movs	r2, #0
 800851a:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 800851e:	f7f8 f8ad 	bl	800067c <__aeabi_dmul>
 8008522:	f7f8 fb83 	bl	8000c2c <__aeabi_d2f>
    pt100temp = (sqrt(pt100temp) + z1) / z4;
 8008526:	ee07 0a10 	vmov	s14, r0
 800852a:	eef0 7a48 	vmov.f32	s15, s16
 800852e:	eee7 7a28 	vfma.f32	s15, s14, s17
 8008532:	ee17 0a90 	vmov	r0, s15
 8008536:	f7f8 f849 	bl	80005cc <__aeabi_f2d>
 800853a:	ec41 0b10 	vmov	d0, r0, r1
 800853e:	f001 fd69 	bl	800a014 <sqrt>
 8008542:	a3b1      	add	r3, pc, #708	; (adr r3, 8008808 <main+0x19f8>)
 8008544:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008548:	ec51 0b10 	vmov	r0, r1, d0
 800854c:	f7f7 fede 	bl	800030c <__aeabi_dsub>
 8008550:	a3af      	add	r3, pc, #700	; (adr r3, 8008810 <main+0x1a00>)
 8008552:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008556:	f7f8 f9bb 	bl	80008d0 <__aeabi_ddiv>
 800855a:	f7f8 fb67 	bl	8000c2c <__aeabi_d2f>
 800855e:	6038      	str	r0, [r7, #0]
    spi_write(0x80,0xd0,device); // three wire
 8008560:	2001      	movs	r0, #1
 8008562:	f7fa f935 	bl	80027d0 <spi_write.constprop.11>
    spi_read(0x0,device);
 8008566:	2001      	movs	r0, #1
 8008568:	f7f9 ff3a 	bl	80023e0 <spi_read.constprop.10>
    result = (hsb << 8) + lsb;
 800856c:	7862      	ldrb	r2, [r4, #1]
 800856e:	78a3      	ldrb	r3, [r4, #2]
 8008570:	eb03 2002 	add.w	r0, r3, r2, lsl #8
    result = (result*430.0) / 32768.0;	  
 8008574:	ee07 0a90 	vmov	s15, r0
 8008578:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800857c:	ee17 0a90 	vmov	r0, s15
 8008580:	f7f8 f824 	bl	80005cc <__aeabi_f2d>
 8008584:	a39e      	add	r3, pc, #632	; (adr r3, 8008800 <main+0x19f0>)
 8008586:	e9d3 2300 	ldrd	r2, r3, [r3]
 800858a:	f7f8 f877 	bl	800067c <__aeabi_dmul>
 800858e:	2200      	movs	r2, #0
 8008590:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 8008594:	f7f8 f872 	bl	800067c <__aeabi_dmul>
 8008598:	f7f8 fb48 	bl	8000c2c <__aeabi_d2f>
    pt100temp = (sqrt(pt100temp) + z1) / z4;
 800859c:	ee07 0a10 	vmov	s14, r0
 80085a0:	eef0 7a48 	vmov.f32	s15, s16
 80085a4:	eee7 7a28 	vfma.f32	s15, s14, s17
 80085a8:	ee17 0a90 	vmov	r0, s15
 80085ac:	f7f8 f80e 	bl	80005cc <__aeabi_f2d>
 80085b0:	ec41 0b10 	vmov	d0, r0, r1
 80085b4:	f001 fd2e 	bl	800a014 <sqrt>
 80085b8:	a393      	add	r3, pc, #588	; (adr r3, 8008808 <main+0x19f8>)
 80085ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80085be:	ec51 0b10 	vmov	r0, r1, d0
 80085c2:	f7f7 fea3 	bl	800030c <__aeabi_dsub>
 80085c6:	a392      	add	r3, pc, #584	; (adr r3, 8008810 <main+0x1a00>)
 80085c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80085cc:	f7f8 f980 	bl	80008d0 <__aeabi_ddiv>
 80085d0:	f7f8 fb2c 	bl	8000c2c <__aeabi_d2f>
 80085d4:	4b98      	ldr	r3, [pc, #608]	; (8008838 <main+0x1a28>)
 80085d6:	6018      	str	r0, [r3, #0]
    spi_write(0x80,0xd0,device); // three wire
 80085d8:	2002      	movs	r0, #2
 80085da:	f7fa f8f9 	bl	80027d0 <spi_write.constprop.11>
    spi_read(0x0,device);
 80085de:	2002      	movs	r0, #2
 80085e0:	f7f9 fefe 	bl	80023e0 <spi_read.constprop.10>
    result = (hsb << 8) + lsb;
 80085e4:	7862      	ldrb	r2, [r4, #1]
 80085e6:	78a3      	ldrb	r3, [r4, #2]
 80085e8:	eb03 2002 	add.w	r0, r3, r2, lsl #8
    result = (result*430.0) / 32768.0;	  
 80085ec:	ee07 0a90 	vmov	s15, r0
 80085f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80085f4:	ee17 0a90 	vmov	r0, s15
 80085f8:	f7f7 ffe8 	bl	80005cc <__aeabi_f2d>
 80085fc:	a380      	add	r3, pc, #512	; (adr r3, 8008800 <main+0x19f0>)
 80085fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008602:	f7f8 f83b 	bl	800067c <__aeabi_dmul>
 8008606:	2200      	movs	r2, #0
 8008608:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 800860c:	f7f8 f836 	bl	800067c <__aeabi_dmul>
 8008610:	f7f8 fb0c 	bl	8000c2c <__aeabi_d2f>
    pt100temp = (sqrt(pt100temp) + z1) / z4;
 8008614:	ee07 0a10 	vmov	s14, r0
 8008618:	eef0 7a48 	vmov.f32	s15, s16
 800861c:	eee7 7a28 	vfma.f32	s15, s14, s17
 8008620:	ee17 0a90 	vmov	r0, s15
 8008624:	f7f7 ffd2 	bl	80005cc <__aeabi_f2d>
 8008628:	ec41 0b10 	vmov	d0, r0, r1
 800862c:	f001 fcf2 	bl	800a014 <sqrt>
 8008630:	a375      	add	r3, pc, #468	; (adr r3, 8008808 <main+0x19f8>)
 8008632:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008636:	ec51 0b10 	vmov	r0, r1, d0
 800863a:	f7f7 fe67 	bl	800030c <__aeabi_dsub>
 800863e:	a374      	add	r3, pc, #464	; (adr r3, 8008810 <main+0x1a00>)
 8008640:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008644:	f7f8 f944 	bl	80008d0 <__aeabi_ddiv>
 8008648:	f7f8 faf0 	bl	8000c2c <__aeabi_d2f>
 800864c:	4b7b      	ldr	r3, [pc, #492]	; (800883c <main+0x1a2c>)
 800864e:	6018      	str	r0, [r3, #0]
    spi_write(0x80,0xd0,device); // three wire
 8008650:	2003      	movs	r0, #3
 8008652:	f7fa f8bd 	bl	80027d0 <spi_write.constprop.11>
    spi_read(0x0,device);
 8008656:	2003      	movs	r0, #3
 8008658:	f7f9 fec2 	bl	80023e0 <spi_read.constprop.10>
    result = (hsb << 8) + lsb;
 800865c:	7862      	ldrb	r2, [r4, #1]
 800865e:	78a3      	ldrb	r3, [r4, #2]
 8008660:	eb03 2002 	add.w	r0, r3, r2, lsl #8
    result = (result*430.0) / 32768.0;	  
 8008664:	ee07 0a90 	vmov	s15, r0
 8008668:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800866c:	ee17 0a90 	vmov	r0, s15
 8008670:	f7f7 ffac 	bl	80005cc <__aeabi_f2d>
 8008674:	a362      	add	r3, pc, #392	; (adr r3, 8008800 <main+0x19f0>)
 8008676:	e9d3 2300 	ldrd	r2, r3, [r3]
 800867a:	f7f7 ffff 	bl	800067c <__aeabi_dmul>
 800867e:	2200      	movs	r2, #0
 8008680:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 8008684:	f7f7 fffa 	bl	800067c <__aeabi_dmul>
 8008688:	f7f8 fad0 	bl	8000c2c <__aeabi_d2f>
    pt100temp = (sqrt(pt100temp) + z1) / z4;
 800868c:	ee07 0a10 	vmov	s14, r0
 8008690:	eef0 7a48 	vmov.f32	s15, s16
 8008694:	eee7 7a28 	vfma.f32	s15, s14, s17
 8008698:	ee17 0a90 	vmov	r0, s15
 800869c:	f7f7 ff96 	bl	80005cc <__aeabi_f2d>
 80086a0:	ec41 0b10 	vmov	d0, r0, r1
 80086a4:	f001 fcb6 	bl	800a014 <sqrt>
 80086a8:	a357      	add	r3, pc, #348	; (adr r3, 8008808 <main+0x19f8>)
 80086aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086ae:	ec51 0b10 	vmov	r0, r1, d0
 80086b2:	f7f7 fe2b 	bl	800030c <__aeabi_dsub>
 80086b6:	a356      	add	r3, pc, #344	; (adr r3, 8008810 <main+0x1a00>)
 80086b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086bc:	f7f8 f908 	bl	80008d0 <__aeabi_ddiv>
 80086c0:	f7f8 fab4 	bl	8000c2c <__aeabi_d2f>
 80086c4:	4b5e      	ldr	r3, [pc, #376]	; (8008840 <main+0x1a30>)
 80086c6:	6018      	str	r0, [r3, #0]
    spi_write(0x80,0xd0,device); // three wire
 80086c8:	2004      	movs	r0, #4
 80086ca:	f7fa f881 	bl	80027d0 <spi_write.constprop.11>
    spi_read(0x0,device);
 80086ce:	2004      	movs	r0, #4
 80086d0:	f7f9 fe86 	bl	80023e0 <spi_read.constprop.10>
    result = (hsb << 8) + lsb;
 80086d4:	7862      	ldrb	r2, [r4, #1]
 80086d6:	78a3      	ldrb	r3, [r4, #2]
 80086d8:	eb03 2002 	add.w	r0, r3, r2, lsl #8
    result = (result*430.0) / 32768.0;	  
 80086dc:	ee07 0a90 	vmov	s15, r0
 80086e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80086e4:	ee17 0a90 	vmov	r0, s15
 80086e8:	f7f7 ff70 	bl	80005cc <__aeabi_f2d>
 80086ec:	a344      	add	r3, pc, #272	; (adr r3, 8008800 <main+0x19f0>)
 80086ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086f2:	f7f7 ffc3 	bl	800067c <__aeabi_dmul>
 80086f6:	2200      	movs	r2, #0
 80086f8:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 80086fc:	f7f7 ffbe 	bl	800067c <__aeabi_dmul>
 8008700:	f7f8 fa94 	bl	8000c2c <__aeabi_d2f>
    pt100temp = (sqrt(pt100temp) + z1) / z4;
 8008704:	ee07 0a90 	vmov	s15, r0
 8008708:	eea7 8aa8 	vfma.f32	s16, s15, s17
 800870c:	ee18 0a10 	vmov	r0, s16
 8008710:	f7f7 ff5c 	bl	80005cc <__aeabi_f2d>
 8008714:	ec41 0b10 	vmov	d0, r0, r1
 8008718:	f001 fc7c 	bl	800a014 <sqrt>
 800871c:	a33a      	add	r3, pc, #232	; (adr r3, 8008808 <main+0x19f8>)
 800871e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008722:	ec51 0b10 	vmov	r0, r1, d0
 8008726:	f7f7 fdf1 	bl	800030c <__aeabi_dsub>
 800872a:	a339      	add	r3, pc, #228	; (adr r3, 8008810 <main+0x1a00>)
 800872c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008730:	f7f8 f8ce 	bl	80008d0 <__aeabi_ddiv>
 8008734:	f7f8 fa7a 	bl	8000c2c <__aeabi_d2f>
 8008738:	4b42      	ldr	r3, [pc, #264]	; (8008844 <main+0x1a34>)
 800873a:	6018      	str	r0, [r3, #0]
	  sprintf(metrics[0],"Irr: %5.0f",irradiance3);
 800873c:	4b42      	ldr	r3, [pc, #264]	; (8008848 <main+0x1a38>)
 800873e:	6818      	ldr	r0, [r3, #0]
 8008740:	f7f7 ff44 	bl	80005cc <__aeabi_f2d>
 8008744:	4602      	mov	r2, r0
 8008746:	460b      	mov	r3, r1
 8008748:	4628      	mov	r0, r5
 800874a:	4940      	ldr	r1, [pc, #256]	; (800884c <main+0x1a3c>)
 800874c:	f001 fdda 	bl	800a304 <sprintf>
	  if (amps < 0.003)
 8008750:	f8d9 0000 	ldr.w	r0, [r9]
 8008754:	f7f7 ff3a 	bl	80005cc <__aeabi_f2d>
 8008758:	a32f      	add	r3, pc, #188	; (adr r3, 8008818 <main+0x1a08>)
 800875a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800875e:	f7f8 f9ff 	bl	8000b60 <__aeabi_dcmplt>
 8008762:	2800      	cmp	r0, #0
 8008764:	f000 81d4 	beq.w	8008b10 <main+0x1d00>
	      sprintf(metrics[1],"Wind:  N/C");
 8008768:	4b39      	ldr	r3, [pc, #228]	; (8008850 <main+0x1a40>)
 800876a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800876e:	f105 030c 	add.w	r3, r5, #12
 8008772:	c303      	stmia	r3!, {r0, r1}
 8008774:	f823 2b02 	strh.w	r2, [r3], #2
 8008778:	0c12      	lsrs	r2, r2, #16
 800877a:	701a      	strb	r2, [r3, #0]
	  else
	      sprintf(metrics[1],"Wind: %4.0f",windspeed);
	  fillTemp(metrics[2],pt100temp1,1);
 800877c:	edd7 7a00 	vldr	s15, [r7]
    if (abs(temp) >100)
 8008780:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8008784:	ee17 3a10 	vmov	r3, s14
 8008788:	2b00      	cmp	r3, #0
 800878a:	bfb8      	it	lt
 800878c:	425b      	neglt	r3, r3
 800878e:	2b64      	cmp	r3, #100	; 0x64
 8008790:	f300 81b8 	bgt.w	8008b04 <main+0x1cf4>
	sprintf(metric,"Temp%d:%3.0fc",temp_num,temp);	    
 8008794:	ee17 0a90 	vmov	r0, s15
 8008798:	f7f7 ff18 	bl	80005cc <__aeabi_f2d>
 800879c:	2201      	movs	r2, #1
 800879e:	e9cd 0100 	strd	r0, r1, [sp]
 80087a2:	492c      	ldr	r1, [pc, #176]	; (8008854 <main+0x1a44>)
 80087a4:	482c      	ldr	r0, [pc, #176]	; (8008858 <main+0x1a48>)
 80087a6:	f001 fdad 	bl	800a304 <sprintf>
	  fillTemp(metrics[3],pt100temp2,2);
 80087aa:	4b23      	ldr	r3, [pc, #140]	; (8008838 <main+0x1a28>)
 80087ac:	edd3 7a00 	vldr	s15, [r3]
    if (abs(temp) >100)
 80087b0:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80087b4:	ee17 3a10 	vmov	r3, s14
 80087b8:	2b00      	cmp	r3, #0
 80087ba:	bfb8      	it	lt
 80087bc:	425b      	neglt	r3, r3
 80087be:	2b64      	cmp	r3, #100	; 0x64
 80087c0:	f300 819a 	bgt.w	8008af8 <main+0x1ce8>
	sprintf(metric,"Temp%d:%3.0fc",temp_num,temp);	    
 80087c4:	ee17 0a90 	vmov	r0, s15
 80087c8:	f7f7 ff00 	bl	80005cc <__aeabi_f2d>
 80087cc:	2202      	movs	r2, #2
 80087ce:	e9cd 0100 	strd	r0, r1, [sp]
 80087d2:	4920      	ldr	r1, [pc, #128]	; (8008854 <main+0x1a44>)
 80087d4:	4821      	ldr	r0, [pc, #132]	; (800885c <main+0x1a4c>)
 80087d6:	f001 fd95 	bl	800a304 <sprintf>
	  fillTemp(metrics[4],pt100temp3,3);
 80087da:	4b18      	ldr	r3, [pc, #96]	; (800883c <main+0x1a2c>)
 80087dc:	edd3 7a00 	vldr	s15, [r3]
    if (abs(temp) >100)
 80087e0:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80087e4:	ee17 3a10 	vmov	r3, s14
 80087e8:	2b00      	cmp	r3, #0
 80087ea:	bfb8      	it	lt
 80087ec:	425b      	neglt	r3, r3
 80087ee:	2b64      	cmp	r3, #100	; 0x64
 80087f0:	f300 817c 	bgt.w	8008aec <main+0x1cdc>
 80087f4:	e03e      	b.n	8008874 <main+0x1a64>
 80087f6:	bf00      	nop
 80087f8:	4189374c 	.word	0x4189374c
 80087fc:	4001e560 	.word	0x4001e560
 8008800:	00000000 	.word	0x00000000
 8008804:	407ae000 	.word	0x407ae000
 8008808:	40000000 	.word	0x40000000
 800880c:	3f700226 	.word	0x3f700226
 8008810:	e0000000 	.word	0xe0000000
 8008814:	beb360af 	.word	0xbeb360af
 8008818:	bc6a7efa 	.word	0xbc6a7efa
 800881c:	3f689374 	.word	0x3f689374
 8008820:	20002504 	.word	0x20002504
 8008824:	200024b0 	.word	0x200024b0
 8008828:	37938317 	.word	0x37938317
 800882c:	b2c66d70 	.word	0xb2c66d70
 8008830:	20002080 	.word	0x20002080
 8008834:	20002010 	.word	0x20002010
 8008838:	20002084 	.word	0x20002084
 800883c:	20002088 	.word	0x20002088
 8008840:	2000208c 	.word	0x2000208c
 8008844:	20002090 	.word	0x20002090
 8008848:	20002008 	.word	0x20002008
 800884c:	0801d880 	.word	0x0801d880
 8008850:	0801d88c 	.word	0x0801d88c
 8008854:	0801d8b0 	.word	0x0801d8b0
 8008858:	20002028 	.word	0x20002028
 800885c:	20002034 	.word	0x20002034
 8008860:	00000000 	.word	0x00000000
 8008864:	40a86a00 	.word	0x40a86a00
 8008868:	00000000 	.word	0x00000000
 800886c:	40affe00 	.word	0x40affe00
 8008870:	20005d48 	.word	0x20005d48
	sprintf(metric,"Temp%d:%3.0fc",temp_num,temp);	    
 8008874:	ee17 0a90 	vmov	r0, s15
 8008878:	f7f7 fea8 	bl	80005cc <__aeabi_f2d>
 800887c:	2203      	movs	r2, #3
 800887e:	e9cd 0100 	strd	r0, r1, [sp]
 8008882:	49af      	ldr	r1, [pc, #700]	; (8008b40 <main+0x1d30>)
 8008884:	48af      	ldr	r0, [pc, #700]	; (8008b44 <main+0x1d34>)
 8008886:	f001 fd3d 	bl	800a304 <sprintf>
	  fillTemp(metrics[5],pt100temp4,4);
 800888a:	4baf      	ldr	r3, [pc, #700]	; (8008b48 <main+0x1d38>)
 800888c:	edd3 7a00 	vldr	s15, [r3]
    if (abs(temp) >100)
 8008890:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8008894:	ee17 3a10 	vmov	r3, s14
 8008898:	2b00      	cmp	r3, #0
 800889a:	bfb8      	it	lt
 800889c:	425b      	neglt	r3, r3
 800889e:	2b64      	cmp	r3, #100	; 0x64
 80088a0:	f300 811e 	bgt.w	8008ae0 <main+0x1cd0>
	sprintf(metric,"Temp%d:%3.0fc",temp_num,temp);	    
 80088a4:	ee17 0a90 	vmov	r0, s15
 80088a8:	f7f7 fe90 	bl	80005cc <__aeabi_f2d>
 80088ac:	2204      	movs	r2, #4
 80088ae:	e9cd 0100 	strd	r0, r1, [sp]
 80088b2:	49a3      	ldr	r1, [pc, #652]	; (8008b40 <main+0x1d30>)
 80088b4:	48a5      	ldr	r0, [pc, #660]	; (8008b4c <main+0x1d3c>)
 80088b6:	f001 fd25 	bl	800a304 <sprintf>
	  if (palReadPad(GPIOC,7) == 0)
 80088ba:	4ba5      	ldr	r3, [pc, #660]	; (8008b50 <main+0x1d40>)
 80088bc:	691b      	ldr	r3, [r3, #16]
 80088be:	061b      	lsls	r3, r3, #24
 80088c0:	f100 80e4 	bmi.w	8008a8c <main+0x1c7c>
	      sprintf(metrics[6],"Rain: %4.2f",rainRate);
 80088c4:	4ba3      	ldr	r3, [pc, #652]	; (8008b54 <main+0x1d44>)
 80088c6:	6818      	ldr	r0, [r3, #0]
 80088c8:	f7f7 fe80 	bl	80005cc <__aeabi_f2d>
 80088cc:	4602      	mov	r2, r0
 80088ce:	460b      	mov	r3, r1
 80088d0:	48a1      	ldr	r0, [pc, #644]	; (8008b58 <main+0x1d48>)
 80088d2:	49a2      	ldr	r1, [pc, #648]	; (8008b5c <main+0x1d4c>)
 80088d4:	f001 fd16 	bl	800a304 <sprintf>
	  else
	      fillTemp(metrics[6],pt100temp5,5);
	  if (snow < .025){
 80088d8:	4ba1      	ldr	r3, [pc, #644]	; (8008b60 <main+0x1d50>)
 80088da:	6818      	ldr	r0, [r3, #0]
 80088dc:	f7f7 fe76 	bl	80005cc <__aeabi_f2d>
 80088e0:	a395      	add	r3, pc, #596	; (adr r3, 8008b38 <main+0x1d28>)
 80088e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80088e6:	4680      	mov	r8, r0
 80088e8:	4689      	mov	r9, r1
 80088ea:	f7f8 f939 	bl	8000b60 <__aeabi_dcmplt>
 80088ee:	2800      	cmp	r0, #0
 80088f0:	f040 80bf 	bne.w	8008a72 <main+0x1c62>
	      snowoutput = 2;
	      sprintf(metrics[7], "Snow:  N/C");
	  }
	  else if (snow < 1.2){
 80088f4:	4640      	mov	r0, r8
 80088f6:	4649      	mov	r1, r9
 80088f8:	f04f 3233 	mov.w	r2, #858993459	; 0x33333333
 80088fc:	4b99      	ldr	r3, [pc, #612]	; (8008b64 <main+0x1d54>)
 80088fe:	f7f8 f92f 	bl	8000b60 <__aeabi_dcmplt>
 8008902:	2800      	cmp	r0, #0
 8008904:	f000 80da 	beq.w	8008abc <main+0x1cac>
	      snowoutput = 1;	     
	      sprintf(metrics[7], "Snow: True");
 8008908:	4a97      	ldr	r2, [pc, #604]	; (8008b68 <main+0x1d58>)
 800890a:	4b98      	ldr	r3, [pc, #608]	; (8008b6c <main+0x1d5c>)
	      snowoutput = 1;	     
 800890c:	4c98      	ldr	r4, [pc, #608]	; (8008b70 <main+0x1d60>)
	      sprintf(metrics[7], "Snow: True");
 800890e:	ca07      	ldmia	r2, {r0, r1, r2}
 8008910:	c303      	stmia	r3!, {r0, r1}
 8008912:	f823 2b02 	strh.w	r2, [r3], #2
	      snowoutput = 1;	     
 8008916:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
	      sprintf(metrics[7], "Snow: True");
 800891a:	0c12      	lsrs	r2, r2, #16
 800891c:	701a      	strb	r2, [r3, #0]
	      snowoutput = 1;	     
 800891e:	6021      	str	r1, [r4, #0]
	  else{
	      snowoutput = 0;
	      sprintf(metrics[7], "Snow:False");
	  }

	  displaymetric = step/32;
 8008920:	4b94      	ldr	r3, [pc, #592]	; (8008b74 <main+0x1d64>)
 8008922:	f8df 9290 	ldr.w	r9, [pc, #656]	; 8008bb4 <main+0x1da4>
 8008926:	881c      	ldrh	r4, [r3, #0]
    memset(&vbuf,0x00,128*32); // I set the clear to be 0x11 instead of 0x00
 8008928:	4893      	ldr	r0, [pc, #588]	; (8008b78 <main+0x1d68>)
 800892a:	4f94      	ldr	r7, [pc, #592]	; (8008b7c <main+0x1d6c>)
	  displaymetric = step/32;
 800892c:	0964      	lsrs	r4, r4, #5
    memset(&vbuf,0x00,128*32); // I set the clear to be 0x11 instead of 0x00
 800892e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8008932:	2100      	movs	r1, #0
	  clear_oled();
	  
	  chprintf((BaseSequentialStream*)&SD1,"%s\r\n",metrics[displaymetric]);
 8008934:	f04f 080c 	mov.w	r8, #12
	  displaymetric = step/32;
 8008938:	f8c9 4000 	str.w	r4, [r9]
 800893c:	4606      	mov	r6, r0
    memset(&vbuf,0x00,128*32); // I set the clear to be 0x11 instead of 0x00
 800893e:	f001 fc97 	bl	800a270 <memset>
	  chprintf((BaseSequentialStream*)&SD1,"%s\r\n",metrics[displaymetric]);
 8008942:	fb08 5204 	mla	r2, r8, r4, r5
 8008946:	498e      	ldr	r1, [pc, #568]	; (8008b80 <main+0x1d70>)
 8008948:	488e      	ldr	r0, [pc, #568]	; (8008b84 <main+0x1d74>)
 800894a:	f7fb f8a1 	bl	8003a90 <chprintf.constprop.14>
	  oled_draw_big_string(0,0,metrics[displaymetric]);
 800894e:	f8d9 3000 	ldr.w	r3, [r9]
  for (j=0;j<(strlen(text));j++)
 8008952:	2400      	movs	r4, #0
	  oled_draw_big_string(0,0,metrics[displaymetric]);
 8008954:	fb08 5803 	mla	r8, r8, r3, r5
 8008958:	2502      	movs	r5, #2
  for (j=0;j<(strlen(text));j++)
 800895a:	4640      	mov	r0, r8
 800895c:	f7f8 fa50 	bl	8000e00 <strlen>
 8008960:	4284      	cmp	r4, r0
 8008962:	f4bf a9d8 	bcs.w	8007d16 <main+0xf06>
 8008966:	f818 1004 	ldrb.w	r1, [r8, r4]
 800896a:	f44f 72c0 	mov.w	r2, #384	; 0x180
      write_big_oled_char(text[j]);
 800896e:	2300      	movs	r3, #0
 8008970:	fb02 7101 	mla	r1, r2, r1, r7
 8008974:	1970      	adds	r0, r6, r5
 8008976:	220c      	movs	r2, #12
 8008978:	fb02 1e03 	mla	lr, r2, r3, r1
 800897c:	eb00 1cc3 	add.w	ip, r0, r3, lsl #7
	      windspeed = 0;
 8008980:	2200      	movs	r2, #0
	vbuf[(oled_current_row+j)][(oled_current_column+i)] = fontbig[a][j][i];
 8008982:	f81e 9002 	ldrb.w	r9, [lr, r2]
 8008986:	f80c 9002 	strb.w	r9, [ip, r2]
 800898a:	3201      	adds	r2, #1
    for (i=0; i<12; i++)
 800898c:	2a0c      	cmp	r2, #12
 800898e:	d1f8      	bne.n	8008982 <main+0x1b72>
 8008990:	3301      	adds	r3, #1
   for (j=0; j<32; j++)
 8008992:	2b20      	cmp	r3, #32
 8008994:	d1ef      	bne.n	8008976 <main+0x1b66>
  for (j=0;j<(strlen(text));j++)
 8008996:	3401      	adds	r4, #1
 8008998:	350c      	adds	r5, #12
 800899a:	b2e4      	uxtb	r4, r4
 800899c:	b2ed      	uxtb	r5, r5
 800899e:	e7dc      	b.n	800895a <main+0x1b4a>
 80089a0:	2320      	movs	r3, #32
 80089a2:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80089a6:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 80089aa:	2b00      	cmp	r3, #0
 80089ac:	f47f a9c5 	bne.w	8007d3a <main+0xf2a>
 80089b0:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 80089b4:	2a00      	cmp	r2, #0
 80089b6:	f47f a9c0 	bne.w	8007d3a <main+0xf2a>
 80089ba:	f89a 3000 	ldrb.w	r3, [sl]
  _dbg_enter_lock();
 80089be:	2101      	movs	r1, #1
 80089c0:	2b02      	cmp	r3, #2
 80089c2:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
 80089c6:	f47f a9ce 	bne.w	8007d66 <main+0xf56>
 80089ca:	f8db 3000 	ldr.w	r3, [fp]
 80089ce:	f8da 1008 	ldr.w	r1, [sl, #8]
 80089d2:	f64a 20aa 	movw	r0, #43690	; 0xaaaa
 80089d6:	455b      	cmp	r3, fp
 80089d8:	6008      	str	r0, [r1, #0]
  _dbg_leave_lock();
 80089da:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 80089de:	d006      	beq.n	80089ee <main+0x1bde>
 80089e0:	f8db 2018 	ldr.w	r2, [fp, #24]
 80089e4:	689b      	ldr	r3, [r3, #8]
 80089e6:	6892      	ldr	r2, [r2, #8]
 80089e8:	429a      	cmp	r2, r3
 80089ea:	f4fe ae48 	bcc.w	800767e <main+0x86e>
 80089ee:	2300      	movs	r3, #0
 80089f0:	f383 8811 	msr	BASEPRI, r3
 80089f4:	f7ff bba3 	b.w	800813e <main+0x132e>
    dmaStreamRelease(adcp->dmastp);
 80089f8:	4b63      	ldr	r3, [pc, #396]	; (8008b88 <main+0x1d78>)
 80089fa:	461c      	mov	r4, r3
 80089fc:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80089fe:	f7f9 f8ff 	bl	8001c00 <dmaStreamRelease>
    adc_lld_stop_adc(adcp);
 8008a02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8008a04:	689a      	ldr	r2, [r3, #8]
 8008a06:	0756      	lsls	r6, r2, #29
 8008a08:	d506      	bpl.n	8008a18 <main+0x1c08>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8008a0a:	689a      	ldr	r2, [r3, #8]
 8008a0c:	f042 0210 	orr.w	r2, r2, #16
 8008a10:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8008a12:	689a      	ldr	r2, [r3, #8]
 8008a14:	06d5      	lsls	r5, r2, #27
 8008a16:	d4fc      	bmi.n	8008a12 <main+0x1c02>
  adcp->adcm->CR |= ADC_CR_ADDIS;
 8008a18:	689a      	ldr	r2, [r3, #8]
 8008a1a:	f042 0202 	orr.w	r2, r2, #2
 8008a1e:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADDIS) != 0)
 8008a20:	689a      	ldr	r2, [r3, #8]
 8008a22:	f012 0202 	ands.w	r2, r2, #2
 8008a26:	d1fb      	bne.n	8008a20 <main+0x1c10>
      clkmask &= ~(1 << 3);
 8008a28:	4c58      	ldr	r4, [pc, #352]	; (8008b8c <main+0x1d7c>)
      adcp->adcc->CCR = STM32_ADC_ADC34_CLOCK_MODE | ADC_DMA_MDMA;
 8008a2a:	4857      	ldr	r0, [pc, #348]	; (8008b88 <main+0x1d78>)
      clkmask &= ~(1 << 3);
 8008a2c:	6821      	ldr	r1, [r4, #0]
      adcp->adcc->CCR = STM32_ADC_ADC34_CLOCK_MODE | ADC_DMA_MDMA;
 8008a2e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 8008a30:	609a      	str	r2, [r3, #8]
      clkmask &= ~(1 << 3);
 8008a32:	f021 0208 	bic.w	r2, r1, #8
 8008a36:	6022      	str	r2, [r4, #0]
  adcp->adcm->CR = ADC_CR_ADVREGEN_1;
 8008a38:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8008a3c:	609a      	str	r2, [r3, #8]
    if ((clkmask & 0x3) == 0) {
 8008a3e:	078c      	lsls	r4, r1, #30
      adcp->adcc->CCR = STM32_ADC_ADC34_CLOCK_MODE | ADC_DMA_MDMA;
 8008a40:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8008a44:	6083      	str	r3, [r0, #8]
    if ((clkmask & 0x3) == 0) {
 8008a46:	d107      	bne.n	8008a58 <main+0x1c48>
      rccDisableADC12();
 8008a48:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
 8008a4c:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
 8008a50:	6953      	ldr	r3, [r2, #20]
 8008a52:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008a56:	6153      	str	r3, [r2, #20]
    if ((clkmask & 0xC) == 0) {
 8008a58:	0748      	lsls	r0, r1, #29
 8008a5a:	f53f ab4c 	bmi.w	80080f6 <main+0x12e6>
      rccDisableADC34();
 8008a5e:	4a4c      	ldr	r2, [pc, #304]	; (8008b90 <main+0x1d80>)
 8008a60:	6953      	ldr	r3, [r2, #20]
 8008a62:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8008a66:	6153      	str	r3, [r2, #20]
 8008a68:	f7ff bb45 	b.w	80080f6 <main+0x12e6>
  chSysSwitch(currp, otp);
 8008a6c:	4849      	ldr	r0, [pc, #292]	; (8008b94 <main+0x1d84>)
 8008a6e:	f7f8 fc9f 	bl	80013b0 <chSysHalt>
	      sprintf(metrics[7], "Snow:  N/C");
 8008a72:	4a49      	ldr	r2, [pc, #292]	; (8008b98 <main+0x1d88>)
 8008a74:	4b3d      	ldr	r3, [pc, #244]	; (8008b6c <main+0x1d5c>)
	      snowoutput = 2;
 8008a76:	4c3e      	ldr	r4, [pc, #248]	; (8008b70 <main+0x1d60>)
	      sprintf(metrics[7], "Snow:  N/C");
 8008a78:	ca07      	ldmia	r2, {r0, r1, r2}
 8008a7a:	c303      	stmia	r3!, {r0, r1}
 8008a7c:	f823 2b02 	strh.w	r2, [r3], #2
	      snowoutput = 2;
 8008a80:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	      sprintf(metrics[7], "Snow:  N/C");
 8008a84:	0c12      	lsrs	r2, r2, #16
 8008a86:	701a      	strb	r2, [r3, #0]
	      snowoutput = 2;
 8008a88:	6021      	str	r1, [r4, #0]
 8008a8a:	e749      	b.n	8008920 <main+0x1b10>
	      fillTemp(metrics[6],pt100temp5,5);
 8008a8c:	4b43      	ldr	r3, [pc, #268]	; (8008b9c <main+0x1d8c>)
 8008a8e:	edd3 7a00 	vldr	s15, [r3]
    if (abs(temp) >100)
 8008a92:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8008a96:	ee17 3a10 	vmov	r3, s14
 8008a9a:	2b00      	cmp	r3, #0
 8008a9c:	bfb8      	it	lt
 8008a9e:	425b      	neglt	r3, r3
 8008aa0:	2b64      	cmp	r3, #100	; 0x64
 8008aa2:	dc17      	bgt.n	8008ad4 <main+0x1cc4>
	sprintf(metric,"Temp%d:%3.0fc",temp_num,temp);	    
 8008aa4:	ee17 0a90 	vmov	r0, s15
 8008aa8:	f7f7 fd90 	bl	80005cc <__aeabi_f2d>
 8008aac:	2205      	movs	r2, #5
 8008aae:	e9cd 0100 	strd	r0, r1, [sp]
 8008ab2:	4923      	ldr	r1, [pc, #140]	; (8008b40 <main+0x1d30>)
 8008ab4:	4828      	ldr	r0, [pc, #160]	; (8008b58 <main+0x1d48>)
 8008ab6:	f001 fc25 	bl	800a304 <sprintf>
 8008aba:	e70d      	b.n	80088d8 <main+0x1ac8>
	      sprintf(metrics[7], "Snow:False");
 8008abc:	4a38      	ldr	r2, [pc, #224]	; (8008ba0 <main+0x1d90>)
 8008abe:	4b2b      	ldr	r3, [pc, #172]	; (8008b6c <main+0x1d5c>)
	      snowoutput = 0;
 8008ac0:	4c2b      	ldr	r4, [pc, #172]	; (8008b70 <main+0x1d60>)
	      sprintf(metrics[7], "Snow:False");
 8008ac2:	ca07      	ldmia	r2, {r0, r1, r2}
 8008ac4:	c303      	stmia	r3!, {r0, r1}
 8008ac6:	f823 2b02 	strh.w	r2, [r3], #2
	      snowoutput = 0;
 8008aca:	2100      	movs	r1, #0
	      sprintf(metrics[7], "Snow:False");
 8008acc:	0c12      	lsrs	r2, r2, #16
 8008ace:	701a      	strb	r2, [r3, #0]
	      snowoutput = 0;
 8008ad0:	6021      	str	r1, [r4, #0]
 8008ad2:	e725      	b.n	8008920 <main+0x1b10>
	sprintf(metric,"Temp%d: N/C",temp_num);
 8008ad4:	2205      	movs	r2, #5
 8008ad6:	4933      	ldr	r1, [pc, #204]	; (8008ba4 <main+0x1d94>)
 8008ad8:	481f      	ldr	r0, [pc, #124]	; (8008b58 <main+0x1d48>)
 8008ada:	f001 fc13 	bl	800a304 <sprintf>
 8008ade:	e6fb      	b.n	80088d8 <main+0x1ac8>
 8008ae0:	2204      	movs	r2, #4
 8008ae2:	4930      	ldr	r1, [pc, #192]	; (8008ba4 <main+0x1d94>)
 8008ae4:	4819      	ldr	r0, [pc, #100]	; (8008b4c <main+0x1d3c>)
 8008ae6:	f001 fc0d 	bl	800a304 <sprintf>
 8008aea:	e6e6      	b.n	80088ba <main+0x1aaa>
 8008aec:	2203      	movs	r2, #3
 8008aee:	492d      	ldr	r1, [pc, #180]	; (8008ba4 <main+0x1d94>)
 8008af0:	4814      	ldr	r0, [pc, #80]	; (8008b44 <main+0x1d34>)
 8008af2:	f001 fc07 	bl	800a304 <sprintf>
 8008af6:	e6c8      	b.n	800888a <main+0x1a7a>
 8008af8:	2202      	movs	r2, #2
 8008afa:	492a      	ldr	r1, [pc, #168]	; (8008ba4 <main+0x1d94>)
 8008afc:	482a      	ldr	r0, [pc, #168]	; (8008ba8 <main+0x1d98>)
 8008afe:	f001 fc01 	bl	800a304 <sprintf>
 8008b02:	e66a      	b.n	80087da <main+0x19ca>
 8008b04:	2201      	movs	r2, #1
 8008b06:	4927      	ldr	r1, [pc, #156]	; (8008ba4 <main+0x1d94>)
 8008b08:	4828      	ldr	r0, [pc, #160]	; (8008bac <main+0x1d9c>)
 8008b0a:	f001 fbfb 	bl	800a304 <sprintf>
 8008b0e:	e64c      	b.n	80087aa <main+0x199a>
	      sprintf(metrics[1],"Wind: %4.0f",windspeed);
 8008b10:	f8d8 0000 	ldr.w	r0, [r8]
 8008b14:	f7f7 fd5a 	bl	80005cc <__aeabi_f2d>
 8008b18:	4602      	mov	r2, r0
 8008b1a:	460b      	mov	r3, r1
 8008b1c:	f105 000c 	add.w	r0, r5, #12
 8008b20:	4923      	ldr	r1, [pc, #140]	; (8008bb0 <main+0x1da0>)
 8008b22:	f001 fbef 	bl	800a304 <sprintf>
 8008b26:	e629      	b.n	800877c <main+0x196c>
	      windspeed = 0;
 8008b28:	2000      	movs	r0, #0
 8008b2a:	e4d3      	b.n	80084d4 <main+0x16c4>
	      irradiance = 0;
 8008b2c:	f04f 0800 	mov.w	r8, #0
 8008b30:	e427      	b.n	8008382 <main+0x1572>
 8008b32:	bf00      	nop
 8008b34:	f3af 8000 	nop.w
 8008b38:	9999999a 	.word	0x9999999a
 8008b3c:	3f999999 	.word	0x3f999999
 8008b40:	0801d8b0 	.word	0x0801d8b0
 8008b44:	20002040 	.word	0x20002040
 8008b48:	2000208c 	.word	0x2000208c
 8008b4c:	2000204c 	.word	0x2000204c
 8008b50:	48000800 	.word	0x48000800
 8008b54:	200020a0 	.word	0x200020a0
 8008b58:	20002058 	.word	0x20002058
 8008b5c:	0801d8c0 	.word	0x0801d8c0
 8008b60:	20002504 	.word	0x20002504
 8008b64:	3ff33333 	.word	0x3ff33333
 8008b68:	0801d8d8 	.word	0x0801d8d8
 8008b6c:	20002064 	.word	0x20002064
 8008b70:	20002508 	.word	0x20002508
 8008b74:	2000250c 	.word	0x2000250c
 8008b78:	20002614 	.word	0x20002614
 8008b7c:	08011764 	.word	0x08011764
 8008b80:	0801d8f0 	.word	0x0801d8f0
 8008b84:	200013d8 	.word	0x200013d8
 8008b88:	20001288 	.word	0x20001288
 8008b8c:	20001fd0 	.word	0x20001fd0
 8008b90:	40021000 	.word	0x40021000
 8008b94:	0800e71c 	.word	0x0800e71c
 8008b98:	0801d8cc 	.word	0x0801d8cc
 8008b9c:	20002090 	.word	0x20002090
 8008ba0:	0801d8e4 	.word	0x0801d8e4
 8008ba4:	0801d8a4 	.word	0x0801d8a4
 8008ba8:	20002034 	.word	0x20002034
 8008bac:	20002028 	.word	0x20002028
 8008bb0:	0801d898 	.word	0x0801d898
 8008bb4:	20001ff0 	.word	0x20001ff0
 8008bb8:	2320      	movs	r3, #32
 8008bba:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008bbe:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 8008bc2:	2b00      	cmp	r3, #0
 8008bc4:	f47f a8b9 	bne.w	8007d3a <main+0xf2a>
 8008bc8:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8008bcc:	2a00      	cmp	r2, #0
 8008bce:	f47f a8b4 	bne.w	8007d3a <main+0xf2a>
 8008bd2:	f89a 3000 	ldrb.w	r3, [sl]
  _dbg_enter_lock();
 8008bd6:	2101      	movs	r1, #1
 8008bd8:	2b02      	cmp	r3, #2
 8008bda:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
 8008bde:	f47f a8c2 	bne.w	8007d66 <main+0xf56>
 8008be2:	f8db 3000 	ldr.w	r3, [fp]
 8008be6:	f8da 1008 	ldr.w	r1, [sl, #8]
 8008bea:	f64a 20aa 	movw	r0, #43690	; 0xaaaa
 8008bee:	455b      	cmp	r3, fp
 8008bf0:	6008      	str	r0, [r1, #0]
  _dbg_leave_lock();
 8008bf2:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 8008bf6:	d006      	beq.n	8008c06 <main+0x1df6>
 8008bf8:	f8db 2018 	ldr.w	r2, [fp, #24]
 8008bfc:	689b      	ldr	r3, [r3, #8]
 8008bfe:	6892      	ldr	r2, [r2, #8]
 8008c00:	429a      	cmp	r2, r3
 8008c02:	f4fe ad3c 	bcc.w	800767e <main+0x86e>
 8008c06:	2300      	movs	r3, #0
 8008c08:	f383 8811 	msr	BASEPRI, r3
 8008c0c:	f7ff bb8b 	b.w	8008326 <main+0x1516>

08008c10 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8008c10:	4b52      	ldr	r3, [pc, #328]	; (8008d5c <__early_init+0x14c>)
  gpiop->OTYPER  = config->otyper;
 8008c12:	4853      	ldr	r0, [pc, #332]	; (8008d60 <__early_init+0x150>)
  rccResetAHB(STM32_GPIO_EN_MASK);
 8008c14:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8008c16:	2200      	movs	r2, #0
 8008c18:	f441 01fc 	orr.w	r1, r1, #8257536	; 0x7e0000
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8008c1c:	b470      	push	{r4, r5, r6}
  rccResetAHB(STM32_GPIO_EN_MASK);
 8008c1e:	6299      	str	r1, [r3, #40]	; 0x28
 8008c20:	629a      	str	r2, [r3, #40]	; 0x28
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8008c22:	695d      	ldr	r5, [r3, #20]
  gpiop->OSPEEDR = config->ospeedr;
 8008c24:	4e4f      	ldr	r6, [pc, #316]	; (8008d64 <__early_init+0x154>)
  gpiop->OTYPER  = config->otyper;
 8008c26:	4950      	ldr	r1, [pc, #320]	; (8008d68 <__early_init+0x158>)
 8008c28:	f04f 4490 	mov.w	r4, #1207959552	; 0x48000000
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8008c2c:	f445 05fc 	orr.w	r5, r5, #8257536	; 0x7e0000
 8008c30:	615d      	str	r5, [r3, #20]
  gpiop->OTYPER  = config->otyper;
 8008c32:	6062      	str	r2, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8008c34:	60a6      	str	r6, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8008c36:	4e4d      	ldr	r6, [pc, #308]	; (8008d6c <__early_init+0x15c>)
 8008c38:	60e6      	str	r6, [r4, #12]
  gpiop->ODR     = config->odr;
 8008c3a:	f64f 75ff 	movw	r5, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 8008c3e:	4e4c      	ldr	r6, [pc, #304]	; (8008d70 <__early_init+0x160>)
  gpiop->ODR     = config->odr;
 8008c40:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8008c42:	6226      	str	r6, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8008c44:	f44f 266e 	mov.w	r6, #974848	; 0xee000
 8008c48:	6266      	str	r6, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8008c4a:	4e4a      	ldr	r6, [pc, #296]	; (8008d74 <__early_init+0x164>)
 8008c4c:	6026      	str	r6, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8008c4e:	24c0      	movs	r4, #192	; 0xc0
 8008c50:	6044      	str	r4, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8008c52:	f24f 04c0 	movw	r4, #61632	; 0xf0c0
 8008c56:	6084      	str	r4, [r0, #8]
  gpiop->AFRL    = config->afrl;
 8008c58:	f04f 4688 	mov.w	r6, #1140850688	; 0x44000000
  gpiop->PUPDR   = config->pupdr;
 8008c5c:	4c46      	ldr	r4, [pc, #280]	; (8008d78 <__early_init+0x168>)
 8008c5e:	60c4      	str	r4, [r0, #12]
  gpiop->ODR     = config->odr;
 8008c60:	6145      	str	r5, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8008c62:	6206      	str	r6, [r0, #32]
  gpiop->MODER   = config->moder;
 8008c64:	f24a 0680 	movw	r6, #41088	; 0xa080
  gpiop->AFRH    = config->afrh;
 8008c68:	6242      	str	r2, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8008c6a:	6006      	str	r6, [r0, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8008c6c:	f04f 4670 	mov.w	r6, #4026531840	; 0xf0000000
  gpiop->OTYPER  = config->otyper;
 8008c70:	604a      	str	r2, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8008c72:	608e      	str	r6, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8008c74:	4e41      	ldr	r6, [pc, #260]	; (8008d7c <__early_init+0x16c>)
 8008c76:	60ce      	str	r6, [r1, #12]
  gpiop->AFRL    = config->afrl;
 8008c78:	f44f 06ee 	mov.w	r6, #7798784	; 0x770000
  gpiop->ODR     = config->odr;
 8008c7c:	614d      	str	r5, [r1, #20]
  gpiop->OTYPER  = config->otyper;
 8008c7e:	4c40      	ldr	r4, [pc, #256]	; (8008d80 <__early_init+0x170>)
  gpiop->AFRL    = config->afrl;
 8008c80:	620e      	str	r6, [r1, #32]
  gpiop->MODER   = config->moder;
 8008c82:	f44f 6620 	mov.w	r6, #2560	; 0xa00
  gpiop->AFRH    = config->afrh;
 8008c86:	624a      	str	r2, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8008c88:	600e      	str	r6, [r1, #0]
  gpiop->PUPDR   = config->pupdr;
 8008c8a:	f04f 3655 	mov.w	r6, #1431655765	; 0x55555555
  gpiop->OTYPER  = config->otyper;
 8008c8e:	6062      	str	r2, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8008c90:	60a2      	str	r2, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8008c92:	60e6      	str	r6, [r4, #12]
  gpiop->ODR     = config->odr;
 8008c94:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8008c96:	6222      	str	r2, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8008c98:	6262      	str	r2, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8008c9a:	6022      	str	r2, [r4, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8008c9c:	4c39      	ldr	r4, [pc, #228]	; (8008d84 <__early_init+0x174>)
  gpiop->OTYPER  = config->otyper;
 8008c9e:	f8c0 2c04 	str.w	r2, [r0, #3076]	; 0xc04
  gpiop->OSPEEDR = config->ospeedr;
 8008ca2:	f8c0 4c08 	str.w	r4, [r0, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 8008ca6:	4c38      	ldr	r4, [pc, #224]	; (8008d88 <__early_init+0x178>)
 8008ca8:	f8c0 4c0c 	str.w	r4, [r0, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 8008cac:	24ff      	movs	r4, #255	; 0xff
 8008cae:	f8c0 4c14 	str.w	r4, [r0, #3092]	; 0xc14
  gpiop->MODER   = config->moder;
 8008cb2:	4c36      	ldr	r4, [pc, #216]	; (8008d8c <__early_init+0x17c>)
  gpiop->AFRL    = config->afrl;
 8008cb4:	f8c0 2c20 	str.w	r2, [r0, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 8008cb8:	f8c0 2c24 	str.w	r2, [r0, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 8008cbc:	f8c0 4c00 	str.w	r4, [r0, #3072]	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
 8008cc0:	240f      	movs	r4, #15
  gpiop->PUPDR   = config->pupdr;
 8008cc2:	4833      	ldr	r0, [pc, #204]	; (8008d90 <__early_init+0x180>)
  gpiop->OTYPER  = config->otyper;
 8008cc4:	f8c1 2c04 	str.w	r2, [r1, #3076]	; 0xc04
  gpiop->OSPEEDR = config->ospeedr;
 8008cc8:	f8c1 4c08 	str.w	r4, [r1, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 8008ccc:	f8c1 0c0c 	str.w	r0, [r1, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 8008cd0:	f8c1 5c14 	str.w	r5, [r1, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 8008cd4:	f8c1 2c20 	str.w	r2, [r1, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 8008cd8:	f8c1 2c24 	str.w	r2, [r1, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 8008cdc:	f8c1 2c00 	str.w	r2, [r1, #3072]	; 0xc00
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8008ce0:	681a      	ldr	r2, [r3, #0]
 8008ce2:	f042 0201 	orr.w	r2, r2, #1
 8008ce6:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8008ce8:	681a      	ldr	r2, [r3, #0]
 8008cea:	0790      	lsls	r0, r2, #30
 8008cec:	d5fc      	bpl.n	8008ce8 <__early_init+0xd8>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8008cee:	685a      	ldr	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8008cf0:	491a      	ldr	r1, [pc, #104]	; (8008d5c <__early_init+0x14c>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8008cf2:	f022 0203 	bic.w	r2, r2, #3
 8008cf6:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8008cf8:	684b      	ldr	r3, [r1, #4]
 8008cfa:	f013 030c 	ands.w	r3, r3, #12
 8008cfe:	d1fb      	bne.n	8008cf8 <__early_init+0xe8>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8008d00:	6808      	ldr	r0, [r1, #0]
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8008d02:	4a16      	ldr	r2, [pc, #88]	; (8008d5c <__early_init+0x14c>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8008d04:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 8008d08:	6008      	str	r0, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8008d0a:	604b      	str	r3, [r1, #4]
  RCC->CSR |= RCC_CSR_LSION;
 8008d0c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8008d0e:	f043 0301 	orr.w	r3, r3, #1
 8008d12:	624b      	str	r3, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8008d14:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8008d16:	0799      	lsls	r1, r3, #30
 8008d18:	d5fc      	bpl.n	8008d14 <__early_init+0x104>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8008d1a:	4b1e      	ldr	r3, [pc, #120]	; (8008d94 <__early_init+0x184>)
 8008d1c:	6053      	str	r3, [r2, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8008d1e:	f44f 5104 	mov.w	r1, #8448	; 0x2100
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8008d22:	2330      	movs	r3, #48	; 0x30
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8008d24:	62d1      	str	r1, [r2, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8008d26:	6313      	str	r3, [r2, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8008d28:	6813      	ldr	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8008d2a:	490c      	ldr	r1, [pc, #48]	; (8008d5c <__early_init+0x14c>)
  RCC->CR   |= RCC_CR_PLLON;
 8008d2c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008d30:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8008d32:	680b      	ldr	r3, [r1, #0]
 8008d34:	019b      	lsls	r3, r3, #6
 8008d36:	d5fc      	bpl.n	8008d32 <__early_init+0x122>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8008d38:	4b17      	ldr	r3, [pc, #92]	; (8008d98 <__early_init+0x188>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8008d3a:	4a08      	ldr	r2, [pc, #32]	; (8008d5c <__early_init+0x14c>)
  FLASH->ACR = STM32_FLASHBITS;
 8008d3c:	2011      	movs	r0, #17
 8008d3e:	6018      	str	r0, [r3, #0]
  RCC->CFGR |= STM32_SW;
 8008d40:	684b      	ldr	r3, [r1, #4]
 8008d42:	f043 0302 	orr.w	r3, r3, #2
 8008d46:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8008d48:	6853      	ldr	r3, [r2, #4]
 8008d4a:	f003 030c 	and.w	r3, r3, #12
 8008d4e:	2b08      	cmp	r3, #8
 8008d50:	d1fa      	bne.n	8008d48 <__early_init+0x138>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_HRTIM1SW | STM32_TIM8SW | STM32_TIM1SW;
 8008d52:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8008d54:	6313      	str	r3, [r2, #48]	; 0x30

  stm32_gpio_init();
  stm32_clock_init();
}
 8008d56:	bc70      	pop	{r4, r5, r6}
 8008d58:	4770      	bx	lr
 8008d5a:	bf00      	nop
 8008d5c:	40021000 	.word	0x40021000
 8008d60:	48000400 	.word	0x48000400
 8008d64:	3cc0fc00 	.word	0x3cc0fc00
 8008d68:	48000800 	.word	0x48000800
 8008d6c:	64151154 	.word	0x64151154
 8008d70:	55500000 	.word	0x55500000
 8008d74:	2a80a800 	.word	0x2a80a800
 8008d78:	55550515 	.word	0x55550515
 8008d7c:	05555555 	.word	0x05555555
 8008d80:	48000c00 	.word	0x48000c00
 8008d84:	ffff00c0 	.word	0xffff00c0
 8008d88:	01155515 	.word	0x01155515
 8008d8c:	55550040 	.word	0x55550040
 8008d90:	55555550 	.word	0x55555550
 8008d94:	001c2400 	.word	0x001c2400
 8008d98:	40022000 	.word	0x40022000
 8008d9c:	00000000 	.word	0x00000000

08008da0 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8008da0:	b570      	push	{r4, r5, r6, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8008da2:	4c33      	ldr	r4, [pc, #204]	; (8008e70 <VectorD8+0xd0>)
 8008da4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8008da6:	f013 0502 	ands.w	r5, r3, #2
 8008daa:	d10b      	bne.n	8008dc4 <VectorD8+0x24>
 8008dac:	2320      	movs	r3, #32
 8008dae:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008db2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8008db4:	4a2f      	ldr	r2, [pc, #188]	; (8008e74 <VectorD8+0xd4>)
 8008db6:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008db8:	2202      	movs	r2, #2
 8008dba:	701a      	strb	r2, [r3, #0]
    trace_next();
 8008dbc:	f7f8 fad8 	bl	8001370 <trace_next>
 8008dc0:	f385 8811 	msr	BASEPRI, r5
 8008dc4:	2520      	movs	r5, #32
 8008dc6:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008dca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008dcc:	2b00      	cmp	r3, #0
 8008dce:	db01      	blt.n	8008dd4 <VectorD8+0x34>
 8008dd0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008dd2:	b112      	cbz	r2, 8008dda <VectorD8+0x3a>
    chSysHalt("SV#8");
 8008dd4:	4828      	ldr	r0, [pc, #160]	; (8008e78 <VectorD8+0xd8>)
 8008dd6:	f7f8 faeb 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8008dda:	3301      	adds	r3, #1
 8008ddc:	6323      	str	r3, [r4, #48]	; 0x30
 8008dde:	f382 8811 	msr	BASEPRI, r2
  serve_interrupt(&SD2);
 8008de2:	4826      	ldr	r0, [pc, #152]	; (8008e7c <VectorD8+0xdc>)
 8008de4:	f7f8 fd14 	bl	8001810 <serve_interrupt>
 8008de8:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008dec:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008dee:	2b00      	cmp	r3, #0
 8008df0:	dd01      	ble.n	8008df6 <VectorD8+0x56>
 8008df2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008df4:	b112      	cbz	r2, 8008dfc <VectorD8+0x5c>
    chSysHalt("SV#9");
 8008df6:	4822      	ldr	r0, [pc, #136]	; (8008e80 <VectorD8+0xe0>)
 8008df8:	f7f8 fada 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8008dfc:	3b01      	subs	r3, #1
 8008dfe:	6323      	str	r3, [r4, #48]	; 0x30
 8008e00:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8008e04:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8008e06:	f013 0602 	ands.w	r6, r3, #2
 8008e0a:	d10a      	bne.n	8008e22 <VectorD8+0x82>
 8008e0c:	f385 8811 	msr	BASEPRI, r5
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8008e10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8008e12:	4a18      	ldr	r2, [pc, #96]	; (8008e74 <VectorD8+0xd4>)
 8008e14:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8008e16:	2203      	movs	r2, #3
 8008e18:	701a      	strb	r2, [r3, #0]
    trace_next();
 8008e1a:	f7f8 faa9 	bl	8001370 <trace_next>
 8008e1e:	f386 8811 	msr	BASEPRI, r6
 8008e22:	2320      	movs	r3, #32
 8008e24:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008e28:	4b16      	ldr	r3, [pc, #88]	; (8008e84 <VectorD8+0xe4>)
 8008e2a:	685b      	ldr	r3, [r3, #4]
 8008e2c:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8008e30:	d102      	bne.n	8008e38 <VectorD8+0x98>
 8008e32:	f383 8811 	msr	BASEPRI, r3
}
 8008e36:	bd70      	pop	{r4, r5, r6, pc}
{
#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
#if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
 8008e38:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008e3c:	f3ef 8309 	mrs	r3, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8008e40:	4a11      	ldr	r2, [pc, #68]	; (8008e88 <VectorD8+0xe8>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8008e42:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8008e46:	68d2      	ldr	r2, [r2, #12]
 8008e48:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8008e4c:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8008e50:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008e54:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8008e58:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8008e5a:	69a2      	ldr	r2, [r4, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008e5c:	6889      	ldr	r1, [r1, #8]
 8008e5e:	6892      	ldr	r2, [r2, #8]
 8008e60:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008e62:	bf8c      	ite	hi
 8008e64:	4a09      	ldrhi	r2, [pc, #36]	; (8008e8c <VectorD8+0xec>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008e66:	4a0a      	ldrls	r2, [pc, #40]	; (8008e90 <VectorD8+0xf0>)
 8008e68:	f843 2c50 	str.w	r2, [r3, #-80]
 8008e6c:	bd70      	pop	{r4, r5, r6, pc}
 8008e6e:	bf00      	nop
 8008e70:	2000159c 	.word	0x2000159c
 8008e74:	0800e4a0 	.word	0x0800e4a0
 8008e78:	0800e59c 	.word	0x0800e59c
 8008e7c:	20001438 	.word	0x20001438
 8008e80:	0800e5a4 	.word	0x0800e5a4
 8008e84:	e000ed00 	.word	0xe000ed00
 8008e88:	e000ef30 	.word	0xe000ef30
 8008e8c:	080002f5 	.word	0x080002f5
 8008e90:	08000300 	.word	0x08000300
	...

08008ea0 <VectorD4>:
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8008ea0:	b570      	push	{r4, r5, r6, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8008ea2:	4c33      	ldr	r4, [pc, #204]	; (8008f70 <VectorD4+0xd0>)
 8008ea4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8008ea6:	f013 0502 	ands.w	r5, r3, #2
 8008eaa:	d10b      	bne.n	8008ec4 <VectorD4+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008eac:	2320      	movs	r3, #32
 8008eae:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008eb2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8008eb4:	4a2f      	ldr	r2, [pc, #188]	; (8008f74 <VectorD4+0xd4>)
 8008eb6:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008eb8:	2202      	movs	r2, #2
 8008eba:	701a      	strb	r2, [r3, #0]
    trace_next();
 8008ebc:	f7f8 fa58 	bl	8001370 <trace_next>
 8008ec0:	f385 8811 	msr	BASEPRI, r5
 8008ec4:	2520      	movs	r5, #32
 8008ec6:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008eca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008ecc:	2b00      	cmp	r3, #0
 8008ece:	db01      	blt.n	8008ed4 <VectorD4+0x34>
 8008ed0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008ed2:	b112      	cbz	r2, 8008eda <VectorD4+0x3a>
    chSysHalt("SV#8");
 8008ed4:	4828      	ldr	r0, [pc, #160]	; (8008f78 <VectorD4+0xd8>)
 8008ed6:	f7f8 fa6b 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8008eda:	3301      	adds	r3, #1
 8008edc:	6323      	str	r3, [r4, #48]	; 0x30
 8008ede:	f382 8811 	msr	BASEPRI, r2
  serve_interrupt(&SD1);
 8008ee2:	4826      	ldr	r0, [pc, #152]	; (8008f7c <VectorD4+0xdc>)
 8008ee4:	f7f8 fc94 	bl	8001810 <serve_interrupt>
 8008ee8:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008eec:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008eee:	2b00      	cmp	r3, #0
 8008ef0:	dd01      	ble.n	8008ef6 <VectorD4+0x56>
 8008ef2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008ef4:	b112      	cbz	r2, 8008efc <VectorD4+0x5c>
    chSysHalt("SV#9");
 8008ef6:	4822      	ldr	r0, [pc, #136]	; (8008f80 <VectorD4+0xe0>)
 8008ef8:	f7f8 fa5a 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8008efc:	3b01      	subs	r3, #1
 8008efe:	6323      	str	r3, [r4, #48]	; 0x30
 8008f00:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8008f04:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8008f06:	f013 0602 	ands.w	r6, r3, #2
 8008f0a:	d10a      	bne.n	8008f22 <VectorD4+0x82>
 8008f0c:	f385 8811 	msr	BASEPRI, r5
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8008f10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8008f12:	4a18      	ldr	r2, [pc, #96]	; (8008f74 <VectorD4+0xd4>)
 8008f14:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8008f16:	2203      	movs	r2, #3
 8008f18:	701a      	strb	r2, [r3, #0]
    trace_next();
 8008f1a:	f7f8 fa29 	bl	8001370 <trace_next>
 8008f1e:	f386 8811 	msr	BASEPRI, r6
 8008f22:	2320      	movs	r3, #32
 8008f24:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008f28:	4b16      	ldr	r3, [pc, #88]	; (8008f84 <VectorD4+0xe4>)
 8008f2a:	685b      	ldr	r3, [r3, #4]
 8008f2c:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8008f30:	d102      	bne.n	8008f38 <VectorD4+0x98>
 8008f32:	f383 8811 	msr	BASEPRI, r3
}
 8008f36:	bd70      	pop	{r4, r5, r6, pc}
  return __builtin_arm_get_fpscr();
 8008f38:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008f3c:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8008f40:	4a11      	ldr	r2, [pc, #68]	; (8008f88 <VectorD4+0xe8>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8008f42:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8008f46:	68d2      	ldr	r2, [r2, #12]
 8008f48:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8008f4c:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8008f50:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008f54:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8008f58:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8008f5a:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8008f5c:	6889      	ldr	r1, [r1, #8]
 8008f5e:	6892      	ldr	r2, [r2, #8]
 8008f60:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008f62:	bf8c      	ite	hi
 8008f64:	4a09      	ldrhi	r2, [pc, #36]	; (8008f8c <VectorD4+0xec>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008f66:	4a0a      	ldrls	r2, [pc, #40]	; (8008f90 <VectorD4+0xf0>)
 8008f68:	f843 2c50 	str.w	r2, [r3, #-80]
 8008f6c:	bd70      	pop	{r4, r5, r6, pc}
 8008f6e:	bf00      	nop
 8008f70:	2000159c 	.word	0x2000159c
 8008f74:	0800e480 	.word	0x0800e480
 8008f78:	0800e59c 	.word	0x0800e59c
 8008f7c:	200013d8 	.word	0x200013d8
 8008f80:	0800e5a4 	.word	0x0800e5a4
 8008f84:	e000ed00 	.word	0xe000ed00
 8008f88:	e000ef30 	.word	0xe000ef30
 8008f8c:	080002f5 	.word	0x080002f5
 8008f90:	08000300 	.word	0x08000300
	...

08008fa0 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8008fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8008fa4:	4c61      	ldr	r4, [pc, #388]	; (800912c <VectorB0+0x18c>)
 8008fa6:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8008fa8:	f013 0502 	ands.w	r5, r3, #2
 8008fac:	d10b      	bne.n	8008fc6 <VectorB0+0x26>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008fae:	2320      	movs	r3, #32
 8008fb0:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008fb4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8008fb6:	4a5e      	ldr	r2, [pc, #376]	; (8009130 <VectorB0+0x190>)
 8008fb8:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8008fba:	2202      	movs	r2, #2
 8008fbc:	701a      	strb	r2, [r3, #0]
    trace_next();
 8008fbe:	f7f8 f9d7 	bl	8001370 <trace_next>
 8008fc2:	f385 8811 	msr	BASEPRI, r5
 8008fc6:	2220      	movs	r2, #32
 8008fc8:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008fcc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008fce:	2b00      	cmp	r3, #0
 8008fd0:	db01      	blt.n	8008fd6 <VectorB0+0x36>
 8008fd2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8008fd4:	b111      	cbz	r1, 8008fdc <VectorB0+0x3c>
    chSysHalt("SV#8");
 8008fd6:	4857      	ldr	r0, [pc, #348]	; (8009134 <VectorB0+0x194>)
 8008fd8:	f7f8 f9ea 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8008fdc:	3301      	adds	r3, #1
 8008fde:	6323      	str	r3, [r4, #48]	; 0x30
 8008fe0:	f381 8811 	msr	BASEPRI, r1
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8008fe4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008fe8:	6918      	ldr	r0, [r3, #16]
 8008fea:	0780      	lsls	r0, r0, #30
 8008fec:	d40a      	bmi.n	8009004 <VectorB0+0x64>
 8008fee:	2220      	movs	r2, #32
 8008ff0:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008ff4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008ff6:	2b00      	cmp	r3, #0
 8008ff8:	dd01      	ble.n	8008ffe <VectorB0+0x5e>
 8008ffa:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8008ffc:	b169      	cbz	r1, 800901a <VectorB0+0x7a>
    chSysHalt("SV#9");
 8008ffe:	484e      	ldr	r0, [pc, #312]	; (8009138 <VectorB0+0x198>)
 8009000:	f7f8 f9d6 	bl	80013b0 <chSysHalt>
    STM32_ST_TIM->SR = 0U;
 8009004:	6119      	str	r1, [r3, #16]
 8009006:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800900a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800900c:	2a00      	cmp	r2, #0
 800900e:	dd01      	ble.n	8009014 <VectorB0+0x74>
 8009010:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8009012:	b30e      	cbz	r6, 8009058 <VectorB0+0xb8>
    chSysHalt("SV#6");
 8009014:	4849      	ldr	r0, [pc, #292]	; (800913c <VectorB0+0x19c>)
 8009016:	f7f8 f9cb 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 800901a:	3b01      	subs	r3, #1
 800901c:	6323      	str	r3, [r4, #48]	; 0x30
 800901e:	f381 8811 	msr	BASEPRI, r1
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009022:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009024:	f013 0502 	ands.w	r5, r3, #2
 8009028:	d10a      	bne.n	8009040 <VectorB0+0xa0>
 800902a:	f382 8811 	msr	BASEPRI, r2
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800902e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009030:	4a3f      	ldr	r2, [pc, #252]	; (8009130 <VectorB0+0x190>)
 8009032:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009034:	2203      	movs	r2, #3
 8009036:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009038:	f7f8 f99a 	bl	8001370 <trace_next>
 800903c:	f385 8811 	msr	BASEPRI, r5
 8009040:	2320      	movs	r3, #32
 8009042:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009046:	4b3e      	ldr	r3, [pc, #248]	; (8009140 <VectorB0+0x1a0>)
 8009048:	685b      	ldr	r3, [r3, #4]
 800904a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800904e:	d133      	bne.n	80090b8 <VectorB0+0x118>
 8009050:	f383 8811 	msr	BASEPRI, r3
}
 8009054:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  _dbg_enter_lock();
 8009058:	2001      	movs	r0, #1
  return (systime_t)STM32_ST_TIM->CNT;
 800905a:	461d      	mov	r5, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 800905c:	69e1      	ldr	r1, [r4, #28]
 800905e:	4f39      	ldr	r7, [pc, #228]	; (8009144 <VectorB0+0x1a4>)
 8009060:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009062:	6360      	str	r0, [r4, #52]	; 0x34
 8009064:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8009066:	f8d1 9008 	ldr.w	r9, [r1, #8]
  return (sysinterval_t)((systime_t)(end - start));
 800906a:	eba2 0a03 	sub.w	sl, r2, r3
 800906e:	45ca      	cmp	sl, r9
 8009070:	d33f      	bcc.n	80090f2 <VectorB0+0x152>
 8009072:	f04f 0820 	mov.w	r8, #32

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8009076:	6808      	ldr	r0, [r1, #0]
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
 8009078:	68ca      	ldr	r2, [r1, #12]
      ch.vtlist.lasttime += vtp->delta;
 800907a:	444b      	add	r3, r9
      vtp->func = NULL;

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800907c:	42b8      	cmp	r0, r7
      ch.vtlist.lasttime += vtp->delta;
 800907e:	62a3      	str	r3, [r4, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8009080:	6047      	str	r7, [r0, #4]
      ch.vtlist.next = vtp->next;
 8009082:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 8009084:	60ce      	str	r6, [r1, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8009086:	d032      	beq.n	80090ee <VectorB0+0x14e>
  _dbg_leave_lock();
 8009088:	6366      	str	r6, [r4, #52]	; 0x34
 800908a:	f386 8811 	msr	BASEPRI, r6
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 800908e:	6908      	ldr	r0, [r1, #16]
 8009090:	4790      	blx	r2
 8009092:	f388 8811 	msr	BASEPRI, r8
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009096:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009098:	2b00      	cmp	r3, #0
 800909a:	ddbb      	ble.n	8009014 <VectorB0+0x74>
 800909c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800909e:	2b00      	cmp	r3, #0
 80090a0:	d1b8      	bne.n	8009014 <VectorB0+0x74>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 80090a2:	69e1      	ldr	r1, [r4, #28]
 80090a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
 80090a6:	ebaa 0a09 	sub.w	sl, sl, r9
    }
    while (vtp->delta <= nowdelta);
 80090aa:	f8d1 9008 	ldr.w	r9, [r1, #8]
  _dbg_enter_lock();
 80090ae:	2201      	movs	r2, #1
 80090b0:	45ca      	cmp	sl, r9
 80090b2:	6362      	str	r2, [r4, #52]	; 0x34
 80090b4:	d2df      	bcs.n	8009076 <VectorB0+0xd6>
 80090b6:	e7d5      	b.n	8009064 <VectorB0+0xc4>
  return __builtin_arm_get_fpscr();
 80090b8:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80090bc:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80090c0:	4a21      	ldr	r2, [pc, #132]	; (8009148 <VectorB0+0x1a8>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80090c2:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80090c6:	68d2      	ldr	r2, [r2, #12]
 80090c8:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80090cc:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80090d0:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80090d4:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80090d8:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80090da:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80090dc:	6889      	ldr	r1, [r1, #8]
 80090de:	6892      	ldr	r2, [r2, #8]
 80090e0:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80090e2:	bf8c      	ite	hi
 80090e4:	4a19      	ldrhi	r2, [pc, #100]	; (800914c <VectorB0+0x1ac>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80090e6:	4a1a      	ldrls	r2, [pc, #104]	; (8009150 <VectorB0+0x1b0>)
 80090e8:	f843 2c50 	str.w	r2, [r3, #-80]
 80090ec:	e7b2      	b.n	8009054 <VectorB0+0xb4>
  STM32_ST_TIM->DIER = 0;
 80090ee:	60ee      	str	r6, [r5, #12]
 80090f0:	e7ca      	b.n	8009088 <VectorB0+0xe8>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80090f2:	42b9      	cmp	r1, r7
 80090f4:	d00f      	beq.n	8009116 <VectorB0+0x176>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 80090f6:	eba9 030a 	sub.w	r3, r9, sl
  ch.vtlist.lasttime += nowdelta;
 80090fa:	62a2      	str	r2, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 80090fc:	608b      	str	r3, [r1, #8]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80090fe:	68e9      	ldr	r1, [r5, #12]
 8009100:	0789      	lsls	r1, r1, #30
 8009102:	d50d      	bpl.n	8009120 <VectorB0+0x180>
 8009104:	2b02      	cmp	r3, #2
 8009106:	bf38      	it	cc
 8009108:	2302      	movcc	r3, #2
  return systime + (systime_t)interval;
 800910a:	18d1      	adds	r1, r2, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800910c:	6369      	str	r1, [r5, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 800910e:	6a69      	ldr	r1, [r5, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8009110:	1a8a      	subs	r2, r1, r2
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8009112:	429a      	cmp	r2, r3
 8009114:	d807      	bhi.n	8009126 <VectorB0+0x186>
  _dbg_leave_lock();
 8009116:	2300      	movs	r3, #0
 8009118:	6363      	str	r3, [r4, #52]	; 0x34
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800911a:	f383 8811 	msr	BASEPRI, r3
 800911e:	e766      	b.n	8008fee <VectorB0+0x4e>
 8009120:	480c      	ldr	r0, [pc, #48]	; (8009154 <VectorB0+0x1b4>)
 8009122:	f7f8 f945 	bl	80013b0 <chSysHalt>
 8009126:	480c      	ldr	r0, [pc, #48]	; (8009158 <VectorB0+0x1b8>)
 8009128:	f7f8 f942 	bl	80013b0 <chSysHalt>
 800912c:	2000159c 	.word	0x2000159c
 8009130:	0800e380 	.word	0x0800e380
 8009134:	0800e59c 	.word	0x0800e59c
 8009138:	0800e5a4 	.word	0x0800e5a4
 800913c:	0800e5ac 	.word	0x0800e5ac
 8009140:	e000ed00 	.word	0xe000ed00
 8009144:	200015b8 	.word	0x200015b8
 8009148:	e000ef30 	.word	0xe000ef30
 800914c:	080002f5 	.word	0x080002f5
 8009150:	08000300 	.word	0x08000300
 8009154:	0800e3cc 	.word	0x0800e3cc
 8009158:	0800e220 	.word	0x0800e220
 800915c:	00000000 	.word	0x00000000

08009160 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8009160:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009162:	4c2d      	ldr	r4, [pc, #180]	; (8009218 <Vector130+0xb8>)
 8009164:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009166:	f013 0502 	ands.w	r5, r3, #2
 800916a:	d10b      	bne.n	8009184 <Vector130+0x24>
 800916c:	2320      	movs	r3, #32
 800916e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009172:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009174:	4a29      	ldr	r2, [pc, #164]	; (800921c <Vector130+0xbc>)
 8009176:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009178:	2202      	movs	r2, #2
 800917a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800917c:	f7f8 f8f8 	bl	8001370 <trace_next>
 8009180:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009184:	f7f8 fb24 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8009188:	4b25      	ldr	r3, [pc, #148]	; (8009220 <Vector130+0xc0>)
 800918a:	4a26      	ldr	r2, [pc, #152]	; (8009224 <Vector130+0xc4>)
 800918c:	6819      	ldr	r1, [r3, #0]
 800918e:	6812      	ldr	r2, [r2, #0]
 8009190:	0c09      	lsrs	r1, r1, #16
 8009192:	f001 010e 	and.w	r1, r1, #14
 8009196:	420a      	tst	r2, r1
 8009198:	d006      	beq.n	80091a8 <Vector130+0x48>
 800919a:	4823      	ldr	r0, [pc, #140]	; (8009228 <Vector130+0xc8>)
 800919c:	6d82      	ldr	r2, [r0, #88]	; 0x58
 800919e:	040d      	lsls	r5, r1, #16
 80091a0:	605d      	str	r5, [r3, #4]
 80091a2:	b10a      	cbz	r2, 80091a8 <Vector130+0x48>
 80091a4:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80091a6:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80091a8:	f7f8 fafa 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80091ac:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80091ae:	f013 0502 	ands.w	r5, r3, #2
 80091b2:	d10b      	bne.n	80091cc <Vector130+0x6c>
 80091b4:	2320      	movs	r3, #32
 80091b6:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80091ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80091bc:	4a17      	ldr	r2, [pc, #92]	; (800921c <Vector130+0xbc>)
 80091be:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80091c0:	2203      	movs	r2, #3
 80091c2:	701a      	strb	r2, [r3, #0]
    trace_next();
 80091c4:	f7f8 f8d4 	bl	8001370 <trace_next>
 80091c8:	f385 8811 	msr	BASEPRI, r5
 80091cc:	2320      	movs	r3, #32
 80091ce:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80091d2:	4b16      	ldr	r3, [pc, #88]	; (800922c <Vector130+0xcc>)
 80091d4:	685b      	ldr	r3, [r3, #4]
 80091d6:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80091da:	d102      	bne.n	80091e2 <Vector130+0x82>
 80091dc:	f383 8811 	msr	BASEPRI, r3
}
 80091e0:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 80091e2:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80091e6:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80091ea:	4a11      	ldr	r2, [pc, #68]	; (8009230 <Vector130+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80091ec:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80091f0:	68d2      	ldr	r2, [r2, #12]
 80091f2:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80091f6:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80091fa:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80091fe:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009202:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009204:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009206:	6889      	ldr	r1, [r1, #8]
 8009208:	6892      	ldr	r2, [r2, #8]
 800920a:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800920c:	bf8c      	ite	hi
 800920e:	4a09      	ldrhi	r2, [pc, #36]	; (8009234 <Vector130+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009210:	4a09      	ldrls	r2, [pc, #36]	; (8009238 <Vector130+0xd8>)
 8009212:	f843 2c50 	str.w	r2, [r3, #-80]
 8009216:	bd38      	pop	{r3, r4, r5, pc}
 8009218:	2000159c 	.word	0x2000159c
 800921c:	0800e534 	.word	0x0800e534
 8009220:	40020400 	.word	0x40020400
 8009224:	40020458 	.word	0x40020458
 8009228:	20001534 	.word	0x20001534
 800922c:	e000ed00 	.word	0xe000ed00
 8009230:	e000ef30 	.word	0xe000ef30
 8009234:	080002f5 	.word	0x080002f5
 8009238:	08000300 	.word	0x08000300
 800923c:	00000000 	.word	0x00000000

08009240 <Vector12C>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8009240:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009242:	4c2d      	ldr	r4, [pc, #180]	; (80092f8 <Vector12C+0xb8>)
 8009244:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009246:	f013 0502 	ands.w	r5, r3, #2
 800924a:	d10b      	bne.n	8009264 <Vector12C+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800924c:	2320      	movs	r3, #32
 800924e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009252:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009254:	4a29      	ldr	r2, [pc, #164]	; (80092fc <Vector12C+0xbc>)
 8009256:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009258:	2202      	movs	r2, #2
 800925a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800925c:	f7f8 f888 	bl	8001370 <trace_next>
 8009260:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009264:	f7f8 fab4 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8009268:	4b25      	ldr	r3, [pc, #148]	; (8009300 <Vector12C+0xc0>)
 800926a:	4a26      	ldr	r2, [pc, #152]	; (8009304 <Vector12C+0xc4>)
 800926c:	6819      	ldr	r1, [r3, #0]
 800926e:	6812      	ldr	r2, [r2, #0]
 8009270:	0b09      	lsrs	r1, r1, #12
 8009272:	f001 010e 	and.w	r1, r1, #14
 8009276:	420a      	tst	r2, r1
 8009278:	d006      	beq.n	8009288 <Vector12C+0x48>
 800927a:	4823      	ldr	r0, [pc, #140]	; (8009308 <Vector12C+0xc8>)
 800927c:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800927e:	030d      	lsls	r5, r1, #12
 8009280:	605d      	str	r5, [r3, #4]
 8009282:	b10a      	cbz	r2, 8009288 <Vector12C+0x48>
 8009284:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8009286:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009288:	f7f8 fa8a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800928c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800928e:	f013 0502 	ands.w	r5, r3, #2
 8009292:	d10b      	bne.n	80092ac <Vector12C+0x6c>
 8009294:	2320      	movs	r3, #32
 8009296:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800929a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800929c:	4a17      	ldr	r2, [pc, #92]	; (80092fc <Vector12C+0xbc>)
 800929e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80092a0:	2203      	movs	r2, #3
 80092a2:	701a      	strb	r2, [r3, #0]
    trace_next();
 80092a4:	f7f8 f864 	bl	8001370 <trace_next>
 80092a8:	f385 8811 	msr	BASEPRI, r5
 80092ac:	2320      	movs	r3, #32
 80092ae:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80092b2:	4b16      	ldr	r3, [pc, #88]	; (800930c <Vector12C+0xcc>)
 80092b4:	685b      	ldr	r3, [r3, #4]
 80092b6:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80092ba:	d102      	bne.n	80092c2 <Vector12C+0x82>
 80092bc:	f383 8811 	msr	BASEPRI, r3
}
 80092c0:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 80092c2:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80092c6:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80092ca:	4a11      	ldr	r2, [pc, #68]	; (8009310 <Vector12C+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80092cc:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80092d0:	68d2      	ldr	r2, [r2, #12]
 80092d2:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80092d6:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80092da:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80092de:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80092e2:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80092e4:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80092e6:	6889      	ldr	r1, [r1, #8]
 80092e8:	6892      	ldr	r2, [r2, #8]
 80092ea:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80092ec:	bf8c      	ite	hi
 80092ee:	4a09      	ldrhi	r2, [pc, #36]	; (8009314 <Vector12C+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80092f0:	4a09      	ldrls	r2, [pc, #36]	; (8009318 <Vector12C+0xd8>)
 80092f2:	f843 2c50 	str.w	r2, [r3, #-80]
 80092f6:	bd38      	pop	{r3, r4, r5, pc}
 80092f8:	2000159c 	.word	0x2000159c
 80092fc:	0800e520 	.word	0x0800e520
 8009300:	40020400 	.word	0x40020400
 8009304:	40020444 	.word	0x40020444
 8009308:	20001534 	.word	0x20001534
 800930c:	e000ed00 	.word	0xe000ed00
 8009310:	e000ef30 	.word	0xe000ef30
 8009314:	080002f5 	.word	0x080002f5
 8009318:	08000300 	.word	0x08000300
 800931c:	00000000 	.word	0x00000000

08009320 <Vector128>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8009320:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009322:	4c2d      	ldr	r4, [pc, #180]	; (80093d8 <Vector128+0xb8>)
 8009324:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009326:	f013 0502 	ands.w	r5, r3, #2
 800932a:	d10b      	bne.n	8009344 <Vector128+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800932c:	2320      	movs	r3, #32
 800932e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009332:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009334:	4a29      	ldr	r2, [pc, #164]	; (80093dc <Vector128+0xbc>)
 8009336:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009338:	2202      	movs	r2, #2
 800933a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800933c:	f7f8 f818 	bl	8001370 <trace_next>
 8009340:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009344:	f7f8 fa44 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8009348:	4b25      	ldr	r3, [pc, #148]	; (80093e0 <Vector128+0xc0>)
 800934a:	4a26      	ldr	r2, [pc, #152]	; (80093e4 <Vector128+0xc4>)
 800934c:	6819      	ldr	r1, [r3, #0]
 800934e:	6812      	ldr	r2, [r2, #0]
 8009350:	0a09      	lsrs	r1, r1, #8
 8009352:	f001 010e 	and.w	r1, r1, #14
 8009356:	420a      	tst	r2, r1
 8009358:	d006      	beq.n	8009368 <Vector128+0x48>
 800935a:	4823      	ldr	r0, [pc, #140]	; (80093e8 <Vector128+0xc8>)
 800935c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800935e:	020d      	lsls	r5, r1, #8
 8009360:	605d      	str	r5, [r3, #4]
 8009362:	b10a      	cbz	r2, 8009368 <Vector128+0x48>
 8009364:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8009366:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009368:	f7f8 fa1a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800936c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800936e:	f013 0502 	ands.w	r5, r3, #2
 8009372:	d10b      	bne.n	800938c <Vector128+0x6c>
 8009374:	2320      	movs	r3, #32
 8009376:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800937a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800937c:	4a17      	ldr	r2, [pc, #92]	; (80093dc <Vector128+0xbc>)
 800937e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009380:	2203      	movs	r2, #3
 8009382:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009384:	f7f7 fff4 	bl	8001370 <trace_next>
 8009388:	f385 8811 	msr	BASEPRI, r5
 800938c:	2320      	movs	r3, #32
 800938e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009392:	4b16      	ldr	r3, [pc, #88]	; (80093ec <Vector128+0xcc>)
 8009394:	685b      	ldr	r3, [r3, #4]
 8009396:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800939a:	d102      	bne.n	80093a2 <Vector128+0x82>
 800939c:	f383 8811 	msr	BASEPRI, r3
}
 80093a0:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 80093a2:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80093a6:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80093aa:	4a11      	ldr	r2, [pc, #68]	; (80093f0 <Vector128+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80093ac:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80093b0:	68d2      	ldr	r2, [r2, #12]
 80093b2:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80093b6:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80093ba:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80093be:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80093c2:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80093c4:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80093c6:	6889      	ldr	r1, [r1, #8]
 80093c8:	6892      	ldr	r2, [r2, #8]
 80093ca:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80093cc:	bf8c      	ite	hi
 80093ce:	4a09      	ldrhi	r2, [pc, #36]	; (80093f4 <Vector128+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80093d0:	4a09      	ldrls	r2, [pc, #36]	; (80093f8 <Vector128+0xd8>)
 80093d2:	f843 2c50 	str.w	r2, [r3, #-80]
 80093d6:	bd38      	pop	{r3, r4, r5, pc}
 80093d8:	2000159c 	.word	0x2000159c
 80093dc:	0800e4fc 	.word	0x0800e4fc
 80093e0:	40020400 	.word	0x40020400
 80093e4:	40020430 	.word	0x40020430
 80093e8:	20001534 	.word	0x20001534
 80093ec:	e000ed00 	.word	0xe000ed00
 80093f0:	e000ef30 	.word	0xe000ef30
 80093f4:	080002f5 	.word	0x080002f5
 80093f8:	08000300 	.word	0x08000300
 80093fc:	00000000 	.word	0x00000000

08009400 <Vector124>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8009400:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009402:	4c34      	ldr	r4, [pc, #208]	; (80094d4 <Vector124+0xd4>)
 8009404:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009406:	f013 0502 	ands.w	r5, r3, #2
 800940a:	d10b      	bne.n	8009424 <Vector124+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800940c:	2320      	movs	r3, #32
 800940e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009412:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009414:	4a30      	ldr	r2, [pc, #192]	; (80094d8 <Vector124+0xd8>)
 8009416:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009418:	2202      	movs	r2, #2
 800941a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800941c:	f7f7 ffa8 	bl	8001370 <trace_next>
 8009420:	f385 8811 	msr	BASEPRI, r5
 8009424:	2320      	movs	r3, #32
 8009426:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800942a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800942c:	2b00      	cmp	r3, #0
 800942e:	db01      	blt.n	8009434 <Vector124+0x34>
 8009430:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009432:	b112      	cbz	r2, 800943a <Vector124+0x3a>
    chSysHalt("SV#8");
 8009434:	4829      	ldr	r0, [pc, #164]	; (80094dc <Vector124+0xdc>)
 8009436:	f7f7 ffbb 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 800943a:	3301      	adds	r3, #1
 800943c:	6323      	str	r3, [r4, #48]	; 0x30
 800943e:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8009442:	4b27      	ldr	r3, [pc, #156]	; (80094e0 <Vector124+0xe0>)
 8009444:	4a27      	ldr	r2, [pc, #156]	; (80094e4 <Vector124+0xe4>)
 8009446:	6819      	ldr	r1, [r3, #0]
 8009448:	6812      	ldr	r2, [r2, #0]
 800944a:	0909      	lsrs	r1, r1, #4
 800944c:	f001 010e 	and.w	r1, r1, #14
 8009450:	420a      	tst	r2, r1
 8009452:	d006      	beq.n	8009462 <Vector124+0x62>
 8009454:	4824      	ldr	r0, [pc, #144]	; (80094e8 <Vector124+0xe8>)
 8009456:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8009458:	010d      	lsls	r5, r1, #4
 800945a:	605d      	str	r5, [r3, #4]
 800945c:	b10a      	cbz	r2, 8009462 <Vector124+0x62>
 800945e:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8009460:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009462:	f7f8 f99d 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009466:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009468:	f013 0502 	ands.w	r5, r3, #2
 800946c:	d10b      	bne.n	8009486 <Vector124+0x86>
 800946e:	2320      	movs	r3, #32
 8009470:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009474:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009476:	4a18      	ldr	r2, [pc, #96]	; (80094d8 <Vector124+0xd8>)
 8009478:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800947a:	2203      	movs	r2, #3
 800947c:	701a      	strb	r2, [r3, #0]
    trace_next();
 800947e:	f7f7 ff77 	bl	8001370 <trace_next>
 8009482:	f385 8811 	msr	BASEPRI, r5
 8009486:	2320      	movs	r3, #32
 8009488:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800948c:	4b17      	ldr	r3, [pc, #92]	; (80094ec <Vector124+0xec>)
 800948e:	685b      	ldr	r3, [r3, #4]
 8009490:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009494:	d102      	bne.n	800949c <Vector124+0x9c>
 8009496:	f383 8811 	msr	BASEPRI, r3
}
 800949a:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 800949c:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80094a0:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80094a4:	4a12      	ldr	r2, [pc, #72]	; (80094f0 <Vector124+0xf0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80094a6:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80094aa:	68d2      	ldr	r2, [r2, #12]
 80094ac:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80094b0:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80094b4:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80094b8:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80094bc:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80094be:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80094c0:	6889      	ldr	r1, [r1, #8]
 80094c2:	6892      	ldr	r2, [r2, #8]
 80094c4:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80094c6:	bf8c      	ite	hi
 80094c8:	4a0a      	ldrhi	r2, [pc, #40]	; (80094f4 <Vector124+0xf4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80094ca:	4a0b      	ldrls	r2, [pc, #44]	; (80094f8 <Vector124+0xf8>)
 80094cc:	f843 2c50 	str.w	r2, [r3, #-80]
 80094d0:	bd38      	pop	{r3, r4, r5, pc}
 80094d2:	bf00      	nop
 80094d4:	2000159c 	.word	0x2000159c
 80094d8:	0800e4dc 	.word	0x0800e4dc
 80094dc:	0800e59c 	.word	0x0800e59c
 80094e0:	40020400 	.word	0x40020400
 80094e4:	4002041c 	.word	0x4002041c
 80094e8:	20001534 	.word	0x20001534
 80094ec:	e000ed00 	.word	0xe000ed00
 80094f0:	e000ef30 	.word	0xe000ef30
 80094f4:	080002f5 	.word	0x080002f5
 80094f8:	08000300 	.word	0x08000300
 80094fc:	00000000 	.word	0x00000000

08009500 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8009500:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009502:	4c39      	ldr	r4, [pc, #228]	; (80095e8 <Vector120+0xe8>)
 8009504:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009506:	f013 0502 	ands.w	r5, r3, #2
 800950a:	d10b      	bne.n	8009524 <Vector120+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800950c:	2320      	movs	r3, #32
 800950e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009512:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009514:	4a35      	ldr	r2, [pc, #212]	; (80095ec <Vector120+0xec>)
 8009516:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009518:	2202      	movs	r2, #2
 800951a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800951c:	f7f7 ff28 	bl	8001370 <trace_next>
 8009520:	f385 8811 	msr	BASEPRI, r5
 8009524:	2320      	movs	r3, #32
 8009526:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800952a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800952c:	2b00      	cmp	r3, #0
 800952e:	db01      	blt.n	8009534 <Vector120+0x34>
 8009530:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009532:	b112      	cbz	r2, 800953a <Vector120+0x3a>
    chSysHalt("SV#8");
 8009534:	482e      	ldr	r0, [pc, #184]	; (80095f0 <Vector120+0xf0>)
 8009536:	f7f7 ff3b 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 800953a:	3301      	adds	r3, #1
 800953c:	6323      	str	r3, [r4, #48]	; 0x30
 800953e:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8009542:	4b2c      	ldr	r3, [pc, #176]	; (80095f4 <Vector120+0xf4>)
 8009544:	4a2c      	ldr	r2, [pc, #176]	; (80095f8 <Vector120+0xf8>)
 8009546:	6819      	ldr	r1, [r3, #0]
 8009548:	6812      	ldr	r2, [r2, #0]
 800954a:	f001 010e 	and.w	r1, r1, #14
 800954e:	420a      	tst	r2, r1
 8009550:	d005      	beq.n	800955e <Vector120+0x5e>
 8009552:	4a2a      	ldr	r2, [pc, #168]	; (80095fc <Vector120+0xfc>)
 8009554:	6059      	str	r1, [r3, #4]
 8009556:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009558:	b10b      	cbz	r3, 800955e <Vector120+0x5e>
 800955a:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 800955c:	4798      	blx	r3
 800955e:	2220      	movs	r2, #32
 8009560:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009564:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009566:	2b00      	cmp	r3, #0
 8009568:	dd01      	ble.n	800956e <Vector120+0x6e>
 800956a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800956c:	b111      	cbz	r1, 8009574 <Vector120+0x74>
    chSysHalt("SV#9");
 800956e:	4824      	ldr	r0, [pc, #144]	; (8009600 <Vector120+0x100>)
 8009570:	f7f7 ff1e 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8009574:	3b01      	subs	r3, #1
 8009576:	6323      	str	r3, [r4, #48]	; 0x30
 8009578:	f381 8811 	msr	BASEPRI, r1
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800957c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800957e:	f013 0502 	ands.w	r5, r3, #2
 8009582:	d10a      	bne.n	800959a <Vector120+0x9a>
 8009584:	f382 8811 	msr	BASEPRI, r2
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009588:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800958a:	4a18      	ldr	r2, [pc, #96]	; (80095ec <Vector120+0xec>)
 800958c:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800958e:	2203      	movs	r2, #3
 8009590:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009592:	f7f7 feed 	bl	8001370 <trace_next>
 8009596:	f385 8811 	msr	BASEPRI, r5
 800959a:	2320      	movs	r3, #32
 800959c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80095a0:	4b18      	ldr	r3, [pc, #96]	; (8009604 <Vector120+0x104>)
 80095a2:	685b      	ldr	r3, [r3, #4]
 80095a4:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80095a8:	d102      	bne.n	80095b0 <Vector120+0xb0>
 80095aa:	f383 8811 	msr	BASEPRI, r3
}
 80095ae:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 80095b0:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80095b4:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80095b8:	4a13      	ldr	r2, [pc, #76]	; (8009608 <Vector120+0x108>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80095ba:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80095be:	68d2      	ldr	r2, [r2, #12]
 80095c0:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80095c4:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80095c8:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80095cc:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80095d0:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80095d2:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80095d4:	6889      	ldr	r1, [r1, #8]
 80095d6:	6892      	ldr	r2, [r2, #8]
 80095d8:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80095da:	bf8c      	ite	hi
 80095dc:	4a0b      	ldrhi	r2, [pc, #44]	; (800960c <Vector120+0x10c>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80095de:	4a0c      	ldrls	r2, [pc, #48]	; (8009610 <Vector120+0x110>)
 80095e0:	f843 2c50 	str.w	r2, [r3, #-80]
 80095e4:	bd38      	pop	{r3, r4, r5, pc}
 80095e6:	bf00      	nop
 80095e8:	2000159c 	.word	0x2000159c
 80095ec:	0800e4c4 	.word	0x0800e4c4
 80095f0:	0800e59c 	.word	0x0800e59c
 80095f4:	40020400 	.word	0x40020400
 80095f8:	40020408 	.word	0x40020408
 80095fc:	20001534 	.word	0x20001534
 8009600:	0800e5a4 	.word	0x0800e5a4
 8009604:	e000ed00 	.word	0xe000ed00
 8009608:	e000ef30 	.word	0xe000ef30
 800960c:	080002f5 	.word	0x080002f5
 8009610:	08000300 	.word	0x08000300
	...

08009620 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8009620:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009622:	4c2d      	ldr	r4, [pc, #180]	; (80096d8 <Vector84+0xb8>)
 8009624:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009626:	f013 0502 	ands.w	r5, r3, #2
 800962a:	d10b      	bne.n	8009644 <Vector84+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800962c:	2320      	movs	r3, #32
 800962e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009632:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009634:	4a29      	ldr	r2, [pc, #164]	; (80096dc <Vector84+0xbc>)
 8009636:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009638:	2202      	movs	r2, #2
 800963a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800963c:	f7f7 fe98 	bl	8001370 <trace_next>
 8009640:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009644:	f7f8 f8c4 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8009648:	4b25      	ldr	r3, [pc, #148]	; (80096e0 <Vector84+0xc0>)
 800964a:	4a26      	ldr	r2, [pc, #152]	; (80096e4 <Vector84+0xc4>)
 800964c:	6819      	ldr	r1, [r3, #0]
 800964e:	6812      	ldr	r2, [r2, #0]
 8009650:	0e09      	lsrs	r1, r1, #24
 8009652:	f001 010e 	and.w	r1, r1, #14
 8009656:	420a      	tst	r2, r1
 8009658:	d006      	beq.n	8009668 <Vector84+0x48>
 800965a:	4823      	ldr	r0, [pc, #140]	; (80096e8 <Vector84+0xc8>)
 800965c:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800965e:	060d      	lsls	r5, r1, #24
 8009660:	605d      	str	r5, [r3, #4]
 8009662:	b10a      	cbz	r2, 8009668 <Vector84+0x48>
 8009664:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8009666:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009668:	f7f8 f89a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800966c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800966e:	f013 0502 	ands.w	r5, r3, #2
 8009672:	d10b      	bne.n	800968c <Vector84+0x6c>
 8009674:	2320      	movs	r3, #32
 8009676:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800967a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800967c:	4a17      	ldr	r2, [pc, #92]	; (80096dc <Vector84+0xbc>)
 800967e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009680:	2203      	movs	r2, #3
 8009682:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009684:	f7f7 fe74 	bl	8001370 <trace_next>
 8009688:	f385 8811 	msr	BASEPRI, r5
 800968c:	2320      	movs	r3, #32
 800968e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009692:	4b16      	ldr	r3, [pc, #88]	; (80096ec <Vector84+0xcc>)
 8009694:	685b      	ldr	r3, [r3, #4]
 8009696:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800969a:	d102      	bne.n	80096a2 <Vector84+0x82>
 800969c:	f383 8811 	msr	BASEPRI, r3
}
 80096a0:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 80096a2:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80096a6:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80096aa:	4a11      	ldr	r2, [pc, #68]	; (80096f0 <Vector84+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 80096ac:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80096b0:	68d2      	ldr	r2, [r2, #12]
 80096b2:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 80096b6:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 80096ba:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80096be:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80096c2:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80096c4:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80096c6:	6889      	ldr	r1, [r1, #8]
 80096c8:	6892      	ldr	r2, [r2, #8]
 80096ca:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80096cc:	bf8c      	ite	hi
 80096ce:	4a09      	ldrhi	r2, [pc, #36]	; (80096f4 <Vector84+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80096d0:	4a09      	ldrls	r2, [pc, #36]	; (80096f8 <Vector84+0xd8>)
 80096d2:	f843 2c50 	str.w	r2, [r3, #-80]
 80096d6:	bd38      	pop	{r3, r4, r5, pc}
 80096d8:	2000159c 	.word	0x2000159c
 80096dc:	0800e4ac 	.word	0x0800e4ac
 80096e0:	40020000 	.word	0x40020000
 80096e4:	40020080 	.word	0x40020080
 80096e8:	20001534 	.word	0x20001534
 80096ec:	e000ed00 	.word	0xe000ed00
 80096f0:	e000ef30 	.word	0xe000ef30
 80096f4:	080002f5 	.word	0x080002f5
 80096f8:	08000300 	.word	0x08000300
 80096fc:	00000000 	.word	0x00000000

08009700 <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8009700:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009702:	4c2d      	ldr	r4, [pc, #180]	; (80097b8 <Vector80+0xb8>)
 8009704:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009706:	f013 0502 	ands.w	r5, r3, #2
 800970a:	d10b      	bne.n	8009724 <Vector80+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800970c:	2320      	movs	r3, #32
 800970e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009712:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009714:	4a29      	ldr	r2, [pc, #164]	; (80097bc <Vector80+0xbc>)
 8009716:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009718:	2202      	movs	r2, #2
 800971a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800971c:	f7f7 fe28 	bl	8001370 <trace_next>
 8009720:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009724:	f7f8 f854 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8009728:	4b25      	ldr	r3, [pc, #148]	; (80097c0 <Vector80+0xc0>)
 800972a:	4a26      	ldr	r2, [pc, #152]	; (80097c4 <Vector80+0xc4>)
 800972c:	6819      	ldr	r1, [r3, #0]
 800972e:	6812      	ldr	r2, [r2, #0]
 8009730:	0d09      	lsrs	r1, r1, #20
 8009732:	f001 010e 	and.w	r1, r1, #14
 8009736:	420a      	tst	r2, r1
 8009738:	d006      	beq.n	8009748 <Vector80+0x48>
 800973a:	4823      	ldr	r0, [pc, #140]	; (80097c8 <Vector80+0xc8>)
 800973c:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800973e:	050d      	lsls	r5, r1, #20
 8009740:	605d      	str	r5, [r3, #4]
 8009742:	b10a      	cbz	r2, 8009748 <Vector80+0x48>
 8009744:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8009746:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009748:	f7f8 f82a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800974c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800974e:	f013 0502 	ands.w	r5, r3, #2
 8009752:	d10b      	bne.n	800976c <Vector80+0x6c>
 8009754:	2320      	movs	r3, #32
 8009756:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800975a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800975c:	4a17      	ldr	r2, [pc, #92]	; (80097bc <Vector80+0xbc>)
 800975e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009760:	2203      	movs	r2, #3
 8009762:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009764:	f7f7 fe04 	bl	8001370 <trace_next>
 8009768:	f385 8811 	msr	BASEPRI, r5
 800976c:	2320      	movs	r3, #32
 800976e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009772:	4b16      	ldr	r3, [pc, #88]	; (80097cc <Vector80+0xcc>)
 8009774:	685b      	ldr	r3, [r3, #4]
 8009776:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800977a:	d102      	bne.n	8009782 <Vector80+0x82>
 800977c:	f383 8811 	msr	BASEPRI, r3
}
 8009780:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009782:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009786:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800978a:	4a11      	ldr	r2, [pc, #68]	; (80097d0 <Vector80+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 800978c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009790:	68d2      	ldr	r2, [r2, #12]
 8009792:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009796:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 800979a:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800979e:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80097a2:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80097a4:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 80097a6:	6889      	ldr	r1, [r1, #8]
 80097a8:	6892      	ldr	r2, [r2, #8]
 80097aa:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80097ac:	bf8c      	ite	hi
 80097ae:	4a09      	ldrhi	r2, [pc, #36]	; (80097d4 <Vector80+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80097b0:	4a09      	ldrls	r2, [pc, #36]	; (80097d8 <Vector80+0xd8>)
 80097b2:	f843 2c50 	str.w	r2, [r3, #-80]
 80097b6:	bd38      	pop	{r3, r4, r5, pc}
 80097b8:	2000159c 	.word	0x2000159c
 80097bc:	0800e474 	.word	0x0800e474
 80097c0:	40020000 	.word	0x40020000
 80097c4:	4002006c 	.word	0x4002006c
 80097c8:	20001534 	.word	0x20001534
 80097cc:	e000ed00 	.word	0xe000ed00
 80097d0:	e000ef30 	.word	0xe000ef30
 80097d4:	080002f5 	.word	0x080002f5
 80097d8:	08000300 	.word	0x08000300
 80097dc:	00000000 	.word	0x00000000

080097e0 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80097e0:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80097e2:	4c2d      	ldr	r4, [pc, #180]	; (8009898 <Vector7C+0xb8>)
 80097e4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80097e6:	f013 0502 	ands.w	r5, r3, #2
 80097ea:	d10b      	bne.n	8009804 <Vector7C+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80097ec:	2320      	movs	r3, #32
 80097ee:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80097f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80097f4:	4a29      	ldr	r2, [pc, #164]	; (800989c <Vector7C+0xbc>)
 80097f6:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80097f8:	2202      	movs	r2, #2
 80097fa:	701a      	strb	r2, [r3, #0]
    trace_next();
 80097fc:	f7f7 fdb8 	bl	8001370 <trace_next>
 8009800:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009804:	f7f7 ffe4 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8009808:	4b25      	ldr	r3, [pc, #148]	; (80098a0 <Vector7C+0xc0>)
 800980a:	4a26      	ldr	r2, [pc, #152]	; (80098a4 <Vector7C+0xc4>)
 800980c:	6819      	ldr	r1, [r3, #0]
 800980e:	6812      	ldr	r2, [r2, #0]
 8009810:	0c09      	lsrs	r1, r1, #16
 8009812:	f001 010e 	and.w	r1, r1, #14
 8009816:	420a      	tst	r2, r1
 8009818:	d006      	beq.n	8009828 <Vector7C+0x48>
 800981a:	4823      	ldr	r0, [pc, #140]	; (80098a8 <Vector7C+0xc8>)
 800981c:	6a02      	ldr	r2, [r0, #32]
 800981e:	040d      	lsls	r5, r1, #16
 8009820:	605d      	str	r5, [r3, #4]
 8009822:	b10a      	cbz	r2, 8009828 <Vector7C+0x48>
 8009824:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8009826:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009828:	f7f7 ffba 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800982c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800982e:	f013 0502 	ands.w	r5, r3, #2
 8009832:	d10b      	bne.n	800984c <Vector7C+0x6c>
 8009834:	2320      	movs	r3, #32
 8009836:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800983a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800983c:	4a17      	ldr	r2, [pc, #92]	; (800989c <Vector7C+0xbc>)
 800983e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009840:	2203      	movs	r2, #3
 8009842:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009844:	f7f7 fd94 	bl	8001370 <trace_next>
 8009848:	f385 8811 	msr	BASEPRI, r5
 800984c:	2320      	movs	r3, #32
 800984e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009852:	4b16      	ldr	r3, [pc, #88]	; (80098ac <Vector7C+0xcc>)
 8009854:	685b      	ldr	r3, [r3, #4]
 8009856:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800985a:	d102      	bne.n	8009862 <Vector7C+0x82>
 800985c:	f383 8811 	msr	BASEPRI, r3
}
 8009860:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009862:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009866:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800986a:	4a11      	ldr	r2, [pc, #68]	; (80098b0 <Vector7C+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 800986c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009870:	68d2      	ldr	r2, [r2, #12]
 8009872:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009876:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 800987a:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800987e:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009882:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009884:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009886:	6889      	ldr	r1, [r1, #8]
 8009888:	6892      	ldr	r2, [r2, #8]
 800988a:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800988c:	bf8c      	ite	hi
 800988e:	4a09      	ldrhi	r2, [pc, #36]	; (80098b4 <Vector7C+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009890:	4a09      	ldrls	r2, [pc, #36]	; (80098b8 <Vector7C+0xd8>)
 8009892:	f843 2c50 	str.w	r2, [r3, #-80]
 8009896:	bd38      	pop	{r3, r4, r5, pc}
 8009898:	2000159c 	.word	0x2000159c
 800989c:	0800e468 	.word	0x0800e468
 80098a0:	40020000 	.word	0x40020000
 80098a4:	40020058 	.word	0x40020058
 80098a8:	20001534 	.word	0x20001534
 80098ac:	e000ed00 	.word	0xe000ed00
 80098b0:	e000ef30 	.word	0xe000ef30
 80098b4:	080002f5 	.word	0x080002f5
 80098b8:	08000300 	.word	0x08000300
 80098bc:	00000000 	.word	0x00000000

080098c0 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80098c0:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80098c2:	4c2d      	ldr	r4, [pc, #180]	; (8009978 <Vector78+0xb8>)
 80098c4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80098c6:	f013 0502 	ands.w	r5, r3, #2
 80098ca:	d10b      	bne.n	80098e4 <Vector78+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80098cc:	2320      	movs	r3, #32
 80098ce:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80098d2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80098d4:	4a29      	ldr	r2, [pc, #164]	; (800997c <Vector78+0xbc>)
 80098d6:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80098d8:	2202      	movs	r2, #2
 80098da:	701a      	strb	r2, [r3, #0]
    trace_next();
 80098dc:	f7f7 fd48 	bl	8001370 <trace_next>
 80098e0:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 80098e4:	f7f7 ff74 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80098e8:	4b25      	ldr	r3, [pc, #148]	; (8009980 <Vector78+0xc0>)
 80098ea:	4a26      	ldr	r2, [pc, #152]	; (8009984 <Vector78+0xc4>)
 80098ec:	6819      	ldr	r1, [r3, #0]
 80098ee:	6812      	ldr	r2, [r2, #0]
 80098f0:	0b09      	lsrs	r1, r1, #12
 80098f2:	f001 010e 	and.w	r1, r1, #14
 80098f6:	420a      	tst	r2, r1
 80098f8:	d006      	beq.n	8009908 <Vector78+0x48>
 80098fa:	4823      	ldr	r0, [pc, #140]	; (8009988 <Vector78+0xc8>)
 80098fc:	6982      	ldr	r2, [r0, #24]
 80098fe:	030d      	lsls	r5, r1, #12
 8009900:	605d      	str	r5, [r3, #4]
 8009902:	b10a      	cbz	r2, 8009908 <Vector78+0x48>
 8009904:	69c0      	ldr	r0, [r0, #28]
 8009906:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009908:	f7f7 ff4a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800990c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800990e:	f013 0502 	ands.w	r5, r3, #2
 8009912:	d10b      	bne.n	800992c <Vector78+0x6c>
 8009914:	2320      	movs	r3, #32
 8009916:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800991a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800991c:	4a17      	ldr	r2, [pc, #92]	; (800997c <Vector78+0xbc>)
 800991e:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009920:	2203      	movs	r2, #3
 8009922:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009924:	f7f7 fd24 	bl	8001370 <trace_next>
 8009928:	f385 8811 	msr	BASEPRI, r5
 800992c:	2320      	movs	r3, #32
 800992e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009932:	4b16      	ldr	r3, [pc, #88]	; (800998c <Vector78+0xcc>)
 8009934:	685b      	ldr	r3, [r3, #4]
 8009936:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800993a:	d102      	bne.n	8009942 <Vector78+0x82>
 800993c:	f383 8811 	msr	BASEPRI, r3
}
 8009940:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009942:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009946:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800994a:	4a11      	ldr	r2, [pc, #68]	; (8009990 <Vector78+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 800994c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009950:	68d2      	ldr	r2, [r2, #12]
 8009952:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009956:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 800995a:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800995e:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009962:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009964:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009966:	6889      	ldr	r1, [r1, #8]
 8009968:	6892      	ldr	r2, [r2, #8]
 800996a:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800996c:	bf8c      	ite	hi
 800996e:	4a09      	ldrhi	r2, [pc, #36]	; (8009994 <Vector78+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009970:	4a09      	ldrls	r2, [pc, #36]	; (8009998 <Vector78+0xd8>)
 8009972:	f843 2c50 	str.w	r2, [r3, #-80]
 8009976:	bd38      	pop	{r3, r4, r5, pc}
 8009978:	2000159c 	.word	0x2000159c
 800997c:	0800e45c 	.word	0x0800e45c
 8009980:	40020000 	.word	0x40020000
 8009984:	40020044 	.word	0x40020044
 8009988:	20001534 	.word	0x20001534
 800998c:	e000ed00 	.word	0xe000ed00
 8009990:	e000ef30 	.word	0xe000ef30
 8009994:	080002f5 	.word	0x080002f5
 8009998:	08000300 	.word	0x08000300
 800999c:	00000000 	.word	0x00000000

080099a0 <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80099a0:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80099a2:	4c2d      	ldr	r4, [pc, #180]	; (8009a58 <Vector74+0xb8>)
 80099a4:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80099a6:	f013 0502 	ands.w	r5, r3, #2
 80099aa:	d10b      	bne.n	80099c4 <Vector74+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80099ac:	2320      	movs	r3, #32
 80099ae:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80099b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80099b4:	4a29      	ldr	r2, [pc, #164]	; (8009a5c <Vector74+0xbc>)
 80099b6:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80099b8:	2202      	movs	r2, #2
 80099ba:	701a      	strb	r2, [r3, #0]
    trace_next();
 80099bc:	f7f7 fcd8 	bl	8001370 <trace_next>
 80099c0:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 80099c4:	f7f7 ff04 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80099c8:	4b25      	ldr	r3, [pc, #148]	; (8009a60 <Vector74+0xc0>)
 80099ca:	4a26      	ldr	r2, [pc, #152]	; (8009a64 <Vector74+0xc4>)
 80099cc:	6819      	ldr	r1, [r3, #0]
 80099ce:	6812      	ldr	r2, [r2, #0]
 80099d0:	0a09      	lsrs	r1, r1, #8
 80099d2:	f001 010e 	and.w	r1, r1, #14
 80099d6:	420a      	tst	r2, r1
 80099d8:	d006      	beq.n	80099e8 <Vector74+0x48>
 80099da:	4823      	ldr	r0, [pc, #140]	; (8009a68 <Vector74+0xc8>)
 80099dc:	6902      	ldr	r2, [r0, #16]
 80099de:	020d      	lsls	r5, r1, #8
 80099e0:	605d      	str	r5, [r3, #4]
 80099e2:	b10a      	cbz	r2, 80099e8 <Vector74+0x48>
 80099e4:	6940      	ldr	r0, [r0, #20]
 80099e6:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80099e8:	f7f7 feda 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80099ec:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80099ee:	f013 0502 	ands.w	r5, r3, #2
 80099f2:	d10b      	bne.n	8009a0c <Vector74+0x6c>
 80099f4:	2320      	movs	r3, #32
 80099f6:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80099fa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80099fc:	4a17      	ldr	r2, [pc, #92]	; (8009a5c <Vector74+0xbc>)
 80099fe:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009a00:	2203      	movs	r2, #3
 8009a02:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009a04:	f7f7 fcb4 	bl	8001370 <trace_next>
 8009a08:	f385 8811 	msr	BASEPRI, r5
 8009a0c:	2320      	movs	r3, #32
 8009a0e:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009a12:	4b16      	ldr	r3, [pc, #88]	; (8009a6c <Vector74+0xcc>)
 8009a14:	685b      	ldr	r3, [r3, #4]
 8009a16:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009a1a:	d102      	bne.n	8009a22 <Vector74+0x82>
 8009a1c:	f383 8811 	msr	BASEPRI, r3
}
 8009a20:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009a22:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009a26:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009a2a:	4a11      	ldr	r2, [pc, #68]	; (8009a70 <Vector74+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009a2c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009a30:	68d2      	ldr	r2, [r2, #12]
 8009a32:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009a36:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009a3a:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009a3e:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009a42:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009a44:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009a46:	6889      	ldr	r1, [r1, #8]
 8009a48:	6892      	ldr	r2, [r2, #8]
 8009a4a:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009a4c:	bf8c      	ite	hi
 8009a4e:	4a09      	ldrhi	r2, [pc, #36]	; (8009a74 <Vector74+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009a50:	4a09      	ldrls	r2, [pc, #36]	; (8009a78 <Vector74+0xd8>)
 8009a52:	f843 2c50 	str.w	r2, [r3, #-80]
 8009a56:	bd38      	pop	{r3, r4, r5, pc}
 8009a58:	2000159c 	.word	0x2000159c
 8009a5c:	0800e41c 	.word	0x0800e41c
 8009a60:	40020000 	.word	0x40020000
 8009a64:	40020030 	.word	0x40020030
 8009a68:	20001534 	.word	0x20001534
 8009a6c:	e000ed00 	.word	0xe000ed00
 8009a70:	e000ef30 	.word	0xe000ef30
 8009a74:	080002f5 	.word	0x080002f5
 8009a78:	08000300 	.word	0x08000300
 8009a7c:	00000000 	.word	0x00000000

08009a80 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8009a80:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009a82:	4c2d      	ldr	r4, [pc, #180]	; (8009b38 <Vector70+0xb8>)
 8009a84:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009a86:	f013 0502 	ands.w	r5, r3, #2
 8009a8a:	d10b      	bne.n	8009aa4 <Vector70+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009a8c:	2320      	movs	r3, #32
 8009a8e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009a92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009a94:	4a29      	ldr	r2, [pc, #164]	; (8009b3c <Vector70+0xbc>)
 8009a96:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009a98:	2202      	movs	r2, #2
 8009a9a:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009a9c:	f7f7 fc68 	bl	8001370 <trace_next>
 8009aa0:	f385 8811 	msr	BASEPRI, r5
  OSAL_IRQ_PROLOGUE();
 8009aa4:	f7f7 fe94 	bl	80017d0 <_dbg_check_enter_isr>
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8009aa8:	4b25      	ldr	r3, [pc, #148]	; (8009b40 <Vector70+0xc0>)
 8009aaa:	4a26      	ldr	r2, [pc, #152]	; (8009b44 <Vector70+0xc4>)
 8009aac:	6819      	ldr	r1, [r3, #0]
 8009aae:	6812      	ldr	r2, [r2, #0]
 8009ab0:	0909      	lsrs	r1, r1, #4
 8009ab2:	f001 010e 	and.w	r1, r1, #14
 8009ab6:	420a      	tst	r2, r1
 8009ab8:	d006      	beq.n	8009ac8 <Vector70+0x48>
 8009aba:	4823      	ldr	r0, [pc, #140]	; (8009b48 <Vector70+0xc8>)
 8009abc:	6882      	ldr	r2, [r0, #8]
 8009abe:	010d      	lsls	r5, r1, #4
 8009ac0:	605d      	str	r5, [r3, #4]
 8009ac2:	b10a      	cbz	r2, 8009ac8 <Vector70+0x48>
 8009ac4:	68c0      	ldr	r0, [r0, #12]
 8009ac6:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8009ac8:	f7f7 fe6a 	bl	80017a0 <_dbg_check_leave_isr>
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009acc:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009ace:	f013 0502 	ands.w	r5, r3, #2
 8009ad2:	d10b      	bne.n	8009aec <Vector70+0x6c>
 8009ad4:	2320      	movs	r3, #32
 8009ad6:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009ada:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009adc:	4a17      	ldr	r2, [pc, #92]	; (8009b3c <Vector70+0xbc>)
 8009ade:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009ae0:	2203      	movs	r2, #3
 8009ae2:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009ae4:	f7f7 fc44 	bl	8001370 <trace_next>
 8009ae8:	f385 8811 	msr	BASEPRI, r5
 8009aec:	2320      	movs	r3, #32
 8009aee:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009af2:	4b16      	ldr	r3, [pc, #88]	; (8009b4c <Vector70+0xcc>)
 8009af4:	685b      	ldr	r3, [r3, #4]
 8009af6:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009afa:	d102      	bne.n	8009b02 <Vector70+0x82>
 8009afc:	f383 8811 	msr	BASEPRI, r3
}
 8009b00:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009b02:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009b06:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009b0a:	4a11      	ldr	r2, [pc, #68]	; (8009b50 <Vector70+0xd0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009b0c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009b10:	68d2      	ldr	r2, [r2, #12]
 8009b12:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009b16:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009b1a:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009b1e:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009b22:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009b24:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009b26:	6889      	ldr	r1, [r1, #8]
 8009b28:	6892      	ldr	r2, [r2, #8]
 8009b2a:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009b2c:	bf8c      	ite	hi
 8009b2e:	4a09      	ldrhi	r2, [pc, #36]	; (8009b54 <Vector70+0xd4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009b30:	4a09      	ldrls	r2, [pc, #36]	; (8009b58 <Vector70+0xd8>)
 8009b32:	f843 2c50 	str.w	r2, [r3, #-80]
 8009b36:	bd38      	pop	{r3, r4, r5, pc}
 8009b38:	2000159c 	.word	0x2000159c
 8009b3c:	0800e3f4 	.word	0x0800e3f4
 8009b40:	40020000 	.word	0x40020000
 8009b44:	4002001c 	.word	0x4002001c
 8009b48:	20001534 	.word	0x20001534
 8009b4c:	e000ed00 	.word	0xe000ed00
 8009b50:	e000ef30 	.word	0xe000ef30
 8009b54:	080002f5 	.word	0x080002f5
 8009b58:	08000300 	.word	0x08000300
 8009b5c:	00000000 	.word	0x00000000

08009b60 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8009b60:	b538      	push	{r3, r4, r5, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009b62:	4c39      	ldr	r4, [pc, #228]	; (8009c48 <Vector6C+0xe8>)
 8009b64:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009b66:	f013 0502 	ands.w	r5, r3, #2
 8009b6a:	d10b      	bne.n	8009b84 <Vector6C+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009b6c:	2320      	movs	r3, #32
 8009b6e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009b72:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009b74:	4a35      	ldr	r2, [pc, #212]	; (8009c4c <Vector6C+0xec>)
 8009b76:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009b78:	2202      	movs	r2, #2
 8009b7a:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009b7c:	f7f7 fbf8 	bl	8001370 <trace_next>
 8009b80:	f385 8811 	msr	BASEPRI, r5
 8009b84:	2320      	movs	r3, #32
 8009b86:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009b8a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009b8c:	2b00      	cmp	r3, #0
 8009b8e:	db01      	blt.n	8009b94 <Vector6C+0x34>
 8009b90:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009b92:	b112      	cbz	r2, 8009b9a <Vector6C+0x3a>
    chSysHalt("SV#8");
 8009b94:	482e      	ldr	r0, [pc, #184]	; (8009c50 <Vector6C+0xf0>)
 8009b96:	f7f7 fc0b 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8009b9a:	3301      	adds	r3, #1
 8009b9c:	6323      	str	r3, [r4, #48]	; 0x30
 8009b9e:	f382 8811 	msr	BASEPRI, r2
  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8009ba2:	4b2c      	ldr	r3, [pc, #176]	; (8009c54 <Vector6C+0xf4>)
 8009ba4:	4a2c      	ldr	r2, [pc, #176]	; (8009c58 <Vector6C+0xf8>)
 8009ba6:	6819      	ldr	r1, [r3, #0]
 8009ba8:	6812      	ldr	r2, [r2, #0]
 8009baa:	f001 010e 	and.w	r1, r1, #14
 8009bae:	420a      	tst	r2, r1
 8009bb0:	d005      	beq.n	8009bbe <Vector6C+0x5e>
 8009bb2:	4a2a      	ldr	r2, [pc, #168]	; (8009c5c <Vector6C+0xfc>)
 8009bb4:	6059      	str	r1, [r3, #4]
 8009bb6:	6813      	ldr	r3, [r2, #0]
 8009bb8:	b10b      	cbz	r3, 8009bbe <Vector6C+0x5e>
 8009bba:	6850      	ldr	r0, [r2, #4]
 8009bbc:	4798      	blx	r3
 8009bbe:	2220      	movs	r2, #32
 8009bc0:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009bc4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009bc6:	2b00      	cmp	r3, #0
 8009bc8:	dd01      	ble.n	8009bce <Vector6C+0x6e>
 8009bca:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8009bcc:	b111      	cbz	r1, 8009bd4 <Vector6C+0x74>
    chSysHalt("SV#9");
 8009bce:	4824      	ldr	r0, [pc, #144]	; (8009c60 <Vector6C+0x100>)
 8009bd0:	f7f7 fbee 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8009bd4:	3b01      	subs	r3, #1
 8009bd6:	6323      	str	r3, [r4, #48]	; 0x30
 8009bd8:	f381 8811 	msr	BASEPRI, r1
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009bdc:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009bde:	f013 0502 	ands.w	r5, r3, #2
 8009be2:	d10a      	bne.n	8009bfa <Vector6C+0x9a>
 8009be4:	f382 8811 	msr	BASEPRI, r2
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009be8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009bea:	4a18      	ldr	r2, [pc, #96]	; (8009c4c <Vector6C+0xec>)
 8009bec:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009bee:	2203      	movs	r2, #3
 8009bf0:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009bf2:	f7f7 fbbd 	bl	8001370 <trace_next>
 8009bf6:	f385 8811 	msr	BASEPRI, r5
 8009bfa:	2320      	movs	r3, #32
 8009bfc:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009c00:	4b18      	ldr	r3, [pc, #96]	; (8009c64 <Vector6C+0x104>)
 8009c02:	685b      	ldr	r3, [r3, #4]
 8009c04:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009c08:	d102      	bne.n	8009c10 <Vector6C+0xb0>
 8009c0a:	f383 8811 	msr	BASEPRI, r3
}
 8009c0e:	bd38      	pop	{r3, r4, r5, pc}
  return __builtin_arm_get_fpscr();
 8009c10:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009c14:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009c18:	4a13      	ldr	r2, [pc, #76]	; (8009c68 <Vector6C+0x108>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009c1a:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009c1e:	68d2      	ldr	r2, [r2, #12]
 8009c20:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009c24:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009c28:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009c2c:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009c30:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009c32:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009c34:	6889      	ldr	r1, [r1, #8]
 8009c36:	6892      	ldr	r2, [r2, #8]
 8009c38:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009c3a:	bf8c      	ite	hi
 8009c3c:	4a0b      	ldrhi	r2, [pc, #44]	; (8009c6c <Vector6C+0x10c>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009c3e:	4a0c      	ldrls	r2, [pc, #48]	; (8009c70 <Vector6C+0x110>)
 8009c40:	f843 2c50 	str.w	r2, [r3, #-80]
 8009c44:	bd38      	pop	{r3, r4, r5, pc}
 8009c46:	bf00      	nop
 8009c48:	2000159c 	.word	0x2000159c
 8009c4c:	0800e3a8 	.word	0x0800e3a8
 8009c50:	0800e59c 	.word	0x0800e59c
 8009c54:	40020000 	.word	0x40020000
 8009c58:	40020008 	.word	0x40020008
 8009c5c:	20001534 	.word	0x20001534
 8009c60:	0800e5a4 	.word	0x0800e5a4
 8009c64:	e000ed00 	.word	0xe000ed00
 8009c68:	e000ef30 	.word	0xe000ef30
 8009c6c:	080002f5 	.word	0x080002f5
 8009c70:	08000300 	.word	0x08000300
	...

08009c80 <Vector134>:
OSAL_IRQ_HANDLER(STM32_ADC4_HANDLER) {
 8009c80:	b570      	push	{r4, r5, r6, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009c82:	4c34      	ldr	r4, [pc, #208]	; (8009d54 <Vector134+0xd4>)
 8009c84:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009c86:	f013 0502 	ands.w	r5, r3, #2
 8009c8a:	d10b      	bne.n	8009ca4 <Vector134+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009c8c:	2320      	movs	r3, #32
 8009c8e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009c92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009c94:	4a30      	ldr	r2, [pc, #192]	; (8009d58 <Vector134+0xd8>)
 8009c96:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009c98:	2202      	movs	r2, #2
 8009c9a:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009c9c:	f7f7 fb68 	bl	8001370 <trace_next>
 8009ca0:	f385 8811 	msr	BASEPRI, r5
 8009ca4:	2520      	movs	r5, #32
 8009ca6:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009caa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009cac:	2b00      	cmp	r3, #0
 8009cae:	db01      	blt.n	8009cb4 <Vector134+0x34>
 8009cb0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009cb2:	b112      	cbz	r2, 8009cba <Vector134+0x3a>
    chSysHalt("SV#8");
 8009cb4:	4829      	ldr	r0, [pc, #164]	; (8009d5c <Vector134+0xdc>)
 8009cb6:	f7f7 fb7b 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8009cba:	3301      	adds	r3, #1
 8009cbc:	6323      	str	r3, [r4, #48]	; 0x30
 8009cbe:	f382 8811 	msr	BASEPRI, r2
  isr  = ADC4->ISR;
 8009cc2:	4b27      	ldr	r3, [pc, #156]	; (8009d60 <Vector134+0xe0>)
  adc_lld_serve_interrupt(&ADCD4, isr);
 8009cc4:	4827      	ldr	r0, [pc, #156]	; (8009d64 <Vector134+0xe4>)
  isr  = ADC4->ISR;
 8009cc6:	6819      	ldr	r1, [r3, #0]
  ADC4->ISR = isr;
 8009cc8:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD4, isr);
 8009cca:	f7f8 f949 	bl	8001f60 <adc_lld_serve_interrupt>
 8009cce:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009cd2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009cd4:	2b00      	cmp	r3, #0
 8009cd6:	dd01      	ble.n	8009cdc <Vector134+0x5c>
 8009cd8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009cda:	b112      	cbz	r2, 8009ce2 <Vector134+0x62>
    chSysHalt("SV#9");
 8009cdc:	4822      	ldr	r0, [pc, #136]	; (8009d68 <Vector134+0xe8>)
 8009cde:	f7f7 fb67 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8009ce2:	3b01      	subs	r3, #1
 8009ce4:	6323      	str	r3, [r4, #48]	; 0x30
 8009ce6:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009cea:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009cec:	f013 0602 	ands.w	r6, r3, #2
 8009cf0:	d10a      	bne.n	8009d08 <Vector134+0x88>
 8009cf2:	f385 8811 	msr	BASEPRI, r5
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009cf6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009cf8:	4a17      	ldr	r2, [pc, #92]	; (8009d58 <Vector134+0xd8>)
 8009cfa:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009cfc:	2203      	movs	r2, #3
 8009cfe:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009d00:	f7f7 fb36 	bl	8001370 <trace_next>
 8009d04:	f386 8811 	msr	BASEPRI, r6
 8009d08:	2320      	movs	r3, #32
 8009d0a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009d0e:	4b17      	ldr	r3, [pc, #92]	; (8009d6c <Vector134+0xec>)
 8009d10:	685b      	ldr	r3, [r3, #4]
 8009d12:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009d16:	d102      	bne.n	8009d1e <Vector134+0x9e>
 8009d18:	f383 8811 	msr	BASEPRI, r3
}
 8009d1c:	bd70      	pop	{r4, r5, r6, pc}
  return __builtin_arm_get_fpscr();
 8009d1e:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009d22:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009d26:	4a12      	ldr	r2, [pc, #72]	; (8009d70 <Vector134+0xf0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009d28:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009d2c:	68d2      	ldr	r2, [r2, #12]
 8009d2e:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009d32:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009d36:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009d3a:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009d3e:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009d40:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009d42:	6889      	ldr	r1, [r1, #8]
 8009d44:	6892      	ldr	r2, [r2, #8]
 8009d46:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009d48:	bf8c      	ite	hi
 8009d4a:	4a0a      	ldrhi	r2, [pc, #40]	; (8009d74 <Vector134+0xf4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009d4c:	4a0a      	ldrls	r2, [pc, #40]	; (8009d78 <Vector134+0xf8>)
 8009d4e:	f843 2c50 	str.w	r2, [r3, #-80]
 8009d52:	bd70      	pop	{r4, r5, r6, pc}
 8009d54:	2000159c 	.word	0x2000159c
 8009d58:	0800e4f0 	.word	0x0800e4f0
 8009d5c:	0800e59c 	.word	0x0800e59c
 8009d60:	50000500 	.word	0x50000500
 8009d64:	20001288 	.word	0x20001288
 8009d68:	0800e5a4 	.word	0x0800e5a4
 8009d6c:	e000ed00 	.word	0xe000ed00
 8009d70:	e000ef30 	.word	0xe000ef30
 8009d74:	080002f5 	.word	0x080002f5
 8009d78:	08000300 	.word	0x08000300
 8009d7c:	00000000 	.word	0x00000000

08009d80 <VectorFC>:
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 8009d80:	b570      	push	{r4, r5, r6, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009d82:	4c34      	ldr	r4, [pc, #208]	; (8009e54 <VectorFC+0xd4>)
 8009d84:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009d86:	f013 0502 	ands.w	r5, r3, #2
 8009d8a:	d10b      	bne.n	8009da4 <VectorFC+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009d8c:	2320      	movs	r3, #32
 8009d8e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009d94:	4a30      	ldr	r2, [pc, #192]	; (8009e58 <VectorFC+0xd8>)
 8009d96:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009d98:	2202      	movs	r2, #2
 8009d9a:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009d9c:	f7f7 fae8 	bl	8001370 <trace_next>
 8009da0:	f385 8811 	msr	BASEPRI, r5
 8009da4:	2520      	movs	r5, #32
 8009da6:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009daa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009dac:	2b00      	cmp	r3, #0
 8009dae:	db01      	blt.n	8009db4 <VectorFC+0x34>
 8009db0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009db2:	b112      	cbz	r2, 8009dba <VectorFC+0x3a>
    chSysHalt("SV#8");
 8009db4:	4829      	ldr	r0, [pc, #164]	; (8009e5c <VectorFC+0xdc>)
 8009db6:	f7f7 fafb 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8009dba:	3301      	adds	r3, #1
 8009dbc:	6323      	str	r3, [r4, #48]	; 0x30
 8009dbe:	f382 8811 	msr	BASEPRI, r2
  isr  = ADC3->ISR;
 8009dc2:	4b27      	ldr	r3, [pc, #156]	; (8009e60 <VectorFC+0xe0>)
  adc_lld_serve_interrupt(&ADCD3, isr);
 8009dc4:	4827      	ldr	r0, [pc, #156]	; (8009e64 <VectorFC+0xe4>)
  isr  = ADC3->ISR;
 8009dc6:	6819      	ldr	r1, [r3, #0]
  ADC3->ISR = isr;
 8009dc8:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD3, isr);
 8009dca:	f7f8 f8c9 	bl	8001f60 <adc_lld_serve_interrupt>
 8009dce:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009dd2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009dd4:	2b00      	cmp	r3, #0
 8009dd6:	dd01      	ble.n	8009ddc <VectorFC+0x5c>
 8009dd8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009dda:	b112      	cbz	r2, 8009de2 <VectorFC+0x62>
    chSysHalt("SV#9");
 8009ddc:	4822      	ldr	r0, [pc, #136]	; (8009e68 <VectorFC+0xe8>)
 8009dde:	f7f7 fae7 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8009de2:	3b01      	subs	r3, #1
 8009de4:	6323      	str	r3, [r4, #48]	; 0x30
 8009de6:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009dea:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009dec:	f013 0602 	ands.w	r6, r3, #2
 8009df0:	d10a      	bne.n	8009e08 <VectorFC+0x88>
 8009df2:	f385 8811 	msr	BASEPRI, r5
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009df6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009df8:	4a17      	ldr	r2, [pc, #92]	; (8009e58 <VectorFC+0xd8>)
 8009dfa:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009dfc:	2203      	movs	r2, #3
 8009dfe:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009e00:	f7f7 fab6 	bl	8001370 <trace_next>
 8009e04:	f386 8811 	msr	BASEPRI, r6
 8009e08:	2320      	movs	r3, #32
 8009e0a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009e0e:	4b17      	ldr	r3, [pc, #92]	; (8009e6c <VectorFC+0xec>)
 8009e10:	685b      	ldr	r3, [r3, #4]
 8009e12:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009e16:	d102      	bne.n	8009e1e <VectorFC+0x9e>
 8009e18:	f383 8811 	msr	BASEPRI, r3
}
 8009e1c:	bd70      	pop	{r4, r5, r6, pc}
  return __builtin_arm_get_fpscr();
 8009e1e:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009e22:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009e26:	4a12      	ldr	r2, [pc, #72]	; (8009e70 <VectorFC+0xf0>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009e28:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009e2c:	68d2      	ldr	r2, [r2, #12]
 8009e2e:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009e32:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009e36:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009e3a:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009e3e:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009e40:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009e42:	6889      	ldr	r1, [r1, #8]
 8009e44:	6892      	ldr	r2, [r2, #8]
 8009e46:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009e48:	bf8c      	ite	hi
 8009e4a:	4a0a      	ldrhi	r2, [pc, #40]	; (8009e74 <VectorFC+0xf4>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009e4c:	4a0a      	ldrls	r2, [pc, #40]	; (8009e78 <VectorFC+0xf8>)
 8009e4e:	f843 2c50 	str.w	r2, [r3, #-80]
 8009e52:	bd70      	pop	{r4, r5, r6, pc}
 8009e54:	2000159c 	.word	0x2000159c
 8009e58:	0800e4d0 	.word	0x0800e4d0
 8009e5c:	0800e59c 	.word	0x0800e59c
 8009e60:	50000400 	.word	0x50000400
 8009e64:	20001250 	.word	0x20001250
 8009e68:	0800e5a4 	.word	0x0800e5a4
 8009e6c:	e000ed00 	.word	0xe000ed00
 8009e70:	e000ef30 	.word	0xe000ef30
 8009e74:	080002f5 	.word	0x080002f5
 8009e78:	08000300 	.word	0x08000300
 8009e7c:	00000000 	.word	0x00000000

08009e80 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8009e80:	b570      	push	{r4, r5, r6, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009e82:	4c38      	ldr	r4, [pc, #224]	; (8009f64 <Vector88+0xe4>)
 8009e84:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009e86:	f013 0502 	ands.w	r5, r3, #2
 8009e8a:	d10b      	bne.n	8009ea4 <Vector88+0x24>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009e8c:	2320      	movs	r3, #32
 8009e8e:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009e92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009e94:	4a34      	ldr	r2, [pc, #208]	; (8009f68 <Vector88+0xe8>)
 8009e96:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8009e98:	2202      	movs	r2, #2
 8009e9a:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009e9c:	f7f7 fa68 	bl	8001370 <trace_next>
 8009ea0:	f385 8811 	msr	BASEPRI, r5
 8009ea4:	2520      	movs	r5, #32
 8009ea6:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009eaa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009eac:	2b00      	cmp	r3, #0
 8009eae:	db01      	blt.n	8009eb4 <Vector88+0x34>
 8009eb0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009eb2:	b112      	cbz	r2, 8009eba <Vector88+0x3a>
    chSysHalt("SV#8");
 8009eb4:	482d      	ldr	r0, [pc, #180]	; (8009f6c <Vector88+0xec>)
 8009eb6:	f7f7 fa7b 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt++;
 8009eba:	3301      	adds	r3, #1
 8009ebc:	6323      	str	r3, [r4, #48]	; 0x30
 8009ebe:	f382 8811 	msr	BASEPRI, r2
  isr  = ADC1->ISR;
 8009ec2:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  adc_lld_serve_interrupt(&ADCD1, isr);
 8009ec6:	482a      	ldr	r0, [pc, #168]	; (8009f70 <Vector88+0xf0>)
  isr  = ADC1->ISR;
 8009ec8:	6819      	ldr	r1, [r3, #0]
  ADC1->ISR = isr;
 8009eca:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD1, isr);
 8009ecc:	f7f8 f848 	bl	8001f60 <adc_lld_serve_interrupt>
  isr  = ADC2->ISR;
 8009ed0:	4b28      	ldr	r3, [pc, #160]	; (8009f74 <Vector88+0xf4>)
  adc_lld_serve_interrupt(&ADCD2, isr);
 8009ed2:	4829      	ldr	r0, [pc, #164]	; (8009f78 <Vector88+0xf8>)
  isr  = ADC2->ISR;
 8009ed4:	6819      	ldr	r1, [r3, #0]
  ADC2->ISR = isr;
 8009ed6:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD2, isr);
 8009ed8:	f7f8 f842 	bl	8001f60 <adc_lld_serve_interrupt>
 8009edc:	f385 8811 	msr	BASEPRI, r5
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009ee0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009ee2:	2b00      	cmp	r3, #0
 8009ee4:	dd01      	ble.n	8009eea <Vector88+0x6a>
 8009ee6:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8009ee8:	b112      	cbz	r2, 8009ef0 <Vector88+0x70>
    chSysHalt("SV#9");
 8009eea:	4824      	ldr	r0, [pc, #144]	; (8009f7c <Vector88+0xfc>)
 8009eec:	f7f7 fa60 	bl	80013b0 <chSysHalt>
  ch.dbg.isr_cnt--;
 8009ef0:	3b01      	subs	r3, #1
 8009ef2:	6323      	str	r3, [r4, #48]	; 0x30
 8009ef4:	f382 8811 	msr	BASEPRI, r2
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8009ef8:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8009efa:	f013 0602 	ands.w	r6, r3, #2
 8009efe:	d10a      	bne.n	8009f16 <Vector88+0x96>
 8009f00:	f385 8811 	msr	BASEPRI, r5
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009f04:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8009f06:	4a18      	ldr	r2, [pc, #96]	; (8009f68 <Vector88+0xe8>)
 8009f08:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8009f0a:	2203      	movs	r2, #3
 8009f0c:	701a      	strb	r2, [r3, #0]
    trace_next();
 8009f0e:	f7f7 fa2f 	bl	8001370 <trace_next>
 8009f12:	f386 8811 	msr	BASEPRI, r6
 8009f16:	2320      	movs	r3, #32
 8009f18:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009f1c:	4b18      	ldr	r3, [pc, #96]	; (8009f80 <Vector88+0x100>)
 8009f1e:	685b      	ldr	r3, [r3, #4]
 8009f20:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8009f24:	d102      	bne.n	8009f2c <Vector88+0xac>
 8009f26:	f383 8811 	msr	BASEPRI, r3
}
 8009f2a:	bd70      	pop	{r4, r5, r6, pc}
  return __builtin_arm_get_fpscr();
 8009f2c:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8009f30:	f3ef 8309 	mrs	r3, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009f34:	4a13      	ldr	r2, [pc, #76]	; (8009f84 <Vector88+0x104>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8009f36:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8009f3a:	68d2      	ldr	r2, [r2, #12]
 8009f3c:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8009f40:	f843 1c4c 	str.w	r1, [r3, #-76]
    ctxp--;
 8009f44:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8009f48:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8009f4c:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8009f4e:	69a2      	ldr	r2, [r4, #24]
    if (chSchIsPreemptionRequired()) {
 8009f50:	6889      	ldr	r1, [r1, #8]
 8009f52:	6892      	ldr	r2, [r2, #8]
 8009f54:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009f56:	bf8c      	ite	hi
 8009f58:	4a0b      	ldrhi	r2, [pc, #44]	; (8009f88 <Vector88+0x108>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8009f5a:	4a0c      	ldrls	r2, [pc, #48]	; (8009f8c <Vector88+0x10c>)
 8009f5c:	f843 2c50 	str.w	r2, [r3, #-80]
 8009f60:	bd70      	pop	{r4, r5, r6, pc}
 8009f62:	bf00      	nop
 8009f64:	2000159c 	.word	0x2000159c
 8009f68:	0800e4b8 	.word	0x0800e4b8
 8009f6c:	0800e59c 	.word	0x0800e59c
 8009f70:	200011e0 	.word	0x200011e0
 8009f74:	50000100 	.word	0x50000100
 8009f78:	20001218 	.word	0x20001218
 8009f7c:	0800e5a4 	.word	0x0800e5a4
 8009f80:	e000ed00 	.word	0xe000ed00
 8009f84:	e000ef30 	.word	0xe000ef30
 8009f88:	080002f5 	.word	0x080002f5
 8009f8c:	08000300 	.word	0x08000300

08009f90 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8009f90:	b570      	push	{r4, r5, r6, lr}
 8009f92:	4d13      	ldr	r5, [pc, #76]	; (8009fe0 <__init_ram_areas+0x50>)
 8009f94:	f105 0680 	add.w	r6, r5, #128	; 0x80
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8009f98:	e955 0403 	ldrd	r0, r4, [r5, #-12]
 8009f9c:	42a0      	cmp	r0, r4
    uint32_t *tp = rap->init_text_area;
 8009f9e:	f855 2c10 	ldr.w	r2, [r5, #-16]
    while (p < rap->clear_area) {
 8009fa2:	d20d      	bcs.n	8009fc0 <__init_ram_areas+0x30>
 8009fa4:	3a04      	subs	r2, #4
 8009fa6:	4603      	mov	r3, r0
      *p = *tp;
 8009fa8:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8009fac:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->clear_area) {
 8009fb0:	42a3      	cmp	r3, r4
 8009fb2:	d3f9      	bcc.n	8009fa8 <__init_ram_areas+0x18>
 8009fb4:	43c3      	mvns	r3, r0
 8009fb6:	441c      	add	r4, r3
 8009fb8:	f024 0403 	bic.w	r4, r4, #3
 8009fbc:	3404      	adds	r4, #4
 8009fbe:	4420      	add	r0, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8009fc0:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8009fc4:	4283      	cmp	r3, r0
 8009fc6:	d907      	bls.n	8009fd8 <__init_ram_areas+0x48>
      *p = 0;
 8009fc8:	43c2      	mvns	r2, r0
 8009fca:	441a      	add	r2, r3
 8009fcc:	f022 0203 	bic.w	r2, r2, #3
 8009fd0:	3204      	adds	r2, #4
 8009fd2:	2100      	movs	r1, #0
 8009fd4:	f000 f94c 	bl	800a270 <memset>
 8009fd8:	3510      	adds	r5, #16
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8009fda:	42b5      	cmp	r5, r6
 8009fdc:	d1dc      	bne.n	8009f98 <__init_ram_areas+0x8>
#endif
}
 8009fde:	bd70      	pop	{r4, r5, r6, pc}
 8009fe0:	0801d92c 	.word	0x0801d92c
	...

08009ff0 <__default_exit>:
void __default_exit(void) {
 8009ff0:	e7fe      	b.n	8009ff0 <__default_exit>
 8009ff2:	bf00      	nop
	...

0800a000 <__late_init>:
 800a000:	4770      	bx	lr
 800a002:	bf00      	nop
	...

0800a010 <__core_init>:
}
 800a010:	4770      	bx	lr
 800a012:	bf00      	nop

0800a014 <sqrt>:
 800a014:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a018:	ed2d 8b02 	vpush	{d8}
 800a01c:	b08b      	sub	sp, #44	; 0x2c
 800a01e:	ec55 4b10 	vmov	r4, r5, d0
 800a022:	f000 f853 	bl	800a0cc <__ieee754_sqrt>
 800a026:	4b27      	ldr	r3, [pc, #156]	; (800a0c4 <sqrt+0xb0>)
 800a028:	eeb0 8a40 	vmov.f32	s16, s0
 800a02c:	eef0 8a60 	vmov.f32	s17, s1
 800a030:	f993 6000 	ldrsb.w	r6, [r3]
 800a034:	1c73      	adds	r3, r6, #1
 800a036:	d012      	beq.n	800a05e <sqrt+0x4a>
 800a038:	4622      	mov	r2, r4
 800a03a:	462b      	mov	r3, r5
 800a03c:	4620      	mov	r0, r4
 800a03e:	4629      	mov	r1, r5
 800a040:	f7f6 fdb6 	bl	8000bb0 <__aeabi_dcmpun>
 800a044:	4607      	mov	r7, r0
 800a046:	b950      	cbnz	r0, 800a05e <sqrt+0x4a>
 800a048:	f04f 0800 	mov.w	r8, #0
 800a04c:	f04f 0900 	mov.w	r9, #0
 800a050:	4620      	mov	r0, r4
 800a052:	4629      	mov	r1, r5
 800a054:	4642      	mov	r2, r8
 800a056:	464b      	mov	r3, r9
 800a058:	f7f6 fd82 	bl	8000b60 <__aeabi_dcmplt>
 800a05c:	b940      	cbnz	r0, 800a070 <sqrt+0x5c>
 800a05e:	eeb0 0a48 	vmov.f32	s0, s16
 800a062:	eef0 0a68 	vmov.f32	s1, s17
 800a066:	b00b      	add	sp, #44	; 0x2c
 800a068:	ecbd 8b02 	vpop	{d8}
 800a06c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a070:	2201      	movs	r2, #1
 800a072:	4b15      	ldr	r3, [pc, #84]	; (800a0c8 <sqrt+0xb4>)
 800a074:	9708      	str	r7, [sp, #32]
 800a076:	9200      	str	r2, [sp, #0]
 800a078:	e9cd 4504 	strd	r4, r5, [sp, #16]
 800a07c:	e9cd 4502 	strd	r4, r5, [sp, #8]
 800a080:	9301      	str	r3, [sp, #4]
 800a082:	b196      	cbz	r6, 800a0aa <sqrt+0x96>
 800a084:	4642      	mov	r2, r8
 800a086:	464b      	mov	r3, r9
 800a088:	4640      	mov	r0, r8
 800a08a:	4649      	mov	r1, r9
 800a08c:	f7f6 fc20 	bl	80008d0 <__aeabi_ddiv>
 800a090:	2e02      	cmp	r6, #2
 800a092:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800a096:	d10a      	bne.n	800a0ae <sqrt+0x9a>
 800a098:	f000 f8e4 	bl	800a264 <__errno>
 800a09c:	2321      	movs	r3, #33	; 0x21
 800a09e:	6003      	str	r3, [r0, #0]
 800a0a0:	9b08      	ldr	r3, [sp, #32]
 800a0a2:	b953      	cbnz	r3, 800a0ba <sqrt+0xa6>
 800a0a4:	ed9d 8b06 	vldr	d8, [sp, #24]
 800a0a8:	e7d9      	b.n	800a05e <sqrt+0x4a>
 800a0aa:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800a0ae:	4668      	mov	r0, sp
 800a0b0:	f000 f8d6 	bl	800a260 <matherr>
 800a0b4:	2800      	cmp	r0, #0
 800a0b6:	d1f3      	bne.n	800a0a0 <sqrt+0x8c>
 800a0b8:	e7ee      	b.n	800a098 <sqrt+0x84>
 800a0ba:	f000 f8d3 	bl	800a264 <__errno>
 800a0be:	9b08      	ldr	r3, [sp, #32]
 800a0c0:	6003      	str	r3, [r0, #0]
 800a0c2:	e7ef      	b.n	800a0a4 <sqrt+0x90>
 800a0c4:	20000830 	.word	0x20000830
 800a0c8:	0801dc04 	.word	0x0801dc04

0800a0cc <__ieee754_sqrt>:
 800a0cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a0d0:	4a62      	ldr	r2, [pc, #392]	; (800a25c <__ieee754_sqrt+0x190>)
 800a0d2:	ec57 6b10 	vmov	r6, r7, d0
 800a0d6:	43ba      	bics	r2, r7
 800a0d8:	f000 8095 	beq.w	800a206 <__ieee754_sqrt+0x13a>
 800a0dc:	2f00      	cmp	r7, #0
 800a0de:	463b      	mov	r3, r7
 800a0e0:	ee10 1a10 	vmov	r1, s0
 800a0e4:	4634      	mov	r4, r6
 800a0e6:	dd54      	ble.n	800a192 <__ieee754_sqrt+0xc6>
 800a0e8:	153f      	asrs	r7, r7, #20
 800a0ea:	f000 80af 	beq.w	800a24c <__ieee754_sqrt+0x180>
 800a0ee:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800a0f2:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 800a0f6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a0fa:	0fe2      	lsrs	r2, r4, #31
 800a0fc:	07f9      	lsls	r1, r7, #31
 800a0fe:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800a102:	ea4f 0544 	mov.w	r5, r4, lsl #1
 800a106:	d503      	bpl.n	800a110 <__ieee754_sqrt+0x44>
 800a108:	0fed      	lsrs	r5, r5, #31
 800a10a:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800a10e:	00a5      	lsls	r5, r4, #2
 800a110:	2600      	movs	r6, #0
 800a112:	107f      	asrs	r7, r7, #1
 800a114:	46b4      	mov	ip, r6
 800a116:	2216      	movs	r2, #22
 800a118:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800a11c:	eb0c 0001 	add.w	r0, ip, r1
 800a120:	4298      	cmp	r0, r3
 800a122:	ea4f 74d5 	mov.w	r4, r5, lsr #31
 800a126:	ea4f 0545 	mov.w	r5, r5, lsl #1
 800a12a:	dc03      	bgt.n	800a134 <__ieee754_sqrt+0x68>
 800a12c:	1a1b      	subs	r3, r3, r0
 800a12e:	eb00 0c01 	add.w	ip, r0, r1
 800a132:	440e      	add	r6, r1
 800a134:	3a01      	subs	r2, #1
 800a136:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 800a13a:	ea4f 0151 	mov.w	r1, r1, lsr #1
 800a13e:	d1ed      	bne.n	800a11c <__ieee754_sqrt+0x50>
 800a140:	4610      	mov	r0, r2
 800a142:	4696      	mov	lr, r2
 800a144:	2420      	movs	r4, #32
 800a146:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800a14a:	e009      	b.n	800a160 <__ieee754_sqrt+0x94>
 800a14c:	d052      	beq.n	800a1f4 <__ieee754_sqrt+0x128>
 800a14e:	005b      	lsls	r3, r3, #1
 800a150:	3c01      	subs	r4, #1
 800a152:	eb03 73d5 	add.w	r3, r3, r5, lsr #31
 800a156:	ea4f 0252 	mov.w	r2, r2, lsr #1
 800a15a:	ea4f 0545 	mov.w	r5, r5, lsl #1
 800a15e:	d036      	beq.n	800a1ce <__ieee754_sqrt+0x102>
 800a160:	4563      	cmp	r3, ip
 800a162:	eb02 010e 	add.w	r1, r2, lr
 800a166:	ddf1      	ble.n	800a14c <__ieee754_sqrt+0x80>
 800a168:	2900      	cmp	r1, #0
 800a16a:	eb01 0e02 	add.w	lr, r1, r2
 800a16e:	db0a      	blt.n	800a186 <__ieee754_sqrt+0xba>
 800a170:	46e0      	mov	r8, ip
 800a172:	eba3 030c 	sub.w	r3, r3, ip
 800a176:	42a9      	cmp	r1, r5
 800a178:	bf88      	it	hi
 800a17a:	f103 33ff 	addhi.w	r3, r3, #4294967295	; 0xffffffff
 800a17e:	1a6d      	subs	r5, r5, r1
 800a180:	4410      	add	r0, r2
 800a182:	46c4      	mov	ip, r8
 800a184:	e7e3      	b.n	800a14e <__ieee754_sqrt+0x82>
 800a186:	f1be 0f00 	cmp.w	lr, #0
 800a18a:	dbf1      	blt.n	800a170 <__ieee754_sqrt+0xa4>
 800a18c:	f10c 0801 	add.w	r8, ip, #1
 800a190:	e7ef      	b.n	800a172 <__ieee754_sqrt+0xa6>
 800a192:	f027 4200 	bic.w	r2, r7, #2147483648	; 0x80000000
 800a196:	4332      	orrs	r2, r6
 800a198:	d02a      	beq.n	800a1f0 <__ieee754_sqrt+0x124>
 800a19a:	2f00      	cmp	r7, #0
 800a19c:	d149      	bne.n	800a232 <__ieee754_sqrt+0x166>
 800a19e:	0aca      	lsrs	r2, r1, #11
 800a1a0:	3b15      	subs	r3, #21
 800a1a2:	0549      	lsls	r1, r1, #21
 800a1a4:	2a00      	cmp	r2, #0
 800a1a6:	d0fa      	beq.n	800a19e <__ieee754_sqrt+0xd2>
 800a1a8:	f412 1080 	ands.w	r0, r2, #1048576	; 0x100000
 800a1ac:	d001      	beq.n	800a1b2 <__ieee754_sqrt+0xe6>
 800a1ae:	e050      	b.n	800a252 <__ieee754_sqrt+0x186>
 800a1b0:	4620      	mov	r0, r4
 800a1b2:	0052      	lsls	r2, r2, #1
 800a1b4:	02d5      	lsls	r5, r2, #11
 800a1b6:	f100 0401 	add.w	r4, r0, #1
 800a1ba:	d5f9      	bpl.n	800a1b0 <__ieee754_sqrt+0xe4>
 800a1bc:	f1c4 0520 	rsb	r5, r4, #32
 800a1c0:	fa01 f404 	lsl.w	r4, r1, r4
 800a1c4:	40e9      	lsrs	r1, r5
 800a1c6:	1a1f      	subs	r7, r3, r0
 800a1c8:	ea41 0302 	orr.w	r3, r1, r2
 800a1cc:	e78f      	b.n	800a0ee <__ieee754_sqrt+0x22>
 800a1ce:	432b      	orrs	r3, r5
 800a1d0:	d129      	bne.n	800a226 <__ieee754_sqrt+0x15a>
 800a1d2:	0844      	lsrs	r4, r0, #1
 800a1d4:	1071      	asrs	r1, r6, #1
 800a1d6:	07f3      	lsls	r3, r6, #31
 800a1d8:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
 800a1dc:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
 800a1e0:	bf48      	it	mi
 800a1e2:	f044 4400 	orrmi.w	r4, r4, #2147483648	; 0x80000000
 800a1e6:	eb01 5307 	add.w	r3, r1, r7, lsl #20
 800a1ea:	4622      	mov	r2, r4
 800a1ec:	ec43 2b10 	vmov	d0, r2, r3
 800a1f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a1f4:	42a9      	cmp	r1, r5
 800a1f6:	d8aa      	bhi.n	800a14e <__ieee754_sqrt+0x82>
 800a1f8:	2900      	cmp	r1, #0
 800a1fa:	eb01 0e02 	add.w	lr, r1, r2
 800a1fe:	dbc2      	blt.n	800a186 <__ieee754_sqrt+0xba>
 800a200:	4698      	mov	r8, r3
 800a202:	2300      	movs	r3, #0
 800a204:	e7bb      	b.n	800a17e <__ieee754_sqrt+0xb2>
 800a206:	ee10 2a10 	vmov	r2, s0
 800a20a:	463b      	mov	r3, r7
 800a20c:	ee10 0a10 	vmov	r0, s0
 800a210:	4639      	mov	r1, r7
 800a212:	f7f6 fa33 	bl	800067c <__aeabi_dmul>
 800a216:	4632      	mov	r2, r6
 800a218:	463b      	mov	r3, r7
 800a21a:	f7f6 f879 	bl	8000310 <__adddf3>
 800a21e:	ec41 0b10 	vmov	d0, r0, r1
 800a222:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a226:	1c42      	adds	r2, r0, #1
 800a228:	bf16      	itet	ne
 800a22a:	1c42      	addne	r2, r0, #1
 800a22c:	3601      	addeq	r6, #1
 800a22e:	0854      	lsrne	r4, r2, #1
 800a230:	e7d0      	b.n	800a1d4 <__ieee754_sqrt+0x108>
 800a232:	ee10 2a10 	vmov	r2, s0
 800a236:	4630      	mov	r0, r6
 800a238:	4639      	mov	r1, r7
 800a23a:	f7f6 f867 	bl	800030c <__aeabi_dsub>
 800a23e:	4602      	mov	r2, r0
 800a240:	460b      	mov	r3, r1
 800a242:	f7f6 fb45 	bl	80008d0 <__aeabi_ddiv>
 800a246:	ec41 0b10 	vmov	d0, r0, r1
 800a24a:	e7d1      	b.n	800a1f0 <__ieee754_sqrt+0x124>
 800a24c:	461a      	mov	r2, r3
 800a24e:	463b      	mov	r3, r7
 800a250:	e7aa      	b.n	800a1a8 <__ieee754_sqrt+0xdc>
 800a252:	460c      	mov	r4, r1
 800a254:	2520      	movs	r5, #32
 800a256:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a25a:	e7b3      	b.n	800a1c4 <__ieee754_sqrt+0xf8>
 800a25c:	7ff00000 	.word	0x7ff00000

0800a260 <matherr>:
 800a260:	2000      	movs	r0, #0
 800a262:	4770      	bx	lr

0800a264 <__errno>:
 800a264:	4b01      	ldr	r3, [pc, #4]	; (800a26c <__errno+0x8>)
 800a266:	6818      	ldr	r0, [r3, #0]
 800a268:	4770      	bx	lr
 800a26a:	bf00      	nop
 800a26c:	20000834 	.word	0x20000834

0800a270 <memset>:
 800a270:	b4f0      	push	{r4, r5, r6, r7}
 800a272:	0786      	lsls	r6, r0, #30
 800a274:	d043      	beq.n	800a2fe <memset+0x8e>
 800a276:	1e54      	subs	r4, r2, #1
 800a278:	2a00      	cmp	r2, #0
 800a27a:	d03e      	beq.n	800a2fa <memset+0x8a>
 800a27c:	b2ca      	uxtb	r2, r1
 800a27e:	4603      	mov	r3, r0
 800a280:	e002      	b.n	800a288 <memset+0x18>
 800a282:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 800a286:	d338      	bcc.n	800a2fa <memset+0x8a>
 800a288:	f803 2b01 	strb.w	r2, [r3], #1
 800a28c:	079d      	lsls	r5, r3, #30
 800a28e:	d1f8      	bne.n	800a282 <memset+0x12>
 800a290:	2c03      	cmp	r4, #3
 800a292:	d92b      	bls.n	800a2ec <memset+0x7c>
 800a294:	b2cd      	uxtb	r5, r1
 800a296:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800a29a:	2c0f      	cmp	r4, #15
 800a29c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800a2a0:	d916      	bls.n	800a2d0 <memset+0x60>
 800a2a2:	f1a4 0710 	sub.w	r7, r4, #16
 800a2a6:	093f      	lsrs	r7, r7, #4
 800a2a8:	f103 0620 	add.w	r6, r3, #32
 800a2ac:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 800a2b0:	f103 0210 	add.w	r2, r3, #16
 800a2b4:	e942 5504 	strd	r5, r5, [r2, #-16]
 800a2b8:	e942 5502 	strd	r5, r5, [r2, #-8]
 800a2bc:	3210      	adds	r2, #16
 800a2be:	42b2      	cmp	r2, r6
 800a2c0:	d1f8      	bne.n	800a2b4 <memset+0x44>
 800a2c2:	f004 040f 	and.w	r4, r4, #15
 800a2c6:	3701      	adds	r7, #1
 800a2c8:	2c03      	cmp	r4, #3
 800a2ca:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800a2ce:	d90d      	bls.n	800a2ec <memset+0x7c>
 800a2d0:	461e      	mov	r6, r3
 800a2d2:	4622      	mov	r2, r4
 800a2d4:	3a04      	subs	r2, #4
 800a2d6:	2a03      	cmp	r2, #3
 800a2d8:	f846 5b04 	str.w	r5, [r6], #4
 800a2dc:	d8fa      	bhi.n	800a2d4 <memset+0x64>
 800a2de:	1f22      	subs	r2, r4, #4
 800a2e0:	f022 0203 	bic.w	r2, r2, #3
 800a2e4:	3204      	adds	r2, #4
 800a2e6:	4413      	add	r3, r2
 800a2e8:	f004 0403 	and.w	r4, r4, #3
 800a2ec:	b12c      	cbz	r4, 800a2fa <memset+0x8a>
 800a2ee:	b2c9      	uxtb	r1, r1
 800a2f0:	441c      	add	r4, r3
 800a2f2:	f803 1b01 	strb.w	r1, [r3], #1
 800a2f6:	429c      	cmp	r4, r3
 800a2f8:	d1fb      	bne.n	800a2f2 <memset+0x82>
 800a2fa:	bcf0      	pop	{r4, r5, r6, r7}
 800a2fc:	4770      	bx	lr
 800a2fe:	4614      	mov	r4, r2
 800a300:	4603      	mov	r3, r0
 800a302:	e7c5      	b.n	800a290 <memset+0x20>

0800a304 <sprintf>:
 800a304:	b40e      	push	{r1, r2, r3}
 800a306:	b530      	push	{r4, r5, lr}
 800a308:	b09c      	sub	sp, #112	; 0x70
 800a30a:	ab1f      	add	r3, sp, #124	; 0x7c
 800a30c:	4c0c      	ldr	r4, [pc, #48]	; (800a340 <sprintf+0x3c>)
 800a30e:	4d0d      	ldr	r5, [pc, #52]	; (800a344 <sprintf+0x40>)
 800a310:	f853 2b04 	ldr.w	r2, [r3], #4
 800a314:	9301      	str	r3, [sp, #4]
 800a316:	4601      	mov	r1, r0
 800a318:	9102      	str	r1, [sp, #8]
 800a31a:	9106      	str	r1, [sp, #24]
 800a31c:	6820      	ldr	r0, [r4, #0]
 800a31e:	a902      	add	r1, sp, #8
 800a320:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800a324:	9407      	str	r4, [sp, #28]
 800a326:	e9cd 4504 	strd	r4, r5, [sp, #16]
 800a32a:	f000 f80d 	bl	800a348 <_svfprintf_r>
 800a32e:	9b02      	ldr	r3, [sp, #8]
 800a330:	2200      	movs	r2, #0
 800a332:	701a      	strb	r2, [r3, #0]
 800a334:	b01c      	add	sp, #112	; 0x70
 800a336:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800a33a:	b003      	add	sp, #12
 800a33c:	4770      	bx	lr
 800a33e:	bf00      	nop
 800a340:	20000834 	.word	0x20000834
 800a344:	ffff0208 	.word	0xffff0208

0800a348 <_svfprintf_r>:
 800a348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a34c:	b0d7      	sub	sp, #348	; 0x15c
 800a34e:	460c      	mov	r4, r1
 800a350:	9106      	str	r1, [sp, #24]
 800a352:	4693      	mov	fp, r2
 800a354:	9309      	str	r3, [sp, #36]	; 0x24
 800a356:	9003      	str	r0, [sp, #12]
 800a358:	f002 fdc2 	bl	800cee0 <_localeconv_r>
 800a35c:	6803      	ldr	r3, [r0, #0]
 800a35e:	9317      	str	r3, [sp, #92]	; 0x5c
 800a360:	4618      	mov	r0, r3
 800a362:	f7f6 fd4d 	bl	8000e00 <strlen>
 800a366:	89a3      	ldrh	r3, [r4, #12]
 800a368:	9016      	str	r0, [sp, #88]	; 0x58
 800a36a:	061f      	lsls	r7, r3, #24
 800a36c:	d503      	bpl.n	800a376 <_svfprintf_r+0x2e>
 800a36e:	6923      	ldr	r3, [r4, #16]
 800a370:	2b00      	cmp	r3, #0
 800a372:	f000 8755 	beq.w	800b220 <_svfprintf_r+0xed8>
 800a376:	2300      	movs	r3, #0
 800a378:	465e      	mov	r6, fp
 800a37a:	ed9f 7b8f 	vldr	d7, [pc, #572]	; 800a5b8 <_svfprintf_r+0x270>
 800a37e:	9310      	str	r3, [sp, #64]	; 0x40
 800a380:	e9cd 332b 	strd	r3, r3, [sp, #172]	; 0xac
 800a384:	9315      	str	r3, [sp, #84]	; 0x54
 800a386:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
 800a38a:	931b      	str	r3, [sp, #108]	; 0x6c
 800a38c:	9318      	str	r3, [sp, #96]	; 0x60
 800a38e:	9305      	str	r3, [sp, #20]
 800a390:	ab2d      	add	r3, sp, #180	; 0xb4
 800a392:	932a      	str	r3, [sp, #168]	; 0xa8
 800a394:	4699      	mov	r9, r3
 800a396:	7833      	ldrb	r3, [r6, #0]
 800a398:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 800a39c:	2b00      	cmp	r3, #0
 800a39e:	f000 82ce 	beq.w	800a93e <_svfprintf_r+0x5f6>
 800a3a2:	2b25      	cmp	r3, #37	; 0x25
 800a3a4:	4634      	mov	r4, r6
 800a3a6:	d102      	bne.n	800a3ae <_svfprintf_r+0x66>
 800a3a8:	e01c      	b.n	800a3e4 <_svfprintf_r+0x9c>
 800a3aa:	2b25      	cmp	r3, #37	; 0x25
 800a3ac:	d003      	beq.n	800a3b6 <_svfprintf_r+0x6e>
 800a3ae:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800a3b2:	2b00      	cmp	r3, #0
 800a3b4:	d1f9      	bne.n	800a3aa <_svfprintf_r+0x62>
 800a3b6:	1ba5      	subs	r5, r4, r6
 800a3b8:	b185      	cbz	r5, 800a3dc <_svfprintf_r+0x94>
 800a3ba:	e9dd 322b 	ldrd	r3, r2, [sp, #172]	; 0xac
 800a3be:	3301      	adds	r3, #1
 800a3c0:	442a      	add	r2, r5
 800a3c2:	2b07      	cmp	r3, #7
 800a3c4:	f8c9 6000 	str.w	r6, [r9]
 800a3c8:	f8c9 5004 	str.w	r5, [r9, #4]
 800a3cc:	e9cd 322b 	strd	r3, r2, [sp, #172]	; 0xac
 800a3d0:	dc7c      	bgt.n	800a4cc <_svfprintf_r+0x184>
 800a3d2:	f109 0908 	add.w	r9, r9, #8
 800a3d6:	9b05      	ldr	r3, [sp, #20]
 800a3d8:	442b      	add	r3, r5
 800a3da:	9305      	str	r3, [sp, #20]
 800a3dc:	7823      	ldrb	r3, [r4, #0]
 800a3de:	2b00      	cmp	r3, #0
 800a3e0:	f000 82ad 	beq.w	800a93e <_svfprintf_r+0x5f6>
 800a3e4:	2300      	movs	r3, #0
 800a3e6:	7867      	ldrb	r7, [r4, #1]
 800a3e8:	9307      	str	r3, [sp, #28]
 800a3ea:	4698      	mov	r8, r3
 800a3ec:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 800a3f0:	f104 0b01 	add.w	fp, r4, #1
 800a3f4:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 800a3f8:	252b      	movs	r5, #43	; 0x2b
 800a3fa:	f10b 0b01 	add.w	fp, fp, #1
 800a3fe:	f1a7 0320 	sub.w	r3, r7, #32
 800a402:	2b5a      	cmp	r3, #90	; 0x5a
 800a404:	f200 83e4 	bhi.w	800abd0 <_svfprintf_r+0x888>
 800a408:	e8df f013 	tbh	[pc, r3, lsl #1]
 800a40c:	03e203a5 	.word	0x03e203a5
 800a410:	03a003e2 	.word	0x03a003e2
 800a414:	03e203e2 	.word	0x03e203e2
 800a418:	038103e2 	.word	0x038103e2
 800a41c:	03e203e2 	.word	0x03e203e2
 800a420:	03b003b5 	.word	0x03b003b5
 800a424:	017203e2 	.word	0x017203e2
 800a428:	03e20158 	.word	0x03e20158
 800a42c:	00c6033b 	.word	0x00c6033b
 800a430:	00c600c6 	.word	0x00c600c6
 800a434:	00c600c6 	.word	0x00c600c6
 800a438:	00c600c6 	.word	0x00c600c6
 800a43c:	00c600c6 	.word	0x00c600c6
 800a440:	03e203e2 	.word	0x03e203e2
 800a444:	03e203e2 	.word	0x03e203e2
 800a448:	03e203e2 	.word	0x03e203e2
 800a44c:	034003e2 	.word	0x034003e2
 800a450:	017703e2 	.word	0x017703e2
 800a454:	034002f0 	.word	0x034002f0
 800a458:	03400340 	.word	0x03400340
 800a45c:	03e203e2 	.word	0x03e203e2
 800a460:	03e203e2 	.word	0x03e203e2
 800a464:	03e202eb 	.word	0x03e202eb
 800a468:	008403e2 	.word	0x008403e2
 800a46c:	03e203e2 	.word	0x03e203e2
 800a470:	02c203e2 	.word	0x02c203e2
 800a474:	03ce03e2 	.word	0x03ce03e2
 800a478:	03e203e2 	.word	0x03e203e2
 800a47c:	03e202ac 	.word	0x03e202ac
 800a480:	03e203e2 	.word	0x03e203e2
 800a484:	03e203e2 	.word	0x03e203e2
 800a488:	03e203e2 	.word	0x03e203e2
 800a48c:	034003e2 	.word	0x034003e2
 800a490:	017703e2 	.word	0x017703e2
 800a494:	034000da 	.word	0x034000da
 800a498:	03400340 	.word	0x03400340
 800a49c:	00da03c1 	.word	0x00da03c1
 800a4a0:	03e2005b 	.word	0x03e2005b
 800a4a4:	03e2031e 	.word	0x03e2031e
 800a4a8:	00860306 	.word	0x00860306
 800a4ac:	005b032b 	.word	0x005b032b
 800a4b0:	02c203e2 	.word	0x02c203e2
 800a4b4:	0129005d 	.word	0x0129005d
 800a4b8:	03e203e2 	.word	0x03e203e2
 800a4bc:	03e20138 	.word	0x03e20138
 800a4c0:	005d      	.short	0x005d
 800a4c2:	f048 0820 	orr.w	r8, r8, #32
 800a4c6:	f89b 7000 	ldrb.w	r7, [fp]
 800a4ca:	e796      	b.n	800a3fa <_svfprintf_r+0xb2>
 800a4cc:	aa2a      	add	r2, sp, #168	; 0xa8
 800a4ce:	9906      	ldr	r1, [sp, #24]
 800a4d0:	9803      	ldr	r0, [sp, #12]
 800a4d2:	f003 fb33 	bl	800db3c <__ssprint_r>
 800a4d6:	b980      	cbnz	r0, 800a4fa <_svfprintf_r+0x1b2>
 800a4d8:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800a4dc:	e77b      	b.n	800a3d6 <_svfprintf_r+0x8e>
 800a4de:	aa2a      	add	r2, sp, #168	; 0xa8
 800a4e0:	4659      	mov	r1, fp
 800a4e2:	4650      	mov	r0, sl
 800a4e4:	f003 fb2a 	bl	800db3c <__ssprint_r>
 800a4e8:	2800      	cmp	r0, #0
 800a4ea:	f001 80c5 	beq.w	800b678 <_svfprintf_r+0x1330>
 800a4ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a4f0:	b11b      	cbz	r3, 800a4fa <_svfprintf_r+0x1b2>
 800a4f2:	990a      	ldr	r1, [sp, #40]	; 0x28
 800a4f4:	9803      	ldr	r0, [sp, #12]
 800a4f6:	f002 fbff 	bl	800ccf8 <_free_r>
 800a4fa:	9b06      	ldr	r3, [sp, #24]
 800a4fc:	899b      	ldrh	r3, [r3, #12]
 800a4fe:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a502:	9b05      	ldr	r3, [sp, #20]
 800a504:	bf18      	it	ne
 800a506:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 800a50a:	9305      	str	r3, [sp, #20]
 800a50c:	9805      	ldr	r0, [sp, #20]
 800a50e:	b057      	add	sp, #348	; 0x15c
 800a510:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a514:	f048 0810 	orr.w	r8, r8, #16
 800a518:	f018 0f20 	tst.w	r8, #32
 800a51c:	f000 8573 	beq.w	800b006 <_svfprintf_r+0xcbe>
 800a520:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a522:	3407      	adds	r4, #7
 800a524:	f024 0307 	bic.w	r3, r4, #7
 800a528:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a52c:	f103 0208 	add.w	r2, r3, #8
 800a530:	9209      	str	r2, [sp, #36]	; 0x24
 800a532:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
 800a536:	2200      	movs	r2, #0
 800a538:	2100      	movs	r1, #0
 800a53a:	f88d 108b 	strb.w	r1, [sp, #139]	; 0x8b
 800a53e:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 800a542:	a956      	add	r1, sp, #344	; 0x158
 800a544:	9104      	str	r1, [sp, #16]
 800a546:	f000 84a7 	beq.w	800ae98 <_svfprintf_r+0xb50>
 800a54a:	ea54 0105 	orrs.w	r1, r4, r5
 800a54e:	f023 0880 	bic.w	r8, r3, #128	; 0x80
 800a552:	d15b      	bne.n	800a60c <_svfprintf_r+0x2c4>
 800a554:	f1ba 0f00 	cmp.w	sl, #0
 800a558:	f040 8796 	bne.w	800b488 <_svfprintf_r+0x1140>
 800a55c:	2a00      	cmp	r2, #0
 800a55e:	f040 851f 	bne.w	800afa0 <_svfprintf_r+0xc58>
 800a562:	f013 0301 	ands.w	r3, r3, #1
 800a566:	ae56      	add	r6, sp, #344	; 0x158
 800a568:	9308      	str	r3, [sp, #32]
 800a56a:	d002      	beq.n	800a572 <_svfprintf_r+0x22a>
 800a56c:	2330      	movs	r3, #48	; 0x30
 800a56e:	f806 3d01 	strb.w	r3, [r6, #-1]!
 800a572:	2300      	movs	r3, #0
 800a574:	930a      	str	r3, [sp, #40]	; 0x28
 800a576:	930f      	str	r3, [sp, #60]	; 0x3c
 800a578:	9314      	str	r3, [sp, #80]	; 0x50
 800a57a:	9311      	str	r3, [sp, #68]	; 0x44
 800a57c:	9b08      	ldr	r3, [sp, #32]
 800a57e:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800a582:	4553      	cmp	r3, sl
 800a584:	bfb8      	it	lt
 800a586:	4653      	movlt	r3, sl
 800a588:	9304      	str	r3, [sp, #16]
 800a58a:	2a00      	cmp	r2, #0
 800a58c:	f000 80c8 	beq.w	800a720 <_svfprintf_r+0x3d8>
 800a590:	9b04      	ldr	r3, [sp, #16]
 800a592:	3301      	adds	r3, #1
 800a594:	9304      	str	r3, [sp, #16]
 800a596:	e0c3      	b.n	800a720 <_svfprintf_r+0x3d8>
 800a598:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 800a59c:	2200      	movs	r2, #0
 800a59e:	f81b 7b01 	ldrb.w	r7, [fp], #1
 800a5a2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a5a6:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 800a5aa:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 800a5ae:	2b09      	cmp	r3, #9
 800a5b0:	d9f5      	bls.n	800a59e <_svfprintf_r+0x256>
 800a5b2:	9207      	str	r2, [sp, #28]
 800a5b4:	e723      	b.n	800a3fe <_svfprintf_r+0xb6>
 800a5b6:	bf00      	nop
	...
 800a5c0:	4643      	mov	r3, r8
 800a5c2:	069e      	lsls	r6, r3, #26
 800a5c4:	f140 8217 	bpl.w	800a9f6 <_svfprintf_r+0x6ae>
 800a5c8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a5ca:	3407      	adds	r4, #7
 800a5cc:	f024 0407 	bic.w	r4, r4, #7
 800a5d0:	e9d4 0100 	ldrd	r0, r1, [r4]
 800a5d4:	f104 0208 	add.w	r2, r4, #8
 800a5d8:	9209      	str	r2, [sp, #36]	; 0x24
 800a5da:	4604      	mov	r4, r0
 800a5dc:	460d      	mov	r5, r1
 800a5de:	2800      	cmp	r0, #0
 800a5e0:	f171 0200 	sbcs.w	r2, r1, #0
 800a5e4:	da05      	bge.n	800a5f2 <_svfprintf_r+0x2aa>
 800a5e6:	222d      	movs	r2, #45	; 0x2d
 800a5e8:	4264      	negs	r4, r4
 800a5ea:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 800a5ee:	f88d 208b 	strb.w	r2, [sp, #139]	; 0x8b
 800a5f2:	aa56      	add	r2, sp, #344	; 0x158
 800a5f4:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 800a5f8:	9204      	str	r2, [sp, #16]
 800a5fa:	f000 86e3 	beq.w	800b3c4 <_svfprintf_r+0x107c>
 800a5fe:	ea54 0105 	orrs.w	r1, r4, r5
 800a602:	f04f 0201 	mov.w	r2, #1
 800a606:	f023 0880 	bic.w	r8, r3, #128	; 0x80
 800a60a:	d0a3      	beq.n	800a554 <_svfprintf_r+0x20c>
 800a60c:	2a01      	cmp	r2, #1
 800a60e:	f000 8447 	beq.w	800aea0 <_svfprintf_r+0xb58>
 800a612:	2a02      	cmp	r2, #2
 800a614:	f000 82ef 	beq.w	800abf6 <_svfprintf_r+0x8ae>
 800a618:	a956      	add	r1, sp, #344	; 0x158
 800a61a:	e000      	b.n	800a61e <_svfprintf_r+0x2d6>
 800a61c:	4631      	mov	r1, r6
 800a61e:	08e2      	lsrs	r2, r4, #3
 800a620:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 800a624:	08e8      	lsrs	r0, r5, #3
 800a626:	f004 0307 	and.w	r3, r4, #7
 800a62a:	4605      	mov	r5, r0
 800a62c:	4614      	mov	r4, r2
 800a62e:	3330      	adds	r3, #48	; 0x30
 800a630:	ea54 0205 	orrs.w	r2, r4, r5
 800a634:	f801 3c01 	strb.w	r3, [r1, #-1]
 800a638:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
 800a63c:	d1ee      	bne.n	800a61c <_svfprintf_r+0x2d4>
 800a63e:	f018 0f01 	tst.w	r8, #1
 800a642:	f000 82e8 	beq.w	800ac16 <_svfprintf_r+0x8ce>
 800a646:	2b30      	cmp	r3, #48	; 0x30
 800a648:	f000 82e5 	beq.w	800ac16 <_svfprintf_r+0x8ce>
 800a64c:	9a04      	ldr	r2, [sp, #16]
 800a64e:	3902      	subs	r1, #2
 800a650:	2330      	movs	r3, #48	; 0x30
 800a652:	1a52      	subs	r2, r2, r1
 800a654:	f806 3c01 	strb.w	r3, [r6, #-1]
 800a658:	9208      	str	r2, [sp, #32]
 800a65a:	460e      	mov	r6, r1
 800a65c:	e789      	b.n	800a572 <_svfprintf_r+0x22a>
 800a65e:	4643      	mov	r3, r8
 800a660:	069e      	lsls	r6, r3, #26
 800a662:	f140 82a6 	bpl.w	800abb2 <_svfprintf_r+0x86a>
 800a666:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a668:	3407      	adds	r4, #7
 800a66a:	f024 0207 	bic.w	r2, r4, #7
 800a66e:	f102 0108 	add.w	r1, r2, #8
 800a672:	e9d2 4500 	ldrd	r4, r5, [r2]
 800a676:	9109      	str	r1, [sp, #36]	; 0x24
 800a678:	2201      	movs	r2, #1
 800a67a:	e75d      	b.n	800a538 <_svfprintf_r+0x1f0>
 800a67c:	4bb6      	ldr	r3, [pc, #728]	; (800a958 <_svfprintf_r+0x610>)
 800a67e:	9315      	str	r3, [sp, #84]	; 0x54
 800a680:	f018 0f20 	tst.w	r8, #32
 800a684:	f000 8174 	beq.w	800a970 <_svfprintf_r+0x628>
 800a688:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a68a:	3407      	adds	r4, #7
 800a68c:	f024 0307 	bic.w	r3, r4, #7
 800a690:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a694:	f103 0208 	add.w	r2, r3, #8
 800a698:	9209      	str	r2, [sp, #36]	; 0x24
 800a69a:	f018 0f01 	tst.w	r8, #1
 800a69e:	d009      	beq.n	800a6b4 <_svfprintf_r+0x36c>
 800a6a0:	ea54 0305 	orrs.w	r3, r4, r5
 800a6a4:	d006      	beq.n	800a6b4 <_svfprintf_r+0x36c>
 800a6a6:	2330      	movs	r3, #48	; 0x30
 800a6a8:	f88d 708d 	strb.w	r7, [sp, #141]	; 0x8d
 800a6ac:	f048 0802 	orr.w	r8, r8, #2
 800a6b0:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 800a6b4:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
 800a6b8:	2202      	movs	r2, #2
 800a6ba:	e73d      	b.n	800a538 <_svfprintf_r+0x1f0>
 800a6bc:	f89b 7000 	ldrb.w	r7, [fp]
 800a6c0:	2f2a      	cmp	r7, #42	; 0x2a
 800a6c2:	f10b 0201 	add.w	r2, fp, #1
 800a6c6:	f001 82eb 	beq.w	800bca0 <_svfprintf_r+0x1958>
 800a6ca:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 800a6ce:	2b09      	cmp	r3, #9
 800a6d0:	4693      	mov	fp, r2
 800a6d2:	f04f 0a00 	mov.w	sl, #0
 800a6d6:	f63f ae92 	bhi.w	800a3fe <_svfprintf_r+0xb6>
 800a6da:	f81b 7b01 	ldrb.w	r7, [fp], #1
 800a6de:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 800a6e2:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
 800a6e6:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 800a6ea:	2b09      	cmp	r3, #9
 800a6ec:	d9f5      	bls.n	800a6da <_svfprintf_r+0x392>
 800a6ee:	e686      	b.n	800a3fe <_svfprintf_r+0xb6>
 800a6f0:	f89b 7000 	ldrb.w	r7, [fp]
 800a6f4:	f048 0804 	orr.w	r8, r8, #4
 800a6f8:	e67f      	b.n	800a3fa <_svfprintf_r+0xb2>
 800a6fa:	9809      	ldr	r0, [sp, #36]	; 0x24
 800a6fc:	2300      	movs	r3, #0
 800a6fe:	6801      	ldr	r1, [r0, #0]
 800a700:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 800a704:	461a      	mov	r2, r3
 800a706:	f88d 10f4 	strb.w	r1, [sp, #244]	; 0xf4
 800a70a:	2301      	movs	r3, #1
 800a70c:	1d01      	adds	r1, r0, #4
 800a70e:	e9cd 3108 	strd	r3, r1, [sp, #32]
 800a712:	9304      	str	r3, [sp, #16]
 800a714:	920a      	str	r2, [sp, #40]	; 0x28
 800a716:	4692      	mov	sl, r2
 800a718:	920f      	str	r2, [sp, #60]	; 0x3c
 800a71a:	9214      	str	r2, [sp, #80]	; 0x50
 800a71c:	9211      	str	r2, [sp, #68]	; 0x44
 800a71e:	ae3d      	add	r6, sp, #244	; 0xf4
 800a720:	f018 0302 	ands.w	r3, r8, #2
 800a724:	930b      	str	r3, [sp, #44]	; 0x2c
 800a726:	d002      	beq.n	800a72e <_svfprintf_r+0x3e6>
 800a728:	9b04      	ldr	r3, [sp, #16]
 800a72a:	3302      	adds	r3, #2
 800a72c:	9304      	str	r3, [sp, #16]
 800a72e:	f018 0384 	ands.w	r3, r8, #132	; 0x84
 800a732:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800a734:	930e      	str	r3, [sp, #56]	; 0x38
 800a736:	d13f      	bne.n	800a7b8 <_svfprintf_r+0x470>
 800a738:	9b07      	ldr	r3, [sp, #28]
 800a73a:	9904      	ldr	r1, [sp, #16]
 800a73c:	1a5d      	subs	r5, r3, r1
 800a73e:	2d00      	cmp	r5, #0
 800a740:	dd3a      	ble.n	800a7b8 <_svfprintf_r+0x470>
 800a742:	2d10      	cmp	r5, #16
 800a744:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800a746:	dd29      	ble.n	800a79c <_svfprintf_r+0x454>
 800a748:	4649      	mov	r1, r9
 800a74a:	4620      	mov	r0, r4
 800a74c:	46b1      	mov	r9, r6
 800a74e:	2310      	movs	r3, #16
 800a750:	9720      	str	r7, [sp, #128]	; 0x80
 800a752:	9c03      	ldr	r4, [sp, #12]
 800a754:	9e06      	ldr	r6, [sp, #24]
 800a756:	e004      	b.n	800a762 <_svfprintf_r+0x41a>
 800a758:	3d10      	subs	r5, #16
 800a75a:	2d10      	cmp	r5, #16
 800a75c:	f101 0108 	add.w	r1, r1, #8
 800a760:	dd18      	ble.n	800a794 <_svfprintf_r+0x44c>
 800a762:	3201      	adds	r2, #1
 800a764:	4f7d      	ldr	r7, [pc, #500]	; (800a95c <_svfprintf_r+0x614>)
 800a766:	3010      	adds	r0, #16
 800a768:	2a07      	cmp	r2, #7
 800a76a:	e9cd 202b 	strd	r2, r0, [sp, #172]	; 0xac
 800a76e:	e9c1 7300 	strd	r7, r3, [r1]
 800a772:	ddf1      	ble.n	800a758 <_svfprintf_r+0x410>
 800a774:	aa2a      	add	r2, sp, #168	; 0xa8
 800a776:	4631      	mov	r1, r6
 800a778:	4620      	mov	r0, r4
 800a77a:	930c      	str	r3, [sp, #48]	; 0x30
 800a77c:	f003 f9de 	bl	800db3c <__ssprint_r>
 800a780:	2800      	cmp	r0, #0
 800a782:	f47f aeb4 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800a786:	3d10      	subs	r5, #16
 800a788:	2d10      	cmp	r5, #16
 800a78a:	e9dd 202b 	ldrd	r2, r0, [sp, #172]	; 0xac
 800a78e:	a92d      	add	r1, sp, #180	; 0xb4
 800a790:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a792:	dce6      	bgt.n	800a762 <_svfprintf_r+0x41a>
 800a794:	9f20      	ldr	r7, [sp, #128]	; 0x80
 800a796:	464e      	mov	r6, r9
 800a798:	4604      	mov	r4, r0
 800a79a:	4689      	mov	r9, r1
 800a79c:	3201      	adds	r2, #1
 800a79e:	4b6f      	ldr	r3, [pc, #444]	; (800a95c <_svfprintf_r+0x614>)
 800a7a0:	442c      	add	r4, r5
 800a7a2:	2a07      	cmp	r2, #7
 800a7a4:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800a7a8:	e9c9 3500 	strd	r3, r5, [r9]
 800a7ac:	f300 857c 	bgt.w	800b2a8 <_svfprintf_r+0xf60>
 800a7b0:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800a7b4:	f109 0908 	add.w	r9, r9, #8
 800a7b8:	b172      	cbz	r2, 800a7d8 <_svfprintf_r+0x490>
 800a7ba:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800a7bc:	3201      	adds	r2, #1
 800a7be:	3401      	adds	r4, #1
 800a7c0:	f10d 008b 	add.w	r0, sp, #139	; 0x8b
 800a7c4:	2101      	movs	r1, #1
 800a7c6:	2a07      	cmp	r2, #7
 800a7c8:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800a7cc:	e9c9 0100 	strd	r0, r1, [r9]
 800a7d0:	f300 8373 	bgt.w	800aeba <_svfprintf_r+0xb72>
 800a7d4:	f109 0908 	add.w	r9, r9, #8
 800a7d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a7da:	b16b      	cbz	r3, 800a7f8 <_svfprintf_r+0x4b0>
 800a7dc:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800a7de:	3301      	adds	r3, #1
 800a7e0:	3402      	adds	r4, #2
 800a7e2:	a923      	add	r1, sp, #140	; 0x8c
 800a7e4:	2202      	movs	r2, #2
 800a7e6:	2b07      	cmp	r3, #7
 800a7e8:	e9cd 342b 	strd	r3, r4, [sp, #172]	; 0xac
 800a7ec:	e9c9 1200 	strd	r1, r2, [r9]
 800a7f0:	f300 836f 	bgt.w	800aed2 <_svfprintf_r+0xb8a>
 800a7f4:	f109 0908 	add.w	r9, r9, #8
 800a7f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a7fa:	2b80      	cmp	r3, #128	; 0x80
 800a7fc:	f000 8279 	beq.w	800acf2 <_svfprintf_r+0x9aa>
 800a800:	9b08      	ldr	r3, [sp, #32]
 800a802:	ebaa 0503 	sub.w	r5, sl, r3
 800a806:	2d00      	cmp	r5, #0
 800a808:	dd35      	ble.n	800a876 <_svfprintf_r+0x52e>
 800a80a:	2d10      	cmp	r5, #16
 800a80c:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800a80e:	4b54      	ldr	r3, [pc, #336]	; (800a960 <_svfprintf_r+0x618>)
 800a810:	dd26      	ble.n	800a860 <_svfprintf_r+0x518>
 800a812:	4649      	mov	r1, r9
 800a814:	4620      	mov	r0, r4
 800a816:	46b1      	mov	r9, r6
 800a818:	f04f 0a10 	mov.w	sl, #16
 800a81c:	9e06      	ldr	r6, [sp, #24]
 800a81e:	461c      	mov	r4, r3
 800a820:	e004      	b.n	800a82c <_svfprintf_r+0x4e4>
 800a822:	3d10      	subs	r5, #16
 800a824:	2d10      	cmp	r5, #16
 800a826:	f101 0108 	add.w	r1, r1, #8
 800a82a:	dd15      	ble.n	800a858 <_svfprintf_r+0x510>
 800a82c:	3201      	adds	r2, #1
 800a82e:	3010      	adds	r0, #16
 800a830:	2a07      	cmp	r2, #7
 800a832:	e9cd 202b 	strd	r2, r0, [sp, #172]	; 0xac
 800a836:	e9c1 4a00 	strd	r4, sl, [r1]
 800a83a:	ddf2      	ble.n	800a822 <_svfprintf_r+0x4da>
 800a83c:	aa2a      	add	r2, sp, #168	; 0xa8
 800a83e:	4631      	mov	r1, r6
 800a840:	9803      	ldr	r0, [sp, #12]
 800a842:	f003 f97b 	bl	800db3c <__ssprint_r>
 800a846:	2800      	cmp	r0, #0
 800a848:	f47f ae51 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800a84c:	3d10      	subs	r5, #16
 800a84e:	2d10      	cmp	r5, #16
 800a850:	e9dd 202b 	ldrd	r2, r0, [sp, #172]	; 0xac
 800a854:	a92d      	add	r1, sp, #180	; 0xb4
 800a856:	dce9      	bgt.n	800a82c <_svfprintf_r+0x4e4>
 800a858:	464e      	mov	r6, r9
 800a85a:	4623      	mov	r3, r4
 800a85c:	4689      	mov	r9, r1
 800a85e:	4604      	mov	r4, r0
 800a860:	3201      	adds	r2, #1
 800a862:	442c      	add	r4, r5
 800a864:	2a07      	cmp	r2, #7
 800a866:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800a86a:	e9c9 3500 	strd	r3, r5, [r9]
 800a86e:	f300 833c 	bgt.w	800aeea <_svfprintf_r+0xba2>
 800a872:	f109 0908 	add.w	r9, r9, #8
 800a876:	f418 7f80 	tst.w	r8, #256	; 0x100
 800a87a:	f040 81db 	bne.w	800ac34 <_svfprintf_r+0x8ec>
 800a87e:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800a880:	9a08      	ldr	r2, [sp, #32]
 800a882:	f8c9 6000 	str.w	r6, [r9]
 800a886:	3301      	adds	r3, #1
 800a888:	4414      	add	r4, r2
 800a88a:	2b07      	cmp	r3, #7
 800a88c:	942c      	str	r4, [sp, #176]	; 0xb0
 800a88e:	f8c9 2004 	str.w	r2, [r9, #4]
 800a892:	932b      	str	r3, [sp, #172]	; 0xac
 800a894:	f300 82a1 	bgt.w	800adda <_svfprintf_r+0xa92>
 800a898:	f109 0908 	add.w	r9, r9, #8
 800a89c:	f018 0f04 	tst.w	r8, #4
 800a8a0:	d033      	beq.n	800a90a <_svfprintf_r+0x5c2>
 800a8a2:	9b07      	ldr	r3, [sp, #28]
 800a8a4:	9a04      	ldr	r2, [sp, #16]
 800a8a6:	1a9d      	subs	r5, r3, r2
 800a8a8:	2d00      	cmp	r5, #0
 800a8aa:	dd2e      	ble.n	800a90a <_svfprintf_r+0x5c2>
 800a8ac:	2d10      	cmp	r5, #16
 800a8ae:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800a8b0:	dd21      	ble.n	800a8f6 <_svfprintf_r+0x5ae>
 800a8b2:	2610      	movs	r6, #16
 800a8b4:	9f03      	ldr	r7, [sp, #12]
 800a8b6:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800a8ba:	e004      	b.n	800a8c6 <_svfprintf_r+0x57e>
 800a8bc:	3d10      	subs	r5, #16
 800a8be:	2d10      	cmp	r5, #16
 800a8c0:	f109 0908 	add.w	r9, r9, #8
 800a8c4:	dd17      	ble.n	800a8f6 <_svfprintf_r+0x5ae>
 800a8c6:	3301      	adds	r3, #1
 800a8c8:	4a24      	ldr	r2, [pc, #144]	; (800a95c <_svfprintf_r+0x614>)
 800a8ca:	3410      	adds	r4, #16
 800a8cc:	2b07      	cmp	r3, #7
 800a8ce:	e9cd 342b 	strd	r3, r4, [sp, #172]	; 0xac
 800a8d2:	e9c9 2600 	strd	r2, r6, [r9]
 800a8d6:	ddf1      	ble.n	800a8bc <_svfprintf_r+0x574>
 800a8d8:	aa2a      	add	r2, sp, #168	; 0xa8
 800a8da:	4641      	mov	r1, r8
 800a8dc:	4638      	mov	r0, r7
 800a8de:	f003 f92d 	bl	800db3c <__ssprint_r>
 800a8e2:	2800      	cmp	r0, #0
 800a8e4:	f47f ae03 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800a8e8:	3d10      	subs	r5, #16
 800a8ea:	2d10      	cmp	r5, #16
 800a8ec:	e9dd 342b 	ldrd	r3, r4, [sp, #172]	; 0xac
 800a8f0:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800a8f4:	dce7      	bgt.n	800a8c6 <_svfprintf_r+0x57e>
 800a8f6:	3301      	adds	r3, #1
 800a8f8:	4a18      	ldr	r2, [pc, #96]	; (800a95c <_svfprintf_r+0x614>)
 800a8fa:	442c      	add	r4, r5
 800a8fc:	2b07      	cmp	r3, #7
 800a8fe:	e9cd 342b 	strd	r3, r4, [sp, #172]	; 0xac
 800a902:	e9c9 2500 	strd	r2, r5, [r9]
 800a906:	f300 83a5 	bgt.w	800b054 <_svfprintf_r+0xd0c>
 800a90a:	9b05      	ldr	r3, [sp, #20]
 800a90c:	9a07      	ldr	r2, [sp, #28]
 800a90e:	9904      	ldr	r1, [sp, #16]
 800a910:	428a      	cmp	r2, r1
 800a912:	bfac      	ite	ge
 800a914:	189b      	addge	r3, r3, r2
 800a916:	185b      	addlt	r3, r3, r1
 800a918:	9305      	str	r3, [sp, #20]
 800a91a:	2c00      	cmp	r4, #0
 800a91c:	f040 8225 	bne.w	800ad6a <_svfprintf_r+0xa22>
 800a920:	2300      	movs	r3, #0
 800a922:	932b      	str	r3, [sp, #172]	; 0xac
 800a924:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a926:	b11b      	cbz	r3, 800a930 <_svfprintf_r+0x5e8>
 800a928:	990a      	ldr	r1, [sp, #40]	; 0x28
 800a92a:	9803      	ldr	r0, [sp, #12]
 800a92c:	f002 f9e4 	bl	800ccf8 <_free_r>
 800a930:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800a934:	465e      	mov	r6, fp
 800a936:	7833      	ldrb	r3, [r6, #0]
 800a938:	2b00      	cmp	r3, #0
 800a93a:	f47f ad32 	bne.w	800a3a2 <_svfprintf_r+0x5a>
 800a93e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800a940:	2b00      	cmp	r3, #0
 800a942:	f43f adda 	beq.w	800a4fa <_svfprintf_r+0x1b2>
 800a946:	9c06      	ldr	r4, [sp, #24]
 800a948:	9803      	ldr	r0, [sp, #12]
 800a94a:	aa2a      	add	r2, sp, #168	; 0xa8
 800a94c:	4621      	mov	r1, r4
 800a94e:	f003 f8f5 	bl	800db3c <__ssprint_r>
 800a952:	89a3      	ldrh	r3, [r4, #12]
 800a954:	e5d3      	b.n	800a4fe <_svfprintf_r+0x1b6>
 800a956:	bf00      	nop
 800a958:	0801dc1c 	.word	0x0801dc1c
 800a95c:	0801dc44 	.word	0x0801dc44
 800a960:	0801dc54 	.word	0x0801dc54
 800a964:	4bae      	ldr	r3, [pc, #696]	; (800ac20 <_svfprintf_r+0x8d8>)
 800a966:	9315      	str	r3, [sp, #84]	; 0x54
 800a968:	f018 0f20 	tst.w	r8, #32
 800a96c:	f47f ae8c 	bne.w	800a688 <_svfprintf_r+0x340>
 800a970:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a972:	f018 0f10 	tst.w	r8, #16
 800a976:	f102 0304 	add.w	r3, r2, #4
 800a97a:	f040 8379 	bne.w	800b070 <_svfprintf_r+0xd28>
 800a97e:	f018 0f40 	tst.w	r8, #64	; 0x40
 800a982:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a984:	f000 8370 	beq.w	800b068 <_svfprintf_r+0xd20>
 800a988:	8814      	ldrh	r4, [r2, #0]
 800a98a:	9309      	str	r3, [sp, #36]	; 0x24
 800a98c:	2500      	movs	r5, #0
 800a98e:	e684      	b.n	800a69a <_svfprintf_r+0x352>
 800a990:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a992:	681e      	ldr	r6, [r3, #0]
 800a994:	2500      	movs	r5, #0
 800a996:	f88d 508b 	strb.w	r5, [sp, #139]	; 0x8b
 800a99a:	1d1c      	adds	r4, r3, #4
 800a99c:	2e00      	cmp	r6, #0
 800a99e:	f000 8473 	beq.w	800b288 <_svfprintf_r+0xf40>
 800a9a2:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 800a9a6:	f000 865f 	beq.w	800b668 <_svfprintf_r+0x1320>
 800a9aa:	4652      	mov	r2, sl
 800a9ac:	4629      	mov	r1, r5
 800a9ae:	4630      	mov	r0, r6
 800a9b0:	f7f6 fa96 	bl	8000ee0 <memchr>
 800a9b4:	900a      	str	r0, [sp, #40]	; 0x28
 800a9b6:	2800      	cmp	r0, #0
 800a9b8:	f000 879a 	beq.w	800b8f0 <_svfprintf_r+0x15a8>
 800a9bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a9be:	1b9b      	subs	r3, r3, r6
 800a9c0:	9308      	str	r3, [sp, #32]
 800a9c2:	46aa      	mov	sl, r5
 800a9c4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a9c8:	9409      	str	r4, [sp, #36]	; 0x24
 800a9ca:	9304      	str	r3, [sp, #16]
 800a9cc:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 800a9d0:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
 800a9d4:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
 800a9d8:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
 800a9dc:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800a9e0:	e5d3      	b.n	800a58a <_svfprintf_r+0x242>
 800a9e2:	f048 0808 	orr.w	r8, r8, #8
 800a9e6:	f89b 7000 	ldrb.w	r7, [fp]
 800a9ea:	e506      	b.n	800a3fa <_svfprintf_r+0xb2>
 800a9ec:	f048 0310 	orr.w	r3, r8, #16
 800a9f0:	069e      	lsls	r6, r3, #26
 800a9f2:	f53f ade9 	bmi.w	800a5c8 <_svfprintf_r+0x280>
 800a9f6:	9909      	ldr	r1, [sp, #36]	; 0x24
 800a9f8:	06dd      	lsls	r5, r3, #27
 800a9fa:	f101 0204 	add.w	r2, r1, #4
 800a9fe:	f100 8351 	bmi.w	800b0a4 <_svfprintf_r+0xd5c>
 800aa02:	065c      	lsls	r4, r3, #25
 800aa04:	9909      	ldr	r1, [sp, #36]	; 0x24
 800aa06:	f140 834a 	bpl.w	800b09e <_svfprintf_r+0xd56>
 800aa0a:	f9b1 4000 	ldrsh.w	r4, [r1]
 800aa0e:	9209      	str	r2, [sp, #36]	; 0x24
 800aa10:	17e5      	asrs	r5, r4, #31
 800aa12:	4620      	mov	r0, r4
 800aa14:	4629      	mov	r1, r5
 800aa16:	e5e2      	b.n	800a5de <_svfprintf_r+0x296>
 800aa18:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800aa1a:	f018 0f20 	tst.w	r8, #32
 800aa1e:	f852 3b04 	ldr.w	r3, [r2], #4
 800aa22:	9209      	str	r2, [sp, #36]	; 0x24
 800aa24:	f040 8345 	bne.w	800b0b2 <_svfprintf_r+0xd6a>
 800aa28:	f018 0f10 	tst.w	r8, #16
 800aa2c:	f040 857c 	bne.w	800b528 <_svfprintf_r+0x11e0>
 800aa30:	f018 0f40 	tst.w	r8, #64	; 0x40
 800aa34:	f040 862e 	bne.w	800b694 <_svfprintf_r+0x134c>
 800aa38:	f418 7f00 	tst.w	r8, #512	; 0x200
 800aa3c:	f000 8574 	beq.w	800b528 <_svfprintf_r+0x11e0>
 800aa40:	9a05      	ldr	r2, [sp, #20]
 800aa42:	701a      	strb	r2, [r3, #0]
 800aa44:	465e      	mov	r6, fp
 800aa46:	e776      	b.n	800a936 <_svfprintf_r+0x5ee>
 800aa48:	f89b 7000 	ldrb.w	r7, [fp]
 800aa4c:	2f6c      	cmp	r7, #108	; 0x6c
 800aa4e:	bf03      	ittte	eq
 800aa50:	f89b 7001 	ldrbeq.w	r7, [fp, #1]
 800aa54:	f048 0820 	orreq.w	r8, r8, #32
 800aa58:	f10b 0b01 	addeq.w	fp, fp, #1
 800aa5c:	f048 0810 	orrne.w	r8, r8, #16
 800aa60:	e4cb      	b.n	800a3fa <_svfprintf_r+0xb2>
 800aa62:	9909      	ldr	r1, [sp, #36]	; 0x24
 800aa64:	4b6f      	ldr	r3, [pc, #444]	; (800ac24 <_svfprintf_r+0x8dc>)
 800aa66:	680c      	ldr	r4, [r1, #0]
 800aa68:	9315      	str	r3, [sp, #84]	; 0x54
 800aa6a:	f647 0230 	movw	r2, #30768	; 0x7830
 800aa6e:	3104      	adds	r1, #4
 800aa70:	f8ad 208c 	strh.w	r2, [sp, #140]	; 0x8c
 800aa74:	f048 0302 	orr.w	r3, r8, #2
 800aa78:	9109      	str	r1, [sp, #36]	; 0x24
 800aa7a:	2500      	movs	r5, #0
 800aa7c:	2202      	movs	r2, #2
 800aa7e:	2778      	movs	r7, #120	; 0x78
 800aa80:	e55a      	b.n	800a538 <_svfprintf_r+0x1f0>
 800aa82:	f048 0880 	orr.w	r8, r8, #128	; 0x80
 800aa86:	f89b 7000 	ldrb.w	r7, [fp]
 800aa8a:	e4b6      	b.n	800a3fa <_svfprintf_r+0xb2>
 800aa8c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800aa8e:	3407      	adds	r4, #7
 800aa90:	f024 0407 	bic.w	r4, r4, #7
 800aa94:	ed94 7b00 	vldr	d7, [r4]
 800aa98:	ec52 1b17 	vmov	r1, r2, d7
 800aa9c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 800aaa0:	931d      	str	r3, [sp, #116]	; 0x74
 800aaa2:	ed8d 7a1c 	vstr	s14, [sp, #112]	; 0x70
 800aaa6:	3408      	adds	r4, #8
 800aaa8:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
 800aaac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800aab0:	4b5d      	ldr	r3, [pc, #372]	; (800ac28 <_svfprintf_r+0x8e0>)
 800aab2:	9409      	str	r4, [sp, #36]	; 0x24
 800aab4:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 800aab8:	f7f6 f87a 	bl	8000bb0 <__aeabi_dcmpun>
 800aabc:	2800      	cmp	r0, #0
 800aabe:	f040 82ff 	bne.w	800b0c0 <_svfprintf_r+0xd78>
 800aac2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800aac6:	4b58      	ldr	r3, [pc, #352]	; (800ac28 <_svfprintf_r+0x8e0>)
 800aac8:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
 800aacc:	f7f6 f852 	bl	8000b74 <__aeabi_dcmple>
 800aad0:	2800      	cmp	r0, #0
 800aad2:	f040 82f5 	bne.w	800b0c0 <_svfprintf_r+0xd78>
 800aad6:	2200      	movs	r2, #0
 800aad8:	2300      	movs	r3, #0
 800aada:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800aade:	f7f6 f83f 	bl	8000b60 <__aeabi_dcmplt>
 800aae2:	2800      	cmp	r0, #0
 800aae4:	f040 86e3 	bne.w	800b8ae <_svfprintf_r+0x1566>
 800aae8:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800aaec:	4e4f      	ldr	r6, [pc, #316]	; (800ac2c <_svfprintf_r+0x8e4>)
 800aaee:	4b50      	ldr	r3, [pc, #320]	; (800ac30 <_svfprintf_r+0x8e8>)
 800aaf0:	2000      	movs	r0, #0
 800aaf2:	2103      	movs	r1, #3
 800aaf4:	9104      	str	r1, [sp, #16]
 800aaf6:	900a      	str	r0, [sp, #40]	; 0x28
 800aaf8:	f028 0880 	bic.w	r8, r8, #128	; 0x80
 800aafc:	2f47      	cmp	r7, #71	; 0x47
 800aafe:	bfd8      	it	le
 800ab00:	461e      	movle	r6, r3
 800ab02:	9108      	str	r1, [sp, #32]
 800ab04:	4682      	mov	sl, r0
 800ab06:	900f      	str	r0, [sp, #60]	; 0x3c
 800ab08:	9014      	str	r0, [sp, #80]	; 0x50
 800ab0a:	9011      	str	r0, [sp, #68]	; 0x44
 800ab0c:	e53d      	b.n	800a58a <_svfprintf_r+0x242>
 800ab0e:	9f03      	ldr	r7, [sp, #12]
 800ab10:	4638      	mov	r0, r7
 800ab12:	f002 f9e5 	bl	800cee0 <_localeconv_r>
 800ab16:	6843      	ldr	r3, [r0, #4]
 800ab18:	9318      	str	r3, [sp, #96]	; 0x60
 800ab1a:	4618      	mov	r0, r3
 800ab1c:	f7f6 f970 	bl	8000e00 <strlen>
 800ab20:	901b      	str	r0, [sp, #108]	; 0x6c
 800ab22:	4604      	mov	r4, r0
 800ab24:	4638      	mov	r0, r7
 800ab26:	f002 f9db 	bl	800cee0 <_localeconv_r>
 800ab2a:	6883      	ldr	r3, [r0, #8]
 800ab2c:	931a      	str	r3, [sp, #104]	; 0x68
 800ab2e:	2c00      	cmp	r4, #0
 800ab30:	f43f acc9 	beq.w	800a4c6 <_svfprintf_r+0x17e>
 800ab34:	f89b 7000 	ldrb.w	r7, [fp]
 800ab38:	2b00      	cmp	r3, #0
 800ab3a:	f43f ac5e 	beq.w	800a3fa <_svfprintf_r+0xb2>
 800ab3e:	781b      	ldrb	r3, [r3, #0]
 800ab40:	2b00      	cmp	r3, #0
 800ab42:	f43f ac5a 	beq.w	800a3fa <_svfprintf_r+0xb2>
 800ab46:	f448 6880 	orr.w	r8, r8, #1024	; 0x400
 800ab4a:	e456      	b.n	800a3fa <_svfprintf_r+0xb2>
 800ab4c:	f048 0801 	orr.w	r8, r8, #1
 800ab50:	f89b 7000 	ldrb.w	r7, [fp]
 800ab54:	e451      	b.n	800a3fa <_svfprintf_r+0xb2>
 800ab56:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 800ab5a:	f89b 7000 	ldrb.w	r7, [fp]
 800ab5e:	2b00      	cmp	r3, #0
 800ab60:	f47f ac4b 	bne.w	800a3fa <_svfprintf_r+0xb2>
 800ab64:	2320      	movs	r3, #32
 800ab66:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 800ab6a:	e446      	b.n	800a3fa <_svfprintf_r+0xb2>
 800ab6c:	f88d 508b 	strb.w	r5, [sp, #139]	; 0x8b
 800ab70:	f89b 7000 	ldrb.w	r7, [fp]
 800ab74:	e441      	b.n	800a3fa <_svfprintf_r+0xb2>
 800ab76:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ab78:	f89b 7000 	ldrb.w	r7, [fp]
 800ab7c:	681a      	ldr	r2, [r3, #0]
 800ab7e:	9207      	str	r2, [sp, #28]
 800ab80:	2a00      	cmp	r2, #0
 800ab82:	f103 0304 	add.w	r3, r3, #4
 800ab86:	f2c0 835a 	blt.w	800b23e <_svfprintf_r+0xef6>
 800ab8a:	9309      	str	r3, [sp, #36]	; 0x24
 800ab8c:	e435      	b.n	800a3fa <_svfprintf_r+0xb2>
 800ab8e:	f89b 7000 	ldrb.w	r7, [fp]
 800ab92:	2f68      	cmp	r7, #104	; 0x68
 800ab94:	bf03      	ittte	eq
 800ab96:	f89b 7001 	ldrbeq.w	r7, [fp, #1]
 800ab9a:	f448 7800 	orreq.w	r8, r8, #512	; 0x200
 800ab9e:	f10b 0b01 	addeq.w	fp, fp, #1
 800aba2:	f048 0840 	orrne.w	r8, r8, #64	; 0x40
 800aba6:	e428      	b.n	800a3fa <_svfprintf_r+0xb2>
 800aba8:	f048 0310 	orr.w	r3, r8, #16
 800abac:	069e      	lsls	r6, r3, #26
 800abae:	f53f ad5a 	bmi.w	800a666 <_svfprintf_r+0x31e>
 800abb2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800abb4:	06dd      	lsls	r5, r3, #27
 800abb6:	f102 0104 	add.w	r1, r2, #4
 800abba:	f100 8261 	bmi.w	800b080 <_svfprintf_r+0xd38>
 800abbe:	065c      	lsls	r4, r3, #25
 800abc0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800abc2:	f140 825a 	bpl.w	800b07a <_svfprintf_r+0xd32>
 800abc6:	8814      	ldrh	r4, [r2, #0]
 800abc8:	9109      	str	r1, [sp, #36]	; 0x24
 800abca:	2500      	movs	r5, #0
 800abcc:	2201      	movs	r2, #1
 800abce:	e4b3      	b.n	800a538 <_svfprintf_r+0x1f0>
 800abd0:	2f00      	cmp	r7, #0
 800abd2:	f43f aeb4 	beq.w	800a93e <_svfprintf_r+0x5f6>
 800abd6:	2300      	movs	r3, #0
 800abd8:	2101      	movs	r1, #1
 800abda:	461a      	mov	r2, r3
 800abdc:	9104      	str	r1, [sp, #16]
 800abde:	f88d 70f4 	strb.w	r7, [sp, #244]	; 0xf4
 800abe2:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 800abe6:	930a      	str	r3, [sp, #40]	; 0x28
 800abe8:	469a      	mov	sl, r3
 800abea:	930f      	str	r3, [sp, #60]	; 0x3c
 800abec:	9314      	str	r3, [sp, #80]	; 0x50
 800abee:	9311      	str	r3, [sp, #68]	; 0x44
 800abf0:	9108      	str	r1, [sp, #32]
 800abf2:	ae3d      	add	r6, sp, #244	; 0xf4
 800abf4:	e594      	b.n	800a720 <_svfprintf_r+0x3d8>
 800abf6:	9815      	ldr	r0, [sp, #84]	; 0x54
 800abf8:	ae56      	add	r6, sp, #344	; 0x158
 800abfa:	0923      	lsrs	r3, r4, #4
 800abfc:	f004 010f 	and.w	r1, r4, #15
 800ac00:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 800ac04:	092a      	lsrs	r2, r5, #4
 800ac06:	461c      	mov	r4, r3
 800ac08:	4615      	mov	r5, r2
 800ac0a:	5c43      	ldrb	r3, [r0, r1]
 800ac0c:	f806 3d01 	strb.w	r3, [r6, #-1]!
 800ac10:	ea54 0305 	orrs.w	r3, r4, r5
 800ac14:	d1f1      	bne.n	800abfa <_svfprintf_r+0x8b2>
 800ac16:	9b04      	ldr	r3, [sp, #16]
 800ac18:	1b9b      	subs	r3, r3, r6
 800ac1a:	9308      	str	r3, [sp, #32]
 800ac1c:	e4a9      	b.n	800a572 <_svfprintf_r+0x22a>
 800ac1e:	bf00      	nop
 800ac20:	0801dc30 	.word	0x0801dc30
 800ac24:	0801dc1c 	.word	0x0801dc1c
 800ac28:	7fefffff 	.word	0x7fefffff
 800ac2c:	0801dc10 	.word	0x0801dc10
 800ac30:	0801dc0c 	.word	0x0801dc0c
 800ac34:	2f65      	cmp	r7, #101	; 0x65
 800ac36:	f340 80dc 	ble.w	800adf2 <_svfprintf_r+0xaaa>
 800ac3a:	2200      	movs	r2, #0
 800ac3c:	2300      	movs	r3, #0
 800ac3e:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800ac42:	f7f5 ff83 	bl	8000b4c <__aeabi_dcmpeq>
 800ac46:	2800      	cmp	r0, #0
 800ac48:	f000 8160 	beq.w	800af0c <_svfprintf_r+0xbc4>
 800ac4c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800ac4e:	4aad      	ldr	r2, [pc, #692]	; (800af04 <_svfprintf_r+0xbbc>)
 800ac50:	f8c9 2000 	str.w	r2, [r9]
 800ac54:	3301      	adds	r3, #1
 800ac56:	3401      	adds	r4, #1
 800ac58:	2201      	movs	r2, #1
 800ac5a:	2b07      	cmp	r3, #7
 800ac5c:	e9cd 342b 	strd	r3, r4, [sp, #172]	; 0xac
 800ac60:	f8c9 2004 	str.w	r2, [r9, #4]
 800ac64:	f300 843c 	bgt.w	800b4e0 <_svfprintf_r+0x1198>
 800ac68:	f109 0908 	add.w	r9, r9, #8
 800ac6c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800ac6e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800ac70:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800ac72:	4293      	cmp	r3, r2
 800ac74:	f280 81e9 	bge.w	800b04a <_svfprintf_r+0xd02>
 800ac78:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800ac7a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800ac7c:	f8c9 2000 	str.w	r2, [r9]
 800ac80:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800ac82:	f8c9 2004 	str.w	r2, [r9, #4]
 800ac86:	3301      	adds	r3, #1
 800ac88:	4414      	add	r4, r2
 800ac8a:	2b07      	cmp	r3, #7
 800ac8c:	e9cd 342b 	strd	r3, r4, [sp, #172]	; 0xac
 800ac90:	f300 82ee 	bgt.w	800b270 <_svfprintf_r+0xf28>
 800ac94:	f109 0908 	add.w	r9, r9, #8
 800ac98:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ac9a:	1e5d      	subs	r5, r3, #1
 800ac9c:	2d00      	cmp	r5, #0
 800ac9e:	f77f adfd 	ble.w	800a89c <_svfprintf_r+0x554>
 800aca2:	2d10      	cmp	r5, #16
 800aca4:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800aca6:	4b98      	ldr	r3, [pc, #608]	; (800af08 <_svfprintf_r+0xbc0>)
 800aca8:	f340 8403 	ble.w	800b4b2 <_svfprintf_r+0x116a>
 800acac:	4619      	mov	r1, r3
 800acae:	2610      	movs	r6, #16
 800acb0:	4623      	mov	r3, r4
 800acb2:	9f03      	ldr	r7, [sp, #12]
 800acb4:	f8dd a018 	ldr.w	sl, [sp, #24]
 800acb8:	460c      	mov	r4, r1
 800acba:	e005      	b.n	800acc8 <_svfprintf_r+0x980>
 800acbc:	f109 0908 	add.w	r9, r9, #8
 800acc0:	3d10      	subs	r5, #16
 800acc2:	2d10      	cmp	r5, #16
 800acc4:	f340 83f2 	ble.w	800b4ac <_svfprintf_r+0x1164>
 800acc8:	3201      	adds	r2, #1
 800acca:	3310      	adds	r3, #16
 800accc:	2a07      	cmp	r2, #7
 800acce:	e9cd 232b 	strd	r2, r3, [sp, #172]	; 0xac
 800acd2:	e9c9 4600 	strd	r4, r6, [r9]
 800acd6:	ddf1      	ble.n	800acbc <_svfprintf_r+0x974>
 800acd8:	aa2a      	add	r2, sp, #168	; 0xa8
 800acda:	4651      	mov	r1, sl
 800acdc:	4638      	mov	r0, r7
 800acde:	f002 ff2d 	bl	800db3c <__ssprint_r>
 800ace2:	2800      	cmp	r0, #0
 800ace4:	f47f ac03 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800ace8:	e9dd 232b 	ldrd	r2, r3, [sp, #172]	; 0xac
 800acec:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800acf0:	e7e6      	b.n	800acc0 <_svfprintf_r+0x978>
 800acf2:	9b07      	ldr	r3, [sp, #28]
 800acf4:	9a04      	ldr	r2, [sp, #16]
 800acf6:	1a9d      	subs	r5, r3, r2
 800acf8:	2d00      	cmp	r5, #0
 800acfa:	f77f ad81 	ble.w	800a800 <_svfprintf_r+0x4b8>
 800acfe:	2d10      	cmp	r5, #16
 800ad00:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800ad02:	4b81      	ldr	r3, [pc, #516]	; (800af08 <_svfprintf_r+0xbc0>)
 800ad04:	dd25      	ble.n	800ad52 <_svfprintf_r+0xa0a>
 800ad06:	4649      	mov	r1, r9
 800ad08:	4620      	mov	r0, r4
 800ad0a:	46b1      	mov	r9, r6
 800ad0c:	461c      	mov	r4, r3
 800ad0e:	9e06      	ldr	r6, [sp, #24]
 800ad10:	e004      	b.n	800ad1c <_svfprintf_r+0x9d4>
 800ad12:	3d10      	subs	r5, #16
 800ad14:	2d10      	cmp	r5, #16
 800ad16:	f101 0108 	add.w	r1, r1, #8
 800ad1a:	dd16      	ble.n	800ad4a <_svfprintf_r+0xa02>
 800ad1c:	3201      	adds	r2, #1
 800ad1e:	3010      	adds	r0, #16
 800ad20:	2310      	movs	r3, #16
 800ad22:	2a07      	cmp	r2, #7
 800ad24:	e9cd 202b 	strd	r2, r0, [sp, #172]	; 0xac
 800ad28:	600c      	str	r4, [r1, #0]
 800ad2a:	604b      	str	r3, [r1, #4]
 800ad2c:	ddf1      	ble.n	800ad12 <_svfprintf_r+0x9ca>
 800ad2e:	aa2a      	add	r2, sp, #168	; 0xa8
 800ad30:	4631      	mov	r1, r6
 800ad32:	9803      	ldr	r0, [sp, #12]
 800ad34:	f002 ff02 	bl	800db3c <__ssprint_r>
 800ad38:	2800      	cmp	r0, #0
 800ad3a:	f47f abd8 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800ad3e:	3d10      	subs	r5, #16
 800ad40:	2d10      	cmp	r5, #16
 800ad42:	e9dd 202b 	ldrd	r2, r0, [sp, #172]	; 0xac
 800ad46:	a92d      	add	r1, sp, #180	; 0xb4
 800ad48:	dce8      	bgt.n	800ad1c <_svfprintf_r+0x9d4>
 800ad4a:	464e      	mov	r6, r9
 800ad4c:	4623      	mov	r3, r4
 800ad4e:	4689      	mov	r9, r1
 800ad50:	4604      	mov	r4, r0
 800ad52:	3201      	adds	r2, #1
 800ad54:	442c      	add	r4, r5
 800ad56:	2a07      	cmp	r2, #7
 800ad58:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800ad5c:	e9c9 3500 	strd	r3, r5, [r9]
 800ad60:	f300 83b1 	bgt.w	800b4c6 <_svfprintf_r+0x117e>
 800ad64:	f109 0908 	add.w	r9, r9, #8
 800ad68:	e54a      	b.n	800a800 <_svfprintf_r+0x4b8>
 800ad6a:	aa2a      	add	r2, sp, #168	; 0xa8
 800ad6c:	9906      	ldr	r1, [sp, #24]
 800ad6e:	9803      	ldr	r0, [sp, #12]
 800ad70:	f002 fee4 	bl	800db3c <__ssprint_r>
 800ad74:	2800      	cmp	r0, #0
 800ad76:	f43f add3 	beq.w	800a920 <_svfprintf_r+0x5d8>
 800ad7a:	f7ff bbb8 	b.w	800a4ee <_svfprintf_r+0x1a6>
 800ad7e:	aa2a      	add	r2, sp, #168	; 0xa8
 800ad80:	9906      	ldr	r1, [sp, #24]
 800ad82:	9803      	ldr	r0, [sp, #12]
 800ad84:	f002 feda 	bl	800db3c <__ssprint_r>
 800ad88:	2800      	cmp	r0, #0
 800ad8a:	f47f abb0 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800ad8e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800ad90:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800ad92:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800ad96:	b91b      	cbnz	r3, 800ada0 <_svfprintf_r+0xa58>
 800ad98:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800ad9a:	2a00      	cmp	r2, #0
 800ad9c:	f000 8492 	beq.w	800b6c4 <_svfprintf_r+0x137c>
 800ada0:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800ada2:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800ada4:	f8c9 1000 	str.w	r1, [r9]
 800ada8:	9916      	ldr	r1, [sp, #88]	; 0x58
 800adaa:	f8c9 1004 	str.w	r1, [r9, #4]
 800adae:	3201      	adds	r2, #1
 800adb0:	440c      	add	r4, r1
 800adb2:	2a07      	cmp	r2, #7
 800adb4:	942c      	str	r4, [sp, #176]	; 0xb0
 800adb6:	922b      	str	r2, [sp, #172]	; 0xac
 800adb8:	f300 85a7 	bgt.w	800b90a <_svfprintf_r+0x15c2>
 800adbc:	f109 0908 	add.w	r9, r9, #8
 800adc0:	2b00      	cmp	r3, #0
 800adc2:	f2c0 8620 	blt.w	800ba06 <_svfprintf_r+0x16be>
 800adc6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800adc8:	3201      	adds	r2, #1
 800adca:	441c      	add	r4, r3
 800adcc:	2a07      	cmp	r2, #7
 800adce:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800add2:	e9c9 6300 	strd	r6, r3, [r9]
 800add6:	f77f ad5f 	ble.w	800a898 <_svfprintf_r+0x550>
 800adda:	aa2a      	add	r2, sp, #168	; 0xa8
 800addc:	9906      	ldr	r1, [sp, #24]
 800adde:	9803      	ldr	r0, [sp, #12]
 800ade0:	f002 feac 	bl	800db3c <__ssprint_r>
 800ade4:	2800      	cmp	r0, #0
 800ade6:	f47f ab82 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800adea:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800adec:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800adf0:	e554      	b.n	800a89c <_svfprintf_r+0x554>
 800adf2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800adf4:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800adf6:	2a01      	cmp	r2, #1
 800adf8:	f104 0401 	add.w	r4, r4, #1
 800adfc:	f103 0501 	add.w	r5, r3, #1
 800ae00:	f109 0708 	add.w	r7, r9, #8
 800ae04:	f340 810e 	ble.w	800b024 <_svfprintf_r+0xcdc>
 800ae08:	2301      	movs	r3, #1
 800ae0a:	2d07      	cmp	r5, #7
 800ae0c:	f8c9 6000 	str.w	r6, [r9]
 800ae10:	e9cd 542b 	strd	r5, r4, [sp, #172]	; 0xac
 800ae14:	f8c9 3004 	str.w	r3, [r9, #4]
 800ae18:	f300 831d 	bgt.w	800b456 <_svfprintf_r+0x110e>
 800ae1c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800ae1e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800ae20:	1c69      	adds	r1, r5, #1
 800ae22:	441c      	add	r4, r3
 800ae24:	2907      	cmp	r1, #7
 800ae26:	910b      	str	r1, [sp, #44]	; 0x2c
 800ae28:	e9cd 142b 	strd	r1, r4, [sp, #172]	; 0xac
 800ae2c:	e9c7 2300 	strd	r2, r3, [r7]
 800ae30:	f300 831d 	bgt.w	800b46e <_svfprintf_r+0x1126>
 800ae34:	3708      	adds	r7, #8
 800ae36:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ae38:	1c53      	adds	r3, r2, #1
 800ae3a:	461d      	mov	r5, r3
 800ae3c:	9508      	str	r5, [sp, #32]
 800ae3e:	9d10      	ldr	r5, [sp, #64]	; 0x40
 800ae40:	930e      	str	r3, [sp, #56]	; 0x38
 800ae42:	2200      	movs	r2, #0
 800ae44:	2300      	movs	r3, #0
 800ae46:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800ae4a:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
 800ae4e:	f107 0908 	add.w	r9, r7, #8
 800ae52:	f7f5 fe7b 	bl	8000b4c <__aeabi_dcmpeq>
 800ae56:	2800      	cmp	r0, #0
 800ae58:	f040 80a7 	bne.w	800afaa <_svfprintf_r+0xc62>
 800ae5c:	9d08      	ldr	r5, [sp, #32]
 800ae5e:	f8c7 a004 	str.w	sl, [r7, #4]
 800ae62:	3601      	adds	r6, #1
 800ae64:	4454      	add	r4, sl
 800ae66:	2d07      	cmp	r5, #7
 800ae68:	603e      	str	r6, [r7, #0]
 800ae6a:	942c      	str	r4, [sp, #176]	; 0xb0
 800ae6c:	952b      	str	r5, [sp, #172]	; 0xac
 800ae6e:	f300 81ef 	bgt.w	800b250 <_svfprintf_r+0xf08>
 800ae72:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ae74:	f107 0310 	add.w	r3, r7, #16
 800ae78:	3202      	adds	r2, #2
 800ae7a:	464f      	mov	r7, r9
 800ae7c:	9208      	str	r2, [sp, #32]
 800ae7e:	4699      	mov	r9, r3
 800ae80:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800ae82:	607a      	str	r2, [r7, #4]
 800ae84:	4414      	add	r4, r2
 800ae86:	9a08      	ldr	r2, [sp, #32]
 800ae88:	942c      	str	r4, [sp, #176]	; 0xb0
 800ae8a:	ab26      	add	r3, sp, #152	; 0x98
 800ae8c:	2a07      	cmp	r2, #7
 800ae8e:	922b      	str	r2, [sp, #172]	; 0xac
 800ae90:	603b      	str	r3, [r7, #0]
 800ae92:	f77f ad03 	ble.w	800a89c <_svfprintf_r+0x554>
 800ae96:	e7a0      	b.n	800adda <_svfprintf_r+0xa92>
 800ae98:	2a01      	cmp	r2, #1
 800ae9a:	4698      	mov	r8, r3
 800ae9c:	f47f abb9 	bne.w	800a612 <_svfprintf_r+0x2ca>
 800aea0:	2d00      	cmp	r5, #0
 800aea2:	bf08      	it	eq
 800aea4:	2c0a      	cmpeq	r4, #10
 800aea6:	f080 8293 	bcs.w	800b3d0 <_svfprintf_r+0x1088>
 800aeaa:	ae56      	add	r6, sp, #344	; 0x158
 800aeac:	3430      	adds	r4, #48	; 0x30
 800aeae:	2301      	movs	r3, #1
 800aeb0:	f806 4d01 	strb.w	r4, [r6, #-1]!
 800aeb4:	9308      	str	r3, [sp, #32]
 800aeb6:	f7ff bb5c 	b.w	800a572 <_svfprintf_r+0x22a>
 800aeba:	aa2a      	add	r2, sp, #168	; 0xa8
 800aebc:	9906      	ldr	r1, [sp, #24]
 800aebe:	9803      	ldr	r0, [sp, #12]
 800aec0:	f002 fe3c 	bl	800db3c <__ssprint_r>
 800aec4:	2800      	cmp	r0, #0
 800aec6:	f47f ab12 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800aeca:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800aecc:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800aed0:	e482      	b.n	800a7d8 <_svfprintf_r+0x490>
 800aed2:	aa2a      	add	r2, sp, #168	; 0xa8
 800aed4:	9906      	ldr	r1, [sp, #24]
 800aed6:	9803      	ldr	r0, [sp, #12]
 800aed8:	f002 fe30 	bl	800db3c <__ssprint_r>
 800aedc:	2800      	cmp	r0, #0
 800aede:	f47f ab06 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800aee2:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800aee4:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800aee8:	e486      	b.n	800a7f8 <_svfprintf_r+0x4b0>
 800aeea:	aa2a      	add	r2, sp, #168	; 0xa8
 800aeec:	9906      	ldr	r1, [sp, #24]
 800aeee:	9803      	ldr	r0, [sp, #12]
 800aef0:	f002 fe24 	bl	800db3c <__ssprint_r>
 800aef4:	2800      	cmp	r0, #0
 800aef6:	f47f aafa 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800aefa:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800aefc:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800af00:	e4b9      	b.n	800a876 <_svfprintf_r+0x52e>
 800af02:	bf00      	nop
 800af04:	0800e710 	.word	0x0800e710
 800af08:	0801dc54 	.word	0x0801dc54
 800af0c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800af0e:	2b00      	cmp	r3, #0
 800af10:	f340 8175 	ble.w	800b1fe <_svfprintf_r+0xeb6>
 800af14:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 800af18:	4293      	cmp	r3, r2
 800af1a:	bfa8      	it	ge
 800af1c:	4613      	movge	r3, r2
 800af1e:	2b00      	cmp	r3, #0
 800af20:	461d      	mov	r5, r3
 800af22:	dd0d      	ble.n	800af40 <_svfprintf_r+0xbf8>
 800af24:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800af26:	f8c9 6000 	str.w	r6, [r9]
 800af2a:	3301      	adds	r3, #1
 800af2c:	442c      	add	r4, r5
 800af2e:	2b07      	cmp	r3, #7
 800af30:	942c      	str	r4, [sp, #176]	; 0xb0
 800af32:	f8c9 5004 	str.w	r5, [r9, #4]
 800af36:	932b      	str	r3, [sp, #172]	; 0xac
 800af38:	f300 84be 	bgt.w	800b8b8 <_svfprintf_r+0x1570>
 800af3c:	f109 0908 	add.w	r9, r9, #8
 800af40:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800af42:	2d00      	cmp	r5, #0
 800af44:	bfa8      	it	ge
 800af46:	1b5b      	subge	r3, r3, r5
 800af48:	2b00      	cmp	r3, #0
 800af4a:	461d      	mov	r5, r3
 800af4c:	f340 81d4 	ble.w	800b2f8 <_svfprintf_r+0xfb0>
 800af50:	2d10      	cmp	r5, #16
 800af52:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800af54:	4bbc      	ldr	r3, [pc, #752]	; (800b248 <_svfprintf_r+0xf00>)
 800af56:	f340 81bb 	ble.w	800b2d0 <_svfprintf_r+0xf88>
 800af5a:	4618      	mov	r0, r3
 800af5c:	4621      	mov	r1, r4
 800af5e:	464b      	mov	r3, r9
 800af60:	2710      	movs	r7, #16
 800af62:	46b1      	mov	r9, r6
 800af64:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800af68:	9c06      	ldr	r4, [sp, #24]
 800af6a:	4606      	mov	r6, r0
 800af6c:	e004      	b.n	800af78 <_svfprintf_r+0xc30>
 800af6e:	3308      	adds	r3, #8
 800af70:	3d10      	subs	r5, #16
 800af72:	2d10      	cmp	r5, #16
 800af74:	f340 81a7 	ble.w	800b2c6 <_svfprintf_r+0xf7e>
 800af78:	3201      	adds	r2, #1
 800af7a:	3110      	adds	r1, #16
 800af7c:	2a07      	cmp	r2, #7
 800af7e:	e9cd 212b 	strd	r2, r1, [sp, #172]	; 0xac
 800af82:	e9c3 6700 	strd	r6, r7, [r3]
 800af86:	ddf2      	ble.n	800af6e <_svfprintf_r+0xc26>
 800af88:	aa2a      	add	r2, sp, #168	; 0xa8
 800af8a:	4621      	mov	r1, r4
 800af8c:	4650      	mov	r0, sl
 800af8e:	f002 fdd5 	bl	800db3c <__ssprint_r>
 800af92:	2800      	cmp	r0, #0
 800af94:	f47f aaab 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800af98:	e9dd 212b 	ldrd	r2, r1, [sp, #172]	; 0xac
 800af9c:	ab2d      	add	r3, sp, #180	; 0xb4
 800af9e:	e7e7      	b.n	800af70 <_svfprintf_r+0xc28>
 800afa0:	f8cd a020 	str.w	sl, [sp, #32]
 800afa4:	ae56      	add	r6, sp, #344	; 0x158
 800afa6:	f7ff bae4 	b.w	800a572 <_svfprintf_r+0x22a>
 800afaa:	f1ba 0f00 	cmp.w	sl, #0
 800afae:	f77f af67 	ble.w	800ae80 <_svfprintf_r+0xb38>
 800afb2:	f1ba 0f10 	cmp.w	sl, #16
 800afb6:	4ba4      	ldr	r3, [pc, #656]	; (800b248 <_svfprintf_r+0xf00>)
 800afb8:	f340 864e 	ble.w	800bc58 <_svfprintf_r+0x1910>
 800afbc:	4619      	mov	r1, r3
 800afbe:	4622      	mov	r2, r4
 800afc0:	463b      	mov	r3, r7
 800afc2:	2610      	movs	r6, #16
 800afc4:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800afc8:	9c06      	ldr	r4, [sp, #24]
 800afca:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800afcc:	460f      	mov	r7, r1
 800afce:	e007      	b.n	800afe0 <_svfprintf_r+0xc98>
 800afd0:	3308      	adds	r3, #8
 800afd2:	f1aa 0a10 	sub.w	sl, sl, #16
 800afd6:	f1ba 0f10 	cmp.w	sl, #16
 800afda:	f340 828d 	ble.w	800b4f8 <_svfprintf_r+0x11b0>
 800afde:	3501      	adds	r5, #1
 800afe0:	3210      	adds	r2, #16
 800afe2:	2d07      	cmp	r5, #7
 800afe4:	e9cd 522b 	strd	r5, r2, [sp, #172]	; 0xac
 800afe8:	e9c3 7600 	strd	r7, r6, [r3]
 800afec:	ddf0      	ble.n	800afd0 <_svfprintf_r+0xc88>
 800afee:	aa2a      	add	r2, sp, #168	; 0xa8
 800aff0:	4621      	mov	r1, r4
 800aff2:	4648      	mov	r0, r9
 800aff4:	f002 fda2 	bl	800db3c <__ssprint_r>
 800aff8:	2800      	cmp	r0, #0
 800affa:	f47f aa78 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800affe:	e9dd 522b 	ldrd	r5, r2, [sp, #172]	; 0xac
 800b002:	ab2d      	add	r3, sp, #180	; 0xb4
 800b004:	e7e5      	b.n	800afd2 <_svfprintf_r+0xc8a>
 800b006:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b008:	f018 0f10 	tst.w	r8, #16
 800b00c:	f102 0304 	add.w	r3, r2, #4
 800b010:	d140      	bne.n	800b094 <_svfprintf_r+0xd4c>
 800b012:	f018 0f40 	tst.w	r8, #64	; 0x40
 800b016:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b018:	d038      	beq.n	800b08c <_svfprintf_r+0xd44>
 800b01a:	8814      	ldrh	r4, [r2, #0]
 800b01c:	9309      	str	r3, [sp, #36]	; 0x24
 800b01e:	2500      	movs	r5, #0
 800b020:	f7ff ba87 	b.w	800a532 <_svfprintf_r+0x1ea>
 800b024:	f018 0f01 	tst.w	r8, #1
 800b028:	f47f aeee 	bne.w	800ae08 <_svfprintf_r+0xac0>
 800b02c:	2201      	movs	r2, #1
 800b02e:	2d07      	cmp	r5, #7
 800b030:	f8c9 6000 	str.w	r6, [r9]
 800b034:	e9cd 542b 	strd	r5, r4, [sp, #172]	; 0xac
 800b038:	f8c9 2004 	str.w	r2, [r9, #4]
 800b03c:	f300 8108 	bgt.w	800b250 <_svfprintf_r+0xf08>
 800b040:	3302      	adds	r3, #2
 800b042:	9308      	str	r3, [sp, #32]
 800b044:	f109 0910 	add.w	r9, r9, #16
 800b048:	e71a      	b.n	800ae80 <_svfprintf_r+0xb38>
 800b04a:	f018 0f01 	tst.w	r8, #1
 800b04e:	f47f ae13 	bne.w	800ac78 <_svfprintf_r+0x930>
 800b052:	e423      	b.n	800a89c <_svfprintf_r+0x554>
 800b054:	aa2a      	add	r2, sp, #168	; 0xa8
 800b056:	9906      	ldr	r1, [sp, #24]
 800b058:	9803      	ldr	r0, [sp, #12]
 800b05a:	f002 fd6f 	bl	800db3c <__ssprint_r>
 800b05e:	2800      	cmp	r0, #0
 800b060:	f47f aa45 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b064:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b066:	e450      	b.n	800a90a <_svfprintf_r+0x5c2>
 800b068:	f418 7f00 	tst.w	r8, #512	; 0x200
 800b06c:	f040 830d 	bne.w	800b68a <_svfprintf_r+0x1342>
 800b070:	6814      	ldr	r4, [r2, #0]
 800b072:	9309      	str	r3, [sp, #36]	; 0x24
 800b074:	2500      	movs	r5, #0
 800b076:	f7ff bb10 	b.w	800a69a <_svfprintf_r+0x352>
 800b07a:	0598      	lsls	r0, r3, #22
 800b07c:	f100 830f 	bmi.w	800b69e <_svfprintf_r+0x1356>
 800b080:	6814      	ldr	r4, [r2, #0]
 800b082:	9109      	str	r1, [sp, #36]	; 0x24
 800b084:	2201      	movs	r2, #1
 800b086:	2500      	movs	r5, #0
 800b088:	f7ff ba56 	b.w	800a538 <_svfprintf_r+0x1f0>
 800b08c:	f418 7f00 	tst.w	r8, #512	; 0x200
 800b090:	f040 8313 	bne.w	800b6ba <_svfprintf_r+0x1372>
 800b094:	6814      	ldr	r4, [r2, #0]
 800b096:	9309      	str	r3, [sp, #36]	; 0x24
 800b098:	2500      	movs	r5, #0
 800b09a:	f7ff ba4a 	b.w	800a532 <_svfprintf_r+0x1ea>
 800b09e:	0598      	lsls	r0, r3, #22
 800b0a0:	f100 8303 	bmi.w	800b6aa <_svfprintf_r+0x1362>
 800b0a4:	680c      	ldr	r4, [r1, #0]
 800b0a6:	9209      	str	r2, [sp, #36]	; 0x24
 800b0a8:	17e5      	asrs	r5, r4, #31
 800b0aa:	4620      	mov	r0, r4
 800b0ac:	4629      	mov	r1, r5
 800b0ae:	f7ff ba96 	b.w	800a5de <_svfprintf_r+0x296>
 800b0b2:	9a05      	ldr	r2, [sp, #20]
 800b0b4:	4610      	mov	r0, r2
 800b0b6:	17d1      	asrs	r1, r2, #31
 800b0b8:	e9c3 0100 	strd	r0, r1, [r3]
 800b0bc:	465e      	mov	r6, fp
 800b0be:	e43a      	b.n	800a936 <_svfprintf_r+0x5ee>
 800b0c0:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800b0c4:	4602      	mov	r2, r0
 800b0c6:	460b      	mov	r3, r1
 800b0c8:	f7f5 fd72 	bl	8000bb0 <__aeabi_dcmpun>
 800b0cc:	2800      	cmp	r0, #0
 800b0ce:	f040 8599 	bne.w	800bc04 <_svfprintf_r+0x18bc>
 800b0d2:	2f61      	cmp	r7, #97	; 0x61
 800b0d4:	f000 8407 	beq.w	800b8e6 <_svfprintf_r+0x159e>
 800b0d8:	2f41      	cmp	r7, #65	; 0x41
 800b0da:	f000 82f9 	beq.w	800b6d0 <_svfprintf_r+0x1388>
 800b0de:	f448 7380 	orr.w	r3, r8, #256	; 0x100
 800b0e2:	f027 0220 	bic.w	r2, r7, #32
 800b0e6:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 800b0ea:	930e      	str	r3, [sp, #56]	; 0x38
 800b0ec:	9204      	str	r2, [sp, #16]
 800b0ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800b0f0:	f000 851f 	beq.w	800bb32 <_svfprintf_r+0x17ea>
 800b0f4:	2a47      	cmp	r2, #71	; 0x47
 800b0f6:	f000 8516 	beq.w	800bb26 <_svfprintf_r+0x17de>
 800b0fa:	2b00      	cmp	r3, #0
 800b0fc:	f2c0 83e9 	blt.w	800b8d2 <_svfprintf_r+0x158a>
 800b100:	ed9d 7b12 	vldr	d7, [sp, #72]	; 0x48
 800b104:	e9cd 000a 	strd	r0, r0, [sp, #40]	; 0x28
 800b108:	ed8d 7b1e 	vstr	d7, [sp, #120]	; 0x78
 800b10c:	2f66      	cmp	r7, #102	; 0x66
 800b10e:	f000 84dd 	beq.w	800bacc <_svfprintf_r+0x1784>
 800b112:	2f46      	cmp	r7, #70	; 0x46
 800b114:	f000 8562 	beq.w	800bbdc <_svfprintf_r+0x1894>
 800b118:	9b04      	ldr	r3, [sp, #16]
 800b11a:	9803      	ldr	r0, [sp, #12]
 800b11c:	2b45      	cmp	r3, #69	; 0x45
 800b11e:	bf0c      	ite	eq
 800b120:	f10a 0501 	addeq.w	r5, sl, #1
 800b124:	4655      	movne	r5, sl
 800b126:	aa28      	add	r2, sp, #160	; 0xa0
 800b128:	ab25      	add	r3, sp, #148	; 0x94
 800b12a:	e9cd 3200 	strd	r3, r2, [sp]
 800b12e:	2102      	movs	r1, #2
 800b130:	ab24      	add	r3, sp, #144	; 0x90
 800b132:	462a      	mov	r2, r5
 800b134:	ed9d 0b1e 	vldr	d0, [sp, #120]	; 0x78
 800b138:	f000 fe7e 	bl	800be38 <_dtoa_r>
 800b13c:	2f67      	cmp	r7, #103	; 0x67
 800b13e:	4606      	mov	r6, r0
 800b140:	f040 8595 	bne.w	800bc6e <_svfprintf_r+0x1926>
 800b144:	f018 0f01 	tst.w	r8, #1
 800b148:	f040 84f7 	bne.w	800bb3a <_svfprintf_r+0x17f2>
 800b14c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800b14e:	4640      	mov	r0, r8
 800b150:	1b9b      	subs	r3, r3, r6
 800b152:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 800b156:	9310      	str	r3, [sp, #64]	; 0x40
 800b158:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b15a:	9311      	str	r3, [sp, #68]	; 0x44
 800b15c:	9b04      	ldr	r3, [sp, #16]
 800b15e:	2b47      	cmp	r3, #71	; 0x47
 800b160:	f000 8371 	beq.w	800b846 <_svfprintf_r+0x14fe>
 800b164:	9b04      	ldr	r3, [sp, #16]
 800b166:	2b46      	cmp	r3, #70	; 0x46
 800b168:	f000 8407 	beq.w	800b97a <_svfprintf_r+0x1632>
 800b16c:	9904      	ldr	r1, [sp, #16]
 800b16e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b170:	b2fa      	uxtb	r2, r7
 800b172:	2941      	cmp	r1, #65	; 0x41
 800b174:	bf08      	it	eq
 800b176:	320f      	addeq	r2, #15
 800b178:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 800b17c:	bf06      	itte	eq
 800b17e:	b2d2      	uxtbeq	r2, r2
 800b180:	2101      	moveq	r1, #1
 800b182:	2100      	movne	r1, #0
 800b184:	2b00      	cmp	r3, #0
 800b186:	9324      	str	r3, [sp, #144]	; 0x90
 800b188:	bfb8      	it	lt
 800b18a:	9b11      	ldrlt	r3, [sp, #68]	; 0x44
 800b18c:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
 800b190:	bfba      	itte	lt
 800b192:	f1c3 0301 	rsblt	r3, r3, #1
 800b196:	222d      	movlt	r2, #45	; 0x2d
 800b198:	222b      	movge	r2, #43	; 0x2b
 800b19a:	2b09      	cmp	r3, #9
 800b19c:	f88d 2099 	strb.w	r2, [sp, #153]	; 0x99
 800b1a0:	f300 84e5 	bgt.w	800bb6e <_svfprintf_r+0x1826>
 800b1a4:	2900      	cmp	r1, #0
 800b1a6:	f040 856a 	bne.w	800bc7e <_svfprintf_r+0x1936>
 800b1aa:	2230      	movs	r2, #48	; 0x30
 800b1ac:	f88d 209a 	strb.w	r2, [sp, #154]	; 0x9a
 800b1b0:	f10d 029b 	add.w	r2, sp, #155	; 0x9b
 800b1b4:	3330      	adds	r3, #48	; 0x30
 800b1b6:	7013      	strb	r3, [r2, #0]
 800b1b8:	1c53      	adds	r3, r2, #1
 800b1ba:	aa26      	add	r2, sp, #152	; 0x98
 800b1bc:	1a9b      	subs	r3, r3, r2
 800b1be:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800b1c0:	9319      	str	r3, [sp, #100]	; 0x64
 800b1c2:	2a01      	cmp	r2, #1
 800b1c4:	4413      	add	r3, r2
 800b1c6:	9308      	str	r3, [sp, #32]
 800b1c8:	f340 8528 	ble.w	800bc1c <_svfprintf_r+0x18d4>
 800b1cc:	9b08      	ldr	r3, [sp, #32]
 800b1ce:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b1d0:	4413      	add	r3, r2
 800b1d2:	9308      	str	r3, [sp, #32]
 800b1d4:	2300      	movs	r3, #0
 800b1d6:	930f      	str	r3, [sp, #60]	; 0x3c
 800b1d8:	9314      	str	r3, [sp, #80]	; 0x50
 800b1da:	9311      	str	r3, [sp, #68]	; 0x44
 800b1dc:	9b08      	ldr	r3, [sp, #32]
 800b1de:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 800b1e2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b1e6:	f440 7880 	orr.w	r8, r0, #256	; 0x100
 800b1ea:	9304      	str	r3, [sp, #16]
 800b1ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b1ee:	2b00      	cmp	r3, #0
 800b1f0:	f040 833c 	bne.w	800b86c <_svfprintf_r+0x1524>
 800b1f4:	469a      	mov	sl, r3
 800b1f6:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800b1fa:	f7ff b9c6 	b.w	800a58a <_svfprintf_r+0x242>
 800b1fe:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800b200:	4912      	ldr	r1, [pc, #72]	; (800b24c <_svfprintf_r+0xf04>)
 800b202:	f8c9 1000 	str.w	r1, [r9]
 800b206:	3201      	adds	r2, #1
 800b208:	3401      	adds	r4, #1
 800b20a:	2101      	movs	r1, #1
 800b20c:	2a07      	cmp	r2, #7
 800b20e:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800b212:	f8c9 1004 	str.w	r1, [r9, #4]
 800b216:	f73f adb2 	bgt.w	800ad7e <_svfprintf_r+0xa36>
 800b21a:	f109 0908 	add.w	r9, r9, #8
 800b21e:	e5ba      	b.n	800ad96 <_svfprintf_r+0xa4e>
 800b220:	2140      	movs	r1, #64	; 0x40
 800b222:	9803      	ldr	r0, [sp, #12]
 800b224:	f001 fe6a 	bl	800cefc <_malloc_r>
 800b228:	9b06      	ldr	r3, [sp, #24]
 800b22a:	6018      	str	r0, [r3, #0]
 800b22c:	6118      	str	r0, [r3, #16]
 800b22e:	2800      	cmp	r0, #0
 800b230:	f000 8553 	beq.w	800bcda <_svfprintf_r+0x1992>
 800b234:	9a06      	ldr	r2, [sp, #24]
 800b236:	2340      	movs	r3, #64	; 0x40
 800b238:	6153      	str	r3, [r2, #20]
 800b23a:	f7ff b89c 	b.w	800a376 <_svfprintf_r+0x2e>
 800b23e:	4252      	negs	r2, r2
 800b240:	9207      	str	r2, [sp, #28]
 800b242:	9309      	str	r3, [sp, #36]	; 0x24
 800b244:	f7ff ba56 	b.w	800a6f4 <_svfprintf_r+0x3ac>
 800b248:	0801dc54 	.word	0x0801dc54
 800b24c:	0800e710 	.word	0x0800e710
 800b250:	aa2a      	add	r2, sp, #168	; 0xa8
 800b252:	9906      	ldr	r1, [sp, #24]
 800b254:	9803      	ldr	r0, [sp, #12]
 800b256:	f002 fc71 	bl	800db3c <__ssprint_r>
 800b25a:	2800      	cmp	r0, #0
 800b25c:	f47f a947 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b260:	e9dd 342b 	ldrd	r3, r4, [sp, #172]	; 0xac
 800b264:	3301      	adds	r3, #1
 800b266:	9308      	str	r3, [sp, #32]
 800b268:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
 800b26c:	af2d      	add	r7, sp, #180	; 0xb4
 800b26e:	e607      	b.n	800ae80 <_svfprintf_r+0xb38>
 800b270:	aa2a      	add	r2, sp, #168	; 0xa8
 800b272:	9906      	ldr	r1, [sp, #24]
 800b274:	9803      	ldr	r0, [sp, #12]
 800b276:	f002 fc61 	bl	800db3c <__ssprint_r>
 800b27a:	2800      	cmp	r0, #0
 800b27c:	f47f a937 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b280:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b282:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b286:	e507      	b.n	800ac98 <_svfprintf_r+0x950>
 800b288:	4653      	mov	r3, sl
 800b28a:	2b06      	cmp	r3, #6
 800b28c:	bf28      	it	cs
 800b28e:	2306      	movcs	r3, #6
 800b290:	46b2      	mov	sl, r6
 800b292:	960f      	str	r6, [sp, #60]	; 0x3c
 800b294:	9614      	str	r6, [sp, #80]	; 0x50
 800b296:	9611      	str	r6, [sp, #68]	; 0x44
 800b298:	960a      	str	r6, [sp, #40]	; 0x28
 800b29a:	4632      	mov	r2, r6
 800b29c:	9304      	str	r3, [sp, #16]
 800b29e:	e9cd 3408 	strd	r3, r4, [sp, #32]
 800b2a2:	4ea4      	ldr	r6, [pc, #656]	; (800b534 <_svfprintf_r+0x11ec>)
 800b2a4:	f7ff b971 	b.w	800a58a <_svfprintf_r+0x242>
 800b2a8:	aa2a      	add	r2, sp, #168	; 0xa8
 800b2aa:	9906      	ldr	r1, [sp, #24]
 800b2ac:	9803      	ldr	r0, [sp, #12]
 800b2ae:	f002 fc45 	bl	800db3c <__ssprint_r>
 800b2b2:	2800      	cmp	r0, #0
 800b2b4:	f47f a91b 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b2b8:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800b2bc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b2be:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b2c2:	f7ff ba79 	b.w	800a7b8 <_svfprintf_r+0x470>
 800b2c6:	460c      	mov	r4, r1
 800b2c8:	4631      	mov	r1, r6
 800b2ca:	464e      	mov	r6, r9
 800b2cc:	4699      	mov	r9, r3
 800b2ce:	460b      	mov	r3, r1
 800b2d0:	3201      	adds	r2, #1
 800b2d2:	442c      	add	r4, r5
 800b2d4:	2a07      	cmp	r2, #7
 800b2d6:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800b2da:	e9c9 3500 	strd	r3, r5, [r9]
 800b2de:	f340 81d1 	ble.w	800b684 <_svfprintf_r+0x133c>
 800b2e2:	aa2a      	add	r2, sp, #168	; 0xa8
 800b2e4:	9906      	ldr	r1, [sp, #24]
 800b2e6:	9803      	ldr	r0, [sp, #12]
 800b2e8:	f002 fc28 	bl	800db3c <__ssprint_r>
 800b2ec:	2800      	cmp	r0, #0
 800b2ee:	f47f a8fe 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b2f2:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b2f4:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b2f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b2fa:	f418 6f80 	tst.w	r8, #1024	; 0x400
 800b2fe:	4433      	add	r3, r6
 800b300:	469a      	mov	sl, r3
 800b302:	f040 811b 	bne.w	800b53c <_svfprintf_r+0x11f4>
 800b306:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b308:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800b30a:	4293      	cmp	r3, r2
 800b30c:	db49      	blt.n	800b3a2 <_svfprintf_r+0x105a>
 800b30e:	f018 0f01 	tst.w	r8, #1
 800b312:	d146      	bne.n	800b3a2 <_svfprintf_r+0x105a>
 800b314:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800b316:	18b5      	adds	r5, r6, r2
 800b318:	eba5 050a 	sub.w	r5, r5, sl
 800b31c:	1ad3      	subs	r3, r2, r3
 800b31e:	429d      	cmp	r5, r3
 800b320:	bfa8      	it	ge
 800b322:	461d      	movge	r5, r3
 800b324:	2d00      	cmp	r5, #0
 800b326:	dd0d      	ble.n	800b344 <_svfprintf_r+0xffc>
 800b328:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800b32a:	f8c9 a000 	str.w	sl, [r9]
 800b32e:	3201      	adds	r2, #1
 800b330:	442c      	add	r4, r5
 800b332:	2a07      	cmp	r2, #7
 800b334:	942c      	str	r4, [sp, #176]	; 0xb0
 800b336:	f8c9 5004 	str.w	r5, [r9, #4]
 800b33a:	922b      	str	r2, [sp, #172]	; 0xac
 800b33c:	f300 833c 	bgt.w	800b9b8 <_svfprintf_r+0x1670>
 800b340:	f109 0908 	add.w	r9, r9, #8
 800b344:	2d00      	cmp	r5, #0
 800b346:	bfac      	ite	ge
 800b348:	1b5d      	subge	r5, r3, r5
 800b34a:	461d      	movlt	r5, r3
 800b34c:	2d00      	cmp	r5, #0
 800b34e:	f77f aaa5 	ble.w	800a89c <_svfprintf_r+0x554>
 800b352:	2d10      	cmp	r5, #16
 800b354:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800b356:	4b78      	ldr	r3, [pc, #480]	; (800b538 <_svfprintf_r+0x11f0>)
 800b358:	f340 80ab 	ble.w	800b4b2 <_svfprintf_r+0x116a>
 800b35c:	4619      	mov	r1, r3
 800b35e:	2610      	movs	r6, #16
 800b360:	4623      	mov	r3, r4
 800b362:	9f03      	ldr	r7, [sp, #12]
 800b364:	f8dd a018 	ldr.w	sl, [sp, #24]
 800b368:	460c      	mov	r4, r1
 800b36a:	e005      	b.n	800b378 <_svfprintf_r+0x1030>
 800b36c:	f109 0908 	add.w	r9, r9, #8
 800b370:	3d10      	subs	r5, #16
 800b372:	2d10      	cmp	r5, #16
 800b374:	f340 809a 	ble.w	800b4ac <_svfprintf_r+0x1164>
 800b378:	3201      	adds	r2, #1
 800b37a:	3310      	adds	r3, #16
 800b37c:	2a07      	cmp	r2, #7
 800b37e:	e9cd 232b 	strd	r2, r3, [sp, #172]	; 0xac
 800b382:	e9c9 4600 	strd	r4, r6, [r9]
 800b386:	ddf1      	ble.n	800b36c <_svfprintf_r+0x1024>
 800b388:	aa2a      	add	r2, sp, #168	; 0xa8
 800b38a:	4651      	mov	r1, sl
 800b38c:	4638      	mov	r0, r7
 800b38e:	f002 fbd5 	bl	800db3c <__ssprint_r>
 800b392:	2800      	cmp	r0, #0
 800b394:	f47f a8ab 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b398:	e9dd 232b 	ldrd	r2, r3, [sp, #172]	; 0xac
 800b39c:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b3a0:	e7e6      	b.n	800b370 <_svfprintf_r+0x1028>
 800b3a2:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800b3a4:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b3a6:	f8c9 1000 	str.w	r1, [r9]
 800b3aa:	9916      	ldr	r1, [sp, #88]	; 0x58
 800b3ac:	f8c9 1004 	str.w	r1, [r9, #4]
 800b3b0:	3201      	adds	r2, #1
 800b3b2:	440c      	add	r4, r1
 800b3b4:	2a07      	cmp	r2, #7
 800b3b6:	942c      	str	r4, [sp, #176]	; 0xb0
 800b3b8:	922b      	str	r2, [sp, #172]	; 0xac
 800b3ba:	f300 82b5 	bgt.w	800b928 <_svfprintf_r+0x15e0>
 800b3be:	f109 0908 	add.w	r9, r9, #8
 800b3c2:	e7a7      	b.n	800b314 <_svfprintf_r+0xfcc>
 800b3c4:	2d00      	cmp	r5, #0
 800b3c6:	bf08      	it	eq
 800b3c8:	2c0a      	cmpeq	r4, #10
 800b3ca:	4698      	mov	r8, r3
 800b3cc:	f4ff ad6d 	bcc.w	800aeaa <_svfprintf_r+0xb62>
 800b3d0:	f408 6380 	and.w	r3, r8, #1024	; 0x400
 800b3d4:	2200      	movs	r2, #0
 800b3d6:	f8cd 9020 	str.w	r9, [sp, #32]
 800b3da:	970a      	str	r7, [sp, #40]	; 0x28
 800b3dc:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 800b3e0:	ae56      	add	r6, sp, #344	; 0x158
 800b3e2:	4691      	mov	r9, r2
 800b3e4:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
 800b3e8:	461f      	mov	r7, r3
 800b3ea:	e00a      	b.n	800b402 <_svfprintf_r+0x10ba>
 800b3ec:	2300      	movs	r3, #0
 800b3ee:	4620      	mov	r0, r4
 800b3f0:	4629      	mov	r1, r5
 800b3f2:	220a      	movs	r2, #10
 800b3f4:	f7f5 fdc4 	bl	8000f80 <__aeabi_uldivmod>
 800b3f8:	4604      	mov	r4, r0
 800b3fa:	460d      	mov	r5, r1
 800b3fc:	ea54 0305 	orrs.w	r3, r4, r5
 800b400:	d046      	beq.n	800b490 <_svfprintf_r+0x1148>
 800b402:	220a      	movs	r2, #10
 800b404:	2300      	movs	r3, #0
 800b406:	4620      	mov	r0, r4
 800b408:	4629      	mov	r1, r5
 800b40a:	f7f5 fdb9 	bl	8000f80 <__aeabi_uldivmod>
 800b40e:	3230      	adds	r2, #48	; 0x30
 800b410:	f806 2c01 	strb.w	r2, [r6, #-1]
 800b414:	f109 0901 	add.w	r9, r9, #1
 800b418:	3e01      	subs	r6, #1
 800b41a:	2f00      	cmp	r7, #0
 800b41c:	d0e6      	beq.n	800b3ec <_svfprintf_r+0x10a4>
 800b41e:	f898 3000 	ldrb.w	r3, [r8]
 800b422:	4599      	cmp	r9, r3
 800b424:	d1e2      	bne.n	800b3ec <_svfprintf_r+0x10a4>
 800b426:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
 800b42a:	d0df      	beq.n	800b3ec <_svfprintf_r+0x10a4>
 800b42c:	2d00      	cmp	r5, #0
 800b42e:	bf08      	it	eq
 800b430:	2c0a      	cmpeq	r4, #10
 800b432:	d3db      	bcc.n	800b3ec <_svfprintf_r+0x10a4>
 800b434:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800b436:	9918      	ldr	r1, [sp, #96]	; 0x60
 800b438:	1af6      	subs	r6, r6, r3
 800b43a:	461a      	mov	r2, r3
 800b43c:	4630      	mov	r0, r6
 800b43e:	f002 fb4b 	bl	800dad8 <strncpy>
 800b442:	f898 3001 	ldrb.w	r3, [r8, #1]
 800b446:	2b00      	cmp	r3, #0
 800b448:	f000 8389 	beq.w	800bb5e <_svfprintf_r+0x1816>
 800b44c:	f108 0801 	add.w	r8, r8, #1
 800b450:	f04f 0900 	mov.w	r9, #0
 800b454:	e7ca      	b.n	800b3ec <_svfprintf_r+0x10a4>
 800b456:	aa2a      	add	r2, sp, #168	; 0xa8
 800b458:	9906      	ldr	r1, [sp, #24]
 800b45a:	9803      	ldr	r0, [sp, #12]
 800b45c:	f002 fb6e 	bl	800db3c <__ssprint_r>
 800b460:	2800      	cmp	r0, #0
 800b462:	f47f a844 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b466:	e9dd 542b 	ldrd	r5, r4, [sp, #172]	; 0xac
 800b46a:	af2d      	add	r7, sp, #180	; 0xb4
 800b46c:	e4d6      	b.n	800ae1c <_svfprintf_r+0xad4>
 800b46e:	aa2a      	add	r2, sp, #168	; 0xa8
 800b470:	9906      	ldr	r1, [sp, #24]
 800b472:	9803      	ldr	r0, [sp, #12]
 800b474:	f002 fb62 	bl	800db3c <__ssprint_r>
 800b478:	2800      	cmp	r0, #0
 800b47a:	f47f a838 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b47e:	e9dd 342b 	ldrd	r3, r4, [sp, #172]	; 0xac
 800b482:	af2d      	add	r7, sp, #180	; 0xb4
 800b484:	930b      	str	r3, [sp, #44]	; 0x2c
 800b486:	e4d6      	b.n	800ae36 <_svfprintf_r+0xaee>
 800b488:	2a01      	cmp	r2, #1
 800b48a:	f47f a8c2 	bne.w	800a612 <_svfprintf_r+0x2ca>
 800b48e:	e50c      	b.n	800aeaa <_svfprintf_r+0xb62>
 800b490:	9b04      	ldr	r3, [sp, #16]
 800b492:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
 800b496:	1b9b      	subs	r3, r3, r6
 800b498:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800b49c:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
 800b4a0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800b4a2:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 800b4a6:	9308      	str	r3, [sp, #32]
 800b4a8:	f7ff b863 	b.w	800a572 <_svfprintf_r+0x22a>
 800b4ac:	4621      	mov	r1, r4
 800b4ae:	461c      	mov	r4, r3
 800b4b0:	460b      	mov	r3, r1
 800b4b2:	3201      	adds	r2, #1
 800b4b4:	442c      	add	r4, r5
 800b4b6:	2a07      	cmp	r2, #7
 800b4b8:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800b4bc:	e9c9 3500 	strd	r3, r5, [r9]
 800b4c0:	f77f a9ea 	ble.w	800a898 <_svfprintf_r+0x550>
 800b4c4:	e489      	b.n	800adda <_svfprintf_r+0xa92>
 800b4c6:	aa2a      	add	r2, sp, #168	; 0xa8
 800b4c8:	9906      	ldr	r1, [sp, #24]
 800b4ca:	9803      	ldr	r0, [sp, #12]
 800b4cc:	f002 fb36 	bl	800db3c <__ssprint_r>
 800b4d0:	2800      	cmp	r0, #0
 800b4d2:	f47f a80c 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b4d6:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b4d8:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b4dc:	f7ff b990 	b.w	800a800 <_svfprintf_r+0x4b8>
 800b4e0:	aa2a      	add	r2, sp, #168	; 0xa8
 800b4e2:	9906      	ldr	r1, [sp, #24]
 800b4e4:	9803      	ldr	r0, [sp, #12]
 800b4e6:	f002 fb29 	bl	800db3c <__ssprint_r>
 800b4ea:	2800      	cmp	r0, #0
 800b4ec:	f47e afff 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b4f0:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b4f4:	f7ff bbba 	b.w	800ac6c <_svfprintf_r+0x924>
 800b4f8:	4614      	mov	r4, r2
 800b4fa:	463a      	mov	r2, r7
 800b4fc:	461f      	mov	r7, r3
 800b4fe:	4613      	mov	r3, r2
 800b500:	462a      	mov	r2, r5
 800b502:	3201      	adds	r2, #1
 800b504:	9208      	str	r2, [sp, #32]
 800b506:	f107 0208 	add.w	r2, r7, #8
 800b50a:	e9c7 3a00 	strd	r3, sl, [r7]
 800b50e:	9b08      	ldr	r3, [sp, #32]
 800b510:	932b      	str	r3, [sp, #172]	; 0xac
 800b512:	4454      	add	r4, sl
 800b514:	2b07      	cmp	r3, #7
 800b516:	942c      	str	r4, [sp, #176]	; 0xb0
 800b518:	f73f ae9a 	bgt.w	800b250 <_svfprintf_r+0xf08>
 800b51c:	3301      	adds	r3, #1
 800b51e:	9308      	str	r3, [sp, #32]
 800b520:	f102 0908 	add.w	r9, r2, #8
 800b524:	4617      	mov	r7, r2
 800b526:	e4ab      	b.n	800ae80 <_svfprintf_r+0xb38>
 800b528:	9a05      	ldr	r2, [sp, #20]
 800b52a:	601a      	str	r2, [r3, #0]
 800b52c:	465e      	mov	r6, fp
 800b52e:	f7ff ba02 	b.w	800a936 <_svfprintf_r+0x5ee>
 800b532:	bf00      	nop
 800b534:	0800e754 	.word	0x0800e754
 800b538:	0801dc54 	.word	0x0801dc54
 800b53c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b53e:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 800b542:	18f3      	adds	r3, r6, r3
 800b544:	9308      	str	r3, [sp, #32]
 800b546:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b548:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
 800b54c:	464a      	mov	r2, r9
 800b54e:	960c      	str	r6, [sp, #48]	; 0x30
 800b550:	4fc2      	ldr	r7, [pc, #776]	; (800b85c <_svfprintf_r+0x1514>)
 800b552:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 800b556:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
 800b55a:	f8dd b018 	ldr.w	fp, [sp, #24]
 800b55e:	4656      	mov	r6, sl
 800b560:	4621      	mov	r1, r4
 800b562:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800b566:	2b00      	cmp	r3, #0
 800b568:	d05e      	beq.n	800b628 <_svfprintf_r+0x12e0>
 800b56a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b56c:	2b00      	cmp	r3, #0
 800b56e:	d15f      	bne.n	800b630 <_svfprintf_r+0x12e8>
 800b570:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b572:	3b01      	subs	r3, #1
 800b574:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800b578:	9314      	str	r3, [sp, #80]	; 0x50
 800b57a:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800b57c:	9818      	ldr	r0, [sp, #96]	; 0x60
 800b57e:	6010      	str	r0, [r2, #0]
 800b580:	3301      	adds	r3, #1
 800b582:	4449      	add	r1, r9
 800b584:	2b07      	cmp	r3, #7
 800b586:	912c      	str	r1, [sp, #176]	; 0xb0
 800b588:	f8c2 9004 	str.w	r9, [r2, #4]
 800b58c:	932b      	str	r3, [sp, #172]	; 0xac
 800b58e:	dc53      	bgt.n	800b638 <_svfprintf_r+0x12f0>
 800b590:	3208      	adds	r2, #8
 800b592:	9808      	ldr	r0, [sp, #32]
 800b594:	f898 3000 	ldrb.w	r3, [r8]
 800b598:	1b85      	subs	r5, r0, r6
 800b59a:	429d      	cmp	r5, r3
 800b59c:	bfa8      	it	ge
 800b59e:	461d      	movge	r5, r3
 800b5a0:	2d00      	cmp	r5, #0
 800b5a2:	dd0b      	ble.n	800b5bc <_svfprintf_r+0x1274>
 800b5a4:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800b5a6:	6016      	str	r6, [r2, #0]
 800b5a8:	3301      	adds	r3, #1
 800b5aa:	4429      	add	r1, r5
 800b5ac:	2b07      	cmp	r3, #7
 800b5ae:	912c      	str	r1, [sp, #176]	; 0xb0
 800b5b0:	6055      	str	r5, [r2, #4]
 800b5b2:	932b      	str	r3, [sp, #172]	; 0xac
 800b5b4:	dc4b      	bgt.n	800b64e <_svfprintf_r+0x1306>
 800b5b6:	f898 3000 	ldrb.w	r3, [r8]
 800b5ba:	3208      	adds	r2, #8
 800b5bc:	2d00      	cmp	r5, #0
 800b5be:	bfac      	ite	ge
 800b5c0:	1b5d      	subge	r5, r3, r5
 800b5c2:	461d      	movlt	r5, r3
 800b5c4:	2d00      	cmp	r5, #0
 800b5c6:	dd2b      	ble.n	800b620 <_svfprintf_r+0x12d8>
 800b5c8:	2d10      	cmp	r5, #16
 800b5ca:	982b      	ldr	r0, [sp, #172]	; 0xac
 800b5cc:	dd1c      	ble.n	800b608 <_svfprintf_r+0x12c0>
 800b5ce:	2410      	movs	r4, #16
 800b5d0:	e004      	b.n	800b5dc <_svfprintf_r+0x1294>
 800b5d2:	3d10      	subs	r5, #16
 800b5d4:	2d10      	cmp	r5, #16
 800b5d6:	f102 0208 	add.w	r2, r2, #8
 800b5da:	dd15      	ble.n	800b608 <_svfprintf_r+0x12c0>
 800b5dc:	3001      	adds	r0, #1
 800b5de:	3110      	adds	r1, #16
 800b5e0:	2807      	cmp	r0, #7
 800b5e2:	e9cd 012b 	strd	r0, r1, [sp, #172]	; 0xac
 800b5e6:	e9c2 7400 	strd	r7, r4, [r2]
 800b5ea:	ddf2      	ble.n	800b5d2 <_svfprintf_r+0x128a>
 800b5ec:	aa2a      	add	r2, sp, #168	; 0xa8
 800b5ee:	4659      	mov	r1, fp
 800b5f0:	4650      	mov	r0, sl
 800b5f2:	f002 faa3 	bl	800db3c <__ssprint_r>
 800b5f6:	2800      	cmp	r0, #0
 800b5f8:	f47e af79 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b5fc:	3d10      	subs	r5, #16
 800b5fe:	2d10      	cmp	r5, #16
 800b600:	e9dd 012b 	ldrd	r0, r1, [sp, #172]	; 0xac
 800b604:	aa2d      	add	r2, sp, #180	; 0xb4
 800b606:	dce9      	bgt.n	800b5dc <_svfprintf_r+0x1294>
 800b608:	3001      	adds	r0, #1
 800b60a:	4429      	add	r1, r5
 800b60c:	2807      	cmp	r0, #7
 800b60e:	e9cd 012b 	strd	r0, r1, [sp, #172]	; 0xac
 800b612:	e9c2 7500 	strd	r7, r5, [r2]
 800b616:	f73e af62 	bgt.w	800a4de <_svfprintf_r+0x196>
 800b61a:	f898 3000 	ldrb.w	r3, [r8]
 800b61e:	3208      	adds	r2, #8
 800b620:	441e      	add	r6, r3
 800b622:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b624:	2b00      	cmp	r3, #0
 800b626:	d1a0      	bne.n	800b56a <_svfprintf_r+0x1222>
 800b628:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b62a:	2b00      	cmp	r3, #0
 800b62c:	f000 80fb 	beq.w	800b826 <_svfprintf_r+0x14de>
 800b630:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b632:	3b01      	subs	r3, #1
 800b634:	930f      	str	r3, [sp, #60]	; 0x3c
 800b636:	e7a0      	b.n	800b57a <_svfprintf_r+0x1232>
 800b638:	aa2a      	add	r2, sp, #168	; 0xa8
 800b63a:	4659      	mov	r1, fp
 800b63c:	4650      	mov	r0, sl
 800b63e:	f002 fa7d 	bl	800db3c <__ssprint_r>
 800b642:	2800      	cmp	r0, #0
 800b644:	f47e af53 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b648:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800b64a:	aa2d      	add	r2, sp, #180	; 0xb4
 800b64c:	e7a1      	b.n	800b592 <_svfprintf_r+0x124a>
 800b64e:	aa2a      	add	r2, sp, #168	; 0xa8
 800b650:	4659      	mov	r1, fp
 800b652:	4650      	mov	r0, sl
 800b654:	f002 fa72 	bl	800db3c <__ssprint_r>
 800b658:	2800      	cmp	r0, #0
 800b65a:	f47e af48 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b65e:	f898 3000 	ldrb.w	r3, [r8]
 800b662:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800b664:	aa2d      	add	r2, sp, #180	; 0xb4
 800b666:	e7a9      	b.n	800b5bc <_svfprintf_r+0x1274>
 800b668:	4630      	mov	r0, r6
 800b66a:	f7f5 fbc9 	bl	8000e00 <strlen>
 800b66e:	46aa      	mov	sl, r5
 800b670:	4603      	mov	r3, r0
 800b672:	9008      	str	r0, [sp, #32]
 800b674:	f7ff b9a6 	b.w	800a9c4 <_svfprintf_r+0x67c>
 800b678:	f898 3000 	ldrb.w	r3, [r8]
 800b67c:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800b67e:	aa2d      	add	r2, sp, #180	; 0xb4
 800b680:	441e      	add	r6, r3
 800b682:	e7ce      	b.n	800b622 <_svfprintf_r+0x12da>
 800b684:	f109 0908 	add.w	r9, r9, #8
 800b688:	e636      	b.n	800b2f8 <_svfprintf_r+0xfb0>
 800b68a:	7814      	ldrb	r4, [r2, #0]
 800b68c:	9309      	str	r3, [sp, #36]	; 0x24
 800b68e:	2500      	movs	r5, #0
 800b690:	f7ff b803 	b.w	800a69a <_svfprintf_r+0x352>
 800b694:	9a05      	ldr	r2, [sp, #20]
 800b696:	801a      	strh	r2, [r3, #0]
 800b698:	465e      	mov	r6, fp
 800b69a:	f7ff b94c 	b.w	800a936 <_svfprintf_r+0x5ee>
 800b69e:	7814      	ldrb	r4, [r2, #0]
 800b6a0:	9109      	str	r1, [sp, #36]	; 0x24
 800b6a2:	2500      	movs	r5, #0
 800b6a4:	2201      	movs	r2, #1
 800b6a6:	f7fe bf47 	b.w	800a538 <_svfprintf_r+0x1f0>
 800b6aa:	f991 4000 	ldrsb.w	r4, [r1]
 800b6ae:	9209      	str	r2, [sp, #36]	; 0x24
 800b6b0:	17e5      	asrs	r5, r4, #31
 800b6b2:	4620      	mov	r0, r4
 800b6b4:	4629      	mov	r1, r5
 800b6b6:	f7fe bf92 	b.w	800a5de <_svfprintf_r+0x296>
 800b6ba:	7814      	ldrb	r4, [r2, #0]
 800b6bc:	9309      	str	r3, [sp, #36]	; 0x24
 800b6be:	2500      	movs	r5, #0
 800b6c0:	f7fe bf37 	b.w	800a532 <_svfprintf_r+0x1ea>
 800b6c4:	f018 0f01 	tst.w	r8, #1
 800b6c8:	f43f a8e8 	beq.w	800a89c <_svfprintf_r+0x554>
 800b6cc:	f7ff bb68 	b.w	800ada0 <_svfprintf_r+0xa58>
 800b6d0:	2330      	movs	r3, #48	; 0x30
 800b6d2:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 800b6d6:	2358      	movs	r3, #88	; 0x58
 800b6d8:	f1ba 0f63 	cmp.w	sl, #99	; 0x63
 800b6dc:	f88d 308d 	strb.w	r3, [sp, #141]	; 0x8d
 800b6e0:	f048 0402 	orr.w	r4, r8, #2
 800b6e4:	f300 81b6 	bgt.w	800ba54 <_svfprintf_r+0x170c>
 800b6e8:	f448 7381 	orr.w	r3, r8, #258	; 0x102
 800b6ec:	930e      	str	r3, [sp, #56]	; 0x38
 800b6ee:	f027 0320 	bic.w	r3, r7, #32
 800b6f2:	9304      	str	r3, [sp, #16]
 800b6f4:	2200      	movs	r2, #0
 800b6f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800b6f8:	920a      	str	r2, [sp, #40]	; 0x28
 800b6fa:	46a0      	mov	r8, r4
 800b6fc:	ae3d      	add	r6, sp, #244	; 0xf4
 800b6fe:	2b00      	cmp	r3, #0
 800b700:	f2c0 80e8 	blt.w	800b8d4 <_svfprintf_r+0x158c>
 800b704:	ed9d 7b12 	vldr	d7, [sp, #72]	; 0x48
 800b708:	ed8d 7b1e 	vstr	d7, [sp, #120]	; 0x78
 800b70c:	2300      	movs	r3, #0
 800b70e:	930b      	str	r3, [sp, #44]	; 0x2c
 800b710:	2f61      	cmp	r7, #97	; 0x61
 800b712:	f000 8160 	beq.w	800b9d6 <_svfprintf_r+0x168e>
 800b716:	2f41      	cmp	r7, #65	; 0x41
 800b718:	f47f acf8 	bne.w	800b10c <_svfprintf_r+0xdc4>
 800b71c:	a824      	add	r0, sp, #144	; 0x90
 800b71e:	ed9d 0b1e 	vldr	d0, [sp, #120]	; 0x78
 800b722:	f002 f9a5 	bl	800da70 <frexp>
 800b726:	2200      	movs	r2, #0
 800b728:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 800b72c:	ec51 0b10 	vmov	r0, r1, d0
 800b730:	f7f4 ffa4 	bl	800067c <__aeabi_dmul>
 800b734:	2200      	movs	r2, #0
 800b736:	2300      	movs	r3, #0
 800b738:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 800b73c:	f7f5 fa06 	bl	8000b4c <__aeabi_dcmpeq>
 800b740:	2800      	cmp	r0, #0
 800b742:	f040 8243 	bne.w	800bbcc <_svfprintf_r+0x1884>
 800b746:	4b46      	ldr	r3, [pc, #280]	; (800b860 <_svfprintf_r+0x1518>)
 800b748:	9308      	str	r3, [sp, #32]
 800b74a:	f10a 34ff 	add.w	r4, sl, #4294967295	; 0xffffffff
 800b74e:	e9cd 9b0f 	strd	r9, fp, [sp, #60]	; 0x3c
 800b752:	9711      	str	r7, [sp, #68]	; 0x44
 800b754:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
 800b758:	46b1      	mov	r9, r6
 800b75a:	9621      	str	r6, [sp, #132]	; 0x84
 800b75c:	f8cd 8080 	str.w	r8, [sp, #128]	; 0x80
 800b760:	f8dd a020 	ldr.w	sl, [sp, #32]
 800b764:	e9dd 670c 	ldrd	r6, r7, [sp, #48]	; 0x30
 800b768:	e003      	b.n	800b772 <_svfprintf_r+0x142a>
 800b76a:	f7f5 f9ef 	bl	8000b4c <__aeabi_dcmpeq>
 800b76e:	bb20      	cbnz	r0, 800b7ba <_svfprintf_r+0x1472>
 800b770:	46a9      	mov	r9, r5
 800b772:	2200      	movs	r2, #0
 800b774:	4b3b      	ldr	r3, [pc, #236]	; (800b864 <_svfprintf_r+0x151c>)
 800b776:	4630      	mov	r0, r6
 800b778:	4639      	mov	r1, r7
 800b77a:	f7f4 ff7f 	bl	800067c <__aeabi_dmul>
 800b77e:	460f      	mov	r7, r1
 800b780:	4606      	mov	r6, r0
 800b782:	f7f5 fa2b 	bl	8000bdc <__aeabi_d2iz>
 800b786:	4680      	mov	r8, r0
 800b788:	f7f4 ff0e 	bl	80005a8 <__aeabi_i2d>
 800b78c:	4602      	mov	r2, r0
 800b78e:	460b      	mov	r3, r1
 800b790:	4630      	mov	r0, r6
 800b792:	4639      	mov	r1, r7
 800b794:	f7f4 fdba 	bl	800030c <__aeabi_dsub>
 800b798:	464d      	mov	r5, r9
 800b79a:	f81a c008 	ldrb.w	ip, [sl, r8]
 800b79e:	f805 cb01 	strb.w	ip, [r5], #1
 800b7a2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 800b7a6:	46a3      	mov	fp, r4
 800b7a8:	4606      	mov	r6, r0
 800b7aa:	460f      	mov	r7, r1
 800b7ac:	f04f 0200 	mov.w	r2, #0
 800b7b0:	f04f 0300 	mov.w	r3, #0
 800b7b4:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 800b7b8:	d1d7      	bne.n	800b76a <_svfprintf_r+0x1422>
 800b7ba:	4630      	mov	r0, r6
 800b7bc:	4639      	mov	r1, r7
 800b7be:	2200      	movs	r2, #0
 800b7c0:	4b29      	ldr	r3, [pc, #164]	; (800b868 <_svfprintf_r+0x1520>)
 800b7c2:	9f11      	ldr	r7, [sp, #68]	; 0x44
 800b7c4:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
 800b7c8:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
 800b7cc:	4644      	mov	r4, r8
 800b7ce:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
 800b7d2:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 800b7d6:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
 800b7da:	9e21      	ldr	r6, [sp, #132]	; 0x84
 800b7dc:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
 800b7e0:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 800b7e4:	f7f5 f9da 	bl	8000b9c <__aeabi_dcmpgt>
 800b7e8:	2800      	cmp	r0, #0
 800b7ea:	f040 80aa 	bne.w	800b942 <_svfprintf_r+0x15fa>
 800b7ee:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 800b7f2:	2200      	movs	r2, #0
 800b7f4:	4b1c      	ldr	r3, [pc, #112]	; (800b868 <_svfprintf_r+0x1520>)
 800b7f6:	f7f5 f9a9 	bl	8000b4c <__aeabi_dcmpeq>
 800b7fa:	b118      	cbz	r0, 800b804 <_svfprintf_r+0x14bc>
 800b7fc:	4623      	mov	r3, r4
 800b7fe:	07db      	lsls	r3, r3, #31
 800b800:	f100 809f 	bmi.w	800b942 <_svfprintf_r+0x15fa>
 800b804:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b806:	2b00      	cmp	r3, #0
 800b808:	db07      	blt.n	800b81a <_svfprintf_r+0x14d2>
 800b80a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b80c:	3301      	adds	r3, #1
 800b80e:	442b      	add	r3, r5
 800b810:	2230      	movs	r2, #48	; 0x30
 800b812:	f805 2b01 	strb.w	r2, [r5], #1
 800b816:	42ab      	cmp	r3, r5
 800b818:	d1fb      	bne.n	800b812 <_svfprintf_r+0x14ca>
 800b81a:	1bab      	subs	r3, r5, r6
 800b81c:	4640      	mov	r0, r8
 800b81e:	9310      	str	r3, [sp, #64]	; 0x40
 800b820:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 800b824:	e498      	b.n	800b158 <_svfprintf_r+0xe10>
 800b826:	46b2      	mov	sl, r6
 800b828:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b82a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800b82c:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
 800b830:	18f3      	adds	r3, r6, r3
 800b832:	459a      	cmp	sl, r3
 800b834:	4691      	mov	r9, r2
 800b836:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800b83a:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 800b83e:	460c      	mov	r4, r1
 800b840:	bf28      	it	cs
 800b842:	469a      	movcs	sl, r3
 800b844:	e55f      	b.n	800b306 <_svfprintf_r+0xfbe>
 800b846:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b848:	1cda      	adds	r2, r3, #3
 800b84a:	db01      	blt.n	800b850 <_svfprintf_r+0x1508>
 800b84c:	4553      	cmp	r3, sl
 800b84e:	dd14      	ble.n	800b87a <_svfprintf_r+0x1532>
 800b850:	3f02      	subs	r7, #2
 800b852:	f027 0320 	bic.w	r3, r7, #32
 800b856:	9304      	str	r3, [sp, #16]
 800b858:	e488      	b.n	800b16c <_svfprintf_r+0xe24>
 800b85a:	bf00      	nop
 800b85c:	0801dc54 	.word	0x0801dc54
 800b860:	0801dc30 	.word	0x0801dc30
 800b864:	40300000 	.word	0x40300000
 800b868:	3fe00000 	.word	0x3fe00000
 800b86c:	222d      	movs	r2, #45	; 0x2d
 800b86e:	f88d 208b 	strb.w	r2, [sp, #139]	; 0x8b
 800b872:	f04f 0a00 	mov.w	sl, #0
 800b876:	f7fe be8b 	b.w	800a590 <_svfprintf_r+0x248>
 800b87a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b87c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800b87e:	428b      	cmp	r3, r1
 800b880:	f2c0 8090 	blt.w	800b9a4 <_svfprintf_r+0x165c>
 800b884:	07c2      	lsls	r2, r0, #31
 800b886:	f140 81a6 	bpl.w	800bbd6 <_svfprintf_r+0x188e>
 800b88a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b88c:	4413      	add	r3, r2
 800b88e:	9308      	str	r3, [sp, #32]
 800b890:	0547      	lsls	r7, r0, #21
 800b892:	d503      	bpl.n	800b89c <_svfprintf_r+0x1554>
 800b894:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b896:	2b00      	cmp	r3, #0
 800b898:	f300 80ef 	bgt.w	800ba7a <_svfprintf_r+0x1732>
 800b89c:	9b08      	ldr	r3, [sp, #32]
 800b89e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b8a2:	9304      	str	r3, [sp, #16]
 800b8a4:	2767      	movs	r7, #103	; 0x67
 800b8a6:	2300      	movs	r3, #0
 800b8a8:	930f      	str	r3, [sp, #60]	; 0x3c
 800b8aa:	9314      	str	r3, [sp, #80]	; 0x50
 800b8ac:	e49e      	b.n	800b1ec <_svfprintf_r+0xea4>
 800b8ae:	222d      	movs	r2, #45	; 0x2d
 800b8b0:	f88d 208b 	strb.w	r2, [sp, #139]	; 0x8b
 800b8b4:	f7ff b91a 	b.w	800aaec <_svfprintf_r+0x7a4>
 800b8b8:	aa2a      	add	r2, sp, #168	; 0xa8
 800b8ba:	9906      	ldr	r1, [sp, #24]
 800b8bc:	9803      	ldr	r0, [sp, #12]
 800b8be:	f002 f93d 	bl	800db3c <__ssprint_r>
 800b8c2:	2800      	cmp	r0, #0
 800b8c4:	f47e ae13 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b8c8:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b8ca:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b8ce:	f7ff bb37 	b.w	800af40 <_svfprintf_r+0xbf8>
 800b8d2:	900a      	str	r0, [sp, #40]	; 0x28
 800b8d4:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
 800b8d8:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 800b8dc:	931f      	str	r3, [sp, #124]	; 0x7c
 800b8de:	232d      	movs	r3, #45	; 0x2d
 800b8e0:	911e      	str	r1, [sp, #120]	; 0x78
 800b8e2:	930b      	str	r3, [sp, #44]	; 0x2c
 800b8e4:	e714      	b.n	800b710 <_svfprintf_r+0x13c8>
 800b8e6:	2330      	movs	r3, #48	; 0x30
 800b8e8:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 800b8ec:	2378      	movs	r3, #120	; 0x78
 800b8ee:	e6f3      	b.n	800b6d8 <_svfprintf_r+0x1390>
 800b8f0:	f8cd a010 	str.w	sl, [sp, #16]
 800b8f4:	f8cd a020 	str.w	sl, [sp, #32]
 800b8f8:	9409      	str	r4, [sp, #36]	; 0x24
 800b8fa:	4682      	mov	sl, r0
 800b8fc:	900f      	str	r0, [sp, #60]	; 0x3c
 800b8fe:	9014      	str	r0, [sp, #80]	; 0x50
 800b900:	9011      	str	r0, [sp, #68]	; 0x44
 800b902:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 800b906:	f7fe be40 	b.w	800a58a <_svfprintf_r+0x242>
 800b90a:	aa2a      	add	r2, sp, #168	; 0xa8
 800b90c:	9906      	ldr	r1, [sp, #24]
 800b90e:	9803      	ldr	r0, [sp, #12]
 800b910:	f002 f914 	bl	800db3c <__ssprint_r>
 800b914:	2800      	cmp	r0, #0
 800b916:	f47e adea 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b91a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b91c:	e9dd 242b 	ldrd	r2, r4, [sp, #172]	; 0xac
 800b920:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b924:	f7ff ba4c 	b.w	800adc0 <_svfprintf_r+0xa78>
 800b928:	aa2a      	add	r2, sp, #168	; 0xa8
 800b92a:	9906      	ldr	r1, [sp, #24]
 800b92c:	9803      	ldr	r0, [sp, #12]
 800b92e:	f002 f905 	bl	800db3c <__ssprint_r>
 800b932:	2800      	cmp	r0, #0
 800b934:	f47e addb 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b938:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b93a:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b93c:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b940:	e4e8      	b.n	800b314 <_svfprintf_r+0xfcc>
 800b942:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b944:	9328      	str	r3, [sp, #160]	; 0xa0
 800b946:	9b08      	ldr	r3, [sp, #32]
 800b948:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 800b94c:	7bd9      	ldrb	r1, [r3, #15]
 800b94e:	4291      	cmp	r1, r2
 800b950:	462b      	mov	r3, r5
 800b952:	d109      	bne.n	800b968 <_svfprintf_r+0x1620>
 800b954:	2030      	movs	r0, #48	; 0x30
 800b956:	f803 0c01 	strb.w	r0, [r3, #-1]
 800b95a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800b95c:	1e5a      	subs	r2, r3, #1
 800b95e:	9228      	str	r2, [sp, #160]	; 0xa0
 800b960:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 800b964:	4291      	cmp	r1, r2
 800b966:	d0f6      	beq.n	800b956 <_svfprintf_r+0x160e>
 800b968:	2a39      	cmp	r2, #57	; 0x39
 800b96a:	bf0b      	itete	eq
 800b96c:	9a08      	ldreq	r2, [sp, #32]
 800b96e:	3201      	addne	r2, #1
 800b970:	7a92      	ldrbeq	r2, [r2, #10]
 800b972:	b2d2      	uxtbne	r2, r2
 800b974:	f803 2c01 	strb.w	r2, [r3, #-1]
 800b978:	e74f      	b.n	800b81a <_svfprintf_r+0x14d2>
 800b97a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b97c:	2b00      	cmp	r3, #0
 800b97e:	f340 8152 	ble.w	800bc26 <_svfprintf_r+0x18de>
 800b982:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b984:	f1ba 0f00 	cmp.w	sl, #0
 800b988:	f040 80eb 	bne.w	800bb62 <_svfprintf_r+0x181a>
 800b98c:	07c4      	lsls	r4, r0, #31
 800b98e:	f100 80e8 	bmi.w	800bb62 <_svfprintf_r+0x181a>
 800b992:	9308      	str	r3, [sp, #32]
 800b994:	2766      	movs	r7, #102	; 0x66
 800b996:	0543      	lsls	r3, r0, #21
 800b998:	d470      	bmi.n	800ba7c <_svfprintf_r+0x1734>
 800b99a:	9b08      	ldr	r3, [sp, #32]
 800b99c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b9a0:	9304      	str	r3, [sp, #16]
 800b9a2:	e780      	b.n	800b8a6 <_svfprintf_r+0x155e>
 800b9a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b9a6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b9a8:	4413      	add	r3, r2
 800b9aa:	9308      	str	r3, [sp, #32]
 800b9ac:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b9ae:	2b00      	cmp	r3, #0
 800b9b0:	f340 8148 	ble.w	800bc44 <_svfprintf_r+0x18fc>
 800b9b4:	2767      	movs	r7, #103	; 0x67
 800b9b6:	e7ee      	b.n	800b996 <_svfprintf_r+0x164e>
 800b9b8:	aa2a      	add	r2, sp, #168	; 0xa8
 800b9ba:	9906      	ldr	r1, [sp, #24]
 800b9bc:	9803      	ldr	r0, [sp, #12]
 800b9be:	f002 f8bd 	bl	800db3c <__ssprint_r>
 800b9c2:	2800      	cmp	r0, #0
 800b9c4:	f47e ad93 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800b9c8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b9ca:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800b9cc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800b9ce:	1ad3      	subs	r3, r2, r3
 800b9d0:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800b9d4:	e4b6      	b.n	800b344 <_svfprintf_r+0xffc>
 800b9d6:	a824      	add	r0, sp, #144	; 0x90
 800b9d8:	ed9d 0b1e 	vldr	d0, [sp, #120]	; 0x78
 800b9dc:	f002 f848 	bl	800da70 <frexp>
 800b9e0:	2200      	movs	r2, #0
 800b9e2:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 800b9e6:	ec51 0b10 	vmov	r0, r1, d0
 800b9ea:	f7f4 fe47 	bl	800067c <__aeabi_dmul>
 800b9ee:	2200      	movs	r2, #0
 800b9f0:	2300      	movs	r3, #0
 800b9f2:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 800b9f6:	f7f5 f8a9 	bl	8000b4c <__aeabi_dcmpeq>
 800b9fa:	b108      	cbz	r0, 800ba00 <_svfprintf_r+0x16b8>
 800b9fc:	2301      	movs	r3, #1
 800b9fe:	9324      	str	r3, [sp, #144]	; 0x90
 800ba00:	4bba      	ldr	r3, [pc, #744]	; (800bcec <_svfprintf_r+0x19a4>)
 800ba02:	9308      	str	r3, [sp, #32]
 800ba04:	e6a1      	b.n	800b74a <_svfprintf_r+0x1402>
 800ba06:	425d      	negs	r5, r3
 800ba08:	3310      	adds	r3, #16
 800ba0a:	4bb9      	ldr	r3, [pc, #740]	; (800bcf0 <_svfprintf_r+0x19a8>)
 800ba0c:	f280 809a 	bge.w	800bb44 <_svfprintf_r+0x17fc>
 800ba10:	4619      	mov	r1, r3
 800ba12:	2710      	movs	r7, #16
 800ba14:	4623      	mov	r3, r4
 800ba16:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800ba1a:	460c      	mov	r4, r1
 800ba1c:	e005      	b.n	800ba2a <_svfprintf_r+0x16e2>
 800ba1e:	f109 0908 	add.w	r9, r9, #8
 800ba22:	3d10      	subs	r5, #16
 800ba24:	2d10      	cmp	r5, #16
 800ba26:	f340 808a 	ble.w	800bb3e <_svfprintf_r+0x17f6>
 800ba2a:	3201      	adds	r2, #1
 800ba2c:	3310      	adds	r3, #16
 800ba2e:	2a07      	cmp	r2, #7
 800ba30:	e9cd 232b 	strd	r2, r3, [sp, #172]	; 0xac
 800ba34:	e9c9 4700 	strd	r4, r7, [r9]
 800ba38:	ddf1      	ble.n	800ba1e <_svfprintf_r+0x16d6>
 800ba3a:	aa2a      	add	r2, sp, #168	; 0xa8
 800ba3c:	9906      	ldr	r1, [sp, #24]
 800ba3e:	4650      	mov	r0, sl
 800ba40:	f002 f87c 	bl	800db3c <__ssprint_r>
 800ba44:	2800      	cmp	r0, #0
 800ba46:	f47e ad52 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800ba4a:	e9dd 232b 	ldrd	r2, r3, [sp, #172]	; 0xac
 800ba4e:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800ba52:	e7e6      	b.n	800ba22 <_svfprintf_r+0x16da>
 800ba54:	f10a 0101 	add.w	r1, sl, #1
 800ba58:	9803      	ldr	r0, [sp, #12]
 800ba5a:	f001 fa4f 	bl	800cefc <_malloc_r>
 800ba5e:	4606      	mov	r6, r0
 800ba60:	2800      	cmp	r0, #0
 800ba62:	f000 814f 	beq.w	800bd04 <_svfprintf_r+0x19bc>
 800ba66:	f448 7381 	orr.w	r3, r8, #258	; 0x102
 800ba6a:	930e      	str	r3, [sp, #56]	; 0x38
 800ba6c:	f027 0320 	bic.w	r3, r7, #32
 800ba70:	9304      	str	r3, [sp, #16]
 800ba72:	46a0      	mov	r8, r4
 800ba74:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800ba76:	900a      	str	r0, [sp, #40]	; 0x28
 800ba78:	e641      	b.n	800b6fe <_svfprintf_r+0x13b6>
 800ba7a:	2767      	movs	r7, #103	; 0x67
 800ba7c:	981a      	ldr	r0, [sp, #104]	; 0x68
 800ba7e:	2200      	movs	r2, #0
 800ba80:	920f      	str	r2, [sp, #60]	; 0x3c
 800ba82:	9214      	str	r2, [sp, #80]	; 0x50
 800ba84:	7803      	ldrb	r3, [r0, #0]
 800ba86:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800ba88:	2bff      	cmp	r3, #255	; 0xff
 800ba8a:	d00c      	beq.n	800baa6 <_svfprintf_r+0x175e>
 800ba8c:	4293      	cmp	r3, r2
 800ba8e:	da0a      	bge.n	800baa6 <_svfprintf_r+0x175e>
 800ba90:	7841      	ldrb	r1, [r0, #1]
 800ba92:	1ad2      	subs	r2, r2, r3
 800ba94:	b1b1      	cbz	r1, 800bac4 <_svfprintf_r+0x177c>
 800ba96:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800ba98:	3301      	adds	r3, #1
 800ba9a:	9314      	str	r3, [sp, #80]	; 0x50
 800ba9c:	460b      	mov	r3, r1
 800ba9e:	2bff      	cmp	r3, #255	; 0xff
 800baa0:	f100 0001 	add.w	r0, r0, #1
 800baa4:	d1f2      	bne.n	800ba8c <_svfprintf_r+0x1744>
 800baa6:	9211      	str	r2, [sp, #68]	; 0x44
 800baa8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800baaa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800baac:	9908      	ldr	r1, [sp, #32]
 800baae:	901a      	str	r0, [sp, #104]	; 0x68
 800bab0:	4413      	add	r3, r2
 800bab2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800bab4:	fb02 1303 	mla	r3, r2, r3, r1
 800bab8:	9308      	str	r3, [sp, #32]
 800baba:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800babe:	9304      	str	r3, [sp, #16]
 800bac0:	f7ff bb94 	b.w	800b1ec <_svfprintf_r+0xea4>
 800bac4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800bac6:	3101      	adds	r1, #1
 800bac8:	910f      	str	r1, [sp, #60]	; 0x3c
 800baca:	e7dd      	b.n	800ba88 <_svfprintf_r+0x1740>
 800bacc:	aa28      	add	r2, sp, #160	; 0xa0
 800bace:	ab25      	add	r3, sp, #148	; 0x94
 800bad0:	e9cd 3200 	strd	r3, r2, [sp]
 800bad4:	2103      	movs	r1, #3
 800bad6:	ab24      	add	r3, sp, #144	; 0x90
 800bad8:	4652      	mov	r2, sl
 800bada:	ed9d 0b1e 	vldr	d0, [sp, #120]	; 0x78
 800bade:	9803      	ldr	r0, [sp, #12]
 800bae0:	f000 f9aa 	bl	800be38 <_dtoa_r>
 800bae4:	4655      	mov	r5, sl
 800bae6:	4606      	mov	r6, r0
 800bae8:	eb00 040a 	add.w	r4, r0, sl
 800baec:	7833      	ldrb	r3, [r6, #0]
 800baee:	2b30      	cmp	r3, #48	; 0x30
 800baf0:	f000 80c9 	beq.w	800bc86 <_svfprintf_r+0x193e>
 800baf4:	9d24      	ldr	r5, [sp, #144]	; 0x90
 800baf6:	442c      	add	r4, r5
 800baf8:	2200      	movs	r2, #0
 800bafa:	2300      	movs	r3, #0
 800bafc:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 800bb00:	f7f5 f824 	bl	8000b4c <__aeabi_dcmpeq>
 800bb04:	b110      	cbz	r0, 800bb0c <_svfprintf_r+0x17c4>
 800bb06:	4623      	mov	r3, r4
 800bb08:	f7ff bb21 	b.w	800b14e <_svfprintf_r+0xe06>
 800bb0c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800bb0e:	42a3      	cmp	r3, r4
 800bb10:	f4bf ab1d 	bcs.w	800b14e <_svfprintf_r+0xe06>
 800bb14:	2130      	movs	r1, #48	; 0x30
 800bb16:	1c5a      	adds	r2, r3, #1
 800bb18:	9228      	str	r2, [sp, #160]	; 0xa0
 800bb1a:	7019      	strb	r1, [r3, #0]
 800bb1c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800bb1e:	429c      	cmp	r4, r3
 800bb20:	d8f9      	bhi.n	800bb16 <_svfprintf_r+0x17ce>
 800bb22:	f7ff bb14 	b.w	800b14e <_svfprintf_r+0xe06>
 800bb26:	f1ba 0f00 	cmp.w	sl, #0
 800bb2a:	f000 8086 	beq.w	800bc3a <_svfprintf_r+0x18f2>
 800bb2e:	900a      	str	r0, [sp, #40]	; 0x28
 800bb30:	e5e5      	b.n	800b6fe <_svfprintf_r+0x13b6>
 800bb32:	900a      	str	r0, [sp, #40]	; 0x28
 800bb34:	f04f 0a06 	mov.w	sl, #6
 800bb38:	e5e1      	b.n	800b6fe <_svfprintf_r+0x13b6>
 800bb3a:	1974      	adds	r4, r6, r5
 800bb3c:	e7dc      	b.n	800baf8 <_svfprintf_r+0x17b0>
 800bb3e:	4621      	mov	r1, r4
 800bb40:	461c      	mov	r4, r3
 800bb42:	460b      	mov	r3, r1
 800bb44:	3201      	adds	r2, #1
 800bb46:	442c      	add	r4, r5
 800bb48:	2a07      	cmp	r2, #7
 800bb4a:	e9cd 242b 	strd	r2, r4, [sp, #172]	; 0xac
 800bb4e:	e9c9 3500 	strd	r3, r5, [r9]
 800bb52:	f300 80b0 	bgt.w	800bcb6 <_svfprintf_r+0x196e>
 800bb56:	f109 0908 	add.w	r9, r9, #8
 800bb5a:	f7ff b934 	b.w	800adc6 <_svfprintf_r+0xa7e>
 800bb5e:	4699      	mov	r9, r3
 800bb60:	e444      	b.n	800b3ec <_svfprintf_r+0x10a4>
 800bb62:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800bb64:	4413      	add	r3, r2
 800bb66:	4453      	add	r3, sl
 800bb68:	9308      	str	r3, [sp, #32]
 800bb6a:	2766      	movs	r7, #102	; 0x66
 800bb6c:	e713      	b.n	800b996 <_svfprintf_r+0x164e>
 800bb6e:	f10d 0ca7 	add.w	ip, sp, #167	; 0xa7
 800bb72:	4664      	mov	r4, ip
 800bb74:	4d5f      	ldr	r5, [pc, #380]	; (800bcf4 <_svfprintf_r+0x19ac>)
 800bb76:	e000      	b.n	800bb7a <_svfprintf_r+0x1832>
 800bb78:	4614      	mov	r4, r2
 800bb7a:	fba5 1203 	umull	r1, r2, r5, r3
 800bb7e:	08d2      	lsrs	r2, r2, #3
 800bb80:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800bb84:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 800bb88:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800bb8c:	4613      	mov	r3, r2
 800bb8e:	2b09      	cmp	r3, #9
 800bb90:	f804 1c01 	strb.w	r1, [r4, #-1]
 800bb94:	f104 32ff 	add.w	r2, r4, #4294967295	; 0xffffffff
 800bb98:	dcee      	bgt.n	800bb78 <_svfprintf_r+0x1830>
 800bb9a:	3330      	adds	r3, #48	; 0x30
 800bb9c:	3c02      	subs	r4, #2
 800bb9e:	b2db      	uxtb	r3, r3
 800bba0:	45a4      	cmp	ip, r4
 800bba2:	f802 3c01 	strb.w	r3, [r2, #-1]
 800bba6:	f240 8094 	bls.w	800bcd2 <_svfprintf_r+0x198a>
 800bbaa:	f10d 049a 	add.w	r4, sp, #154	; 0x9a
 800bbae:	4611      	mov	r1, r2
 800bbb0:	e001      	b.n	800bbb6 <_svfprintf_r+0x186e>
 800bbb2:	f811 3b01 	ldrb.w	r3, [r1], #1
 800bbb6:	f804 3b01 	strb.w	r3, [r4], #1
 800bbba:	458c      	cmp	ip, r1
 800bbbc:	d1f9      	bne.n	800bbb2 <_svfprintf_r+0x186a>
 800bbbe:	ab2a      	add	r3, sp, #168	; 0xa8
 800bbc0:	1a9b      	subs	r3, r3, r2
 800bbc2:	f10d 029a 	add.w	r2, sp, #154	; 0x9a
 800bbc6:	4413      	add	r3, r2
 800bbc8:	f7ff baf7 	b.w	800b1ba <_svfprintf_r+0xe72>
 800bbcc:	2301      	movs	r3, #1
 800bbce:	9324      	str	r3, [sp, #144]	; 0x90
 800bbd0:	4b49      	ldr	r3, [pc, #292]	; (800bcf8 <_svfprintf_r+0x19b0>)
 800bbd2:	9308      	str	r3, [sp, #32]
 800bbd4:	e5b9      	b.n	800b74a <_svfprintf_r+0x1402>
 800bbd6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800bbd8:	9308      	str	r3, [sp, #32]
 800bbda:	e659      	b.n	800b890 <_svfprintf_r+0x1548>
 800bbdc:	aa28      	add	r2, sp, #160	; 0xa0
 800bbde:	ab25      	add	r3, sp, #148	; 0x94
 800bbe0:	e9cd 3200 	strd	r3, r2, [sp]
 800bbe4:	2103      	movs	r1, #3
 800bbe6:	ab24      	add	r3, sp, #144	; 0x90
 800bbe8:	4652      	mov	r2, sl
 800bbea:	ed9d 0b1e 	vldr	d0, [sp, #120]	; 0x78
 800bbee:	9803      	ldr	r0, [sp, #12]
 800bbf0:	f000 f922 	bl	800be38 <_dtoa_r>
 800bbf4:	4655      	mov	r5, sl
 800bbf6:	4606      	mov	r6, r0
 800bbf8:	2f46      	cmp	r7, #70	; 0x46
 800bbfa:	eb06 0405 	add.w	r4, r6, r5
 800bbfe:	f43f af75 	beq.w	800baec <_svfprintf_r+0x17a4>
 800bc02:	e779      	b.n	800baf8 <_svfprintf_r+0x17b0>
 800bc04:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800bc06:	4e3d      	ldr	r6, [pc, #244]	; (800bcfc <_svfprintf_r+0x19b4>)
 800bc08:	2b00      	cmp	r3, #0
 800bc0a:	bfb6      	itet	lt
 800bc0c:	222d      	movlt	r2, #45	; 0x2d
 800bc0e:	f89d 208b 	ldrbge.w	r2, [sp, #139]	; 0x8b
 800bc12:	f88d 208b 	strblt.w	r2, [sp, #139]	; 0x8b
 800bc16:	4b3a      	ldr	r3, [pc, #232]	; (800bd00 <_svfprintf_r+0x19b8>)
 800bc18:	f7fe bf6a 	b.w	800aaf0 <_svfprintf_r+0x7a8>
 800bc1c:	07c5      	lsls	r5, r0, #31
 800bc1e:	f57f aad9 	bpl.w	800b1d4 <_svfprintf_r+0xe8c>
 800bc22:	f7ff bad3 	b.w	800b1cc <_svfprintf_r+0xe84>
 800bc26:	f1ba 0f00 	cmp.w	sl, #0
 800bc2a:	d117      	bne.n	800bc5c <_svfprintf_r+0x1914>
 800bc2c:	07c1      	lsls	r1, r0, #31
 800bc2e:	d415      	bmi.n	800bc5c <_svfprintf_r+0x1914>
 800bc30:	2301      	movs	r3, #1
 800bc32:	9304      	str	r3, [sp, #16]
 800bc34:	9308      	str	r3, [sp, #32]
 800bc36:	2766      	movs	r7, #102	; 0x66
 800bc38:	e635      	b.n	800b8a6 <_svfprintf_r+0x155e>
 800bc3a:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 800bc3e:	f04f 0a01 	mov.w	sl, #1
 800bc42:	e55c      	b.n	800b6fe <_svfprintf_r+0x13b6>
 800bc44:	9a08      	ldr	r2, [sp, #32]
 800bc46:	f1c3 0301 	rsb	r3, r3, #1
 800bc4a:	441a      	add	r2, r3
 800bc4c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 800bc50:	9208      	str	r2, [sp, #32]
 800bc52:	9304      	str	r3, [sp, #16]
 800bc54:	2767      	movs	r7, #103	; 0x67
 800bc56:	e626      	b.n	800b8a6 <_svfprintf_r+0x155e>
 800bc58:	464a      	mov	r2, r9
 800bc5a:	e456      	b.n	800b50a <_svfprintf_r+0x11c2>
 800bc5c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800bc5e:	3301      	adds	r3, #1
 800bc60:	4453      	add	r3, sl
 800bc62:	9308      	str	r3, [sp, #32]
 800bc64:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800bc68:	9304      	str	r3, [sp, #16]
 800bc6a:	2766      	movs	r7, #102	; 0x66
 800bc6c:	e61b      	b.n	800b8a6 <_svfprintf_r+0x155e>
 800bc6e:	2f47      	cmp	r7, #71	; 0x47
 800bc70:	f47f af63 	bne.w	800bb3a <_svfprintf_r+0x17f2>
 800bc74:	f018 0f01 	tst.w	r8, #1
 800bc78:	f43f aa68 	beq.w	800b14c <_svfprintf_r+0xe04>
 800bc7c:	e7bc      	b.n	800bbf8 <_svfprintf_r+0x18b0>
 800bc7e:	f10d 029a 	add.w	r2, sp, #154	; 0x9a
 800bc82:	f7ff ba97 	b.w	800b1b4 <_svfprintf_r+0xe6c>
 800bc86:	2200      	movs	r2, #0
 800bc88:	2300      	movs	r3, #0
 800bc8a:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 800bc8e:	f7f4 ff5d 	bl	8000b4c <__aeabi_dcmpeq>
 800bc92:	2800      	cmp	r0, #0
 800bc94:	f47f af2e 	bne.w	800baf4 <_svfprintf_r+0x17ac>
 800bc98:	f1c5 0501 	rsb	r5, r5, #1
 800bc9c:	9524      	str	r5, [sp, #144]	; 0x90
 800bc9e:	e72a      	b.n	800baf6 <_svfprintf_r+0x17ae>
 800bca0:	9909      	ldr	r1, [sp, #36]	; 0x24
 800bca2:	f89b 7001 	ldrb.w	r7, [fp, #1]
 800bca6:	680b      	ldr	r3, [r1, #0]
 800bca8:	ea43 7ae3 	orr.w	sl, r3, r3, asr #31
 800bcac:	1d0b      	adds	r3, r1, #4
 800bcae:	4693      	mov	fp, r2
 800bcb0:	9309      	str	r3, [sp, #36]	; 0x24
 800bcb2:	f7fe bba2 	b.w	800a3fa <_svfprintf_r+0xb2>
 800bcb6:	aa2a      	add	r2, sp, #168	; 0xa8
 800bcb8:	9906      	ldr	r1, [sp, #24]
 800bcba:	9803      	ldr	r0, [sp, #12]
 800bcbc:	f001 ff3e 	bl	800db3c <__ssprint_r>
 800bcc0:	2800      	cmp	r0, #0
 800bcc2:	f47e ac14 	bne.w	800a4ee <_svfprintf_r+0x1a6>
 800bcc6:	e9dd 242b 	ldrd	r2, r4, [sp, #172]	; 0xac
 800bcca:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 800bcce:	f7ff b87a 	b.w	800adc6 <_svfprintf_r+0xa7e>
 800bcd2:	f10d 039a 	add.w	r3, sp, #154	; 0x9a
 800bcd6:	f7ff ba70 	b.w	800b1ba <_svfprintf_r+0xe72>
 800bcda:	9a03      	ldr	r2, [sp, #12]
 800bcdc:	230c      	movs	r3, #12
 800bcde:	6013      	str	r3, [r2, #0]
 800bce0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bce4:	9305      	str	r3, [sp, #20]
 800bce6:	f7fe bc11 	b.w	800a50c <_svfprintf_r+0x1c4>
 800bcea:	bf00      	nop
 800bcec:	0801dc1c 	.word	0x0801dc1c
 800bcf0:	0801dc54 	.word	0x0801dc54
 800bcf4:	cccccccd 	.word	0xcccccccd
 800bcf8:	0801dc30 	.word	0x0801dc30
 800bcfc:	0801dc18 	.word	0x0801dc18
 800bd00:	0801dc14 	.word	0x0801dc14
 800bd04:	9a06      	ldr	r2, [sp, #24]
 800bd06:	8993      	ldrh	r3, [r2, #12]
 800bd08:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bd0c:	8193      	strh	r3, [r2, #12]
 800bd0e:	f7fe bbf6 	b.w	800a4fe <_svfprintf_r+0x1b6>
 800bd12:	bf00      	nop

0800bd14 <quorem>:
 800bd14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bd18:	6903      	ldr	r3, [r0, #16]
 800bd1a:	690f      	ldr	r7, [r1, #16]
 800bd1c:	42bb      	cmp	r3, r7
 800bd1e:	b083      	sub	sp, #12
 800bd20:	f2c0 8086 	blt.w	800be30 <quorem+0x11c>
 800bd24:	3f01      	subs	r7, #1
 800bd26:	f101 0914 	add.w	r9, r1, #20
 800bd2a:	f100 0a14 	add.w	sl, r0, #20
 800bd2e:	f859 2027 	ldr.w	r2, [r9, r7, lsl #2]
 800bd32:	f85a 3027 	ldr.w	r3, [sl, r7, lsl #2]
 800bd36:	00bc      	lsls	r4, r7, #2
 800bd38:	3201      	adds	r2, #1
 800bd3a:	fbb3 f8f2 	udiv	r8, r3, r2
 800bd3e:	eb0a 0304 	add.w	r3, sl, r4
 800bd42:	9400      	str	r4, [sp, #0]
 800bd44:	eb09 0b04 	add.w	fp, r9, r4
 800bd48:	9301      	str	r3, [sp, #4]
 800bd4a:	f1b8 0f00 	cmp.w	r8, #0
 800bd4e:	d038      	beq.n	800bdc2 <quorem+0xae>
 800bd50:	2500      	movs	r5, #0
 800bd52:	462e      	mov	r6, r5
 800bd54:	46ce      	mov	lr, r9
 800bd56:	46d4      	mov	ip, sl
 800bd58:	f85e 4b04 	ldr.w	r4, [lr], #4
 800bd5c:	f8dc 3000 	ldr.w	r3, [ip]
 800bd60:	b2a2      	uxth	r2, r4
 800bd62:	fb08 5502 	mla	r5, r8, r2, r5
 800bd66:	0c22      	lsrs	r2, r4, #16
 800bd68:	0c2c      	lsrs	r4, r5, #16
 800bd6a:	fb08 4202 	mla	r2, r8, r2, r4
 800bd6e:	b2ad      	uxth	r5, r5
 800bd70:	1b75      	subs	r5, r6, r5
 800bd72:	b296      	uxth	r6, r2
 800bd74:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
 800bd78:	fa15 f383 	uxtah	r3, r5, r3
 800bd7c:	eb06 4623 	add.w	r6, r6, r3, asr #16
 800bd80:	b29b      	uxth	r3, r3
 800bd82:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800bd86:	45f3      	cmp	fp, lr
 800bd88:	ea4f 4512 	mov.w	r5, r2, lsr #16
 800bd8c:	f84c 3b04 	str.w	r3, [ip], #4
 800bd90:	ea4f 4626 	mov.w	r6, r6, asr #16
 800bd94:	d2e0      	bcs.n	800bd58 <quorem+0x44>
 800bd96:	9b00      	ldr	r3, [sp, #0]
 800bd98:	f85a 3003 	ldr.w	r3, [sl, r3]
 800bd9c:	b98b      	cbnz	r3, 800bdc2 <quorem+0xae>
 800bd9e:	9a01      	ldr	r2, [sp, #4]
 800bda0:	1f13      	subs	r3, r2, #4
 800bda2:	459a      	cmp	sl, r3
 800bda4:	d20c      	bcs.n	800bdc0 <quorem+0xac>
 800bda6:	f852 3c04 	ldr.w	r3, [r2, #-4]
 800bdaa:	b94b      	cbnz	r3, 800bdc0 <quorem+0xac>
 800bdac:	f1a2 0308 	sub.w	r3, r2, #8
 800bdb0:	e002      	b.n	800bdb8 <quorem+0xa4>
 800bdb2:	681a      	ldr	r2, [r3, #0]
 800bdb4:	3b04      	subs	r3, #4
 800bdb6:	b91a      	cbnz	r2, 800bdc0 <quorem+0xac>
 800bdb8:	459a      	cmp	sl, r3
 800bdba:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
 800bdbe:	d3f8      	bcc.n	800bdb2 <quorem+0x9e>
 800bdc0:	6107      	str	r7, [r0, #16]
 800bdc2:	4604      	mov	r4, r0
 800bdc4:	f001 fd60 	bl	800d888 <__mcmp>
 800bdc8:	2800      	cmp	r0, #0
 800bdca:	db2d      	blt.n	800be28 <quorem+0x114>
 800bdcc:	f108 0801 	add.w	r8, r8, #1
 800bdd0:	4655      	mov	r5, sl
 800bdd2:	2300      	movs	r3, #0
 800bdd4:	f859 1b04 	ldr.w	r1, [r9], #4
 800bdd8:	6828      	ldr	r0, [r5, #0]
 800bdda:	b28a      	uxth	r2, r1
 800bddc:	1a9a      	subs	r2, r3, r2
 800bdde:	0c0b      	lsrs	r3, r1, #16
 800bde0:	fa12 f280 	uxtah	r2, r2, r0
 800bde4:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
 800bde8:	eb03 4322 	add.w	r3, r3, r2, asr #16
 800bdec:	b292      	uxth	r2, r2
 800bdee:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 800bdf2:	45cb      	cmp	fp, r9
 800bdf4:	f845 2b04 	str.w	r2, [r5], #4
 800bdf8:	ea4f 4323 	mov.w	r3, r3, asr #16
 800bdfc:	d2ea      	bcs.n	800bdd4 <quorem+0xc0>
 800bdfe:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
 800be02:	eb0a 0387 	add.w	r3, sl, r7, lsl #2
 800be06:	b97a      	cbnz	r2, 800be28 <quorem+0x114>
 800be08:	1f1a      	subs	r2, r3, #4
 800be0a:	4592      	cmp	sl, r2
 800be0c:	d20b      	bcs.n	800be26 <quorem+0x112>
 800be0e:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800be12:	b942      	cbnz	r2, 800be26 <quorem+0x112>
 800be14:	3b08      	subs	r3, #8
 800be16:	e002      	b.n	800be1e <quorem+0x10a>
 800be18:	681a      	ldr	r2, [r3, #0]
 800be1a:	3b04      	subs	r3, #4
 800be1c:	b91a      	cbnz	r2, 800be26 <quorem+0x112>
 800be1e:	459a      	cmp	sl, r3
 800be20:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
 800be24:	d3f8      	bcc.n	800be18 <quorem+0x104>
 800be26:	6127      	str	r7, [r4, #16]
 800be28:	4640      	mov	r0, r8
 800be2a:	b003      	add	sp, #12
 800be2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800be30:	2000      	movs	r0, #0
 800be32:	b003      	add	sp, #12
 800be34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800be38 <_dtoa_r>:
 800be38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800be3c:	ec55 4b10 	vmov	r4, r5, d0
 800be40:	b09b      	sub	sp, #108	; 0x6c
 800be42:	6c06      	ldr	r6, [r0, #64]	; 0x40
 800be44:	9102      	str	r1, [sp, #8]
 800be46:	4681      	mov	r9, r0
 800be48:	9207      	str	r2, [sp, #28]
 800be4a:	9305      	str	r3, [sp, #20]
 800be4c:	e9cd 4500 	strd	r4, r5, [sp]
 800be50:	b156      	cbz	r6, 800be68 <_dtoa_r+0x30>
 800be52:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800be54:	6072      	str	r2, [r6, #4]
 800be56:	2301      	movs	r3, #1
 800be58:	4093      	lsls	r3, r2
 800be5a:	60b3      	str	r3, [r6, #8]
 800be5c:	4631      	mov	r1, r6
 800be5e:	f001 fb23 	bl	800d4a8 <_Bfree>
 800be62:	2300      	movs	r3, #0
 800be64:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
 800be68:	f1b5 0800 	subs.w	r8, r5, #0
 800be6c:	9a24      	ldr	r2, [sp, #144]	; 0x90
 800be6e:	bfb4      	ite	lt
 800be70:	2301      	movlt	r3, #1
 800be72:	2300      	movge	r3, #0
 800be74:	6013      	str	r3, [r2, #0]
 800be76:	4b76      	ldr	r3, [pc, #472]	; (800c050 <_dtoa_r+0x218>)
 800be78:	bfbc      	itt	lt
 800be7a:	f028 4800 	biclt.w	r8, r8, #2147483648	; 0x80000000
 800be7e:	f8cd 8004 	strlt.w	r8, [sp, #4]
 800be82:	ea33 0308 	bics.w	r3, r3, r8
 800be86:	f000 80a6 	beq.w	800bfd6 <_dtoa_r+0x19e>
 800be8a:	e9dd 6700 	ldrd	r6, r7, [sp]
 800be8e:	2200      	movs	r2, #0
 800be90:	2300      	movs	r3, #0
 800be92:	4630      	mov	r0, r6
 800be94:	4639      	mov	r1, r7
 800be96:	f7f4 fe59 	bl	8000b4c <__aeabi_dcmpeq>
 800be9a:	4605      	mov	r5, r0
 800be9c:	b178      	cbz	r0, 800bebe <_dtoa_r+0x86>
 800be9e:	9a05      	ldr	r2, [sp, #20]
 800bea0:	2301      	movs	r3, #1
 800bea2:	6013      	str	r3, [r2, #0]
 800bea4:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800bea6:	2b00      	cmp	r3, #0
 800bea8:	f000 80c0 	beq.w	800c02c <_dtoa_r+0x1f4>
 800beac:	4b69      	ldr	r3, [pc, #420]	; (800c054 <_dtoa_r+0x21c>)
 800beae:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800beb0:	f103 3bff 	add.w	fp, r3, #4294967295	; 0xffffffff
 800beb4:	6013      	str	r3, [r2, #0]
 800beb6:	4658      	mov	r0, fp
 800beb8:	b01b      	add	sp, #108	; 0x6c
 800beba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bebe:	aa18      	add	r2, sp, #96	; 0x60
 800bec0:	a919      	add	r1, sp, #100	; 0x64
 800bec2:	ec47 6b10 	vmov	d0, r6, r7
 800bec6:	4648      	mov	r0, r9
 800bec8:	f001 fd70 	bl	800d9ac <__d2b>
 800becc:	ea5f 5418 	movs.w	r4, r8, lsr #20
 800bed0:	4682      	mov	sl, r0
 800bed2:	f040 80a0 	bne.w	800c016 <_dtoa_r+0x1de>
 800bed6:	e9dd 5418 	ldrd	r5, r4, [sp, #96]	; 0x60
 800beda:	442c      	add	r4, r5
 800bedc:	f204 4332 	addw	r3, r4, #1074	; 0x432
 800bee0:	2b20      	cmp	r3, #32
 800bee2:	f340 842c 	ble.w	800c73e <_dtoa_r+0x906>
 800bee6:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800beea:	fa08 f803 	lsl.w	r8, r8, r3
 800beee:	9b00      	ldr	r3, [sp, #0]
 800bef0:	f204 4012 	addw	r0, r4, #1042	; 0x412
 800bef4:	fa23 f000 	lsr.w	r0, r3, r0
 800bef8:	ea48 0000 	orr.w	r0, r8, r0
 800befc:	f7f4 fb44 	bl	8000588 <__aeabi_ui2d>
 800bf00:	2301      	movs	r3, #1
 800bf02:	4606      	mov	r6, r0
 800bf04:	3c01      	subs	r4, #1
 800bf06:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 800bf0a:	930f      	str	r3, [sp, #60]	; 0x3c
 800bf0c:	4630      	mov	r0, r6
 800bf0e:	4639      	mov	r1, r7
 800bf10:	2200      	movs	r2, #0
 800bf12:	4b51      	ldr	r3, [pc, #324]	; (800c058 <_dtoa_r+0x220>)
 800bf14:	f7f4 f9fa 	bl	800030c <__aeabi_dsub>
 800bf18:	a347      	add	r3, pc, #284	; (adr r3, 800c038 <_dtoa_r+0x200>)
 800bf1a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800bf1e:	f7f4 fbad 	bl	800067c <__aeabi_dmul>
 800bf22:	a347      	add	r3, pc, #284	; (adr r3, 800c040 <_dtoa_r+0x208>)
 800bf24:	e9d3 2300 	ldrd	r2, r3, [r3]
 800bf28:	f7f4 f9f2 	bl	8000310 <__adddf3>
 800bf2c:	4606      	mov	r6, r0
 800bf2e:	4620      	mov	r0, r4
 800bf30:	460f      	mov	r7, r1
 800bf32:	f7f4 fb39 	bl	80005a8 <__aeabi_i2d>
 800bf36:	a344      	add	r3, pc, #272	; (adr r3, 800c048 <_dtoa_r+0x210>)
 800bf38:	e9d3 2300 	ldrd	r2, r3, [r3]
 800bf3c:	f7f4 fb9e 	bl	800067c <__aeabi_dmul>
 800bf40:	4602      	mov	r2, r0
 800bf42:	460b      	mov	r3, r1
 800bf44:	4630      	mov	r0, r6
 800bf46:	4639      	mov	r1, r7
 800bf48:	f7f4 f9e2 	bl	8000310 <__adddf3>
 800bf4c:	4606      	mov	r6, r0
 800bf4e:	460f      	mov	r7, r1
 800bf50:	f7f4 fe44 	bl	8000bdc <__aeabi_d2iz>
 800bf54:	2200      	movs	r2, #0
 800bf56:	9006      	str	r0, [sp, #24]
 800bf58:	2300      	movs	r3, #0
 800bf5a:	4630      	mov	r0, r6
 800bf5c:	4639      	mov	r1, r7
 800bf5e:	f7f4 fdff 	bl	8000b60 <__aeabi_dcmplt>
 800bf62:	2800      	cmp	r0, #0
 800bf64:	f040 8273 	bne.w	800c44e <_dtoa_r+0x616>
 800bf68:	9e06      	ldr	r6, [sp, #24]
 800bf6a:	2e16      	cmp	r6, #22
 800bf6c:	f200 825d 	bhi.w	800c42a <_dtoa_r+0x5f2>
 800bf70:	4b3a      	ldr	r3, [pc, #232]	; (800c05c <_dtoa_r+0x224>)
 800bf72:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 800bf76:	e9d3 0100 	ldrd	r0, r1, [r3]
 800bf7a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800bf7e:	f7f4 fe0d 	bl	8000b9c <__aeabi_dcmpgt>
 800bf82:	2800      	cmp	r0, #0
 800bf84:	f000 83d7 	beq.w	800c736 <_dtoa_r+0x8fe>
 800bf88:	1e73      	subs	r3, r6, #1
 800bf8a:	9306      	str	r3, [sp, #24]
 800bf8c:	2300      	movs	r3, #0
 800bf8e:	930d      	str	r3, [sp, #52]	; 0x34
 800bf90:	1b2c      	subs	r4, r5, r4
 800bf92:	f1b4 0801 	subs.w	r8, r4, #1
 800bf96:	f100 8254 	bmi.w	800c442 <_dtoa_r+0x60a>
 800bf9a:	2300      	movs	r3, #0
 800bf9c:	9308      	str	r3, [sp, #32]
 800bf9e:	9b06      	ldr	r3, [sp, #24]
 800bfa0:	2b00      	cmp	r3, #0
 800bfa2:	f2c0 8245 	blt.w	800c430 <_dtoa_r+0x5f8>
 800bfa6:	4498      	add	r8, r3
 800bfa8:	930c      	str	r3, [sp, #48]	; 0x30
 800bfaa:	2300      	movs	r3, #0
 800bfac:	930b      	str	r3, [sp, #44]	; 0x2c
 800bfae:	9b02      	ldr	r3, [sp, #8]
 800bfb0:	2b09      	cmp	r3, #9
 800bfb2:	d85b      	bhi.n	800c06c <_dtoa_r+0x234>
 800bfb4:	2b05      	cmp	r3, #5
 800bfb6:	f340 83c0 	ble.w	800c73a <_dtoa_r+0x902>
 800bfba:	3b04      	subs	r3, #4
 800bfbc:	9302      	str	r3, [sp, #8]
 800bfbe:	2500      	movs	r5, #0
 800bfc0:	9b02      	ldr	r3, [sp, #8]
 800bfc2:	3b02      	subs	r3, #2
 800bfc4:	2b03      	cmp	r3, #3
 800bfc6:	f200 8498 	bhi.w	800c8fa <_dtoa_r+0xac2>
 800bfca:	e8df f013 	tbh	[pc, r3, lsl #1]
 800bfce:	03df      	.short	0x03df
 800bfd0:	03e803bf 	.word	0x03e803bf
 800bfd4:	04f5      	.short	0x04f5
 800bfd6:	9a05      	ldr	r2, [sp, #20]
 800bfd8:	f242 730f 	movw	r3, #9999	; 0x270f
 800bfdc:	6013      	str	r3, [r2, #0]
 800bfde:	9b00      	ldr	r3, [sp, #0]
 800bfe0:	b983      	cbnz	r3, 800c004 <_dtoa_r+0x1cc>
 800bfe2:	f3c8 0313 	ubfx	r3, r8, #0, #20
 800bfe6:	b96b      	cbnz	r3, 800c004 <_dtoa_r+0x1cc>
 800bfe8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800bfea:	f8df b074 	ldr.w	fp, [pc, #116]	; 800c060 <_dtoa_r+0x228>
 800bfee:	2b00      	cmp	r3, #0
 800bff0:	f43f af61 	beq.w	800beb6 <_dtoa_r+0x7e>
 800bff4:	f10b 0308 	add.w	r3, fp, #8
 800bff8:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800bffa:	4658      	mov	r0, fp
 800bffc:	6013      	str	r3, [r2, #0]
 800bffe:	b01b      	add	sp, #108	; 0x6c
 800c000:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c004:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800c006:	f8df b05c 	ldr.w	fp, [pc, #92]	; 800c064 <_dtoa_r+0x22c>
 800c00a:	2b00      	cmp	r3, #0
 800c00c:	f43f af53 	beq.w	800beb6 <_dtoa_r+0x7e>
 800c010:	f10b 0303 	add.w	r3, fp, #3
 800c014:	e7f0      	b.n	800bff8 <_dtoa_r+0x1c0>
 800c016:	f3c7 0313 	ubfx	r3, r7, #0, #20
 800c01a:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 800c01e:	950f      	str	r5, [sp, #60]	; 0x3c
 800c020:	f2a4 34ff 	subw	r4, r4, #1023	; 0x3ff
 800c024:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 800c028:	9d18      	ldr	r5, [sp, #96]	; 0x60
 800c02a:	e76f      	b.n	800bf0c <_dtoa_r+0xd4>
 800c02c:	f8df b038 	ldr.w	fp, [pc, #56]	; 800c068 <_dtoa_r+0x230>
 800c030:	4658      	mov	r0, fp
 800c032:	b01b      	add	sp, #108	; 0x6c
 800c034:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c038:	636f4361 	.word	0x636f4361
 800c03c:	3fd287a7 	.word	0x3fd287a7
 800c040:	8b60c8b3 	.word	0x8b60c8b3
 800c044:	3fc68a28 	.word	0x3fc68a28
 800c048:	509f79fb 	.word	0x509f79fb
 800c04c:	3fd34413 	.word	0x3fd34413
 800c050:	7ff00000 	.word	0x7ff00000
 800c054:	0800e711 	.word	0x0800e711
 800c058:	3ff80000 	.word	0x3ff80000
 800c05c:	0801dca0 	.word	0x0801dca0
 800c060:	0801dc64 	.word	0x0801dc64
 800c064:	0801dc70 	.word	0x0801dc70
 800c068:	0800e710 	.word	0x0800e710
 800c06c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800c070:	2501      	movs	r5, #1
 800c072:	e9cd 4509 	strd	r4, r5, [sp, #36]	; 0x24
 800c076:	2300      	movs	r3, #0
 800c078:	9302      	str	r3, [sp, #8]
 800c07a:	9307      	str	r3, [sp, #28]
 800c07c:	2100      	movs	r1, #0
 800c07e:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 800c082:	940e      	str	r4, [sp, #56]	; 0x38
 800c084:	4648      	mov	r0, r9
 800c086:	f001 f9e9 	bl	800d45c <_Balloc>
 800c08a:	2c0e      	cmp	r4, #14
 800c08c:	4683      	mov	fp, r0
 800c08e:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
 800c092:	f200 80fb 	bhi.w	800c28c <_dtoa_r+0x454>
 800c096:	2d00      	cmp	r5, #0
 800c098:	f000 80f8 	beq.w	800c28c <_dtoa_r+0x454>
 800c09c:	ed9d 7b00 	vldr	d7, [sp]
 800c0a0:	9906      	ldr	r1, [sp, #24]
 800c0a2:	2900      	cmp	r1, #0
 800c0a4:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 800c0a8:	f340 83e5 	ble.w	800c876 <_dtoa_r+0xa3e>
 800c0ac:	4b9d      	ldr	r3, [pc, #628]	; (800c324 <_dtoa_r+0x4ec>)
 800c0ae:	f001 020f 	and.w	r2, r1, #15
 800c0b2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c0b6:	ed93 7b00 	vldr	d7, [r3]
 800c0ba:	110c      	asrs	r4, r1, #4
 800c0bc:	06e2      	lsls	r2, r4, #27
 800c0be:	ed8d 7b00 	vstr	d7, [sp]
 800c0c2:	f140 849e 	bpl.w	800ca02 <_dtoa_r+0xbca>
 800c0c6:	4b98      	ldr	r3, [pc, #608]	; (800c328 <_dtoa_r+0x4f0>)
 800c0c8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800c0cc:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800c0d0:	f7f4 fbfe 	bl	80008d0 <__aeabi_ddiv>
 800c0d4:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800c0d8:	f004 040f 	and.w	r4, r4, #15
 800c0dc:	2603      	movs	r6, #3
 800c0de:	b17c      	cbz	r4, 800c100 <_dtoa_r+0x2c8>
 800c0e0:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c0e4:	4d90      	ldr	r5, [pc, #576]	; (800c328 <_dtoa_r+0x4f0>)
 800c0e6:	07e3      	lsls	r3, r4, #31
 800c0e8:	d504      	bpl.n	800c0f4 <_dtoa_r+0x2bc>
 800c0ea:	e9d5 2300 	ldrd	r2, r3, [r5]
 800c0ee:	f7f4 fac5 	bl	800067c <__aeabi_dmul>
 800c0f2:	3601      	adds	r6, #1
 800c0f4:	1064      	asrs	r4, r4, #1
 800c0f6:	f105 0508 	add.w	r5, r5, #8
 800c0fa:	d1f4      	bne.n	800c0e6 <_dtoa_r+0x2ae>
 800c0fc:	e9cd 0100 	strd	r0, r1, [sp]
 800c100:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c104:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800c108:	f7f4 fbe2 	bl	80008d0 <__aeabi_ddiv>
 800c10c:	e9cd 0100 	strd	r0, r1, [sp]
 800c110:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c112:	b143      	cbz	r3, 800c126 <_dtoa_r+0x2ee>
 800c114:	2200      	movs	r2, #0
 800c116:	4b85      	ldr	r3, [pc, #532]	; (800c32c <_dtoa_r+0x4f4>)
 800c118:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c11c:	f7f4 fd20 	bl	8000b60 <__aeabi_dcmplt>
 800c120:	2800      	cmp	r0, #0
 800c122:	f040 84ff 	bne.w	800cb24 <_dtoa_r+0xcec>
 800c126:	4630      	mov	r0, r6
 800c128:	f7f4 fa3e 	bl	80005a8 <__aeabi_i2d>
 800c12c:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c130:	f7f4 faa4 	bl	800067c <__aeabi_dmul>
 800c134:	4b7e      	ldr	r3, [pc, #504]	; (800c330 <_dtoa_r+0x4f8>)
 800c136:	2200      	movs	r2, #0
 800c138:	f7f4 f8ea 	bl	8000310 <__adddf3>
 800c13c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c13e:	4606      	mov	r6, r0
 800c140:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800c144:	2b00      	cmp	r3, #0
 800c146:	f000 841c 	beq.w	800c982 <_dtoa_r+0xb4a>
 800c14a:	9b06      	ldr	r3, [sp, #24]
 800c14c:	9316      	str	r3, [sp, #88]	; 0x58
 800c14e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c150:	9312      	str	r3, [sp, #72]	; 0x48
 800c152:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c156:	f7f4 fd41 	bl	8000bdc <__aeabi_d2iz>
 800c15a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800c15c:	4b71      	ldr	r3, [pc, #452]	; (800c324 <_dtoa_r+0x4ec>)
 800c15e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c162:	ed13 7b02 	vldr	d7, [r3, #-8]
 800c166:	f100 0530 	add.w	r5, r0, #48	; 0x30
 800c16a:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
 800c16e:	f7f4 fa1b 	bl	80005a8 <__aeabi_i2d>
 800c172:	460b      	mov	r3, r1
 800c174:	4602      	mov	r2, r0
 800c176:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c17a:	e9cd 6700 	strd	r6, r7, [sp]
 800c17e:	f7f4 f8c5 	bl	800030c <__aeabi_dsub>
 800c182:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c184:	b2ed      	uxtb	r5, r5
 800c186:	4606      	mov	r6, r0
 800c188:	460f      	mov	r7, r1
 800c18a:	f10b 0401 	add.w	r4, fp, #1
 800c18e:	2b00      	cmp	r3, #0
 800c190:	f000 8458 	beq.w	800ca44 <_dtoa_r+0xc0c>
 800c194:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 800c198:	2000      	movs	r0, #0
 800c19a:	4966      	ldr	r1, [pc, #408]	; (800c334 <_dtoa_r+0x4fc>)
 800c19c:	f7f4 fb98 	bl	80008d0 <__aeabi_ddiv>
 800c1a0:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c1a4:	f7f4 f8b2 	bl	800030c <__aeabi_dsub>
 800c1a8:	f88b 5000 	strb.w	r5, [fp]
 800c1ac:	4632      	mov	r2, r6
 800c1ae:	463b      	mov	r3, r7
 800c1b0:	e9cd 0100 	strd	r0, r1, [sp]
 800c1b4:	f7f4 fcf2 	bl	8000b9c <__aeabi_dcmpgt>
 800c1b8:	2800      	cmp	r0, #0
 800c1ba:	f040 8502 	bne.w	800cbc2 <_dtoa_r+0xd8a>
 800c1be:	4632      	mov	r2, r6
 800c1c0:	463b      	mov	r3, r7
 800c1c2:	2000      	movs	r0, #0
 800c1c4:	4959      	ldr	r1, [pc, #356]	; (800c32c <_dtoa_r+0x4f4>)
 800c1c6:	f7f4 f8a1 	bl	800030c <__aeabi_dsub>
 800c1ca:	4602      	mov	r2, r0
 800c1cc:	460b      	mov	r3, r1
 800c1ce:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c1d2:	f7f4 fce3 	bl	8000b9c <__aeabi_dcmpgt>
 800c1d6:	2800      	cmp	r0, #0
 800c1d8:	f040 84fb 	bne.w	800cbd2 <_dtoa_r+0xd9a>
 800c1dc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800c1de:	2a01      	cmp	r2, #1
 800c1e0:	d050      	beq.n	800c284 <_dtoa_r+0x44c>
 800c1e2:	445a      	add	r2, fp
 800c1e4:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
 800c1e8:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 800c1ec:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
 800c1f0:	4692      	mov	sl, r2
 800c1f2:	46cb      	mov	fp, r9
 800c1f4:	e9dd 8900 	ldrd	r8, r9, [sp]
 800c1f8:	e00c      	b.n	800c214 <_dtoa_r+0x3dc>
 800c1fa:	2000      	movs	r0, #0
 800c1fc:	494b      	ldr	r1, [pc, #300]	; (800c32c <_dtoa_r+0x4f4>)
 800c1fe:	f7f4 f885 	bl	800030c <__aeabi_dsub>
 800c202:	4642      	mov	r2, r8
 800c204:	464b      	mov	r3, r9
 800c206:	f7f4 fcab 	bl	8000b60 <__aeabi_dcmplt>
 800c20a:	2800      	cmp	r0, #0
 800c20c:	f040 84dc 	bne.w	800cbc8 <_dtoa_r+0xd90>
 800c210:	4554      	cmp	r4, sl
 800c212:	d030      	beq.n	800c276 <_dtoa_r+0x43e>
 800c214:	4640      	mov	r0, r8
 800c216:	4649      	mov	r1, r9
 800c218:	2200      	movs	r2, #0
 800c21a:	4b47      	ldr	r3, [pc, #284]	; (800c338 <_dtoa_r+0x500>)
 800c21c:	f7f4 fa2e 	bl	800067c <__aeabi_dmul>
 800c220:	2200      	movs	r2, #0
 800c222:	4b45      	ldr	r3, [pc, #276]	; (800c338 <_dtoa_r+0x500>)
 800c224:	4680      	mov	r8, r0
 800c226:	4689      	mov	r9, r1
 800c228:	4630      	mov	r0, r6
 800c22a:	4639      	mov	r1, r7
 800c22c:	f7f4 fa26 	bl	800067c <__aeabi_dmul>
 800c230:	460f      	mov	r7, r1
 800c232:	4606      	mov	r6, r0
 800c234:	f7f4 fcd2 	bl	8000bdc <__aeabi_d2iz>
 800c238:	4605      	mov	r5, r0
 800c23a:	f7f4 f9b5 	bl	80005a8 <__aeabi_i2d>
 800c23e:	4602      	mov	r2, r0
 800c240:	460b      	mov	r3, r1
 800c242:	4630      	mov	r0, r6
 800c244:	4639      	mov	r1, r7
 800c246:	f7f4 f861 	bl	800030c <__aeabi_dsub>
 800c24a:	3530      	adds	r5, #48	; 0x30
 800c24c:	b2ed      	uxtb	r5, r5
 800c24e:	4642      	mov	r2, r8
 800c250:	464b      	mov	r3, r9
 800c252:	f804 5b01 	strb.w	r5, [r4], #1
 800c256:	4606      	mov	r6, r0
 800c258:	460f      	mov	r7, r1
 800c25a:	f7f4 fc81 	bl	8000b60 <__aeabi_dcmplt>
 800c25e:	4632      	mov	r2, r6
 800c260:	463b      	mov	r3, r7
 800c262:	2800      	cmp	r0, #0
 800c264:	d0c9      	beq.n	800c1fa <_dtoa_r+0x3c2>
 800c266:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c268:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 800c26c:	9306      	str	r3, [sp, #24]
 800c26e:	46d9      	mov	r9, fp
 800c270:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 800c274:	e236      	b.n	800c6e4 <_dtoa_r+0x8ac>
 800c276:	46d9      	mov	r9, fp
 800c278:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
 800c27c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 800c280:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 800c284:	e9dd 3410 	ldrd	r3, r4, [sp, #64]	; 0x40
 800c288:	e9cd 3400 	strd	r3, r4, [sp]
 800c28c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800c28e:	2b00      	cmp	r3, #0
 800c290:	f2c0 80ae 	blt.w	800c3f0 <_dtoa_r+0x5b8>
 800c294:	9a06      	ldr	r2, [sp, #24]
 800c296:	2a0e      	cmp	r2, #14
 800c298:	f300 80aa 	bgt.w	800c3f0 <_dtoa_r+0x5b8>
 800c29c:	4b21      	ldr	r3, [pc, #132]	; (800c324 <_dtoa_r+0x4ec>)
 800c29e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c2a2:	ed93 7b00 	vldr	d7, [r3]
 800c2a6:	9b07      	ldr	r3, [sp, #28]
 800c2a8:	2b00      	cmp	r3, #0
 800c2aa:	ed8d 7b02 	vstr	d7, [sp, #8]
 800c2ae:	f2c0 82be 	blt.w	800c82e <_dtoa_r+0x9f6>
 800c2b2:	e9dd 6700 	ldrd	r6, r7, [sp]
 800c2b6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c2ba:	4630      	mov	r0, r6
 800c2bc:	4639      	mov	r1, r7
 800c2be:	f7f4 fb07 	bl	80008d0 <__aeabi_ddiv>
 800c2c2:	f7f4 fc8b 	bl	8000bdc <__aeabi_d2iz>
 800c2c6:	4605      	mov	r5, r0
 800c2c8:	f7f4 f96e 	bl	80005a8 <__aeabi_i2d>
 800c2cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c2d0:	f7f4 f9d4 	bl	800067c <__aeabi_dmul>
 800c2d4:	460b      	mov	r3, r1
 800c2d6:	4602      	mov	r2, r0
 800c2d8:	4639      	mov	r1, r7
 800c2da:	4630      	mov	r0, r6
 800c2dc:	f7f4 f816 	bl	800030c <__aeabi_dsub>
 800c2e0:	f105 0330 	add.w	r3, r5, #48	; 0x30
 800c2e4:	f88b 3000 	strb.w	r3, [fp]
 800c2e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c2ea:	2b01      	cmp	r3, #1
 800c2ec:	4606      	mov	r6, r0
 800c2ee:	460f      	mov	r7, r1
 800c2f0:	f10b 0401 	add.w	r4, fp, #1
 800c2f4:	d053      	beq.n	800c39e <_dtoa_r+0x566>
 800c2f6:	2200      	movs	r2, #0
 800c2f8:	4b0f      	ldr	r3, [pc, #60]	; (800c338 <_dtoa_r+0x500>)
 800c2fa:	f7f4 f9bf 	bl	800067c <__aeabi_dmul>
 800c2fe:	2200      	movs	r2, #0
 800c300:	2300      	movs	r3, #0
 800c302:	4606      	mov	r6, r0
 800c304:	460f      	mov	r7, r1
 800c306:	f7f4 fc21 	bl	8000b4c <__aeabi_dcmpeq>
 800c30a:	2800      	cmp	r0, #0
 800c30c:	f040 81ea 	bne.w	800c6e4 <_dtoa_r+0x8ac>
 800c310:	f8cd a000 	str.w	sl, [sp]
 800c314:	f8cd 901c 	str.w	r9, [sp, #28]
 800c318:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 800c31c:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 800c320:	e017      	b.n	800c352 <_dtoa_r+0x51a>
 800c322:	bf00      	nop
 800c324:	0801dca0 	.word	0x0801dca0
 800c328:	0801dc78 	.word	0x0801dc78
 800c32c:	3ff00000 	.word	0x3ff00000
 800c330:	401c0000 	.word	0x401c0000
 800c334:	3fe00000 	.word	0x3fe00000
 800c338:	40240000 	.word	0x40240000
 800c33c:	f7f4 f99e 	bl	800067c <__aeabi_dmul>
 800c340:	2200      	movs	r2, #0
 800c342:	2300      	movs	r3, #0
 800c344:	4606      	mov	r6, r0
 800c346:	460f      	mov	r7, r1
 800c348:	f7f4 fc00 	bl	8000b4c <__aeabi_dcmpeq>
 800c34c:	2800      	cmp	r0, #0
 800c34e:	f040 833d 	bne.w	800c9cc <_dtoa_r+0xb94>
 800c352:	464a      	mov	r2, r9
 800c354:	4653      	mov	r3, sl
 800c356:	4630      	mov	r0, r6
 800c358:	4639      	mov	r1, r7
 800c35a:	f7f4 fab9 	bl	80008d0 <__aeabi_ddiv>
 800c35e:	f7f4 fc3d 	bl	8000bdc <__aeabi_d2iz>
 800c362:	4605      	mov	r5, r0
 800c364:	f7f4 f920 	bl	80005a8 <__aeabi_i2d>
 800c368:	464a      	mov	r2, r9
 800c36a:	4653      	mov	r3, sl
 800c36c:	f7f4 f986 	bl	800067c <__aeabi_dmul>
 800c370:	4602      	mov	r2, r0
 800c372:	460b      	mov	r3, r1
 800c374:	4630      	mov	r0, r6
 800c376:	4639      	mov	r1, r7
 800c378:	f7f3 ffc8 	bl	800030c <__aeabi_dsub>
 800c37c:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 800c380:	f804 cb01 	strb.w	ip, [r4], #1
 800c384:	eba4 0c0b 	sub.w	ip, r4, fp
 800c388:	45e0      	cmp	r8, ip
 800c38a:	4606      	mov	r6, r0
 800c38c:	460f      	mov	r7, r1
 800c38e:	f04f 0200 	mov.w	r2, #0
 800c392:	4bc1      	ldr	r3, [pc, #772]	; (800c698 <_dtoa_r+0x860>)
 800c394:	d1d2      	bne.n	800c33c <_dtoa_r+0x504>
 800c396:	f8dd a000 	ldr.w	sl, [sp]
 800c39a:	f8dd 901c 	ldr.w	r9, [sp, #28]
 800c39e:	4632      	mov	r2, r6
 800c3a0:	463b      	mov	r3, r7
 800c3a2:	4630      	mov	r0, r6
 800c3a4:	4639      	mov	r1, r7
 800c3a6:	f7f3 ffb3 	bl	8000310 <__adddf3>
 800c3aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c3ae:	4606      	mov	r6, r0
 800c3b0:	460f      	mov	r7, r1
 800c3b2:	f7f4 fbf3 	bl	8000b9c <__aeabi_dcmpgt>
 800c3b6:	b958      	cbnz	r0, 800c3d0 <_dtoa_r+0x598>
 800c3b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c3bc:	4630      	mov	r0, r6
 800c3be:	4639      	mov	r1, r7
 800c3c0:	f7f4 fbc4 	bl	8000b4c <__aeabi_dcmpeq>
 800c3c4:	2800      	cmp	r0, #0
 800c3c6:	f000 818d 	beq.w	800c6e4 <_dtoa_r+0x8ac>
 800c3ca:	07e9      	lsls	r1, r5, #31
 800c3cc:	f140 818a 	bpl.w	800c6e4 <_dtoa_r+0x8ac>
 800c3d0:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 800c3d4:	e005      	b.n	800c3e2 <_dtoa_r+0x5aa>
 800c3d6:	459b      	cmp	fp, r3
 800c3d8:	f000 8373 	beq.w	800cac2 <_dtoa_r+0xc8a>
 800c3dc:	f813 5c01 	ldrb.w	r5, [r3, #-1]
 800c3e0:	461c      	mov	r4, r3
 800c3e2:	2d39      	cmp	r5, #57	; 0x39
 800c3e4:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
 800c3e8:	d0f5      	beq.n	800c3d6 <_dtoa_r+0x59e>
 800c3ea:	3501      	adds	r5, #1
 800c3ec:	701d      	strb	r5, [r3, #0]
 800c3ee:	e179      	b.n	800c6e4 <_dtoa_r+0x8ac>
 800c3f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c3f2:	2a00      	cmp	r2, #0
 800c3f4:	d03b      	beq.n	800c46e <_dtoa_r+0x636>
 800c3f6:	9a02      	ldr	r2, [sp, #8]
 800c3f8:	2a01      	cmp	r2, #1
 800c3fa:	f340 820b 	ble.w	800c814 <_dtoa_r+0x9dc>
 800c3fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c400:	1e5f      	subs	r7, r3, #1
 800c402:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c404:	42bb      	cmp	r3, r7
 800c406:	f2c0 82e6 	blt.w	800c9d6 <_dtoa_r+0xb9e>
 800c40a:	1bdf      	subs	r7, r3, r7
 800c40c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c40e:	2b00      	cmp	r3, #0
 800c410:	f2c0 830b 	blt.w	800ca2a <_dtoa_r+0xbf2>
 800c414:	9a08      	ldr	r2, [sp, #32]
 800c416:	4614      	mov	r4, r2
 800c418:	441a      	add	r2, r3
 800c41a:	4498      	add	r8, r3
 800c41c:	9208      	str	r2, [sp, #32]
 800c41e:	2101      	movs	r1, #1
 800c420:	4648      	mov	r0, r9
 800c422:	f001 f8db 	bl	800d5dc <__i2b>
 800c426:	4605      	mov	r5, r0
 800c428:	e024      	b.n	800c474 <_dtoa_r+0x63c>
 800c42a:	2301      	movs	r3, #1
 800c42c:	930d      	str	r3, [sp, #52]	; 0x34
 800c42e:	e5af      	b.n	800bf90 <_dtoa_r+0x158>
 800c430:	9a08      	ldr	r2, [sp, #32]
 800c432:	9b06      	ldr	r3, [sp, #24]
 800c434:	1ad2      	subs	r2, r2, r3
 800c436:	425b      	negs	r3, r3
 800c438:	930b      	str	r3, [sp, #44]	; 0x2c
 800c43a:	2300      	movs	r3, #0
 800c43c:	9208      	str	r2, [sp, #32]
 800c43e:	930c      	str	r3, [sp, #48]	; 0x30
 800c440:	e5b5      	b.n	800bfae <_dtoa_r+0x176>
 800c442:	f1c4 0301 	rsb	r3, r4, #1
 800c446:	9308      	str	r3, [sp, #32]
 800c448:	f04f 0800 	mov.w	r8, #0
 800c44c:	e5a7      	b.n	800bf9e <_dtoa_r+0x166>
 800c44e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800c452:	4640      	mov	r0, r8
 800c454:	f7f4 f8a8 	bl	80005a8 <__aeabi_i2d>
 800c458:	4632      	mov	r2, r6
 800c45a:	463b      	mov	r3, r7
 800c45c:	f7f4 fb76 	bl	8000b4c <__aeabi_dcmpeq>
 800c460:	2800      	cmp	r0, #0
 800c462:	f47f ad81 	bne.w	800bf68 <_dtoa_r+0x130>
 800c466:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
 800c46a:	9306      	str	r3, [sp, #24]
 800c46c:	e57c      	b.n	800bf68 <_dtoa_r+0x130>
 800c46e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800c470:	9c08      	ldr	r4, [sp, #32]
 800c472:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800c474:	2c00      	cmp	r4, #0
 800c476:	dd0c      	ble.n	800c492 <_dtoa_r+0x65a>
 800c478:	f1b8 0f00 	cmp.w	r8, #0
 800c47c:	dd09      	ble.n	800c492 <_dtoa_r+0x65a>
 800c47e:	4544      	cmp	r4, r8
 800c480:	9a08      	ldr	r2, [sp, #32]
 800c482:	4623      	mov	r3, r4
 800c484:	bfa8      	it	ge
 800c486:	4643      	movge	r3, r8
 800c488:	1ad2      	subs	r2, r2, r3
 800c48a:	9208      	str	r2, [sp, #32]
 800c48c:	1ae4      	subs	r4, r4, r3
 800c48e:	eba8 0803 	sub.w	r8, r8, r3
 800c492:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c494:	b16b      	cbz	r3, 800c4b2 <_dtoa_r+0x67a>
 800c496:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c498:	2a00      	cmp	r2, #0
 800c49a:	f000 8290 	beq.w	800c9be <_dtoa_r+0xb86>
 800c49e:	1bde      	subs	r6, r3, r7
 800c4a0:	2f00      	cmp	r7, #0
 800c4a2:	f040 819b 	bne.w	800c7dc <_dtoa_r+0x9a4>
 800c4a6:	4651      	mov	r1, sl
 800c4a8:	4632      	mov	r2, r6
 800c4aa:	4648      	mov	r0, r9
 800c4ac:	f001 f946 	bl	800d73c <__pow5mult>
 800c4b0:	4682      	mov	sl, r0
 800c4b2:	2101      	movs	r1, #1
 800c4b4:	4648      	mov	r0, r9
 800c4b6:	f001 f891 	bl	800d5dc <__i2b>
 800c4ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c4bc:	4606      	mov	r6, r0
 800c4be:	2a00      	cmp	r2, #0
 800c4c0:	f040 8125 	bne.w	800c70e <_dtoa_r+0x8d6>
 800c4c4:	9b02      	ldr	r3, [sp, #8]
 800c4c6:	2b01      	cmp	r3, #1
 800c4c8:	f340 816c 	ble.w	800c7a4 <_dtoa_r+0x96c>
 800c4cc:	2001      	movs	r0, #1
 800c4ce:	4440      	add	r0, r8
 800c4d0:	f010 001f 	ands.w	r0, r0, #31
 800c4d4:	f000 8119 	beq.w	800c70a <_dtoa_r+0x8d2>
 800c4d8:	f1c0 0320 	rsb	r3, r0, #32
 800c4dc:	2b04      	cmp	r3, #4
 800c4de:	f340 83ac 	ble.w	800cc3a <_dtoa_r+0xe02>
 800c4e2:	f1c0 001c 	rsb	r0, r0, #28
 800c4e6:	9b08      	ldr	r3, [sp, #32]
 800c4e8:	4403      	add	r3, r0
 800c4ea:	9308      	str	r3, [sp, #32]
 800c4ec:	4404      	add	r4, r0
 800c4ee:	4480      	add	r8, r0
 800c4f0:	9b08      	ldr	r3, [sp, #32]
 800c4f2:	2b00      	cmp	r3, #0
 800c4f4:	dd05      	ble.n	800c502 <_dtoa_r+0x6ca>
 800c4f6:	4651      	mov	r1, sl
 800c4f8:	461a      	mov	r2, r3
 800c4fa:	4648      	mov	r0, r9
 800c4fc:	f001 f96e 	bl	800d7dc <__lshift>
 800c500:	4682      	mov	sl, r0
 800c502:	f1b8 0f00 	cmp.w	r8, #0
 800c506:	dd05      	ble.n	800c514 <_dtoa_r+0x6dc>
 800c508:	4631      	mov	r1, r6
 800c50a:	4642      	mov	r2, r8
 800c50c:	4648      	mov	r0, r9
 800c50e:	f001 f965 	bl	800d7dc <__lshift>
 800c512:	4606      	mov	r6, r0
 800c514:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c516:	2b00      	cmp	r3, #0
 800c518:	d177      	bne.n	800c60a <_dtoa_r+0x7d2>
 800c51a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c51c:	2b00      	cmp	r3, #0
 800c51e:	f340 8209 	ble.w	800c934 <_dtoa_r+0xafc>
 800c522:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c524:	2b00      	cmp	r3, #0
 800c526:	f000 8089 	beq.w	800c63c <_dtoa_r+0x804>
 800c52a:	2c00      	cmp	r4, #0
 800c52c:	f300 816b 	bgt.w	800c806 <_dtoa_r+0x9ce>
 800c530:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800c532:	2b00      	cmp	r3, #0
 800c534:	f040 81cd 	bne.w	800c8d2 <_dtoa_r+0xa9a>
 800c538:	46a8      	mov	r8, r5
 800c53a:	9a00      	ldr	r2, [sp, #0]
 800c53c:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 800c540:	f002 0201 	and.w	r2, r2, #1
 800c544:	920a      	str	r2, [sp, #40]	; 0x28
 800c546:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c548:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 800c54c:	441a      	add	r2, r3
 800c54e:	465f      	mov	r7, fp
 800c550:	9209      	str	r2, [sp, #36]	; 0x24
 800c552:	46b3      	mov	fp, r6
 800c554:	4659      	mov	r1, fp
 800c556:	4650      	mov	r0, sl
 800c558:	f7ff fbdc 	bl	800bd14 <quorem>
 800c55c:	4629      	mov	r1, r5
 800c55e:	4604      	mov	r4, r0
 800c560:	4650      	mov	r0, sl
 800c562:	f001 f991 	bl	800d888 <__mcmp>
 800c566:	4659      	mov	r1, fp
 800c568:	4606      	mov	r6, r0
 800c56a:	4642      	mov	r2, r8
 800c56c:	4648      	mov	r0, r9
 800c56e:	f001 f9a7 	bl	800d8c0 <__mdiff>
 800c572:	f104 0330 	add.w	r3, r4, #48	; 0x30
 800c576:	9300      	str	r3, [sp, #0]
 800c578:	68c3      	ldr	r3, [r0, #12]
 800c57a:	4601      	mov	r1, r0
 800c57c:	2b00      	cmp	r3, #0
 800c57e:	f040 81d4 	bne.w	800c92a <_dtoa_r+0xaf2>
 800c582:	9008      	str	r0, [sp, #32]
 800c584:	4650      	mov	r0, sl
 800c586:	f001 f97f 	bl	800d888 <__mcmp>
 800c58a:	9a08      	ldr	r2, [sp, #32]
 800c58c:	9007      	str	r0, [sp, #28]
 800c58e:	4611      	mov	r1, r2
 800c590:	4648      	mov	r0, r9
 800c592:	f000 ff89 	bl	800d4a8 <_Bfree>
 800c596:	9b07      	ldr	r3, [sp, #28]
 800c598:	b933      	cbnz	r3, 800c5a8 <_dtoa_r+0x770>
 800c59a:	9a02      	ldr	r2, [sp, #8]
 800c59c:	b922      	cbnz	r2, 800c5a8 <_dtoa_r+0x770>
 800c59e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c5a0:	2b00      	cmp	r3, #0
 800c5a2:	f000 8319 	beq.w	800cbd8 <_dtoa_r+0xda0>
 800c5a6:	9b02      	ldr	r3, [sp, #8]
 800c5a8:	2e00      	cmp	r6, #0
 800c5aa:	f2c0 821c 	blt.w	800c9e6 <_dtoa_r+0xbae>
 800c5ae:	d105      	bne.n	800c5bc <_dtoa_r+0x784>
 800c5b0:	9a02      	ldr	r2, [sp, #8]
 800c5b2:	b91a      	cbnz	r2, 800c5bc <_dtoa_r+0x784>
 800c5b4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c5b6:	2a00      	cmp	r2, #0
 800c5b8:	f000 8215 	beq.w	800c9e6 <_dtoa_r+0xbae>
 800c5bc:	2b00      	cmp	r3, #0
 800c5be:	f107 0401 	add.w	r4, r7, #1
 800c5c2:	f300 8225 	bgt.w	800ca10 <_dtoa_r+0xbd8>
 800c5c6:	9b00      	ldr	r3, [sp, #0]
 800c5c8:	703b      	strb	r3, [r7, #0]
 800c5ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c5cc:	42bb      	cmp	r3, r7
 800c5ce:	f000 8230 	beq.w	800ca32 <_dtoa_r+0xbfa>
 800c5d2:	4651      	mov	r1, sl
 800c5d4:	2300      	movs	r3, #0
 800c5d6:	220a      	movs	r2, #10
 800c5d8:	4648      	mov	r0, r9
 800c5da:	f000 ff6f 	bl	800d4bc <__multadd>
 800c5de:	4545      	cmp	r5, r8
 800c5e0:	4682      	mov	sl, r0
 800c5e2:	4629      	mov	r1, r5
 800c5e4:	f04f 0300 	mov.w	r3, #0
 800c5e8:	f04f 020a 	mov.w	r2, #10
 800c5ec:	4648      	mov	r0, r9
 800c5ee:	f000 8196 	beq.w	800c91e <_dtoa_r+0xae6>
 800c5f2:	f000 ff63 	bl	800d4bc <__multadd>
 800c5f6:	4641      	mov	r1, r8
 800c5f8:	4605      	mov	r5, r0
 800c5fa:	2300      	movs	r3, #0
 800c5fc:	220a      	movs	r2, #10
 800c5fe:	4648      	mov	r0, r9
 800c600:	f000 ff5c 	bl	800d4bc <__multadd>
 800c604:	4627      	mov	r7, r4
 800c606:	4680      	mov	r8, r0
 800c608:	e7a4      	b.n	800c554 <_dtoa_r+0x71c>
 800c60a:	4631      	mov	r1, r6
 800c60c:	4650      	mov	r0, sl
 800c60e:	f001 f93b 	bl	800d888 <__mcmp>
 800c612:	2800      	cmp	r0, #0
 800c614:	da81      	bge.n	800c51a <_dtoa_r+0x6e2>
 800c616:	9f06      	ldr	r7, [sp, #24]
 800c618:	4651      	mov	r1, sl
 800c61a:	2300      	movs	r3, #0
 800c61c:	220a      	movs	r2, #10
 800c61e:	4648      	mov	r0, r9
 800c620:	3f01      	subs	r7, #1
 800c622:	9706      	str	r7, [sp, #24]
 800c624:	f000 ff4a 	bl	800d4bc <__multadd>
 800c628:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c62a:	4682      	mov	sl, r0
 800c62c:	2b00      	cmp	r3, #0
 800c62e:	f040 82eb 	bne.w	800cc08 <_dtoa_r+0xdd0>
 800c632:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c634:	2b00      	cmp	r3, #0
 800c636:	f340 82f3 	ble.w	800cc20 <_dtoa_r+0xde8>
 800c63a:	9309      	str	r3, [sp, #36]	; 0x24
 800c63c:	465c      	mov	r4, fp
 800c63e:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 800c642:	e002      	b.n	800c64a <_dtoa_r+0x812>
 800c644:	f000 ff3a 	bl	800d4bc <__multadd>
 800c648:	4682      	mov	sl, r0
 800c64a:	4631      	mov	r1, r6
 800c64c:	4650      	mov	r0, sl
 800c64e:	f7ff fb61 	bl	800bd14 <quorem>
 800c652:	f100 0730 	add.w	r7, r0, #48	; 0x30
 800c656:	f804 7b01 	strb.w	r7, [r4], #1
 800c65a:	eba4 030b 	sub.w	r3, r4, fp
 800c65e:	4598      	cmp	r8, r3
 800c660:	f04f 020a 	mov.w	r2, #10
 800c664:	f04f 0300 	mov.w	r3, #0
 800c668:	4651      	mov	r1, sl
 800c66a:	4648      	mov	r0, r9
 800c66c:	dcea      	bgt.n	800c644 <_dtoa_r+0x80c>
 800c66e:	2300      	movs	r3, #0
 800c670:	9700      	str	r7, [sp, #0]
 800c672:	9302      	str	r3, [sp, #8]
 800c674:	4651      	mov	r1, sl
 800c676:	2201      	movs	r2, #1
 800c678:	4648      	mov	r0, r9
 800c67a:	f001 f8af 	bl	800d7dc <__lshift>
 800c67e:	4631      	mov	r1, r6
 800c680:	4682      	mov	sl, r0
 800c682:	f001 f901 	bl	800d888 <__mcmp>
 800c686:	2800      	cmp	r0, #0
 800c688:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 800c68c:	dc14      	bgt.n	800c6b8 <_dtoa_r+0x880>
 800c68e:	d108      	bne.n	800c6a2 <_dtoa_r+0x86a>
 800c690:	9b00      	ldr	r3, [sp, #0]
 800c692:	07db      	lsls	r3, r3, #31
 800c694:	d410      	bmi.n	800c6b8 <_dtoa_r+0x880>
 800c696:	e004      	b.n	800c6a2 <_dtoa_r+0x86a>
 800c698:	40240000 	.word	0x40240000
 800c69c:	f814 2c02 	ldrb.w	r2, [r4, #-2]
 800c6a0:	461c      	mov	r4, r3
 800c6a2:	2a30      	cmp	r2, #48	; 0x30
 800c6a4:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
 800c6a8:	d0f8      	beq.n	800c69c <_dtoa_r+0x864>
 800c6aa:	e00b      	b.n	800c6c4 <_dtoa_r+0x88c>
 800c6ac:	459b      	cmp	fp, r3
 800c6ae:	f000 814e 	beq.w	800c94e <_dtoa_r+0xb16>
 800c6b2:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 800c6b6:	461c      	mov	r4, r3
 800c6b8:	2a39      	cmp	r2, #57	; 0x39
 800c6ba:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
 800c6be:	d0f5      	beq.n	800c6ac <_dtoa_r+0x874>
 800c6c0:	3201      	adds	r2, #1
 800c6c2:	701a      	strb	r2, [r3, #0]
 800c6c4:	4631      	mov	r1, r6
 800c6c6:	4648      	mov	r0, r9
 800c6c8:	f000 feee 	bl	800d4a8 <_Bfree>
 800c6cc:	b155      	cbz	r5, 800c6e4 <_dtoa_r+0x8ac>
 800c6ce:	9902      	ldr	r1, [sp, #8]
 800c6d0:	b121      	cbz	r1, 800c6dc <_dtoa_r+0x8a4>
 800c6d2:	42a9      	cmp	r1, r5
 800c6d4:	d002      	beq.n	800c6dc <_dtoa_r+0x8a4>
 800c6d6:	4648      	mov	r0, r9
 800c6d8:	f000 fee6 	bl	800d4a8 <_Bfree>
 800c6dc:	4629      	mov	r1, r5
 800c6de:	4648      	mov	r0, r9
 800c6e0:	f000 fee2 	bl	800d4a8 <_Bfree>
 800c6e4:	4651      	mov	r1, sl
 800c6e6:	4648      	mov	r0, r9
 800c6e8:	f000 fede 	bl	800d4a8 <_Bfree>
 800c6ec:	2200      	movs	r2, #0
 800c6ee:	9b06      	ldr	r3, [sp, #24]
 800c6f0:	7022      	strb	r2, [r4, #0]
 800c6f2:	9a05      	ldr	r2, [sp, #20]
 800c6f4:	3301      	adds	r3, #1
 800c6f6:	6013      	str	r3, [r2, #0]
 800c6f8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800c6fa:	2b00      	cmp	r3, #0
 800c6fc:	f43f abdb 	beq.w	800beb6 <_dtoa_r+0x7e>
 800c700:	4658      	mov	r0, fp
 800c702:	601c      	str	r4, [r3, #0]
 800c704:	b01b      	add	sp, #108	; 0x6c
 800c706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c70a:	201c      	movs	r0, #28
 800c70c:	e6eb      	b.n	800c4e6 <_dtoa_r+0x6ae>
 800c70e:	4601      	mov	r1, r0
 800c710:	4648      	mov	r0, r9
 800c712:	f001 f813 	bl	800d73c <__pow5mult>
 800c716:	9b02      	ldr	r3, [sp, #8]
 800c718:	2b01      	cmp	r3, #1
 800c71a:	4606      	mov	r6, r0
 800c71c:	f340 80d4 	ble.w	800c8c8 <_dtoa_r+0xa90>
 800c720:	2300      	movs	r3, #0
 800c722:	930c      	str	r3, [sp, #48]	; 0x30
 800c724:	6933      	ldr	r3, [r6, #16]
 800c726:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800c72a:	6918      	ldr	r0, [r3, #16]
 800c72c:	f000 ff06 	bl	800d53c <__hi0bits>
 800c730:	f1c0 0020 	rsb	r0, r0, #32
 800c734:	e6cb      	b.n	800c4ce <_dtoa_r+0x696>
 800c736:	900d      	str	r0, [sp, #52]	; 0x34
 800c738:	e42a      	b.n	800bf90 <_dtoa_r+0x158>
 800c73a:	2501      	movs	r5, #1
 800c73c:	e440      	b.n	800bfc0 <_dtoa_r+0x188>
 800c73e:	f1c3 0820 	rsb	r8, r3, #32
 800c742:	9b00      	ldr	r3, [sp, #0]
 800c744:	fa03 f008 	lsl.w	r0, r3, r8
 800c748:	f7ff bbd8 	b.w	800befc <_dtoa_r+0xc4>
 800c74c:	2300      	movs	r3, #0
 800c74e:	930a      	str	r3, [sp, #40]	; 0x28
 800c750:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 800c754:	4413      	add	r3, r2
 800c756:	930e      	str	r3, [sp, #56]	; 0x38
 800c758:	3301      	adds	r3, #1
 800c75a:	2b01      	cmp	r3, #1
 800c75c:	461e      	mov	r6, r3
 800c75e:	9309      	str	r3, [sp, #36]	; 0x24
 800c760:	bfb8      	it	lt
 800c762:	2601      	movlt	r6, #1
 800c764:	2100      	movs	r1, #0
 800c766:	2e17      	cmp	r6, #23
 800c768:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 800c76c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800c76e:	f77f ac89 	ble.w	800c084 <_dtoa_r+0x24c>
 800c772:	2201      	movs	r2, #1
 800c774:	2304      	movs	r3, #4
 800c776:	005b      	lsls	r3, r3, #1
 800c778:	f103 0014 	add.w	r0, r3, #20
 800c77c:	42b0      	cmp	r0, r6
 800c77e:	4611      	mov	r1, r2
 800c780:	f102 0201 	add.w	r2, r2, #1
 800c784:	d9f7      	bls.n	800c776 <_dtoa_r+0x93e>
 800c786:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 800c78a:	e47b      	b.n	800c084 <_dtoa_r+0x24c>
 800c78c:	2300      	movs	r3, #0
 800c78e:	930a      	str	r3, [sp, #40]	; 0x28
 800c790:	9e07      	ldr	r6, [sp, #28]
 800c792:	2e00      	cmp	r6, #0
 800c794:	f340 80e2 	ble.w	800c95c <_dtoa_r+0xb24>
 800c798:	960e      	str	r6, [sp, #56]	; 0x38
 800c79a:	9609      	str	r6, [sp, #36]	; 0x24
 800c79c:	e7e2      	b.n	800c764 <_dtoa_r+0x92c>
 800c79e:	2301      	movs	r3, #1
 800c7a0:	930a      	str	r3, [sp, #40]	; 0x28
 800c7a2:	e7f5      	b.n	800c790 <_dtoa_r+0x958>
 800c7a4:	9b00      	ldr	r3, [sp, #0]
 800c7a6:	2b00      	cmp	r3, #0
 800c7a8:	f47f ae90 	bne.w	800c4cc <_dtoa_r+0x694>
 800c7ac:	e9dd 1200 	ldrd	r1, r2, [sp]
 800c7b0:	f3c2 0313 	ubfx	r3, r2, #0, #20
 800c7b4:	2b00      	cmp	r3, #0
 800c7b6:	f040 8192 	bne.w	800cade <_dtoa_r+0xca6>
 800c7ba:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 800c7be:	0d1b      	lsrs	r3, r3, #20
 800c7c0:	051b      	lsls	r3, r3, #20
 800c7c2:	b12b      	cbz	r3, 800c7d0 <_dtoa_r+0x998>
 800c7c4:	9b08      	ldr	r3, [sp, #32]
 800c7c6:	3301      	adds	r3, #1
 800c7c8:	9308      	str	r3, [sp, #32]
 800c7ca:	f108 0801 	add.w	r8, r8, #1
 800c7ce:	2301      	movs	r3, #1
 800c7d0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c7d2:	930c      	str	r3, [sp, #48]	; 0x30
 800c7d4:	2a00      	cmp	r2, #0
 800c7d6:	f43f ae79 	beq.w	800c4cc <_dtoa_r+0x694>
 800c7da:	e7a3      	b.n	800c724 <_dtoa_r+0x8ec>
 800c7dc:	463a      	mov	r2, r7
 800c7de:	4629      	mov	r1, r5
 800c7e0:	4648      	mov	r0, r9
 800c7e2:	f000 ffab 	bl	800d73c <__pow5mult>
 800c7e6:	4652      	mov	r2, sl
 800c7e8:	4601      	mov	r1, r0
 800c7ea:	4605      	mov	r5, r0
 800c7ec:	4648      	mov	r0, r9
 800c7ee:	f000 feff 	bl	800d5f0 <__multiply>
 800c7f2:	4651      	mov	r1, sl
 800c7f4:	4607      	mov	r7, r0
 800c7f6:	4648      	mov	r0, r9
 800c7f8:	f000 fe56 	bl	800d4a8 <_Bfree>
 800c7fc:	46ba      	mov	sl, r7
 800c7fe:	2e00      	cmp	r6, #0
 800c800:	f43f ae57 	beq.w	800c4b2 <_dtoa_r+0x67a>
 800c804:	e64f      	b.n	800c4a6 <_dtoa_r+0x66e>
 800c806:	4629      	mov	r1, r5
 800c808:	4622      	mov	r2, r4
 800c80a:	4648      	mov	r0, r9
 800c80c:	f000 ffe6 	bl	800d7dc <__lshift>
 800c810:	4605      	mov	r5, r0
 800c812:	e68d      	b.n	800c530 <_dtoa_r+0x6f8>
 800c814:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c816:	2a00      	cmp	r2, #0
 800c818:	f000 815d 	beq.w	800cad6 <_dtoa_r+0xc9e>
 800c81c:	f203 4333 	addw	r3, r3, #1075	; 0x433
 800c820:	9a08      	ldr	r2, [sp, #32]
 800c822:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800c824:	4614      	mov	r4, r2
 800c826:	441a      	add	r2, r3
 800c828:	4498      	add	r8, r3
 800c82a:	9208      	str	r2, [sp, #32]
 800c82c:	e5f7      	b.n	800c41e <_dtoa_r+0x5e6>
 800c82e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c830:	2b00      	cmp	r3, #0
 800c832:	f73f ad3e 	bgt.w	800c2b2 <_dtoa_r+0x47a>
 800c836:	f040 80bc 	bne.w	800c9b2 <_dtoa_r+0xb7a>
 800c83a:	ec51 0b17 	vmov	r0, r1, d7
 800c83e:	2200      	movs	r2, #0
 800c840:	4bb2      	ldr	r3, [pc, #712]	; (800cb0c <_dtoa_r+0xcd4>)
 800c842:	f7f3 ff1b 	bl	800067c <__aeabi_dmul>
 800c846:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c84a:	f7f4 f99d 	bl	8000b88 <__aeabi_dcmpge>
 800c84e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800c850:	4635      	mov	r5, r6
 800c852:	2800      	cmp	r0, #0
 800c854:	d176      	bne.n	800c944 <_dtoa_r+0xb0c>
 800c856:	9a06      	ldr	r2, [sp, #24]
 800c858:	2331      	movs	r3, #49	; 0x31
 800c85a:	3201      	adds	r2, #1
 800c85c:	9206      	str	r2, [sp, #24]
 800c85e:	f88b 3000 	strb.w	r3, [fp]
 800c862:	f10b 0401 	add.w	r4, fp, #1
 800c866:	4631      	mov	r1, r6
 800c868:	4648      	mov	r0, r9
 800c86a:	f000 fe1d 	bl	800d4a8 <_Bfree>
 800c86e:	2d00      	cmp	r5, #0
 800c870:	f47f af34 	bne.w	800c6dc <_dtoa_r+0x8a4>
 800c874:	e736      	b.n	800c6e4 <_dtoa_r+0x8ac>
 800c876:	f000 8142 	beq.w	800cafe <_dtoa_r+0xcc6>
 800c87a:	9b06      	ldr	r3, [sp, #24]
 800c87c:	425c      	negs	r4, r3
 800c87e:	4ba4      	ldr	r3, [pc, #656]	; (800cb10 <_dtoa_r+0xcd8>)
 800c880:	f004 020f 	and.w	r2, r4, #15
 800c884:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c888:	e9d3 2300 	ldrd	r2, r3, [r3]
 800c88c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800c890:	f7f3 fef4 	bl	800067c <__aeabi_dmul>
 800c894:	1124      	asrs	r4, r4, #4
 800c896:	e9cd 0100 	strd	r0, r1, [sp]
 800c89a:	f000 81c6 	beq.w	800cc2a <_dtoa_r+0xdf2>
 800c89e:	4d9d      	ldr	r5, [pc, #628]	; (800cb14 <_dtoa_r+0xcdc>)
 800c8a0:	2300      	movs	r3, #0
 800c8a2:	2602      	movs	r6, #2
 800c8a4:	07e7      	lsls	r7, r4, #31
 800c8a6:	d505      	bpl.n	800c8b4 <_dtoa_r+0xa7c>
 800c8a8:	e9d5 2300 	ldrd	r2, r3, [r5]
 800c8ac:	f7f3 fee6 	bl	800067c <__aeabi_dmul>
 800c8b0:	3601      	adds	r6, #1
 800c8b2:	2301      	movs	r3, #1
 800c8b4:	1064      	asrs	r4, r4, #1
 800c8b6:	f105 0508 	add.w	r5, r5, #8
 800c8ba:	d1f3      	bne.n	800c8a4 <_dtoa_r+0xa6c>
 800c8bc:	2b00      	cmp	r3, #0
 800c8be:	f43f ac27 	beq.w	800c110 <_dtoa_r+0x2d8>
 800c8c2:	e9cd 0100 	strd	r0, r1, [sp]
 800c8c6:	e423      	b.n	800c110 <_dtoa_r+0x2d8>
 800c8c8:	9b00      	ldr	r3, [sp, #0]
 800c8ca:	2b00      	cmp	r3, #0
 800c8cc:	f43f af6e 	beq.w	800c7ac <_dtoa_r+0x974>
 800c8d0:	e726      	b.n	800c720 <_dtoa_r+0x8e8>
 800c8d2:	6869      	ldr	r1, [r5, #4]
 800c8d4:	4648      	mov	r0, r9
 800c8d6:	f000 fdc1 	bl	800d45c <_Balloc>
 800c8da:	692b      	ldr	r3, [r5, #16]
 800c8dc:	3302      	adds	r3, #2
 800c8de:	009a      	lsls	r2, r3, #2
 800c8e0:	4604      	mov	r4, r0
 800c8e2:	f105 010c 	add.w	r1, r5, #12
 800c8e6:	300c      	adds	r0, #12
 800c8e8:	f7f4 f9f0 	bl	8000ccc <memcpy>
 800c8ec:	4621      	mov	r1, r4
 800c8ee:	2201      	movs	r2, #1
 800c8f0:	4648      	mov	r0, r9
 800c8f2:	f000 ff73 	bl	800d7dc <__lshift>
 800c8f6:	4680      	mov	r8, r0
 800c8f8:	e61f      	b.n	800c53a <_dtoa_r+0x702>
 800c8fa:	2400      	movs	r4, #0
 800c8fc:	f8c9 4044 	str.w	r4, [r9, #68]	; 0x44
 800c900:	4621      	mov	r1, r4
 800c902:	4648      	mov	r0, r9
 800c904:	f000 fdaa 	bl	800d45c <_Balloc>
 800c908:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800c90c:	930e      	str	r3, [sp, #56]	; 0x38
 800c90e:	9309      	str	r3, [sp, #36]	; 0x24
 800c910:	2301      	movs	r3, #1
 800c912:	4683      	mov	fp, r0
 800c914:	9407      	str	r4, [sp, #28]
 800c916:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
 800c91a:	930a      	str	r3, [sp, #40]	; 0x28
 800c91c:	e4b6      	b.n	800c28c <_dtoa_r+0x454>
 800c91e:	f000 fdcd 	bl	800d4bc <__multadd>
 800c922:	4627      	mov	r7, r4
 800c924:	4605      	mov	r5, r0
 800c926:	4680      	mov	r8, r0
 800c928:	e614      	b.n	800c554 <_dtoa_r+0x71c>
 800c92a:	4648      	mov	r0, r9
 800c92c:	f000 fdbc 	bl	800d4a8 <_Bfree>
 800c930:	2301      	movs	r3, #1
 800c932:	e639      	b.n	800c5a8 <_dtoa_r+0x770>
 800c934:	9b02      	ldr	r3, [sp, #8]
 800c936:	2b02      	cmp	r3, #2
 800c938:	f77f adf3 	ble.w	800c522 <_dtoa_r+0x6ea>
 800c93c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c93e:	2b00      	cmp	r3, #0
 800c940:	f000 80cf 	beq.w	800cae2 <_dtoa_r+0xcaa>
 800c944:	9b07      	ldr	r3, [sp, #28]
 800c946:	43db      	mvns	r3, r3
 800c948:	9306      	str	r3, [sp, #24]
 800c94a:	465c      	mov	r4, fp
 800c94c:	e78b      	b.n	800c866 <_dtoa_r+0xa2e>
 800c94e:	9a06      	ldr	r2, [sp, #24]
 800c950:	2331      	movs	r3, #49	; 0x31
 800c952:	3201      	adds	r2, #1
 800c954:	9206      	str	r2, [sp, #24]
 800c956:	f88b 3000 	strb.w	r3, [fp]
 800c95a:	e6b3      	b.n	800c6c4 <_dtoa_r+0x88c>
 800c95c:	2401      	movs	r4, #1
 800c95e:	9409      	str	r4, [sp, #36]	; 0x24
 800c960:	9407      	str	r4, [sp, #28]
 800c962:	f7ff bb8b 	b.w	800c07c <_dtoa_r+0x244>
 800c966:	4630      	mov	r0, r6
 800c968:	f7f3 fe1e 	bl	80005a8 <__aeabi_i2d>
 800c96c:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c970:	f7f3 fe84 	bl	800067c <__aeabi_dmul>
 800c974:	2200      	movs	r2, #0
 800c976:	4b68      	ldr	r3, [pc, #416]	; (800cb18 <_dtoa_r+0xce0>)
 800c978:	f7f3 fcca 	bl	8000310 <__adddf3>
 800c97c:	4606      	mov	r6, r0
 800c97e:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800c982:	2200      	movs	r2, #0
 800c984:	4b61      	ldr	r3, [pc, #388]	; (800cb0c <_dtoa_r+0xcd4>)
 800c986:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c98a:	f7f3 fcbf 	bl	800030c <__aeabi_dsub>
 800c98e:	4632      	mov	r2, r6
 800c990:	463b      	mov	r3, r7
 800c992:	4604      	mov	r4, r0
 800c994:	460d      	mov	r5, r1
 800c996:	f7f4 f901 	bl	8000b9c <__aeabi_dcmpgt>
 800c99a:	2800      	cmp	r0, #0
 800c99c:	d14f      	bne.n	800ca3e <_dtoa_r+0xc06>
 800c99e:	4632      	mov	r2, r6
 800c9a0:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 800c9a4:	4620      	mov	r0, r4
 800c9a6:	4629      	mov	r1, r5
 800c9a8:	f7f4 f8da 	bl	8000b60 <__aeabi_dcmplt>
 800c9ac:	2800      	cmp	r0, #0
 800c9ae:	f43f ac69 	beq.w	800c284 <_dtoa_r+0x44c>
 800c9b2:	2600      	movs	r6, #0
 800c9b4:	4635      	mov	r5, r6
 800c9b6:	e7c5      	b.n	800c944 <_dtoa_r+0xb0c>
 800c9b8:	2301      	movs	r3, #1
 800c9ba:	930a      	str	r3, [sp, #40]	; 0x28
 800c9bc:	e6c8      	b.n	800c750 <_dtoa_r+0x918>
 800c9be:	4651      	mov	r1, sl
 800c9c0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800c9c2:	4648      	mov	r0, r9
 800c9c4:	f000 feba 	bl	800d73c <__pow5mult>
 800c9c8:	4682      	mov	sl, r0
 800c9ca:	e572      	b.n	800c4b2 <_dtoa_r+0x67a>
 800c9cc:	f8dd a000 	ldr.w	sl, [sp]
 800c9d0:	f8dd 901c 	ldr.w	r9, [sp, #28]
 800c9d4:	e686      	b.n	800c6e4 <_dtoa_r+0x8ac>
 800c9d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c9d8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c9da:	1afb      	subs	r3, r7, r3
 800c9dc:	441a      	add	r2, r3
 800c9de:	e9cd 720b 	strd	r7, r2, [sp, #44]	; 0x2c
 800c9e2:	2700      	movs	r7, #0
 800c9e4:	e512      	b.n	800c40c <_dtoa_r+0x5d4>
 800c9e6:	2b00      	cmp	r3, #0
 800c9e8:	9402      	str	r4, [sp, #8]
 800c9ea:	465e      	mov	r6, fp
 800c9ec:	f107 0401 	add.w	r4, r7, #1
 800c9f0:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800c9f4:	f300 80ba 	bgt.w	800cb6c <_dtoa_r+0xd34>
 800c9f8:	9b00      	ldr	r3, [sp, #0]
 800c9fa:	9502      	str	r5, [sp, #8]
 800c9fc:	703b      	strb	r3, [r7, #0]
 800c9fe:	4645      	mov	r5, r8
 800ca00:	e660      	b.n	800c6c4 <_dtoa_r+0x88c>
 800ca02:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 800ca06:	2602      	movs	r6, #2
 800ca08:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 800ca0c:	f7ff bb67 	b.w	800c0de <_dtoa_r+0x2a6>
 800ca10:	9b00      	ldr	r3, [sp, #0]
 800ca12:	2b39      	cmp	r3, #57	; 0x39
 800ca14:	465e      	mov	r6, fp
 800ca16:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800ca1a:	f000 80b9 	beq.w	800cb90 <_dtoa_r+0xd58>
 800ca1e:	9b00      	ldr	r3, [sp, #0]
 800ca20:	9502      	str	r5, [sp, #8]
 800ca22:	3301      	adds	r3, #1
 800ca24:	703b      	strb	r3, [r7, #0]
 800ca26:	4645      	mov	r5, r8
 800ca28:	e64c      	b.n	800c6c4 <_dtoa_r+0x88c>
 800ca2a:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 800ca2e:	1a9c      	subs	r4, r3, r2
 800ca30:	e4f5      	b.n	800c41e <_dtoa_r+0x5e6>
 800ca32:	465e      	mov	r6, fp
 800ca34:	9502      	str	r5, [sp, #8]
 800ca36:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800ca3a:	4645      	mov	r5, r8
 800ca3c:	e61a      	b.n	800c674 <_dtoa_r+0x83c>
 800ca3e:	2600      	movs	r6, #0
 800ca40:	4635      	mov	r5, r6
 800ca42:	e708      	b.n	800c856 <_dtoa_r+0xa1e>
 800ca44:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 800ca48:	e9dd 0100 	ldrd	r0, r1, [sp]
 800ca4c:	f7f3 fe16 	bl	800067c <__aeabi_dmul>
 800ca50:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800ca52:	f88b 5000 	strb.w	r5, [fp]
 800ca56:	2b01      	cmp	r3, #1
 800ca58:	e9cd 0100 	strd	r0, r1, [sp]
 800ca5c:	d020      	beq.n	800caa0 <_dtoa_r+0xc68>
 800ca5e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800ca60:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
 800ca64:	445b      	add	r3, fp
 800ca66:	4698      	mov	r8, r3
 800ca68:	2200      	movs	r2, #0
 800ca6a:	4b2c      	ldr	r3, [pc, #176]	; (800cb1c <_dtoa_r+0xce4>)
 800ca6c:	4630      	mov	r0, r6
 800ca6e:	4639      	mov	r1, r7
 800ca70:	f7f3 fe04 	bl	800067c <__aeabi_dmul>
 800ca74:	460f      	mov	r7, r1
 800ca76:	4606      	mov	r6, r0
 800ca78:	f7f4 f8b0 	bl	8000bdc <__aeabi_d2iz>
 800ca7c:	4605      	mov	r5, r0
 800ca7e:	f7f3 fd93 	bl	80005a8 <__aeabi_i2d>
 800ca82:	3530      	adds	r5, #48	; 0x30
 800ca84:	4602      	mov	r2, r0
 800ca86:	460b      	mov	r3, r1
 800ca88:	4630      	mov	r0, r6
 800ca8a:	4639      	mov	r1, r7
 800ca8c:	f7f3 fc3e 	bl	800030c <__aeabi_dsub>
 800ca90:	f804 5b01 	strb.w	r5, [r4], #1
 800ca94:	4544      	cmp	r4, r8
 800ca96:	4606      	mov	r6, r0
 800ca98:	460f      	mov	r7, r1
 800ca9a:	d1e5      	bne.n	800ca68 <_dtoa_r+0xc30>
 800ca9c:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
 800caa0:	4b1f      	ldr	r3, [pc, #124]	; (800cb20 <_dtoa_r+0xce8>)
 800caa2:	2200      	movs	r2, #0
 800caa4:	e9dd 0100 	ldrd	r0, r1, [sp]
 800caa8:	f7f3 fc32 	bl	8000310 <__adddf3>
 800caac:	4632      	mov	r2, r6
 800caae:	463b      	mov	r3, r7
 800cab0:	f7f4 f856 	bl	8000b60 <__aeabi_dcmplt>
 800cab4:	2800      	cmp	r0, #0
 800cab6:	d070      	beq.n	800cb9a <_dtoa_r+0xd62>
 800cab8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800caba:	9306      	str	r3, [sp, #24]
 800cabc:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 800cac0:	e48f      	b.n	800c3e2 <_dtoa_r+0x5aa>
 800cac2:	2330      	movs	r3, #48	; 0x30
 800cac4:	f88b 3000 	strb.w	r3, [fp]
 800cac8:	9b06      	ldr	r3, [sp, #24]
 800caca:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 800cace:	3301      	adds	r3, #1
 800cad0:	9306      	str	r3, [sp, #24]
 800cad2:	465b      	mov	r3, fp
 800cad4:	e489      	b.n	800c3ea <_dtoa_r+0x5b2>
 800cad6:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800cad8:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 800cadc:	e6a0      	b.n	800c820 <_dtoa_r+0x9e8>
 800cade:	2300      	movs	r3, #0
 800cae0:	e676      	b.n	800c7d0 <_dtoa_r+0x998>
 800cae2:	4631      	mov	r1, r6
 800cae4:	2205      	movs	r2, #5
 800cae6:	4648      	mov	r0, r9
 800cae8:	f000 fce8 	bl	800d4bc <__multadd>
 800caec:	4601      	mov	r1, r0
 800caee:	4606      	mov	r6, r0
 800caf0:	4650      	mov	r0, sl
 800caf2:	f000 fec9 	bl	800d888 <__mcmp>
 800caf6:	2800      	cmp	r0, #0
 800caf8:	f73f aead 	bgt.w	800c856 <_dtoa_r+0xa1e>
 800cafc:	e722      	b.n	800c944 <_dtoa_r+0xb0c>
 800cafe:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 800cb02:	2602      	movs	r6, #2
 800cb04:	ed8d 7b00 	vstr	d7, [sp]
 800cb08:	f7ff bb02 	b.w	800c110 <_dtoa_r+0x2d8>
 800cb0c:	40140000 	.word	0x40140000
 800cb10:	0801dca0 	.word	0x0801dca0
 800cb14:	0801dc78 	.word	0x0801dc78
 800cb18:	401c0000 	.word	0x401c0000
 800cb1c:	40240000 	.word	0x40240000
 800cb20:	3fe00000 	.word	0x3fe00000
 800cb24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cb26:	2b00      	cmp	r3, #0
 800cb28:	f43f af1d 	beq.w	800c966 <_dtoa_r+0xb2e>
 800cb2c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 800cb2e:	2c00      	cmp	r4, #0
 800cb30:	f77f aba8 	ble.w	800c284 <_dtoa_r+0x44c>
 800cb34:	2200      	movs	r2, #0
 800cb36:	4b45      	ldr	r3, [pc, #276]	; (800cc4c <_dtoa_r+0xe14>)
 800cb38:	e9dd 0100 	ldrd	r0, r1, [sp]
 800cb3c:	f7f3 fd9e 	bl	800067c <__aeabi_dmul>
 800cb40:	e9cd 0100 	strd	r0, r1, [sp]
 800cb44:	1c70      	adds	r0, r6, #1
 800cb46:	f7f3 fd2f 	bl	80005a8 <__aeabi_i2d>
 800cb4a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800cb4e:	f7f3 fd95 	bl	800067c <__aeabi_dmul>
 800cb52:	4b3f      	ldr	r3, [pc, #252]	; (800cc50 <_dtoa_r+0xe18>)
 800cb54:	2200      	movs	r2, #0
 800cb56:	f7f3 fbdb 	bl	8000310 <__adddf3>
 800cb5a:	9b06      	ldr	r3, [sp, #24]
 800cb5c:	9412      	str	r4, [sp, #72]	; 0x48
 800cb5e:	3b01      	subs	r3, #1
 800cb60:	4606      	mov	r6, r0
 800cb62:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800cb66:	9316      	str	r3, [sp, #88]	; 0x58
 800cb68:	f7ff baf3 	b.w	800c152 <_dtoa_r+0x31a>
 800cb6c:	4651      	mov	r1, sl
 800cb6e:	2201      	movs	r2, #1
 800cb70:	4648      	mov	r0, r9
 800cb72:	f000 fe33 	bl	800d7dc <__lshift>
 800cb76:	4631      	mov	r1, r6
 800cb78:	4682      	mov	sl, r0
 800cb7a:	f000 fe85 	bl	800d888 <__mcmp>
 800cb7e:	2800      	cmp	r0, #0
 800cb80:	dd3b      	ble.n	800cbfa <_dtoa_r+0xdc2>
 800cb82:	9b00      	ldr	r3, [sp, #0]
 800cb84:	2b39      	cmp	r3, #57	; 0x39
 800cb86:	d003      	beq.n	800cb90 <_dtoa_r+0xd58>
 800cb88:	9b02      	ldr	r3, [sp, #8]
 800cb8a:	3331      	adds	r3, #49	; 0x31
 800cb8c:	9300      	str	r3, [sp, #0]
 800cb8e:	e733      	b.n	800c9f8 <_dtoa_r+0xbc0>
 800cb90:	2239      	movs	r2, #57	; 0x39
 800cb92:	9502      	str	r5, [sp, #8]
 800cb94:	703a      	strb	r2, [r7, #0]
 800cb96:	4645      	mov	r5, r8
 800cb98:	e58e      	b.n	800c6b8 <_dtoa_r+0x880>
 800cb9a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800cb9e:	2000      	movs	r0, #0
 800cba0:	492c      	ldr	r1, [pc, #176]	; (800cc54 <_dtoa_r+0xe1c>)
 800cba2:	f7f3 fbb3 	bl	800030c <__aeabi_dsub>
 800cba6:	4632      	mov	r2, r6
 800cba8:	463b      	mov	r3, r7
 800cbaa:	f7f3 fff7 	bl	8000b9c <__aeabi_dcmpgt>
 800cbae:	b910      	cbnz	r0, 800cbb6 <_dtoa_r+0xd7e>
 800cbb0:	f7ff bb68 	b.w	800c284 <_dtoa_r+0x44c>
 800cbb4:	4614      	mov	r4, r2
 800cbb6:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 800cbba:	2b30      	cmp	r3, #48	; 0x30
 800cbbc:	f104 32ff 	add.w	r2, r4, #4294967295	; 0xffffffff
 800cbc0:	d0f8      	beq.n	800cbb4 <_dtoa_r+0xd7c>
 800cbc2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800cbc4:	9306      	str	r3, [sp, #24]
 800cbc6:	e58d      	b.n	800c6e4 <_dtoa_r+0x8ac>
 800cbc8:	46d9      	mov	r9, fp
 800cbca:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 800cbce:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 800cbd2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800cbd4:	9306      	str	r3, [sp, #24]
 800cbd6:	e404      	b.n	800c3e2 <_dtoa_r+0x5aa>
 800cbd8:	9b00      	ldr	r3, [sp, #0]
 800cbda:	2b39      	cmp	r3, #57	; 0x39
 800cbdc:	4621      	mov	r1, r4
 800cbde:	4632      	mov	r2, r6
 800cbe0:	f107 0401 	add.w	r4, r7, #1
 800cbe4:	465e      	mov	r6, fp
 800cbe6:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800cbea:	d0d1      	beq.n	800cb90 <_dtoa_r+0xd58>
 800cbec:	2a00      	cmp	r2, #0
 800cbee:	f77f af03 	ble.w	800c9f8 <_dtoa_r+0xbc0>
 800cbf2:	460b      	mov	r3, r1
 800cbf4:	3331      	adds	r3, #49	; 0x31
 800cbf6:	9300      	str	r3, [sp, #0]
 800cbf8:	e6fe      	b.n	800c9f8 <_dtoa_r+0xbc0>
 800cbfa:	f47f aefd 	bne.w	800c9f8 <_dtoa_r+0xbc0>
 800cbfe:	9b00      	ldr	r3, [sp, #0]
 800cc00:	07da      	lsls	r2, r3, #31
 800cc02:	f57f aef9 	bpl.w	800c9f8 <_dtoa_r+0xbc0>
 800cc06:	e7bc      	b.n	800cb82 <_dtoa_r+0xd4a>
 800cc08:	4629      	mov	r1, r5
 800cc0a:	2300      	movs	r3, #0
 800cc0c:	220a      	movs	r2, #10
 800cc0e:	4648      	mov	r0, r9
 800cc10:	f000 fc54 	bl	800d4bc <__multadd>
 800cc14:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cc16:	2b00      	cmp	r3, #0
 800cc18:	4605      	mov	r5, r0
 800cc1a:	dd09      	ble.n	800cc30 <_dtoa_r+0xdf8>
 800cc1c:	9309      	str	r3, [sp, #36]	; 0x24
 800cc1e:	e484      	b.n	800c52a <_dtoa_r+0x6f2>
 800cc20:	9b02      	ldr	r3, [sp, #8]
 800cc22:	2b02      	cmp	r3, #2
 800cc24:	dc0e      	bgt.n	800cc44 <_dtoa_r+0xe0c>
 800cc26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cc28:	e507      	b.n	800c63a <_dtoa_r+0x802>
 800cc2a:	2602      	movs	r6, #2
 800cc2c:	f7ff ba70 	b.w	800c110 <_dtoa_r+0x2d8>
 800cc30:	9b02      	ldr	r3, [sp, #8]
 800cc32:	2b02      	cmp	r3, #2
 800cc34:	dc06      	bgt.n	800cc44 <_dtoa_r+0xe0c>
 800cc36:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cc38:	e7f0      	b.n	800cc1c <_dtoa_r+0xde4>
 800cc3a:	f43f ac59 	beq.w	800c4f0 <_dtoa_r+0x6b8>
 800cc3e:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 800cc42:	e450      	b.n	800c4e6 <_dtoa_r+0x6ae>
 800cc44:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cc46:	9309      	str	r3, [sp, #36]	; 0x24
 800cc48:	e678      	b.n	800c93c <_dtoa_r+0xb04>
 800cc4a:	bf00      	nop
 800cc4c:	40240000 	.word	0x40240000
 800cc50:	401c0000 	.word	0x401c0000
 800cc54:	3fe00000 	.word	0x3fe00000

0800cc58 <_malloc_trim_r>:
 800cc58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cc5a:	4f24      	ldr	r7, [pc, #144]	; (800ccec <_malloc_trim_r+0x94>)
 800cc5c:	460c      	mov	r4, r1
 800cc5e:	4606      	mov	r6, r0
 800cc60:	f000 fbf0 	bl	800d444 <__malloc_lock>
 800cc64:	68bb      	ldr	r3, [r7, #8]
 800cc66:	685d      	ldr	r5, [r3, #4]
 800cc68:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
 800cc6c:	310f      	adds	r1, #15
 800cc6e:	f025 0503 	bic.w	r5, r5, #3
 800cc72:	4429      	add	r1, r5
 800cc74:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 800cc78:	f021 010f 	bic.w	r1, r1, #15
 800cc7c:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 800cc80:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800cc84:	db07      	blt.n	800cc96 <_malloc_trim_r+0x3e>
 800cc86:	2100      	movs	r1, #0
 800cc88:	4630      	mov	r0, r6
 800cc8a:	f7f8 feb9 	bl	8005a00 <_sbrk_r>
 800cc8e:	68bb      	ldr	r3, [r7, #8]
 800cc90:	442b      	add	r3, r5
 800cc92:	4298      	cmp	r0, r3
 800cc94:	d004      	beq.n	800cca0 <_malloc_trim_r+0x48>
 800cc96:	4630      	mov	r0, r6
 800cc98:	f000 fbda 	bl	800d450 <__malloc_unlock>
 800cc9c:	2000      	movs	r0, #0
 800cc9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cca0:	4261      	negs	r1, r4
 800cca2:	4630      	mov	r0, r6
 800cca4:	f7f8 feac 	bl	8005a00 <_sbrk_r>
 800cca8:	3001      	adds	r0, #1
 800ccaa:	d00d      	beq.n	800ccc8 <_malloc_trim_r+0x70>
 800ccac:	4b10      	ldr	r3, [pc, #64]	; (800ccf0 <_malloc_trim_r+0x98>)
 800ccae:	68ba      	ldr	r2, [r7, #8]
 800ccb0:	6819      	ldr	r1, [r3, #0]
 800ccb2:	1b2d      	subs	r5, r5, r4
 800ccb4:	f045 0501 	orr.w	r5, r5, #1
 800ccb8:	4630      	mov	r0, r6
 800ccba:	1b09      	subs	r1, r1, r4
 800ccbc:	6055      	str	r5, [r2, #4]
 800ccbe:	6019      	str	r1, [r3, #0]
 800ccc0:	f000 fbc6 	bl	800d450 <__malloc_unlock>
 800ccc4:	2001      	movs	r0, #1
 800ccc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ccc8:	2100      	movs	r1, #0
 800ccca:	4630      	mov	r0, r6
 800cccc:	f7f8 fe98 	bl	8005a00 <_sbrk_r>
 800ccd0:	68ba      	ldr	r2, [r7, #8]
 800ccd2:	1a83      	subs	r3, r0, r2
 800ccd4:	2b0f      	cmp	r3, #15
 800ccd6:	ddde      	ble.n	800cc96 <_malloc_trim_r+0x3e>
 800ccd8:	4c06      	ldr	r4, [pc, #24]	; (800ccf4 <_malloc_trim_r+0x9c>)
 800ccda:	4905      	ldr	r1, [pc, #20]	; (800ccf0 <_malloc_trim_r+0x98>)
 800ccdc:	6824      	ldr	r4, [r4, #0]
 800ccde:	f043 0301 	orr.w	r3, r3, #1
 800cce2:	1b00      	subs	r0, r0, r4
 800cce4:	6053      	str	r3, [r2, #4]
 800cce6:	6008      	str	r0, [r1, #0]
 800cce8:	e7d5      	b.n	800cc96 <_malloc_trim_r+0x3e>
 800ccea:	bf00      	nop
 800ccec:	20000c60 	.word	0x20000c60
 800ccf0:	20005d4c 	.word	0x20005d4c
 800ccf4:	20001068 	.word	0x20001068

0800ccf8 <_free_r>:
 800ccf8:	2900      	cmp	r1, #0
 800ccfa:	d053      	beq.n	800cda4 <_free_r+0xac>
 800ccfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ccfe:	460c      	mov	r4, r1
 800cd00:	4606      	mov	r6, r0
 800cd02:	f000 fb9f 	bl	800d444 <__malloc_lock>
 800cd06:	f854 cc04 	ldr.w	ip, [r4, #-4]
 800cd0a:	4f71      	ldr	r7, [pc, #452]	; (800ced0 <_free_r+0x1d8>)
 800cd0c:	f02c 0101 	bic.w	r1, ip, #1
 800cd10:	f1a4 0508 	sub.w	r5, r4, #8
 800cd14:	186b      	adds	r3, r5, r1
 800cd16:	68b8      	ldr	r0, [r7, #8]
 800cd18:	685a      	ldr	r2, [r3, #4]
 800cd1a:	4298      	cmp	r0, r3
 800cd1c:	f022 0203 	bic.w	r2, r2, #3
 800cd20:	d053      	beq.n	800cdca <_free_r+0xd2>
 800cd22:	f01c 0f01 	tst.w	ip, #1
 800cd26:	605a      	str	r2, [r3, #4]
 800cd28:	eb03 0002 	add.w	r0, r3, r2
 800cd2c:	d13b      	bne.n	800cda6 <_free_r+0xae>
 800cd2e:	f854 cc08 	ldr.w	ip, [r4, #-8]
 800cd32:	6840      	ldr	r0, [r0, #4]
 800cd34:	eba5 050c 	sub.w	r5, r5, ip
 800cd38:	f107 0e08 	add.w	lr, r7, #8
 800cd3c:	68ac      	ldr	r4, [r5, #8]
 800cd3e:	4574      	cmp	r4, lr
 800cd40:	4461      	add	r1, ip
 800cd42:	f000 0001 	and.w	r0, r0, #1
 800cd46:	d075      	beq.n	800ce34 <_free_r+0x13c>
 800cd48:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 800cd4c:	f8c4 c00c 	str.w	ip, [r4, #12]
 800cd50:	f8cc 4008 	str.w	r4, [ip, #8]
 800cd54:	b360      	cbz	r0, 800cdb0 <_free_r+0xb8>
 800cd56:	f041 0301 	orr.w	r3, r1, #1
 800cd5a:	606b      	str	r3, [r5, #4]
 800cd5c:	5069      	str	r1, [r5, r1]
 800cd5e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800cd62:	d350      	bcc.n	800ce06 <_free_r+0x10e>
 800cd64:	0a4b      	lsrs	r3, r1, #9
 800cd66:	2b04      	cmp	r3, #4
 800cd68:	d870      	bhi.n	800ce4c <_free_r+0x154>
 800cd6a:	098b      	lsrs	r3, r1, #6
 800cd6c:	f103 0439 	add.w	r4, r3, #57	; 0x39
 800cd70:	00e4      	lsls	r4, r4, #3
 800cd72:	f103 0238 	add.w	r2, r3, #56	; 0x38
 800cd76:	1938      	adds	r0, r7, r4
 800cd78:	593b      	ldr	r3, [r7, r4]
 800cd7a:	3808      	subs	r0, #8
 800cd7c:	4298      	cmp	r0, r3
 800cd7e:	d078      	beq.n	800ce72 <_free_r+0x17a>
 800cd80:	685a      	ldr	r2, [r3, #4]
 800cd82:	f022 0203 	bic.w	r2, r2, #3
 800cd86:	428a      	cmp	r2, r1
 800cd88:	d971      	bls.n	800ce6e <_free_r+0x176>
 800cd8a:	689b      	ldr	r3, [r3, #8]
 800cd8c:	4298      	cmp	r0, r3
 800cd8e:	d1f7      	bne.n	800cd80 <_free_r+0x88>
 800cd90:	68c3      	ldr	r3, [r0, #12]
 800cd92:	e9c5 0302 	strd	r0, r3, [r5, #8]
 800cd96:	609d      	str	r5, [r3, #8]
 800cd98:	60c5      	str	r5, [r0, #12]
 800cd9a:	4630      	mov	r0, r6
 800cd9c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800cda0:	f000 bb56 	b.w	800d450 <__malloc_unlock>
 800cda4:	4770      	bx	lr
 800cda6:	6840      	ldr	r0, [r0, #4]
 800cda8:	f000 0001 	and.w	r0, r0, #1
 800cdac:	2800      	cmp	r0, #0
 800cdae:	d1d2      	bne.n	800cd56 <_free_r+0x5e>
 800cdb0:	6898      	ldr	r0, [r3, #8]
 800cdb2:	4c48      	ldr	r4, [pc, #288]	; (800ced4 <_free_r+0x1dc>)
 800cdb4:	4411      	add	r1, r2
 800cdb6:	42a0      	cmp	r0, r4
 800cdb8:	f041 0201 	orr.w	r2, r1, #1
 800cdbc:	d062      	beq.n	800ce84 <_free_r+0x18c>
 800cdbe:	68db      	ldr	r3, [r3, #12]
 800cdc0:	60c3      	str	r3, [r0, #12]
 800cdc2:	6098      	str	r0, [r3, #8]
 800cdc4:	606a      	str	r2, [r5, #4]
 800cdc6:	5069      	str	r1, [r5, r1]
 800cdc8:	e7c9      	b.n	800cd5e <_free_r+0x66>
 800cdca:	f01c 0f01 	tst.w	ip, #1
 800cdce:	440a      	add	r2, r1
 800cdd0:	d107      	bne.n	800cde2 <_free_r+0xea>
 800cdd2:	f854 3c08 	ldr.w	r3, [r4, #-8]
 800cdd6:	1aed      	subs	r5, r5, r3
 800cdd8:	441a      	add	r2, r3
 800cdda:	e9d5 1302 	ldrd	r1, r3, [r5, #8]
 800cdde:	60cb      	str	r3, [r1, #12]
 800cde0:	6099      	str	r1, [r3, #8]
 800cde2:	4b3d      	ldr	r3, [pc, #244]	; (800ced8 <_free_r+0x1e0>)
 800cde4:	681b      	ldr	r3, [r3, #0]
 800cde6:	f042 0101 	orr.w	r1, r2, #1
 800cdea:	4293      	cmp	r3, r2
 800cdec:	6069      	str	r1, [r5, #4]
 800cdee:	60bd      	str	r5, [r7, #8]
 800cdf0:	d804      	bhi.n	800cdfc <_free_r+0x104>
 800cdf2:	4b3a      	ldr	r3, [pc, #232]	; (800cedc <_free_r+0x1e4>)
 800cdf4:	4630      	mov	r0, r6
 800cdf6:	6819      	ldr	r1, [r3, #0]
 800cdf8:	f7ff ff2e 	bl	800cc58 <_malloc_trim_r>
 800cdfc:	4630      	mov	r0, r6
 800cdfe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800ce02:	f000 bb25 	b.w	800d450 <__malloc_unlock>
 800ce06:	08c9      	lsrs	r1, r1, #3
 800ce08:	6878      	ldr	r0, [r7, #4]
 800ce0a:	1c4a      	adds	r2, r1, #1
 800ce0c:	2301      	movs	r3, #1
 800ce0e:	1089      	asrs	r1, r1, #2
 800ce10:	408b      	lsls	r3, r1
 800ce12:	4303      	orrs	r3, r0
 800ce14:	eb07 01c2 	add.w	r1, r7, r2, lsl #3
 800ce18:	f857 0032 	ldr.w	r0, [r7, r2, lsl #3]
 800ce1c:	607b      	str	r3, [r7, #4]
 800ce1e:	3908      	subs	r1, #8
 800ce20:	e9c5 0102 	strd	r0, r1, [r5, #8]
 800ce24:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
 800ce28:	60c5      	str	r5, [r0, #12]
 800ce2a:	4630      	mov	r0, r6
 800ce2c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800ce30:	f000 bb0e 	b.w	800d450 <__malloc_unlock>
 800ce34:	2800      	cmp	r0, #0
 800ce36:	d145      	bne.n	800cec4 <_free_r+0x1cc>
 800ce38:	440a      	add	r2, r1
 800ce3a:	e9d3 1302 	ldrd	r1, r3, [r3, #8]
 800ce3e:	f042 0001 	orr.w	r0, r2, #1
 800ce42:	60cb      	str	r3, [r1, #12]
 800ce44:	6099      	str	r1, [r3, #8]
 800ce46:	6068      	str	r0, [r5, #4]
 800ce48:	50aa      	str	r2, [r5, r2]
 800ce4a:	e7d7      	b.n	800cdfc <_free_r+0x104>
 800ce4c:	2b14      	cmp	r3, #20
 800ce4e:	d908      	bls.n	800ce62 <_free_r+0x16a>
 800ce50:	2b54      	cmp	r3, #84	; 0x54
 800ce52:	d81e      	bhi.n	800ce92 <_free_r+0x19a>
 800ce54:	0b0b      	lsrs	r3, r1, #12
 800ce56:	f103 046f 	add.w	r4, r3, #111	; 0x6f
 800ce5a:	00e4      	lsls	r4, r4, #3
 800ce5c:	f103 026e 	add.w	r2, r3, #110	; 0x6e
 800ce60:	e789      	b.n	800cd76 <_free_r+0x7e>
 800ce62:	f103 045c 	add.w	r4, r3, #92	; 0x5c
 800ce66:	00e4      	lsls	r4, r4, #3
 800ce68:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 800ce6c:	e783      	b.n	800cd76 <_free_r+0x7e>
 800ce6e:	4618      	mov	r0, r3
 800ce70:	e78e      	b.n	800cd90 <_free_r+0x98>
 800ce72:	1093      	asrs	r3, r2, #2
 800ce74:	6879      	ldr	r1, [r7, #4]
 800ce76:	2201      	movs	r2, #1
 800ce78:	fa02 f303 	lsl.w	r3, r2, r3
 800ce7c:	430b      	orrs	r3, r1
 800ce7e:	607b      	str	r3, [r7, #4]
 800ce80:	4603      	mov	r3, r0
 800ce82:	e786      	b.n	800cd92 <_free_r+0x9a>
 800ce84:	e9c7 5504 	strd	r5, r5, [r7, #16]
 800ce88:	e9c5 0002 	strd	r0, r0, [r5, #8]
 800ce8c:	606a      	str	r2, [r5, #4]
 800ce8e:	5069      	str	r1, [r5, r1]
 800ce90:	e7b4      	b.n	800cdfc <_free_r+0x104>
 800ce92:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800ce96:	d806      	bhi.n	800cea6 <_free_r+0x1ae>
 800ce98:	0bcb      	lsrs	r3, r1, #15
 800ce9a:	f103 0478 	add.w	r4, r3, #120	; 0x78
 800ce9e:	00e4      	lsls	r4, r4, #3
 800cea0:	f103 0277 	add.w	r2, r3, #119	; 0x77
 800cea4:	e767      	b.n	800cd76 <_free_r+0x7e>
 800cea6:	f240 5254 	movw	r2, #1364	; 0x554
 800ceaa:	4293      	cmp	r3, r2
 800ceac:	d806      	bhi.n	800cebc <_free_r+0x1c4>
 800ceae:	0c8b      	lsrs	r3, r1, #18
 800ceb0:	f103 047d 	add.w	r4, r3, #125	; 0x7d
 800ceb4:	00e4      	lsls	r4, r4, #3
 800ceb6:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 800ceba:	e75c      	b.n	800cd76 <_free_r+0x7e>
 800cebc:	f44f 747e 	mov.w	r4, #1016	; 0x3f8
 800cec0:	227e      	movs	r2, #126	; 0x7e
 800cec2:	e758      	b.n	800cd76 <_free_r+0x7e>
 800cec4:	f041 0201 	orr.w	r2, r1, #1
 800cec8:	606a      	str	r2, [r5, #4]
 800ceca:	6019      	str	r1, [r3, #0]
 800cecc:	e796      	b.n	800cdfc <_free_r+0x104>
 800cece:	bf00      	nop
 800ced0:	20000c60 	.word	0x20000c60
 800ced4:	20000c68 	.word	0x20000c68
 800ced8:	2000106c 	.word	0x2000106c
 800cedc:	20005d7c 	.word	0x20005d7c

0800cee0 <_localeconv_r>:
 800cee0:	4a04      	ldr	r2, [pc, #16]	; (800cef4 <_localeconv_r+0x14>)
 800cee2:	4b05      	ldr	r3, [pc, #20]	; (800cef8 <_localeconv_r+0x18>)
 800cee4:	6812      	ldr	r2, [r2, #0]
 800cee6:	6b50      	ldr	r0, [r2, #52]	; 0x34
 800cee8:	2800      	cmp	r0, #0
 800ceea:	bf08      	it	eq
 800ceec:	4618      	moveq	r0, r3
 800ceee:	30f0      	adds	r0, #240	; 0xf0
 800cef0:	4770      	bx	lr
 800cef2:	bf00      	nop
 800cef4:	20000834 	.word	0x20000834
 800cef8:	20001070 	.word	0x20001070

0800cefc <_malloc_r>:
 800cefc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cf00:	f101 050b 	add.w	r5, r1, #11
 800cf04:	2d16      	cmp	r5, #22
 800cf06:	b083      	sub	sp, #12
 800cf08:	4606      	mov	r6, r0
 800cf0a:	d823      	bhi.n	800cf54 <_malloc_r+0x58>
 800cf0c:	2910      	cmp	r1, #16
 800cf0e:	f200 80b9 	bhi.w	800d084 <_malloc_r+0x188>
 800cf12:	f000 fa97 	bl	800d444 <__malloc_lock>
 800cf16:	2510      	movs	r5, #16
 800cf18:	2318      	movs	r3, #24
 800cf1a:	2002      	movs	r0, #2
 800cf1c:	4fc5      	ldr	r7, [pc, #788]	; (800d234 <_malloc_r+0x338>)
 800cf1e:	443b      	add	r3, r7
 800cf20:	f1a3 0208 	sub.w	r2, r3, #8
 800cf24:	685c      	ldr	r4, [r3, #4]
 800cf26:	4294      	cmp	r4, r2
 800cf28:	f000 8166 	beq.w	800d1f8 <_malloc_r+0x2fc>
 800cf2c:	6863      	ldr	r3, [r4, #4]
 800cf2e:	f023 0303 	bic.w	r3, r3, #3
 800cf32:	4423      	add	r3, r4
 800cf34:	e9d4 5102 	ldrd	r5, r1, [r4, #8]
 800cf38:	685a      	ldr	r2, [r3, #4]
 800cf3a:	60e9      	str	r1, [r5, #12]
 800cf3c:	f042 0201 	orr.w	r2, r2, #1
 800cf40:	608d      	str	r5, [r1, #8]
 800cf42:	4630      	mov	r0, r6
 800cf44:	605a      	str	r2, [r3, #4]
 800cf46:	f000 fa83 	bl	800d450 <__malloc_unlock>
 800cf4a:	3408      	adds	r4, #8
 800cf4c:	4620      	mov	r0, r4
 800cf4e:	b003      	add	sp, #12
 800cf50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cf54:	f035 0507 	bics.w	r5, r5, #7
 800cf58:	f100 8094 	bmi.w	800d084 <_malloc_r+0x188>
 800cf5c:	42a9      	cmp	r1, r5
 800cf5e:	f200 8091 	bhi.w	800d084 <_malloc_r+0x188>
 800cf62:	f000 fa6f 	bl	800d444 <__malloc_lock>
 800cf66:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 800cf6a:	f0c0 8183 	bcc.w	800d274 <_malloc_r+0x378>
 800cf6e:	0a6b      	lsrs	r3, r5, #9
 800cf70:	f000 808f 	beq.w	800d092 <_malloc_r+0x196>
 800cf74:	2b04      	cmp	r3, #4
 800cf76:	f200 8146 	bhi.w	800d206 <_malloc_r+0x30a>
 800cf7a:	09ab      	lsrs	r3, r5, #6
 800cf7c:	f103 0039 	add.w	r0, r3, #57	; 0x39
 800cf80:	f103 0c38 	add.w	ip, r3, #56	; 0x38
 800cf84:	00c3      	lsls	r3, r0, #3
 800cf86:	4fab      	ldr	r7, [pc, #684]	; (800d234 <_malloc_r+0x338>)
 800cf88:	443b      	add	r3, r7
 800cf8a:	f1a3 0108 	sub.w	r1, r3, #8
 800cf8e:	685c      	ldr	r4, [r3, #4]
 800cf90:	42a1      	cmp	r1, r4
 800cf92:	d106      	bne.n	800cfa2 <_malloc_r+0xa6>
 800cf94:	e00c      	b.n	800cfb0 <_malloc_r+0xb4>
 800cf96:	2a00      	cmp	r2, #0
 800cf98:	f280 811d 	bge.w	800d1d6 <_malloc_r+0x2da>
 800cf9c:	68e4      	ldr	r4, [r4, #12]
 800cf9e:	42a1      	cmp	r1, r4
 800cfa0:	d006      	beq.n	800cfb0 <_malloc_r+0xb4>
 800cfa2:	6863      	ldr	r3, [r4, #4]
 800cfa4:	f023 0303 	bic.w	r3, r3, #3
 800cfa8:	1b5a      	subs	r2, r3, r5
 800cfaa:	2a0f      	cmp	r2, #15
 800cfac:	ddf3      	ble.n	800cf96 <_malloc_r+0x9a>
 800cfae:	4660      	mov	r0, ip
 800cfb0:	693c      	ldr	r4, [r7, #16]
 800cfb2:	f8df c294 	ldr.w	ip, [pc, #660]	; 800d248 <_malloc_r+0x34c>
 800cfb6:	4564      	cmp	r4, ip
 800cfb8:	d071      	beq.n	800d09e <_malloc_r+0x1a2>
 800cfba:	6863      	ldr	r3, [r4, #4]
 800cfbc:	f023 0303 	bic.w	r3, r3, #3
 800cfc0:	1b5a      	subs	r2, r3, r5
 800cfc2:	2a0f      	cmp	r2, #15
 800cfc4:	f300 8144 	bgt.w	800d250 <_malloc_r+0x354>
 800cfc8:	2a00      	cmp	r2, #0
 800cfca:	e9c7 cc04 	strd	ip, ip, [r7, #16]
 800cfce:	f280 8126 	bge.w	800d21e <_malloc_r+0x322>
 800cfd2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cfd6:	f080 8169 	bcs.w	800d2ac <_malloc_r+0x3b0>
 800cfda:	08db      	lsrs	r3, r3, #3
 800cfdc:	1c59      	adds	r1, r3, #1
 800cfde:	687a      	ldr	r2, [r7, #4]
 800cfe0:	f857 8031 	ldr.w	r8, [r7, r1, lsl #3]
 800cfe4:	f8c4 8008 	str.w	r8, [r4, #8]
 800cfe8:	f04f 0e01 	mov.w	lr, #1
 800cfec:	109b      	asrs	r3, r3, #2
 800cfee:	fa0e f303 	lsl.w	r3, lr, r3
 800cff2:	eb07 0ec1 	add.w	lr, r7, r1, lsl #3
 800cff6:	4313      	orrs	r3, r2
 800cff8:	f1ae 0208 	sub.w	r2, lr, #8
 800cffc:	60e2      	str	r2, [r4, #12]
 800cffe:	607b      	str	r3, [r7, #4]
 800d000:	f847 4031 	str.w	r4, [r7, r1, lsl #3]
 800d004:	f8c8 400c 	str.w	r4, [r8, #12]
 800d008:	1082      	asrs	r2, r0, #2
 800d00a:	2401      	movs	r4, #1
 800d00c:	4094      	lsls	r4, r2
 800d00e:	429c      	cmp	r4, r3
 800d010:	d84b      	bhi.n	800d0aa <_malloc_r+0x1ae>
 800d012:	421c      	tst	r4, r3
 800d014:	d106      	bne.n	800d024 <_malloc_r+0x128>
 800d016:	f020 0003 	bic.w	r0, r0, #3
 800d01a:	0064      	lsls	r4, r4, #1
 800d01c:	421c      	tst	r4, r3
 800d01e:	f100 0004 	add.w	r0, r0, #4
 800d022:	d0fa      	beq.n	800d01a <_malloc_r+0x11e>
 800d024:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 800d028:	46ce      	mov	lr, r9
 800d02a:	4680      	mov	r8, r0
 800d02c:	f8de 300c 	ldr.w	r3, [lr, #12]
 800d030:	459e      	cmp	lr, r3
 800d032:	d107      	bne.n	800d044 <_malloc_r+0x148>
 800d034:	e122      	b.n	800d27c <_malloc_r+0x380>
 800d036:	2a00      	cmp	r2, #0
 800d038:	f280 8129 	bge.w	800d28e <_malloc_r+0x392>
 800d03c:	68db      	ldr	r3, [r3, #12]
 800d03e:	459e      	cmp	lr, r3
 800d040:	f000 811c 	beq.w	800d27c <_malloc_r+0x380>
 800d044:	6859      	ldr	r1, [r3, #4]
 800d046:	f021 0103 	bic.w	r1, r1, #3
 800d04a:	1b4a      	subs	r2, r1, r5
 800d04c:	2a0f      	cmp	r2, #15
 800d04e:	ddf2      	ble.n	800d036 <_malloc_r+0x13a>
 800d050:	e9d3 8e02 	ldrd	r8, lr, [r3, #8]
 800d054:	195c      	adds	r4, r3, r5
 800d056:	f045 0501 	orr.w	r5, r5, #1
 800d05a:	605d      	str	r5, [r3, #4]
 800d05c:	f042 0501 	orr.w	r5, r2, #1
 800d060:	f8c8 e00c 	str.w	lr, [r8, #12]
 800d064:	4630      	mov	r0, r6
 800d066:	f8ce 8008 	str.w	r8, [lr, #8]
 800d06a:	e9c7 4404 	strd	r4, r4, [r7, #16]
 800d06e:	e9c4 cc02 	strd	ip, ip, [r4, #8]
 800d072:	6065      	str	r5, [r4, #4]
 800d074:	505a      	str	r2, [r3, r1]
 800d076:	9301      	str	r3, [sp, #4]
 800d078:	f000 f9ea 	bl	800d450 <__malloc_unlock>
 800d07c:	9b01      	ldr	r3, [sp, #4]
 800d07e:	f103 0408 	add.w	r4, r3, #8
 800d082:	e763      	b.n	800cf4c <_malloc_r+0x50>
 800d084:	2400      	movs	r4, #0
 800d086:	230c      	movs	r3, #12
 800d088:	4620      	mov	r0, r4
 800d08a:	6033      	str	r3, [r6, #0]
 800d08c:	b003      	add	sp, #12
 800d08e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d092:	f44f 7300 	mov.w	r3, #512	; 0x200
 800d096:	2040      	movs	r0, #64	; 0x40
 800d098:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 800d09c:	e773      	b.n	800cf86 <_malloc_r+0x8a>
 800d09e:	687b      	ldr	r3, [r7, #4]
 800d0a0:	1082      	asrs	r2, r0, #2
 800d0a2:	2401      	movs	r4, #1
 800d0a4:	4094      	lsls	r4, r2
 800d0a6:	429c      	cmp	r4, r3
 800d0a8:	d9b3      	bls.n	800d012 <_malloc_r+0x116>
 800d0aa:	68bc      	ldr	r4, [r7, #8]
 800d0ac:	6863      	ldr	r3, [r4, #4]
 800d0ae:	f023 0903 	bic.w	r9, r3, #3
 800d0b2:	45a9      	cmp	r9, r5
 800d0b4:	d303      	bcc.n	800d0be <_malloc_r+0x1c2>
 800d0b6:	eba9 0305 	sub.w	r3, r9, r5
 800d0ba:	2b0f      	cmp	r3, #15
 800d0bc:	dc7b      	bgt.n	800d1b6 <_malloc_r+0x2ba>
 800d0be:	4b5e      	ldr	r3, [pc, #376]	; (800d238 <_malloc_r+0x33c>)
 800d0c0:	f8df a188 	ldr.w	sl, [pc, #392]	; 800d24c <_malloc_r+0x350>
 800d0c4:	681a      	ldr	r2, [r3, #0]
 800d0c6:	f8da 3000 	ldr.w	r3, [sl]
 800d0ca:	3301      	adds	r3, #1
 800d0cc:	eb05 0802 	add.w	r8, r5, r2
 800d0d0:	f000 8148 	beq.w	800d364 <_malloc_r+0x468>
 800d0d4:	f508 5880 	add.w	r8, r8, #4096	; 0x1000
 800d0d8:	f108 080f 	add.w	r8, r8, #15
 800d0dc:	f428 687f 	bic.w	r8, r8, #4080	; 0xff0
 800d0e0:	f028 080f 	bic.w	r8, r8, #15
 800d0e4:	4641      	mov	r1, r8
 800d0e6:	4630      	mov	r0, r6
 800d0e8:	f7f8 fc8a 	bl	8005a00 <_sbrk_r>
 800d0ec:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800d0f0:	4683      	mov	fp, r0
 800d0f2:	f000 8104 	beq.w	800d2fe <_malloc_r+0x402>
 800d0f6:	eb04 0009 	add.w	r0, r4, r9
 800d0fa:	4558      	cmp	r0, fp
 800d0fc:	f200 80fd 	bhi.w	800d2fa <_malloc_r+0x3fe>
 800d100:	4a4e      	ldr	r2, [pc, #312]	; (800d23c <_malloc_r+0x340>)
 800d102:	6813      	ldr	r3, [r2, #0]
 800d104:	4443      	add	r3, r8
 800d106:	6013      	str	r3, [r2, #0]
 800d108:	f000 814d 	beq.w	800d3a6 <_malloc_r+0x4aa>
 800d10c:	f8da 1000 	ldr.w	r1, [sl]
 800d110:	3101      	adds	r1, #1
 800d112:	bf1b      	ittet	ne
 800d114:	ebab 0000 	subne.w	r0, fp, r0
 800d118:	181b      	addne	r3, r3, r0
 800d11a:	f8ca b000 	streq.w	fp, [sl]
 800d11e:	6013      	strne	r3, [r2, #0]
 800d120:	f01b 0307 	ands.w	r3, fp, #7
 800d124:	f000 8134 	beq.w	800d390 <_malloc_r+0x494>
 800d128:	f1c3 0108 	rsb	r1, r3, #8
 800d12c:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 800d130:	448b      	add	fp, r1
 800d132:	3308      	adds	r3, #8
 800d134:	44d8      	add	r8, fp
 800d136:	f3c8 080b 	ubfx	r8, r8, #0, #12
 800d13a:	eba3 0808 	sub.w	r8, r3, r8
 800d13e:	4641      	mov	r1, r8
 800d140:	4630      	mov	r0, r6
 800d142:	9201      	str	r2, [sp, #4]
 800d144:	f7f8 fc5c 	bl	8005a00 <_sbrk_r>
 800d148:	1c43      	adds	r3, r0, #1
 800d14a:	9a01      	ldr	r2, [sp, #4]
 800d14c:	f000 8146 	beq.w	800d3dc <_malloc_r+0x4e0>
 800d150:	eba0 010b 	sub.w	r1, r0, fp
 800d154:	4441      	add	r1, r8
 800d156:	f041 0101 	orr.w	r1, r1, #1
 800d15a:	6813      	ldr	r3, [r2, #0]
 800d15c:	f8c7 b008 	str.w	fp, [r7, #8]
 800d160:	4443      	add	r3, r8
 800d162:	42bc      	cmp	r4, r7
 800d164:	f8cb 1004 	str.w	r1, [fp, #4]
 800d168:	6013      	str	r3, [r2, #0]
 800d16a:	d015      	beq.n	800d198 <_malloc_r+0x29c>
 800d16c:	f1b9 0f0f 	cmp.w	r9, #15
 800d170:	f240 8130 	bls.w	800d3d4 <_malloc_r+0x4d8>
 800d174:	6860      	ldr	r0, [r4, #4]
 800d176:	f1a9 010c 	sub.w	r1, r9, #12
 800d17a:	f021 0107 	bic.w	r1, r1, #7
 800d17e:	f000 0001 	and.w	r0, r0, #1
 800d182:	eb04 0c01 	add.w	ip, r4, r1
 800d186:	4308      	orrs	r0, r1
 800d188:	f04f 0e05 	mov.w	lr, #5
 800d18c:	290f      	cmp	r1, #15
 800d18e:	6060      	str	r0, [r4, #4]
 800d190:	e9cc ee01 	strd	lr, lr, [ip, #4]
 800d194:	f200 813a 	bhi.w	800d40c <_malloc_r+0x510>
 800d198:	4a29      	ldr	r2, [pc, #164]	; (800d240 <_malloc_r+0x344>)
 800d19a:	482a      	ldr	r0, [pc, #168]	; (800d244 <_malloc_r+0x348>)
 800d19c:	6811      	ldr	r1, [r2, #0]
 800d19e:	68bc      	ldr	r4, [r7, #8]
 800d1a0:	428b      	cmp	r3, r1
 800d1a2:	6801      	ldr	r1, [r0, #0]
 800d1a4:	bf88      	it	hi
 800d1a6:	6013      	strhi	r3, [r2, #0]
 800d1a8:	6862      	ldr	r2, [r4, #4]
 800d1aa:	428b      	cmp	r3, r1
 800d1ac:	f022 0203 	bic.w	r2, r2, #3
 800d1b0:	bf88      	it	hi
 800d1b2:	6003      	strhi	r3, [r0, #0]
 800d1b4:	e0a7      	b.n	800d306 <_malloc_r+0x40a>
 800d1b6:	1962      	adds	r2, r4, r5
 800d1b8:	f043 0301 	orr.w	r3, r3, #1
 800d1bc:	f045 0501 	orr.w	r5, r5, #1
 800d1c0:	6065      	str	r5, [r4, #4]
 800d1c2:	4630      	mov	r0, r6
 800d1c4:	60ba      	str	r2, [r7, #8]
 800d1c6:	6053      	str	r3, [r2, #4]
 800d1c8:	f000 f942 	bl	800d450 <__malloc_unlock>
 800d1cc:	3408      	adds	r4, #8
 800d1ce:	4620      	mov	r0, r4
 800d1d0:	b003      	add	sp, #12
 800d1d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d1d6:	4423      	add	r3, r4
 800d1d8:	68e1      	ldr	r1, [r4, #12]
 800d1da:	685a      	ldr	r2, [r3, #4]
 800d1dc:	68a5      	ldr	r5, [r4, #8]
 800d1de:	f042 0201 	orr.w	r2, r2, #1
 800d1e2:	60e9      	str	r1, [r5, #12]
 800d1e4:	4630      	mov	r0, r6
 800d1e6:	608d      	str	r5, [r1, #8]
 800d1e8:	605a      	str	r2, [r3, #4]
 800d1ea:	f000 f931 	bl	800d450 <__malloc_unlock>
 800d1ee:	3408      	adds	r4, #8
 800d1f0:	4620      	mov	r0, r4
 800d1f2:	b003      	add	sp, #12
 800d1f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d1f8:	68dc      	ldr	r4, [r3, #12]
 800d1fa:	42a3      	cmp	r3, r4
 800d1fc:	bf08      	it	eq
 800d1fe:	3002      	addeq	r0, #2
 800d200:	f43f aed6 	beq.w	800cfb0 <_malloc_r+0xb4>
 800d204:	e692      	b.n	800cf2c <_malloc_r+0x30>
 800d206:	2b14      	cmp	r3, #20
 800d208:	d971      	bls.n	800d2ee <_malloc_r+0x3f2>
 800d20a:	2b54      	cmp	r3, #84	; 0x54
 800d20c:	f200 80ad 	bhi.w	800d36a <_malloc_r+0x46e>
 800d210:	0b2b      	lsrs	r3, r5, #12
 800d212:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 800d216:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
 800d21a:	00c3      	lsls	r3, r0, #3
 800d21c:	e6b3      	b.n	800cf86 <_malloc_r+0x8a>
 800d21e:	4423      	add	r3, r4
 800d220:	4630      	mov	r0, r6
 800d222:	685a      	ldr	r2, [r3, #4]
 800d224:	f042 0201 	orr.w	r2, r2, #1
 800d228:	605a      	str	r2, [r3, #4]
 800d22a:	3408      	adds	r4, #8
 800d22c:	f000 f910 	bl	800d450 <__malloc_unlock>
 800d230:	e68c      	b.n	800cf4c <_malloc_r+0x50>
 800d232:	bf00      	nop
 800d234:	20000c60 	.word	0x20000c60
 800d238:	20005d7c 	.word	0x20005d7c
 800d23c:	20005d4c 	.word	0x20005d4c
 800d240:	20005d74 	.word	0x20005d74
 800d244:	20005d78 	.word	0x20005d78
 800d248:	20000c68 	.word	0x20000c68
 800d24c:	20001068 	.word	0x20001068
 800d250:	1961      	adds	r1, r4, r5
 800d252:	f045 0e01 	orr.w	lr, r5, #1
 800d256:	f042 0501 	orr.w	r5, r2, #1
 800d25a:	f8c4 e004 	str.w	lr, [r4, #4]
 800d25e:	4630      	mov	r0, r6
 800d260:	e9c7 1104 	strd	r1, r1, [r7, #16]
 800d264:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 800d268:	604d      	str	r5, [r1, #4]
 800d26a:	50e2      	str	r2, [r4, r3]
 800d26c:	f000 f8f0 	bl	800d450 <__malloc_unlock>
 800d270:	3408      	adds	r4, #8
 800d272:	e66b      	b.n	800cf4c <_malloc_r+0x50>
 800d274:	08e8      	lsrs	r0, r5, #3
 800d276:	f105 0308 	add.w	r3, r5, #8
 800d27a:	e64f      	b.n	800cf1c <_malloc_r+0x20>
 800d27c:	f108 0801 	add.w	r8, r8, #1
 800d280:	f018 0f03 	tst.w	r8, #3
 800d284:	f10e 0e08 	add.w	lr, lr, #8
 800d288:	f47f aed0 	bne.w	800d02c <_malloc_r+0x130>
 800d28c:	e052      	b.n	800d334 <_malloc_r+0x438>
 800d28e:	4419      	add	r1, r3
 800d290:	461c      	mov	r4, r3
 800d292:	684a      	ldr	r2, [r1, #4]
 800d294:	68db      	ldr	r3, [r3, #12]
 800d296:	f854 5f08 	ldr.w	r5, [r4, #8]!
 800d29a:	f042 0201 	orr.w	r2, r2, #1
 800d29e:	604a      	str	r2, [r1, #4]
 800d2a0:	4630      	mov	r0, r6
 800d2a2:	60eb      	str	r3, [r5, #12]
 800d2a4:	609d      	str	r5, [r3, #8]
 800d2a6:	f000 f8d3 	bl	800d450 <__malloc_unlock>
 800d2aa:	e64f      	b.n	800cf4c <_malloc_r+0x50>
 800d2ac:	0a5a      	lsrs	r2, r3, #9
 800d2ae:	2a04      	cmp	r2, #4
 800d2b0:	d935      	bls.n	800d31e <_malloc_r+0x422>
 800d2b2:	2a14      	cmp	r2, #20
 800d2b4:	d86f      	bhi.n	800d396 <_malloc_r+0x49a>
 800d2b6:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 800d2ba:	00c9      	lsls	r1, r1, #3
 800d2bc:	325b      	adds	r2, #91	; 0x5b
 800d2be:	eb07 0e01 	add.w	lr, r7, r1
 800d2c2:	5879      	ldr	r1, [r7, r1]
 800d2c4:	f1ae 0e08 	sub.w	lr, lr, #8
 800d2c8:	458e      	cmp	lr, r1
 800d2ca:	d058      	beq.n	800d37e <_malloc_r+0x482>
 800d2cc:	684a      	ldr	r2, [r1, #4]
 800d2ce:	f022 0203 	bic.w	r2, r2, #3
 800d2d2:	429a      	cmp	r2, r3
 800d2d4:	d902      	bls.n	800d2dc <_malloc_r+0x3e0>
 800d2d6:	6889      	ldr	r1, [r1, #8]
 800d2d8:	458e      	cmp	lr, r1
 800d2da:	d1f7      	bne.n	800d2cc <_malloc_r+0x3d0>
 800d2dc:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 800d2e0:	687b      	ldr	r3, [r7, #4]
 800d2e2:	e9c4 1e02 	strd	r1, lr, [r4, #8]
 800d2e6:	f8ce 4008 	str.w	r4, [lr, #8]
 800d2ea:	60cc      	str	r4, [r1, #12]
 800d2ec:	e68c      	b.n	800d008 <_malloc_r+0x10c>
 800d2ee:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 800d2f2:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
 800d2f6:	00c3      	lsls	r3, r0, #3
 800d2f8:	e645      	b.n	800cf86 <_malloc_r+0x8a>
 800d2fa:	42bc      	cmp	r4, r7
 800d2fc:	d072      	beq.n	800d3e4 <_malloc_r+0x4e8>
 800d2fe:	68bc      	ldr	r4, [r7, #8]
 800d300:	6862      	ldr	r2, [r4, #4]
 800d302:	f022 0203 	bic.w	r2, r2, #3
 800d306:	4295      	cmp	r5, r2
 800d308:	eba2 0305 	sub.w	r3, r2, r5
 800d30c:	d802      	bhi.n	800d314 <_malloc_r+0x418>
 800d30e:	2b0f      	cmp	r3, #15
 800d310:	f73f af51 	bgt.w	800d1b6 <_malloc_r+0x2ba>
 800d314:	4630      	mov	r0, r6
 800d316:	f000 f89b 	bl	800d450 <__malloc_unlock>
 800d31a:	2400      	movs	r4, #0
 800d31c:	e616      	b.n	800cf4c <_malloc_r+0x50>
 800d31e:	099a      	lsrs	r2, r3, #6
 800d320:	f102 0139 	add.w	r1, r2, #57	; 0x39
 800d324:	00c9      	lsls	r1, r1, #3
 800d326:	3238      	adds	r2, #56	; 0x38
 800d328:	e7c9      	b.n	800d2be <_malloc_r+0x3c2>
 800d32a:	f8d9 9000 	ldr.w	r9, [r9]
 800d32e:	4599      	cmp	r9, r3
 800d330:	f040 8083 	bne.w	800d43a <_malloc_r+0x53e>
 800d334:	f010 0f03 	tst.w	r0, #3
 800d338:	f1a9 0308 	sub.w	r3, r9, #8
 800d33c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 800d340:	d1f3      	bne.n	800d32a <_malloc_r+0x42e>
 800d342:	687b      	ldr	r3, [r7, #4]
 800d344:	ea23 0304 	bic.w	r3, r3, r4
 800d348:	607b      	str	r3, [r7, #4]
 800d34a:	0064      	lsls	r4, r4, #1
 800d34c:	429c      	cmp	r4, r3
 800d34e:	f63f aeac 	bhi.w	800d0aa <_malloc_r+0x1ae>
 800d352:	b91c      	cbnz	r4, 800d35c <_malloc_r+0x460>
 800d354:	e6a9      	b.n	800d0aa <_malloc_r+0x1ae>
 800d356:	0064      	lsls	r4, r4, #1
 800d358:	f108 0804 	add.w	r8, r8, #4
 800d35c:	421c      	tst	r4, r3
 800d35e:	d0fa      	beq.n	800d356 <_malloc_r+0x45a>
 800d360:	4640      	mov	r0, r8
 800d362:	e65f      	b.n	800d024 <_malloc_r+0x128>
 800d364:	f108 0810 	add.w	r8, r8, #16
 800d368:	e6bc      	b.n	800d0e4 <_malloc_r+0x1e8>
 800d36a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800d36e:	d826      	bhi.n	800d3be <_malloc_r+0x4c2>
 800d370:	0beb      	lsrs	r3, r5, #15
 800d372:	f103 0078 	add.w	r0, r3, #120	; 0x78
 800d376:	f103 0c77 	add.w	ip, r3, #119	; 0x77
 800d37a:	00c3      	lsls	r3, r0, #3
 800d37c:	e603      	b.n	800cf86 <_malloc_r+0x8a>
 800d37e:	687b      	ldr	r3, [r7, #4]
 800d380:	1092      	asrs	r2, r2, #2
 800d382:	f04f 0801 	mov.w	r8, #1
 800d386:	fa08 f202 	lsl.w	r2, r8, r2
 800d38a:	4313      	orrs	r3, r2
 800d38c:	607b      	str	r3, [r7, #4]
 800d38e:	e7a8      	b.n	800d2e2 <_malloc_r+0x3e6>
 800d390:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d394:	e6ce      	b.n	800d134 <_malloc_r+0x238>
 800d396:	2a54      	cmp	r2, #84	; 0x54
 800d398:	d829      	bhi.n	800d3ee <_malloc_r+0x4f2>
 800d39a:	0b1a      	lsrs	r2, r3, #12
 800d39c:	f102 016f 	add.w	r1, r2, #111	; 0x6f
 800d3a0:	00c9      	lsls	r1, r1, #3
 800d3a2:	326e      	adds	r2, #110	; 0x6e
 800d3a4:	e78b      	b.n	800d2be <_malloc_r+0x3c2>
 800d3a6:	f3c0 010b 	ubfx	r1, r0, #0, #12
 800d3aa:	2900      	cmp	r1, #0
 800d3ac:	f47f aeae 	bne.w	800d10c <_malloc_r+0x210>
 800d3b0:	eb09 0208 	add.w	r2, r9, r8
 800d3b4:	68b9      	ldr	r1, [r7, #8]
 800d3b6:	f042 0201 	orr.w	r2, r2, #1
 800d3ba:	604a      	str	r2, [r1, #4]
 800d3bc:	e6ec      	b.n	800d198 <_malloc_r+0x29c>
 800d3be:	f240 5254 	movw	r2, #1364	; 0x554
 800d3c2:	4293      	cmp	r3, r2
 800d3c4:	d81c      	bhi.n	800d400 <_malloc_r+0x504>
 800d3c6:	0cab      	lsrs	r3, r5, #18
 800d3c8:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 800d3cc:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
 800d3d0:	00c3      	lsls	r3, r0, #3
 800d3d2:	e5d8      	b.n	800cf86 <_malloc_r+0x8a>
 800d3d4:	2301      	movs	r3, #1
 800d3d6:	f8cb 3004 	str.w	r3, [fp, #4]
 800d3da:	e79b      	b.n	800d314 <_malloc_r+0x418>
 800d3dc:	2101      	movs	r1, #1
 800d3de:	f04f 0800 	mov.w	r8, #0
 800d3e2:	e6ba      	b.n	800d15a <_malloc_r+0x25e>
 800d3e4:	4a16      	ldr	r2, [pc, #88]	; (800d440 <_malloc_r+0x544>)
 800d3e6:	6813      	ldr	r3, [r2, #0]
 800d3e8:	4443      	add	r3, r8
 800d3ea:	6013      	str	r3, [r2, #0]
 800d3ec:	e68e      	b.n	800d10c <_malloc_r+0x210>
 800d3ee:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800d3f2:	d814      	bhi.n	800d41e <_malloc_r+0x522>
 800d3f4:	0bda      	lsrs	r2, r3, #15
 800d3f6:	f102 0178 	add.w	r1, r2, #120	; 0x78
 800d3fa:	00c9      	lsls	r1, r1, #3
 800d3fc:	3277      	adds	r2, #119	; 0x77
 800d3fe:	e75e      	b.n	800d2be <_malloc_r+0x3c2>
 800d400:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 800d404:	207f      	movs	r0, #127	; 0x7f
 800d406:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 800d40a:	e5bc      	b.n	800cf86 <_malloc_r+0x8a>
 800d40c:	f104 0108 	add.w	r1, r4, #8
 800d410:	4630      	mov	r0, r6
 800d412:	9201      	str	r2, [sp, #4]
 800d414:	f7ff fc70 	bl	800ccf8 <_free_r>
 800d418:	9a01      	ldr	r2, [sp, #4]
 800d41a:	6813      	ldr	r3, [r2, #0]
 800d41c:	e6bc      	b.n	800d198 <_malloc_r+0x29c>
 800d41e:	f240 5154 	movw	r1, #1364	; 0x554
 800d422:	428a      	cmp	r2, r1
 800d424:	d805      	bhi.n	800d432 <_malloc_r+0x536>
 800d426:	0c9a      	lsrs	r2, r3, #18
 800d428:	f102 017d 	add.w	r1, r2, #125	; 0x7d
 800d42c:	00c9      	lsls	r1, r1, #3
 800d42e:	327c      	adds	r2, #124	; 0x7c
 800d430:	e745      	b.n	800d2be <_malloc_r+0x3c2>
 800d432:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
 800d436:	227e      	movs	r2, #126	; 0x7e
 800d438:	e741      	b.n	800d2be <_malloc_r+0x3c2>
 800d43a:	687b      	ldr	r3, [r7, #4]
 800d43c:	e785      	b.n	800d34a <_malloc_r+0x44e>
 800d43e:	bf00      	nop
 800d440:	20005d4c 	.word	0x20005d4c

0800d444 <__malloc_lock>:
 800d444:	4801      	ldr	r0, [pc, #4]	; (800d44c <__malloc_lock+0x8>)
 800d446:	f000 bc27 	b.w	800dc98 <__retarget_lock_acquire_recursive>
 800d44a:	bf00      	nop
 800d44c:	20005d90 	.word	0x20005d90

0800d450 <__malloc_unlock>:
 800d450:	4801      	ldr	r0, [pc, #4]	; (800d458 <__malloc_unlock+0x8>)
 800d452:	f000 bc23 	b.w	800dc9c <__retarget_lock_release_recursive>
 800d456:	bf00      	nop
 800d458:	20005d90 	.word	0x20005d90

0800d45c <_Balloc>:
 800d45c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800d45e:	b570      	push	{r4, r5, r6, lr}
 800d460:	4605      	mov	r5, r0
 800d462:	460c      	mov	r4, r1
 800d464:	b14b      	cbz	r3, 800d47a <_Balloc+0x1e>
 800d466:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800d46a:	b180      	cbz	r0, 800d48e <_Balloc+0x32>
 800d46c:	6802      	ldr	r2, [r0, #0]
 800d46e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 800d472:	2300      	movs	r3, #0
 800d474:	e9c0 3303 	strd	r3, r3, [r0, #12]
 800d478:	bd70      	pop	{r4, r5, r6, pc}
 800d47a:	2221      	movs	r2, #33	; 0x21
 800d47c:	2104      	movs	r1, #4
 800d47e:	f000 fbd7 	bl	800dc30 <_calloc_r>
 800d482:	4603      	mov	r3, r0
 800d484:	64e8      	str	r0, [r5, #76]	; 0x4c
 800d486:	2800      	cmp	r0, #0
 800d488:	d1ed      	bne.n	800d466 <_Balloc+0xa>
 800d48a:	2000      	movs	r0, #0
 800d48c:	bd70      	pop	{r4, r5, r6, pc}
 800d48e:	2101      	movs	r1, #1
 800d490:	fa01 f604 	lsl.w	r6, r1, r4
 800d494:	1d72      	adds	r2, r6, #5
 800d496:	4628      	mov	r0, r5
 800d498:	0092      	lsls	r2, r2, #2
 800d49a:	f000 fbc9 	bl	800dc30 <_calloc_r>
 800d49e:	2800      	cmp	r0, #0
 800d4a0:	d0f3      	beq.n	800d48a <_Balloc+0x2e>
 800d4a2:	e9c0 4601 	strd	r4, r6, [r0, #4]
 800d4a6:	e7e4      	b.n	800d472 <_Balloc+0x16>

0800d4a8 <_Bfree>:
 800d4a8:	b131      	cbz	r1, 800d4b8 <_Bfree+0x10>
 800d4aa:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800d4ac:	684a      	ldr	r2, [r1, #4]
 800d4ae:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800d4b2:	6008      	str	r0, [r1, #0]
 800d4b4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800d4b8:	4770      	bx	lr
 800d4ba:	bf00      	nop

0800d4bc <__multadd>:
 800d4bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d4be:	690c      	ldr	r4, [r1, #16]
 800d4c0:	b083      	sub	sp, #12
 800d4c2:	460d      	mov	r5, r1
 800d4c4:	4606      	mov	r6, r0
 800d4c6:	f101 0c14 	add.w	ip, r1, #20
 800d4ca:	2700      	movs	r7, #0
 800d4cc:	f8dc 0000 	ldr.w	r0, [ip]
 800d4d0:	b281      	uxth	r1, r0
 800d4d2:	fb02 3301 	mla	r3, r2, r1, r3
 800d4d6:	0c01      	lsrs	r1, r0, #16
 800d4d8:	0c18      	lsrs	r0, r3, #16
 800d4da:	fb02 0101 	mla	r1, r2, r1, r0
 800d4de:	b29b      	uxth	r3, r3
 800d4e0:	3701      	adds	r7, #1
 800d4e2:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 800d4e6:	42bc      	cmp	r4, r7
 800d4e8:	f84c 3b04 	str.w	r3, [ip], #4
 800d4ec:	ea4f 4311 	mov.w	r3, r1, lsr #16
 800d4f0:	dcec      	bgt.n	800d4cc <__multadd+0x10>
 800d4f2:	b13b      	cbz	r3, 800d504 <__multadd+0x48>
 800d4f4:	68aa      	ldr	r2, [r5, #8]
 800d4f6:	42a2      	cmp	r2, r4
 800d4f8:	dd07      	ble.n	800d50a <__multadd+0x4e>
 800d4fa:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 800d4fe:	3401      	adds	r4, #1
 800d500:	6153      	str	r3, [r2, #20]
 800d502:	612c      	str	r4, [r5, #16]
 800d504:	4628      	mov	r0, r5
 800d506:	b003      	add	sp, #12
 800d508:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d50a:	6869      	ldr	r1, [r5, #4]
 800d50c:	9301      	str	r3, [sp, #4]
 800d50e:	3101      	adds	r1, #1
 800d510:	4630      	mov	r0, r6
 800d512:	f7ff ffa3 	bl	800d45c <_Balloc>
 800d516:	692a      	ldr	r2, [r5, #16]
 800d518:	3202      	adds	r2, #2
 800d51a:	f105 010c 	add.w	r1, r5, #12
 800d51e:	4607      	mov	r7, r0
 800d520:	0092      	lsls	r2, r2, #2
 800d522:	300c      	adds	r0, #12
 800d524:	f7f3 fbd2 	bl	8000ccc <memcpy>
 800d528:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 800d52a:	6869      	ldr	r1, [r5, #4]
 800d52c:	9b01      	ldr	r3, [sp, #4]
 800d52e:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 800d532:	6028      	str	r0, [r5, #0]
 800d534:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 800d538:	463d      	mov	r5, r7
 800d53a:	e7de      	b.n	800d4fa <__multadd+0x3e>

0800d53c <__hi0bits>:
 800d53c:	0c02      	lsrs	r2, r0, #16
 800d53e:	0412      	lsls	r2, r2, #16
 800d540:	4603      	mov	r3, r0
 800d542:	b9c2      	cbnz	r2, 800d576 <__hi0bits+0x3a>
 800d544:	0403      	lsls	r3, r0, #16
 800d546:	2010      	movs	r0, #16
 800d548:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 800d54c:	bf04      	itt	eq
 800d54e:	021b      	lsleq	r3, r3, #8
 800d550:	3008      	addeq	r0, #8
 800d552:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 800d556:	bf04      	itt	eq
 800d558:	011b      	lsleq	r3, r3, #4
 800d55a:	3004      	addeq	r0, #4
 800d55c:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 800d560:	bf04      	itt	eq
 800d562:	009b      	lsleq	r3, r3, #2
 800d564:	3002      	addeq	r0, #2
 800d566:	2b00      	cmp	r3, #0
 800d568:	db04      	blt.n	800d574 <__hi0bits+0x38>
 800d56a:	005b      	lsls	r3, r3, #1
 800d56c:	d501      	bpl.n	800d572 <__hi0bits+0x36>
 800d56e:	3001      	adds	r0, #1
 800d570:	4770      	bx	lr
 800d572:	2020      	movs	r0, #32
 800d574:	4770      	bx	lr
 800d576:	2000      	movs	r0, #0
 800d578:	e7e6      	b.n	800d548 <__hi0bits+0xc>
 800d57a:	bf00      	nop

0800d57c <__lo0bits>:
 800d57c:	6803      	ldr	r3, [r0, #0]
 800d57e:	f013 0207 	ands.w	r2, r3, #7
 800d582:	4601      	mov	r1, r0
 800d584:	d007      	beq.n	800d596 <__lo0bits+0x1a>
 800d586:	07da      	lsls	r2, r3, #31
 800d588:	d41f      	bmi.n	800d5ca <__lo0bits+0x4e>
 800d58a:	0798      	lsls	r0, r3, #30
 800d58c:	d51f      	bpl.n	800d5ce <__lo0bits+0x52>
 800d58e:	085b      	lsrs	r3, r3, #1
 800d590:	600b      	str	r3, [r1, #0]
 800d592:	2001      	movs	r0, #1
 800d594:	4770      	bx	lr
 800d596:	b298      	uxth	r0, r3
 800d598:	b1a0      	cbz	r0, 800d5c4 <__lo0bits+0x48>
 800d59a:	4610      	mov	r0, r2
 800d59c:	f013 0fff 	tst.w	r3, #255	; 0xff
 800d5a0:	bf04      	itt	eq
 800d5a2:	0a1b      	lsreq	r3, r3, #8
 800d5a4:	3008      	addeq	r0, #8
 800d5a6:	071a      	lsls	r2, r3, #28
 800d5a8:	bf04      	itt	eq
 800d5aa:	091b      	lsreq	r3, r3, #4
 800d5ac:	3004      	addeq	r0, #4
 800d5ae:	079a      	lsls	r2, r3, #30
 800d5b0:	bf04      	itt	eq
 800d5b2:	089b      	lsreq	r3, r3, #2
 800d5b4:	3002      	addeq	r0, #2
 800d5b6:	07da      	lsls	r2, r3, #31
 800d5b8:	d402      	bmi.n	800d5c0 <__lo0bits+0x44>
 800d5ba:	085b      	lsrs	r3, r3, #1
 800d5bc:	d00b      	beq.n	800d5d6 <__lo0bits+0x5a>
 800d5be:	3001      	adds	r0, #1
 800d5c0:	600b      	str	r3, [r1, #0]
 800d5c2:	4770      	bx	lr
 800d5c4:	0c1b      	lsrs	r3, r3, #16
 800d5c6:	2010      	movs	r0, #16
 800d5c8:	e7e8      	b.n	800d59c <__lo0bits+0x20>
 800d5ca:	2000      	movs	r0, #0
 800d5cc:	4770      	bx	lr
 800d5ce:	089b      	lsrs	r3, r3, #2
 800d5d0:	600b      	str	r3, [r1, #0]
 800d5d2:	2002      	movs	r0, #2
 800d5d4:	4770      	bx	lr
 800d5d6:	2020      	movs	r0, #32
 800d5d8:	4770      	bx	lr
 800d5da:	bf00      	nop

0800d5dc <__i2b>:
 800d5dc:	b510      	push	{r4, lr}
 800d5de:	460c      	mov	r4, r1
 800d5e0:	2101      	movs	r1, #1
 800d5e2:	f7ff ff3b 	bl	800d45c <_Balloc>
 800d5e6:	2201      	movs	r2, #1
 800d5e8:	e9c0 2404 	strd	r2, r4, [r0, #16]
 800d5ec:	bd10      	pop	{r4, pc}
 800d5ee:	bf00      	nop

0800d5f0 <__multiply>:
 800d5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d5f4:	690e      	ldr	r6, [r1, #16]
 800d5f6:	6914      	ldr	r4, [r2, #16]
 800d5f8:	42a6      	cmp	r6, r4
 800d5fa:	b083      	sub	sp, #12
 800d5fc:	460f      	mov	r7, r1
 800d5fe:	4615      	mov	r5, r2
 800d600:	da04      	bge.n	800d60c <__multiply+0x1c>
 800d602:	4632      	mov	r2, r6
 800d604:	462f      	mov	r7, r5
 800d606:	4626      	mov	r6, r4
 800d608:	460d      	mov	r5, r1
 800d60a:	4614      	mov	r4, r2
 800d60c:	e9d7 1301 	ldrd	r1, r3, [r7, #4]
 800d610:	eb06 0804 	add.w	r8, r6, r4
 800d614:	4543      	cmp	r3, r8
 800d616:	bfb8      	it	lt
 800d618:	3101      	addlt	r1, #1
 800d61a:	f7ff ff1f 	bl	800d45c <_Balloc>
 800d61e:	f100 0914 	add.w	r9, r0, #20
 800d622:	eb09 0e88 	add.w	lr, r9, r8, lsl #2
 800d626:	45f1      	cmp	r9, lr
 800d628:	9000      	str	r0, [sp, #0]
 800d62a:	d205      	bcs.n	800d638 <__multiply+0x48>
 800d62c:	464b      	mov	r3, r9
 800d62e:	2200      	movs	r2, #0
 800d630:	f843 2b04 	str.w	r2, [r3], #4
 800d634:	459e      	cmp	lr, r3
 800d636:	d8fb      	bhi.n	800d630 <__multiply+0x40>
 800d638:	f105 0a14 	add.w	sl, r5, #20
 800d63c:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
 800d640:	f107 0314 	add.w	r3, r7, #20
 800d644:	45a2      	cmp	sl, r4
 800d646:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 800d64a:	d261      	bcs.n	800d710 <__multiply+0x120>
 800d64c:	1b64      	subs	r4, r4, r5
 800d64e:	3c15      	subs	r4, #21
 800d650:	f024 0403 	bic.w	r4, r4, #3
 800d654:	f8cd e004 	str.w	lr, [sp, #4]
 800d658:	44a2      	add	sl, r4
 800d65a:	f105 0210 	add.w	r2, r5, #16
 800d65e:	469e      	mov	lr, r3
 800d660:	e005      	b.n	800d66e <__multiply+0x7e>
 800d662:	0c2d      	lsrs	r5, r5, #16
 800d664:	d12b      	bne.n	800d6be <__multiply+0xce>
 800d666:	4592      	cmp	sl, r2
 800d668:	f109 0904 	add.w	r9, r9, #4
 800d66c:	d04e      	beq.n	800d70c <__multiply+0x11c>
 800d66e:	f852 5f04 	ldr.w	r5, [r2, #4]!
 800d672:	fa1f fb85 	uxth.w	fp, r5
 800d676:	f1bb 0f00 	cmp.w	fp, #0
 800d67a:	d0f2      	beq.n	800d662 <__multiply+0x72>
 800d67c:	4677      	mov	r7, lr
 800d67e:	464e      	mov	r6, r9
 800d680:	2000      	movs	r0, #0
 800d682:	e000      	b.n	800d686 <__multiply+0x96>
 800d684:	4626      	mov	r6, r4
 800d686:	f857 1b04 	ldr.w	r1, [r7], #4
 800d68a:	6834      	ldr	r4, [r6, #0]
 800d68c:	b28b      	uxth	r3, r1
 800d68e:	b2a5      	uxth	r5, r4
 800d690:	0c09      	lsrs	r1, r1, #16
 800d692:	0c24      	lsrs	r4, r4, #16
 800d694:	fb0b 5303 	mla	r3, fp, r3, r5
 800d698:	4403      	add	r3, r0
 800d69a:	fb0b 4001 	mla	r0, fp, r1, r4
 800d69e:	eb00 4013 	add.w	r0, r0, r3, lsr #16
 800d6a2:	4634      	mov	r4, r6
 800d6a4:	b29b      	uxth	r3, r3
 800d6a6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 800d6aa:	45bc      	cmp	ip, r7
 800d6ac:	ea4f 4010 	mov.w	r0, r0, lsr #16
 800d6b0:	f844 3b04 	str.w	r3, [r4], #4
 800d6b4:	d8e6      	bhi.n	800d684 <__multiply+0x94>
 800d6b6:	6070      	str	r0, [r6, #4]
 800d6b8:	6815      	ldr	r5, [r2, #0]
 800d6ba:	0c2d      	lsrs	r5, r5, #16
 800d6bc:	d0d3      	beq.n	800d666 <__multiply+0x76>
 800d6be:	f8d9 3000 	ldr.w	r3, [r9]
 800d6c2:	4676      	mov	r6, lr
 800d6c4:	4618      	mov	r0, r3
 800d6c6:	46cb      	mov	fp, r9
 800d6c8:	2100      	movs	r1, #0
 800d6ca:	e000      	b.n	800d6ce <__multiply+0xde>
 800d6cc:	46a3      	mov	fp, r4
 800d6ce:	8834      	ldrh	r4, [r6, #0]
 800d6d0:	0c00      	lsrs	r0, r0, #16
 800d6d2:	fb05 0004 	mla	r0, r5, r4, r0
 800d6d6:	4401      	add	r1, r0
 800d6d8:	b29b      	uxth	r3, r3
 800d6da:	465c      	mov	r4, fp
 800d6dc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800d6e0:	f844 3b04 	str.w	r3, [r4], #4
 800d6e4:	f856 3b04 	ldr.w	r3, [r6], #4
 800d6e8:	f8db 0004 	ldr.w	r0, [fp, #4]
 800d6ec:	0c1b      	lsrs	r3, r3, #16
 800d6ee:	b287      	uxth	r7, r0
 800d6f0:	fb05 7303 	mla	r3, r5, r3, r7
 800d6f4:	eb03 4311 	add.w	r3, r3, r1, lsr #16
 800d6f8:	45b4      	cmp	ip, r6
 800d6fa:	ea4f 4113 	mov.w	r1, r3, lsr #16
 800d6fe:	d8e5      	bhi.n	800d6cc <__multiply+0xdc>
 800d700:	4592      	cmp	sl, r2
 800d702:	f8cb 3004 	str.w	r3, [fp, #4]
 800d706:	f109 0904 	add.w	r9, r9, #4
 800d70a:	d1b0      	bne.n	800d66e <__multiply+0x7e>
 800d70c:	f8dd e004 	ldr.w	lr, [sp, #4]
 800d710:	f1b8 0f00 	cmp.w	r8, #0
 800d714:	dd0b      	ble.n	800d72e <__multiply+0x13e>
 800d716:	f85e 3c04 	ldr.w	r3, [lr, #-4]
 800d71a:	f1ae 0e04 	sub.w	lr, lr, #4
 800d71e:	b11b      	cbz	r3, 800d728 <__multiply+0x138>
 800d720:	e005      	b.n	800d72e <__multiply+0x13e>
 800d722:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
 800d726:	b913      	cbnz	r3, 800d72e <__multiply+0x13e>
 800d728:	f1b8 0801 	subs.w	r8, r8, #1
 800d72c:	d1f9      	bne.n	800d722 <__multiply+0x132>
 800d72e:	9800      	ldr	r0, [sp, #0]
 800d730:	f8c0 8010 	str.w	r8, [r0, #16]
 800d734:	b003      	add	sp, #12
 800d736:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d73a:	bf00      	nop

0800d73c <__pow5mult>:
 800d73c:	f012 0303 	ands.w	r3, r2, #3
 800d740:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d744:	4614      	mov	r4, r2
 800d746:	4607      	mov	r7, r0
 800d748:	d12e      	bne.n	800d7a8 <__pow5mult+0x6c>
 800d74a:	460d      	mov	r5, r1
 800d74c:	10a4      	asrs	r4, r4, #2
 800d74e:	d01c      	beq.n	800d78a <__pow5mult+0x4e>
 800d750:	6cbe      	ldr	r6, [r7, #72]	; 0x48
 800d752:	b396      	cbz	r6, 800d7ba <__pow5mult+0x7e>
 800d754:	07e3      	lsls	r3, r4, #31
 800d756:	f04f 0800 	mov.w	r8, #0
 800d75a:	d406      	bmi.n	800d76a <__pow5mult+0x2e>
 800d75c:	1064      	asrs	r4, r4, #1
 800d75e:	d014      	beq.n	800d78a <__pow5mult+0x4e>
 800d760:	6830      	ldr	r0, [r6, #0]
 800d762:	b1a8      	cbz	r0, 800d790 <__pow5mult+0x54>
 800d764:	4606      	mov	r6, r0
 800d766:	07e3      	lsls	r3, r4, #31
 800d768:	d5f8      	bpl.n	800d75c <__pow5mult+0x20>
 800d76a:	4632      	mov	r2, r6
 800d76c:	4629      	mov	r1, r5
 800d76e:	4638      	mov	r0, r7
 800d770:	f7ff ff3e 	bl	800d5f0 <__multiply>
 800d774:	b1b5      	cbz	r5, 800d7a4 <__pow5mult+0x68>
 800d776:	686a      	ldr	r2, [r5, #4]
 800d778:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d77a:	1064      	asrs	r4, r4, #1
 800d77c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800d780:	6029      	str	r1, [r5, #0]
 800d782:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 800d786:	4605      	mov	r5, r0
 800d788:	d1ea      	bne.n	800d760 <__pow5mult+0x24>
 800d78a:	4628      	mov	r0, r5
 800d78c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d790:	4632      	mov	r2, r6
 800d792:	4631      	mov	r1, r6
 800d794:	4638      	mov	r0, r7
 800d796:	f7ff ff2b 	bl	800d5f0 <__multiply>
 800d79a:	6030      	str	r0, [r6, #0]
 800d79c:	f8c0 8000 	str.w	r8, [r0]
 800d7a0:	4606      	mov	r6, r0
 800d7a2:	e7e0      	b.n	800d766 <__pow5mult+0x2a>
 800d7a4:	4605      	mov	r5, r0
 800d7a6:	e7d9      	b.n	800d75c <__pow5mult+0x20>
 800d7a8:	3b01      	subs	r3, #1
 800d7aa:	4a0b      	ldr	r2, [pc, #44]	; (800d7d8 <__pow5mult+0x9c>)
 800d7ac:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800d7b0:	2300      	movs	r3, #0
 800d7b2:	f7ff fe83 	bl	800d4bc <__multadd>
 800d7b6:	4605      	mov	r5, r0
 800d7b8:	e7c8      	b.n	800d74c <__pow5mult+0x10>
 800d7ba:	2101      	movs	r1, #1
 800d7bc:	4638      	mov	r0, r7
 800d7be:	f7ff fe4d 	bl	800d45c <_Balloc>
 800d7c2:	f240 2371 	movw	r3, #625	; 0x271
 800d7c6:	6143      	str	r3, [r0, #20]
 800d7c8:	2201      	movs	r2, #1
 800d7ca:	2300      	movs	r3, #0
 800d7cc:	6102      	str	r2, [r0, #16]
 800d7ce:	4606      	mov	r6, r0
 800d7d0:	64b8      	str	r0, [r7, #72]	; 0x48
 800d7d2:	6003      	str	r3, [r0, #0]
 800d7d4:	e7be      	b.n	800d754 <__pow5mult+0x18>
 800d7d6:	bf00      	nop
 800d7d8:	0801dd68 	.word	0x0801dd68

0800d7dc <__lshift>:
 800d7dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d7e0:	4691      	mov	r9, r2
 800d7e2:	690a      	ldr	r2, [r1, #16]
 800d7e4:	460e      	mov	r6, r1
 800d7e6:	ea4f 1469 	mov.w	r4, r9, asr #5
 800d7ea:	e9d1 1301 	ldrd	r1, r3, [r1, #4]
 800d7ee:	eb04 0802 	add.w	r8, r4, r2
 800d7f2:	f108 0501 	add.w	r5, r8, #1
 800d7f6:	429d      	cmp	r5, r3
 800d7f8:	4607      	mov	r7, r0
 800d7fa:	dd04      	ble.n	800d806 <__lshift+0x2a>
 800d7fc:	005b      	lsls	r3, r3, #1
 800d7fe:	429d      	cmp	r5, r3
 800d800:	f101 0101 	add.w	r1, r1, #1
 800d804:	dcfa      	bgt.n	800d7fc <__lshift+0x20>
 800d806:	4638      	mov	r0, r7
 800d808:	f7ff fe28 	bl	800d45c <_Balloc>
 800d80c:	2c00      	cmp	r4, #0
 800d80e:	f100 0314 	add.w	r3, r0, #20
 800d812:	dd37      	ble.n	800d884 <__lshift+0xa8>
 800d814:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 800d818:	2200      	movs	r2, #0
 800d81a:	f843 2b04 	str.w	r2, [r3], #4
 800d81e:	428b      	cmp	r3, r1
 800d820:	d1fb      	bne.n	800d81a <__lshift+0x3e>
 800d822:	6934      	ldr	r4, [r6, #16]
 800d824:	f106 0314 	add.w	r3, r6, #20
 800d828:	f019 091f 	ands.w	r9, r9, #31
 800d82c:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
 800d830:	d020      	beq.n	800d874 <__lshift+0x98>
 800d832:	f1c9 0e20 	rsb	lr, r9, #32
 800d836:	2200      	movs	r2, #0
 800d838:	e000      	b.n	800d83c <__lshift+0x60>
 800d83a:	4651      	mov	r1, sl
 800d83c:	681c      	ldr	r4, [r3, #0]
 800d83e:	468a      	mov	sl, r1
 800d840:	fa04 f409 	lsl.w	r4, r4, r9
 800d844:	4314      	orrs	r4, r2
 800d846:	f84a 4b04 	str.w	r4, [sl], #4
 800d84a:	f853 2b04 	ldr.w	r2, [r3], #4
 800d84e:	4563      	cmp	r3, ip
 800d850:	fa22 f20e 	lsr.w	r2, r2, lr
 800d854:	d3f1      	bcc.n	800d83a <__lshift+0x5e>
 800d856:	604a      	str	r2, [r1, #4]
 800d858:	b10a      	cbz	r2, 800d85e <__lshift+0x82>
 800d85a:	f108 0502 	add.w	r5, r8, #2
 800d85e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d860:	6872      	ldr	r2, [r6, #4]
 800d862:	3d01      	subs	r5, #1
 800d864:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800d868:	6105      	str	r5, [r0, #16]
 800d86a:	6031      	str	r1, [r6, #0]
 800d86c:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 800d870:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d874:	3904      	subs	r1, #4
 800d876:	f853 2b04 	ldr.w	r2, [r3], #4
 800d87a:	f841 2f04 	str.w	r2, [r1, #4]!
 800d87e:	459c      	cmp	ip, r3
 800d880:	d8f9      	bhi.n	800d876 <__lshift+0x9a>
 800d882:	e7ec      	b.n	800d85e <__lshift+0x82>
 800d884:	4619      	mov	r1, r3
 800d886:	e7cc      	b.n	800d822 <__lshift+0x46>

0800d888 <__mcmp>:
 800d888:	b430      	push	{r4, r5}
 800d88a:	690b      	ldr	r3, [r1, #16]
 800d88c:	4605      	mov	r5, r0
 800d88e:	6900      	ldr	r0, [r0, #16]
 800d890:	1ac0      	subs	r0, r0, r3
 800d892:	d10f      	bne.n	800d8b4 <__mcmp+0x2c>
 800d894:	009b      	lsls	r3, r3, #2
 800d896:	3514      	adds	r5, #20
 800d898:	3114      	adds	r1, #20
 800d89a:	4419      	add	r1, r3
 800d89c:	442b      	add	r3, r5
 800d89e:	e001      	b.n	800d8a4 <__mcmp+0x1c>
 800d8a0:	429d      	cmp	r5, r3
 800d8a2:	d207      	bcs.n	800d8b4 <__mcmp+0x2c>
 800d8a4:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800d8a8:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800d8ac:	4294      	cmp	r4, r2
 800d8ae:	d0f7      	beq.n	800d8a0 <__mcmp+0x18>
 800d8b0:	d302      	bcc.n	800d8b8 <__mcmp+0x30>
 800d8b2:	2001      	movs	r0, #1
 800d8b4:	bc30      	pop	{r4, r5}
 800d8b6:	4770      	bx	lr
 800d8b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800d8bc:	e7fa      	b.n	800d8b4 <__mcmp+0x2c>
 800d8be:	bf00      	nop

0800d8c0 <__mdiff>:
 800d8c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d8c4:	6913      	ldr	r3, [r2, #16]
 800d8c6:	690d      	ldr	r5, [r1, #16]
 800d8c8:	1aed      	subs	r5, r5, r3
 800d8ca:	2d00      	cmp	r5, #0
 800d8cc:	460e      	mov	r6, r1
 800d8ce:	4690      	mov	r8, r2
 800d8d0:	f101 0414 	add.w	r4, r1, #20
 800d8d4:	f102 0714 	add.w	r7, r2, #20
 800d8d8:	d114      	bne.n	800d904 <__mdiff+0x44>
 800d8da:	009b      	lsls	r3, r3, #2
 800d8dc:	18e2      	adds	r2, r4, r3
 800d8de:	443b      	add	r3, r7
 800d8e0:	e001      	b.n	800d8e6 <__mdiff+0x26>
 800d8e2:	42a2      	cmp	r2, r4
 800d8e4:	d959      	bls.n	800d99a <__mdiff+0xda>
 800d8e6:	f852 cd04 	ldr.w	ip, [r2, #-4]!
 800d8ea:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800d8ee:	458c      	cmp	ip, r1
 800d8f0:	d0f7      	beq.n	800d8e2 <__mdiff+0x22>
 800d8f2:	d209      	bcs.n	800d908 <__mdiff+0x48>
 800d8f4:	4622      	mov	r2, r4
 800d8f6:	4633      	mov	r3, r6
 800d8f8:	463c      	mov	r4, r7
 800d8fa:	4646      	mov	r6, r8
 800d8fc:	4617      	mov	r7, r2
 800d8fe:	4698      	mov	r8, r3
 800d900:	2501      	movs	r5, #1
 800d902:	e001      	b.n	800d908 <__mdiff+0x48>
 800d904:	dbf6      	blt.n	800d8f4 <__mdiff+0x34>
 800d906:	2500      	movs	r5, #0
 800d908:	6871      	ldr	r1, [r6, #4]
 800d90a:	f7ff fda7 	bl	800d45c <_Balloc>
 800d90e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800d912:	6936      	ldr	r6, [r6, #16]
 800d914:	60c5      	str	r5, [r0, #12]
 800d916:	eb07 0e83 	add.w	lr, r7, r3, lsl #2
 800d91a:	46bc      	mov	ip, r7
 800d91c:	f100 0514 	add.w	r5, r0, #20
 800d920:	eb04 0786 	add.w	r7, r4, r6, lsl #2
 800d924:	2300      	movs	r3, #0
 800d926:	f85c 1b04 	ldr.w	r1, [ip], #4
 800d92a:	f854 8b04 	ldr.w	r8, [r4], #4
 800d92e:	b28a      	uxth	r2, r1
 800d930:	fa13 f388 	uxtah	r3, r3, r8
 800d934:	0c09      	lsrs	r1, r1, #16
 800d936:	1a9a      	subs	r2, r3, r2
 800d938:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
 800d93c:	eb03 4322 	add.w	r3, r3, r2, asr #16
 800d940:	b292      	uxth	r2, r2
 800d942:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 800d946:	45e6      	cmp	lr, ip
 800d948:	f845 2b04 	str.w	r2, [r5], #4
 800d94c:	ea4f 4323 	mov.w	r3, r3, asr #16
 800d950:	d8e9      	bhi.n	800d926 <__mdiff+0x66>
 800d952:	42a7      	cmp	r7, r4
 800d954:	d917      	bls.n	800d986 <__mdiff+0xc6>
 800d956:	46ae      	mov	lr, r5
 800d958:	46a4      	mov	ip, r4
 800d95a:	f85c 2b04 	ldr.w	r2, [ip], #4
 800d95e:	fa13 f382 	uxtah	r3, r3, r2
 800d962:	1419      	asrs	r1, r3, #16
 800d964:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 800d968:	b29b      	uxth	r3, r3
 800d96a:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
 800d96e:	4567      	cmp	r7, ip
 800d970:	f84e 2b04 	str.w	r2, [lr], #4
 800d974:	ea4f 4321 	mov.w	r3, r1, asr #16
 800d978:	d8ef      	bhi.n	800d95a <__mdiff+0x9a>
 800d97a:	43e4      	mvns	r4, r4
 800d97c:	4427      	add	r7, r4
 800d97e:	f027 0703 	bic.w	r7, r7, #3
 800d982:	3704      	adds	r7, #4
 800d984:	443d      	add	r5, r7
 800d986:	3d04      	subs	r5, #4
 800d988:	b922      	cbnz	r2, 800d994 <__mdiff+0xd4>
 800d98a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800d98e:	3e01      	subs	r6, #1
 800d990:	2b00      	cmp	r3, #0
 800d992:	d0fa      	beq.n	800d98a <__mdiff+0xca>
 800d994:	6106      	str	r6, [r0, #16]
 800d996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d99a:	2100      	movs	r1, #0
 800d99c:	f7ff fd5e 	bl	800d45c <_Balloc>
 800d9a0:	2201      	movs	r2, #1
 800d9a2:	2300      	movs	r3, #0
 800d9a4:	e9c0 2304 	strd	r2, r3, [r0, #16]
 800d9a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d9ac <__d2b>:
 800d9ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d9b0:	460f      	mov	r7, r1
 800d9b2:	b083      	sub	sp, #12
 800d9b4:	2101      	movs	r1, #1
 800d9b6:	ec55 4b10 	vmov	r4, r5, d0
 800d9ba:	4616      	mov	r6, r2
 800d9bc:	f7ff fd4e 	bl	800d45c <_Balloc>
 800d9c0:	f3c5 580a 	ubfx	r8, r5, #20, #11
 800d9c4:	4681      	mov	r9, r0
 800d9c6:	f3c5 0313 	ubfx	r3, r5, #0, #20
 800d9ca:	f1b8 0f00 	cmp.w	r8, #0
 800d9ce:	d001      	beq.n	800d9d4 <__d2b+0x28>
 800d9d0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800d9d4:	2c00      	cmp	r4, #0
 800d9d6:	9301      	str	r3, [sp, #4]
 800d9d8:	d024      	beq.n	800da24 <__d2b+0x78>
 800d9da:	a802      	add	r0, sp, #8
 800d9dc:	f840 4d08 	str.w	r4, [r0, #-8]!
 800d9e0:	f7ff fdcc 	bl	800d57c <__lo0bits>
 800d9e4:	2800      	cmp	r0, #0
 800d9e6:	d136      	bne.n	800da56 <__d2b+0xaa>
 800d9e8:	e9dd 2300 	ldrd	r2, r3, [sp]
 800d9ec:	f8c9 2014 	str.w	r2, [r9, #20]
 800d9f0:	2b00      	cmp	r3, #0
 800d9f2:	bf0c      	ite	eq
 800d9f4:	2101      	moveq	r1, #1
 800d9f6:	2102      	movne	r1, #2
 800d9f8:	f8c9 3018 	str.w	r3, [r9, #24]
 800d9fc:	f8c9 1010 	str.w	r1, [r9, #16]
 800da00:	f1b8 0f00 	cmp.w	r8, #0
 800da04:	d11b      	bne.n	800da3e <__d2b+0x92>
 800da06:	eb09 0381 	add.w	r3, r9, r1, lsl #2
 800da0a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 800da0e:	6038      	str	r0, [r7, #0]
 800da10:	6918      	ldr	r0, [r3, #16]
 800da12:	f7ff fd93 	bl	800d53c <__hi0bits>
 800da16:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 800da1a:	6030      	str	r0, [r6, #0]
 800da1c:	4648      	mov	r0, r9
 800da1e:	b003      	add	sp, #12
 800da20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800da24:	a801      	add	r0, sp, #4
 800da26:	f7ff fda9 	bl	800d57c <__lo0bits>
 800da2a:	9b01      	ldr	r3, [sp, #4]
 800da2c:	f8c9 3014 	str.w	r3, [r9, #20]
 800da30:	2101      	movs	r1, #1
 800da32:	3020      	adds	r0, #32
 800da34:	f8c9 1010 	str.w	r1, [r9, #16]
 800da38:	f1b8 0f00 	cmp.w	r8, #0
 800da3c:	d0e3      	beq.n	800da06 <__d2b+0x5a>
 800da3e:	f2a8 4833 	subw	r8, r8, #1075	; 0x433
 800da42:	eb08 0300 	add.w	r3, r8, r0
 800da46:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 800da4a:	603b      	str	r3, [r7, #0]
 800da4c:	6030      	str	r0, [r6, #0]
 800da4e:	4648      	mov	r0, r9
 800da50:	b003      	add	sp, #12
 800da52:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800da56:	e9dd 1300 	ldrd	r1, r3, [sp]
 800da5a:	f1c0 0220 	rsb	r2, r0, #32
 800da5e:	fa03 f202 	lsl.w	r2, r3, r2
 800da62:	430a      	orrs	r2, r1
 800da64:	40c3      	lsrs	r3, r0
 800da66:	9301      	str	r3, [sp, #4]
 800da68:	f8c9 2014 	str.w	r2, [r9, #20]
 800da6c:	e7c0      	b.n	800d9f0 <__d2b+0x44>
 800da6e:	bf00      	nop

0800da70 <frexp>:
 800da70:	ec53 2b10 	vmov	r2, r3, d0
 800da74:	b570      	push	{r4, r5, r6, lr}
 800da76:	4e16      	ldr	r6, [pc, #88]	; (800dad0 <frexp+0x60>)
 800da78:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800da7c:	2500      	movs	r5, #0
 800da7e:	42b1      	cmp	r1, r6
 800da80:	4604      	mov	r4, r0
 800da82:	6005      	str	r5, [r0, #0]
 800da84:	dc21      	bgt.n	800daca <frexp+0x5a>
 800da86:	ee10 6a10 	vmov	r6, s0
 800da8a:	430e      	orrs	r6, r1
 800da8c:	d01d      	beq.n	800daca <frexp+0x5a>
 800da8e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800da92:	4618      	mov	r0, r3
 800da94:	da0c      	bge.n	800dab0 <frexp+0x40>
 800da96:	4619      	mov	r1, r3
 800da98:	2200      	movs	r2, #0
 800da9a:	ee10 0a10 	vmov	r0, s0
 800da9e:	4b0d      	ldr	r3, [pc, #52]	; (800dad4 <frexp+0x64>)
 800daa0:	f7f2 fdec 	bl	800067c <__aeabi_dmul>
 800daa4:	f06f 0535 	mvn.w	r5, #53	; 0x35
 800daa8:	4602      	mov	r2, r0
 800daaa:	4608      	mov	r0, r1
 800daac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800dab0:	f020 40ff 	bic.w	r0, r0, #2139095040	; 0x7f800000
 800dab4:	1509      	asrs	r1, r1, #20
 800dab6:	f420 00e0 	bic.w	r0, r0, #7340032	; 0x700000
 800daba:	f2a1 31fe 	subw	r1, r1, #1022	; 0x3fe
 800dabe:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
 800dac2:	4429      	add	r1, r5
 800dac4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800dac8:	6021      	str	r1, [r4, #0]
 800daca:	ec43 2b10 	vmov	d0, r2, r3
 800dace:	bd70      	pop	{r4, r5, r6, pc}
 800dad0:	7fefffff 	.word	0x7fefffff
 800dad4:	43500000 	.word	0x43500000

0800dad8 <strncpy>:
 800dad8:	ea40 0301 	orr.w	r3, r0, r1
 800dadc:	079b      	lsls	r3, r3, #30
 800dade:	b470      	push	{r4, r5, r6}
 800dae0:	d12a      	bne.n	800db38 <strncpy+0x60>
 800dae2:	2a03      	cmp	r2, #3
 800dae4:	d928      	bls.n	800db38 <strncpy+0x60>
 800dae6:	460c      	mov	r4, r1
 800dae8:	4603      	mov	r3, r0
 800daea:	4621      	mov	r1, r4
 800daec:	f854 6b04 	ldr.w	r6, [r4], #4
 800daf0:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 800daf4:	ea25 0506 	bic.w	r5, r5, r6
 800daf8:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 800dafc:	d106      	bne.n	800db0c <strncpy+0x34>
 800dafe:	3a04      	subs	r2, #4
 800db00:	2a03      	cmp	r2, #3
 800db02:	f843 6b04 	str.w	r6, [r3], #4
 800db06:	4621      	mov	r1, r4
 800db08:	d8ef      	bhi.n	800daea <strncpy+0x12>
 800db0a:	b19a      	cbz	r2, 800db34 <strncpy+0x5c>
 800db0c:	780c      	ldrb	r4, [r1, #0]
 800db0e:	701c      	strb	r4, [r3, #0]
 800db10:	3a01      	subs	r2, #1
 800db12:	3301      	adds	r3, #1
 800db14:	b13c      	cbz	r4, 800db26 <strncpy+0x4e>
 800db16:	b16a      	cbz	r2, 800db34 <strncpy+0x5c>
 800db18:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800db1c:	f803 4b01 	strb.w	r4, [r3], #1
 800db20:	3a01      	subs	r2, #1
 800db22:	2c00      	cmp	r4, #0
 800db24:	d1f7      	bne.n	800db16 <strncpy+0x3e>
 800db26:	b12a      	cbz	r2, 800db34 <strncpy+0x5c>
 800db28:	441a      	add	r2, r3
 800db2a:	2100      	movs	r1, #0
 800db2c:	f803 1b01 	strb.w	r1, [r3], #1
 800db30:	4293      	cmp	r3, r2
 800db32:	d1fb      	bne.n	800db2c <strncpy+0x54>
 800db34:	bc70      	pop	{r4, r5, r6}
 800db36:	4770      	bx	lr
 800db38:	4603      	mov	r3, r0
 800db3a:	e7e6      	b.n	800db0a <strncpy+0x32>

0800db3c <__ssprint_r>:
 800db3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800db40:	6893      	ldr	r3, [r2, #8]
 800db42:	b083      	sub	sp, #12
 800db44:	4690      	mov	r8, r2
 800db46:	2b00      	cmp	r3, #0
 800db48:	d06c      	beq.n	800dc24 <__ssprint_r+0xe8>
 800db4a:	6817      	ldr	r7, [r2, #0]
 800db4c:	688d      	ldr	r5, [r1, #8]
 800db4e:	4682      	mov	sl, r0
 800db50:	460c      	mov	r4, r1
 800db52:	6808      	ldr	r0, [r1, #0]
 800db54:	3708      	adds	r7, #8
 800db56:	e042      	b.n	800dbde <__ssprint_r+0xa2>
 800db58:	89a3      	ldrh	r3, [r4, #12]
 800db5a:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800db5e:	d02d      	beq.n	800dbbc <__ssprint_r+0x80>
 800db60:	e9d4 1504 	ldrd	r1, r5, [r4, #16]
 800db64:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800db68:	eba0 0b01 	sub.w	fp, r0, r1
 800db6c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 800db70:	1c70      	adds	r0, r6, #1
 800db72:	106d      	asrs	r5, r5, #1
 800db74:	4458      	add	r0, fp
 800db76:	42a8      	cmp	r0, r5
 800db78:	462a      	mov	r2, r5
 800db7a:	bf84      	itt	hi
 800db7c:	4605      	movhi	r5, r0
 800db7e:	462a      	movhi	r2, r5
 800db80:	055b      	lsls	r3, r3, #21
 800db82:	d536      	bpl.n	800dbf2 <__ssprint_r+0xb6>
 800db84:	4611      	mov	r1, r2
 800db86:	4650      	mov	r0, sl
 800db88:	f7ff f9b8 	bl	800cefc <_malloc_r>
 800db8c:	2800      	cmp	r0, #0
 800db8e:	d03a      	beq.n	800dc06 <__ssprint_r+0xca>
 800db90:	465a      	mov	r2, fp
 800db92:	6921      	ldr	r1, [r4, #16]
 800db94:	9001      	str	r0, [sp, #4]
 800db96:	f7f3 f899 	bl	8000ccc <memcpy>
 800db9a:	89a2      	ldrh	r2, [r4, #12]
 800db9c:	9b01      	ldr	r3, [sp, #4]
 800db9e:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 800dba2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800dba6:	81a2      	strh	r2, [r4, #12]
 800dba8:	eba5 020b 	sub.w	r2, r5, fp
 800dbac:	eb03 000b 	add.w	r0, r3, fp
 800dbb0:	6165      	str	r5, [r4, #20]
 800dbb2:	6123      	str	r3, [r4, #16]
 800dbb4:	6020      	str	r0, [r4, #0]
 800dbb6:	60a2      	str	r2, [r4, #8]
 800dbb8:	4635      	mov	r5, r6
 800dbba:	46b3      	mov	fp, r6
 800dbbc:	465a      	mov	r2, fp
 800dbbe:	4649      	mov	r1, r9
 800dbc0:	f000 f884 	bl	800dccc <memmove>
 800dbc4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800dbc8:	68a2      	ldr	r2, [r4, #8]
 800dbca:	6820      	ldr	r0, [r4, #0]
 800dbcc:	1b55      	subs	r5, r2, r5
 800dbce:	4458      	add	r0, fp
 800dbd0:	1b9e      	subs	r6, r3, r6
 800dbd2:	60a5      	str	r5, [r4, #8]
 800dbd4:	6020      	str	r0, [r4, #0]
 800dbd6:	f8c8 6008 	str.w	r6, [r8, #8]
 800dbda:	b31e      	cbz	r6, 800dc24 <__ssprint_r+0xe8>
 800dbdc:	3708      	adds	r7, #8
 800dbde:	e957 9602 	ldrd	r9, r6, [r7, #-8]
 800dbe2:	46ab      	mov	fp, r5
 800dbe4:	2e00      	cmp	r6, #0
 800dbe6:	d0f9      	beq.n	800dbdc <__ssprint_r+0xa0>
 800dbe8:	42ae      	cmp	r6, r5
 800dbea:	d2b5      	bcs.n	800db58 <__ssprint_r+0x1c>
 800dbec:	4635      	mov	r5, r6
 800dbee:	46b3      	mov	fp, r6
 800dbf0:	e7e4      	b.n	800dbbc <__ssprint_r+0x80>
 800dbf2:	4650      	mov	r0, sl
 800dbf4:	f000 f8ce 	bl	800dd94 <_realloc_r>
 800dbf8:	4603      	mov	r3, r0
 800dbfa:	2800      	cmp	r0, #0
 800dbfc:	d1d4      	bne.n	800dba8 <__ssprint_r+0x6c>
 800dbfe:	6921      	ldr	r1, [r4, #16]
 800dc00:	4650      	mov	r0, sl
 800dc02:	f7ff f879 	bl	800ccf8 <_free_r>
 800dc06:	230c      	movs	r3, #12
 800dc08:	f8ca 3000 	str.w	r3, [sl]
 800dc0c:	89a3      	ldrh	r3, [r4, #12]
 800dc0e:	2200      	movs	r2, #0
 800dc10:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dc14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800dc18:	81a3      	strh	r3, [r4, #12]
 800dc1a:	e9c8 2201 	strd	r2, r2, [r8, #4]
 800dc1e:	b003      	add	sp, #12
 800dc20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800dc24:	2000      	movs	r0, #0
 800dc26:	f8c8 0004 	str.w	r0, [r8, #4]
 800dc2a:	b003      	add	sp, #12
 800dc2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800dc30 <_calloc_r>:
 800dc30:	b510      	push	{r4, lr}
 800dc32:	fb02 f101 	mul.w	r1, r2, r1
 800dc36:	f7ff f961 	bl	800cefc <_malloc_r>
 800dc3a:	4604      	mov	r4, r0
 800dc3c:	b1d8      	cbz	r0, 800dc76 <_calloc_r+0x46>
 800dc3e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800dc42:	f022 0203 	bic.w	r2, r2, #3
 800dc46:	3a04      	subs	r2, #4
 800dc48:	2a24      	cmp	r2, #36	; 0x24
 800dc4a:	d81d      	bhi.n	800dc88 <_calloc_r+0x58>
 800dc4c:	2a13      	cmp	r2, #19
 800dc4e:	d914      	bls.n	800dc7a <_calloc_r+0x4a>
 800dc50:	2300      	movs	r3, #0
 800dc52:	2a1b      	cmp	r2, #27
 800dc54:	e9c0 3300 	strd	r3, r3, [r0]
 800dc58:	d91b      	bls.n	800dc92 <_calloc_r+0x62>
 800dc5a:	2a24      	cmp	r2, #36	; 0x24
 800dc5c:	e9c0 3302 	strd	r3, r3, [r0, #8]
 800dc60:	bf0a      	itet	eq
 800dc62:	e9c0 3304 	strdeq	r3, r3, [r0, #16]
 800dc66:	f100 0210 	addne.w	r2, r0, #16
 800dc6a:	f100 0218 	addeq.w	r2, r0, #24
 800dc6e:	2300      	movs	r3, #0
 800dc70:	e9c2 3300 	strd	r3, r3, [r2]
 800dc74:	6093      	str	r3, [r2, #8]
 800dc76:	4620      	mov	r0, r4
 800dc78:	bd10      	pop	{r4, pc}
 800dc7a:	4602      	mov	r2, r0
 800dc7c:	2300      	movs	r3, #0
 800dc7e:	e9c2 3300 	strd	r3, r3, [r2]
 800dc82:	6093      	str	r3, [r2, #8]
 800dc84:	4620      	mov	r0, r4
 800dc86:	bd10      	pop	{r4, pc}
 800dc88:	2100      	movs	r1, #0
 800dc8a:	f7fc faf1 	bl	800a270 <memset>
 800dc8e:	4620      	mov	r0, r4
 800dc90:	bd10      	pop	{r4, pc}
 800dc92:	f100 0208 	add.w	r2, r0, #8
 800dc96:	e7f1      	b.n	800dc7c <_calloc_r+0x4c>

0800dc98 <__retarget_lock_acquire_recursive>:
 800dc98:	4770      	bx	lr
 800dc9a:	bf00      	nop

0800dc9c <__retarget_lock_release_recursive>:
 800dc9c:	4770      	bx	lr
 800dc9e:	bf00      	nop

0800dca0 <__ascii_mbtowc>:
 800dca0:	b082      	sub	sp, #8
 800dca2:	b149      	cbz	r1, 800dcb8 <__ascii_mbtowc+0x18>
 800dca4:	b15a      	cbz	r2, 800dcbe <__ascii_mbtowc+0x1e>
 800dca6:	b16b      	cbz	r3, 800dcc4 <__ascii_mbtowc+0x24>
 800dca8:	7813      	ldrb	r3, [r2, #0]
 800dcaa:	600b      	str	r3, [r1, #0]
 800dcac:	7812      	ldrb	r2, [r2, #0]
 800dcae:	1c10      	adds	r0, r2, #0
 800dcb0:	bf18      	it	ne
 800dcb2:	2001      	movne	r0, #1
 800dcb4:	b002      	add	sp, #8
 800dcb6:	4770      	bx	lr
 800dcb8:	a901      	add	r1, sp, #4
 800dcba:	2a00      	cmp	r2, #0
 800dcbc:	d1f3      	bne.n	800dca6 <__ascii_mbtowc+0x6>
 800dcbe:	4610      	mov	r0, r2
 800dcc0:	b002      	add	sp, #8
 800dcc2:	4770      	bx	lr
 800dcc4:	f06f 0001 	mvn.w	r0, #1
 800dcc8:	e7f4      	b.n	800dcb4 <__ascii_mbtowc+0x14>
 800dcca:	bf00      	nop

0800dccc <memmove>:
 800dccc:	4288      	cmp	r0, r1
 800dcce:	b4f0      	push	{r4, r5, r6, r7}
 800dcd0:	d90d      	bls.n	800dcee <memmove+0x22>
 800dcd2:	188b      	adds	r3, r1, r2
 800dcd4:	4283      	cmp	r3, r0
 800dcd6:	d90a      	bls.n	800dcee <memmove+0x22>
 800dcd8:	1884      	adds	r4, r0, r2
 800dcda:	b132      	cbz	r2, 800dcea <memmove+0x1e>
 800dcdc:	4622      	mov	r2, r4
 800dcde:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800dce2:	f802 4d01 	strb.w	r4, [r2, #-1]!
 800dce6:	4299      	cmp	r1, r3
 800dce8:	d1f9      	bne.n	800dcde <memmove+0x12>
 800dcea:	bcf0      	pop	{r4, r5, r6, r7}
 800dcec:	4770      	bx	lr
 800dcee:	2a0f      	cmp	r2, #15
 800dcf0:	d949      	bls.n	800dd86 <memmove+0xba>
 800dcf2:	ea40 0301 	orr.w	r3, r0, r1
 800dcf6:	079b      	lsls	r3, r3, #30
 800dcf8:	d147      	bne.n	800dd8a <memmove+0xbe>
 800dcfa:	f1a2 0310 	sub.w	r3, r2, #16
 800dcfe:	091b      	lsrs	r3, r3, #4
 800dd00:	f101 0720 	add.w	r7, r1, #32
 800dd04:	eb07 1703 	add.w	r7, r7, r3, lsl #4
 800dd08:	f101 0410 	add.w	r4, r1, #16
 800dd0c:	f100 0510 	add.w	r5, r0, #16
 800dd10:	f854 6c10 	ldr.w	r6, [r4, #-16]
 800dd14:	f845 6c10 	str.w	r6, [r5, #-16]
 800dd18:	f854 6c0c 	ldr.w	r6, [r4, #-12]
 800dd1c:	f845 6c0c 	str.w	r6, [r5, #-12]
 800dd20:	f854 6c08 	ldr.w	r6, [r4, #-8]
 800dd24:	f845 6c08 	str.w	r6, [r5, #-8]
 800dd28:	f854 6c04 	ldr.w	r6, [r4, #-4]
 800dd2c:	f845 6c04 	str.w	r6, [r5, #-4]
 800dd30:	3410      	adds	r4, #16
 800dd32:	42bc      	cmp	r4, r7
 800dd34:	f105 0510 	add.w	r5, r5, #16
 800dd38:	d1ea      	bne.n	800dd10 <memmove+0x44>
 800dd3a:	3301      	adds	r3, #1
 800dd3c:	f002 050f 	and.w	r5, r2, #15
 800dd40:	011b      	lsls	r3, r3, #4
 800dd42:	2d03      	cmp	r5, #3
 800dd44:	4419      	add	r1, r3
 800dd46:	4403      	add	r3, r0
 800dd48:	d921      	bls.n	800dd8e <memmove+0xc2>
 800dd4a:	1f1f      	subs	r7, r3, #4
 800dd4c:	460e      	mov	r6, r1
 800dd4e:	462c      	mov	r4, r5
 800dd50:	3c04      	subs	r4, #4
 800dd52:	f856 cb04 	ldr.w	ip, [r6], #4
 800dd56:	f847 cf04 	str.w	ip, [r7, #4]!
 800dd5a:	2c03      	cmp	r4, #3
 800dd5c:	d8f8      	bhi.n	800dd50 <memmove+0x84>
 800dd5e:	1f2c      	subs	r4, r5, #4
 800dd60:	f024 0403 	bic.w	r4, r4, #3
 800dd64:	3404      	adds	r4, #4
 800dd66:	4423      	add	r3, r4
 800dd68:	4421      	add	r1, r4
 800dd6a:	f002 0203 	and.w	r2, r2, #3
 800dd6e:	2a00      	cmp	r2, #0
 800dd70:	d0bb      	beq.n	800dcea <memmove+0x1e>
 800dd72:	3b01      	subs	r3, #1
 800dd74:	440a      	add	r2, r1
 800dd76:	f811 4b01 	ldrb.w	r4, [r1], #1
 800dd7a:	f803 4f01 	strb.w	r4, [r3, #1]!
 800dd7e:	4291      	cmp	r1, r2
 800dd80:	d1f9      	bne.n	800dd76 <memmove+0xaa>
 800dd82:	bcf0      	pop	{r4, r5, r6, r7}
 800dd84:	4770      	bx	lr
 800dd86:	4603      	mov	r3, r0
 800dd88:	e7f1      	b.n	800dd6e <memmove+0xa2>
 800dd8a:	4603      	mov	r3, r0
 800dd8c:	e7f1      	b.n	800dd72 <memmove+0xa6>
 800dd8e:	462a      	mov	r2, r5
 800dd90:	e7ed      	b.n	800dd6e <memmove+0xa2>
 800dd92:	bf00      	nop

0800dd94 <_realloc_r>:
 800dd94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dd98:	4692      	mov	sl, r2
 800dd9a:	b083      	sub	sp, #12
 800dd9c:	2900      	cmp	r1, #0
 800dd9e:	f000 80a1 	beq.w	800dee4 <_realloc_r+0x150>
 800dda2:	460d      	mov	r5, r1
 800dda4:	4680      	mov	r8, r0
 800dda6:	f10a 040b 	add.w	r4, sl, #11
 800ddaa:	f7ff fb4b 	bl	800d444 <__malloc_lock>
 800ddae:	f855 2c04 	ldr.w	r2, [r5, #-4]
 800ddb2:	2c16      	cmp	r4, #22
 800ddb4:	f022 0603 	bic.w	r6, r2, #3
 800ddb8:	f1a5 0708 	sub.w	r7, r5, #8
 800ddbc:	d83e      	bhi.n	800de3c <_realloc_r+0xa8>
 800ddbe:	2410      	movs	r4, #16
 800ddc0:	4621      	mov	r1, r4
 800ddc2:	45a2      	cmp	sl, r4
 800ddc4:	d83f      	bhi.n	800de46 <_realloc_r+0xb2>
 800ddc6:	428e      	cmp	r6, r1
 800ddc8:	eb07 0906 	add.w	r9, r7, r6
 800ddcc:	da74      	bge.n	800deb8 <_realloc_r+0x124>
 800ddce:	4bc7      	ldr	r3, [pc, #796]	; (800e0ec <_realloc_r+0x358>)
 800ddd0:	6898      	ldr	r0, [r3, #8]
 800ddd2:	4548      	cmp	r0, r9
 800ddd4:	f000 80aa 	beq.w	800df2c <_realloc_r+0x198>
 800ddd8:	f8d9 0004 	ldr.w	r0, [r9, #4]
 800dddc:	f020 0301 	bic.w	r3, r0, #1
 800dde0:	444b      	add	r3, r9
 800dde2:	685b      	ldr	r3, [r3, #4]
 800dde4:	07db      	lsls	r3, r3, #31
 800dde6:	f140 8083 	bpl.w	800def0 <_realloc_r+0x15c>
 800ddea:	07d2      	lsls	r2, r2, #31
 800ddec:	d534      	bpl.n	800de58 <_realloc_r+0xc4>
 800ddee:	4651      	mov	r1, sl
 800ddf0:	4640      	mov	r0, r8
 800ddf2:	f7ff f883 	bl	800cefc <_malloc_r>
 800ddf6:	4682      	mov	sl, r0
 800ddf8:	b1e0      	cbz	r0, 800de34 <_realloc_r+0xa0>
 800ddfa:	f855 3c04 	ldr.w	r3, [r5, #-4]
 800ddfe:	f023 0301 	bic.w	r3, r3, #1
 800de02:	443b      	add	r3, r7
 800de04:	f1a0 0208 	sub.w	r2, r0, #8
 800de08:	4293      	cmp	r3, r2
 800de0a:	f000 80f9 	beq.w	800e000 <_realloc_r+0x26c>
 800de0e:	1f32      	subs	r2, r6, #4
 800de10:	2a24      	cmp	r2, #36	; 0x24
 800de12:	f200 8107 	bhi.w	800e024 <_realloc_r+0x290>
 800de16:	2a13      	cmp	r2, #19
 800de18:	6829      	ldr	r1, [r5, #0]
 800de1a:	f200 80e6 	bhi.w	800dfea <_realloc_r+0x256>
 800de1e:	4603      	mov	r3, r0
 800de20:	462a      	mov	r2, r5
 800de22:	6019      	str	r1, [r3, #0]
 800de24:	6851      	ldr	r1, [r2, #4]
 800de26:	6059      	str	r1, [r3, #4]
 800de28:	6892      	ldr	r2, [r2, #8]
 800de2a:	609a      	str	r2, [r3, #8]
 800de2c:	4629      	mov	r1, r5
 800de2e:	4640      	mov	r0, r8
 800de30:	f7fe ff62 	bl	800ccf8 <_free_r>
 800de34:	4640      	mov	r0, r8
 800de36:	f7ff fb0b 	bl	800d450 <__malloc_unlock>
 800de3a:	e04f      	b.n	800dedc <_realloc_r+0x148>
 800de3c:	f024 0407 	bic.w	r4, r4, #7
 800de40:	2c00      	cmp	r4, #0
 800de42:	4621      	mov	r1, r4
 800de44:	dabd      	bge.n	800ddc2 <_realloc_r+0x2e>
 800de46:	f04f 0a00 	mov.w	sl, #0
 800de4a:	230c      	movs	r3, #12
 800de4c:	4650      	mov	r0, sl
 800de4e:	f8c8 3000 	str.w	r3, [r8]
 800de52:	b003      	add	sp, #12
 800de54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800de58:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800de5c:	eba7 0b03 	sub.w	fp, r7, r3
 800de60:	f8db 2004 	ldr.w	r2, [fp, #4]
 800de64:	f022 0203 	bic.w	r2, r2, #3
 800de68:	18b3      	adds	r3, r6, r2
 800de6a:	428b      	cmp	r3, r1
 800de6c:	dbbf      	blt.n	800ddee <_realloc_r+0x5a>
 800de6e:	46da      	mov	sl, fp
 800de70:	f8db 100c 	ldr.w	r1, [fp, #12]
 800de74:	f85a 0f08 	ldr.w	r0, [sl, #8]!
 800de78:	1f32      	subs	r2, r6, #4
 800de7a:	2a24      	cmp	r2, #36	; 0x24
 800de7c:	60c1      	str	r1, [r0, #12]
 800de7e:	eb0b 0903 	add.w	r9, fp, r3
 800de82:	6088      	str	r0, [r1, #8]
 800de84:	f200 80c6 	bhi.w	800e014 <_realloc_r+0x280>
 800de88:	2a13      	cmp	r2, #19
 800de8a:	6829      	ldr	r1, [r5, #0]
 800de8c:	f240 80c0 	bls.w	800e010 <_realloc_r+0x27c>
 800de90:	f8cb 1008 	str.w	r1, [fp, #8]
 800de94:	6869      	ldr	r1, [r5, #4]
 800de96:	f8cb 100c 	str.w	r1, [fp, #12]
 800de9a:	2a1b      	cmp	r2, #27
 800de9c:	68a9      	ldr	r1, [r5, #8]
 800de9e:	f200 80d8 	bhi.w	800e052 <_realloc_r+0x2be>
 800dea2:	f10b 0210 	add.w	r2, fp, #16
 800dea6:	3508      	adds	r5, #8
 800dea8:	6011      	str	r1, [r2, #0]
 800deaa:	6869      	ldr	r1, [r5, #4]
 800deac:	6051      	str	r1, [r2, #4]
 800deae:	68a9      	ldr	r1, [r5, #8]
 800deb0:	6091      	str	r1, [r2, #8]
 800deb2:	461e      	mov	r6, r3
 800deb4:	465f      	mov	r7, fp
 800deb6:	4655      	mov	r5, sl
 800deb8:	687b      	ldr	r3, [r7, #4]
 800deba:	1b32      	subs	r2, r6, r4
 800debc:	2a0f      	cmp	r2, #15
 800debe:	f003 0301 	and.w	r3, r3, #1
 800dec2:	d822      	bhi.n	800df0a <_realloc_r+0x176>
 800dec4:	4333      	orrs	r3, r6
 800dec6:	607b      	str	r3, [r7, #4]
 800dec8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800decc:	f043 0301 	orr.w	r3, r3, #1
 800ded0:	f8c9 3004 	str.w	r3, [r9, #4]
 800ded4:	4640      	mov	r0, r8
 800ded6:	f7ff fabb 	bl	800d450 <__malloc_unlock>
 800deda:	46aa      	mov	sl, r5
 800dedc:	4650      	mov	r0, sl
 800dede:	b003      	add	sp, #12
 800dee0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800dee4:	4611      	mov	r1, r2
 800dee6:	b003      	add	sp, #12
 800dee8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800deec:	f7ff b806 	b.w	800cefc <_malloc_r>
 800def0:	f020 0003 	bic.w	r0, r0, #3
 800def4:	1833      	adds	r3, r6, r0
 800def6:	428b      	cmp	r3, r1
 800def8:	db61      	blt.n	800dfbe <_realloc_r+0x22a>
 800defa:	e9d9 1202 	ldrd	r1, r2, [r9, #8]
 800defe:	461e      	mov	r6, r3
 800df00:	60ca      	str	r2, [r1, #12]
 800df02:	eb07 0903 	add.w	r9, r7, r3
 800df06:	6091      	str	r1, [r2, #8]
 800df08:	e7d6      	b.n	800deb8 <_realloc_r+0x124>
 800df0a:	1939      	adds	r1, r7, r4
 800df0c:	4323      	orrs	r3, r4
 800df0e:	f042 0201 	orr.w	r2, r2, #1
 800df12:	607b      	str	r3, [r7, #4]
 800df14:	604a      	str	r2, [r1, #4]
 800df16:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800df1a:	f043 0301 	orr.w	r3, r3, #1
 800df1e:	3108      	adds	r1, #8
 800df20:	f8c9 3004 	str.w	r3, [r9, #4]
 800df24:	4640      	mov	r0, r8
 800df26:	f7fe fee7 	bl	800ccf8 <_free_r>
 800df2a:	e7d3      	b.n	800ded4 <_realloc_r+0x140>
 800df2c:	6840      	ldr	r0, [r0, #4]
 800df2e:	f020 0903 	bic.w	r9, r0, #3
 800df32:	44b1      	add	r9, r6
 800df34:	f104 0010 	add.w	r0, r4, #16
 800df38:	4581      	cmp	r9, r0
 800df3a:	da77      	bge.n	800e02c <_realloc_r+0x298>
 800df3c:	07d2      	lsls	r2, r2, #31
 800df3e:	f53f af56 	bmi.w	800ddee <_realloc_r+0x5a>
 800df42:	f855 2c08 	ldr.w	r2, [r5, #-8]
 800df46:	eba7 0b02 	sub.w	fp, r7, r2
 800df4a:	f8db 2004 	ldr.w	r2, [fp, #4]
 800df4e:	f022 0203 	bic.w	r2, r2, #3
 800df52:	4491      	add	r9, r2
 800df54:	4548      	cmp	r0, r9
 800df56:	dc87      	bgt.n	800de68 <_realloc_r+0xd4>
 800df58:	46da      	mov	sl, fp
 800df5a:	f8db 100c 	ldr.w	r1, [fp, #12]
 800df5e:	f85a 0f08 	ldr.w	r0, [sl, #8]!
 800df62:	1f32      	subs	r2, r6, #4
 800df64:	2a24      	cmp	r2, #36	; 0x24
 800df66:	60c1      	str	r1, [r0, #12]
 800df68:	6088      	str	r0, [r1, #8]
 800df6a:	f200 80a1 	bhi.w	800e0b0 <_realloc_r+0x31c>
 800df6e:	2a13      	cmp	r2, #19
 800df70:	6829      	ldr	r1, [r5, #0]
 800df72:	f240 809b 	bls.w	800e0ac <_realloc_r+0x318>
 800df76:	f8cb 1008 	str.w	r1, [fp, #8]
 800df7a:	6869      	ldr	r1, [r5, #4]
 800df7c:	f8cb 100c 	str.w	r1, [fp, #12]
 800df80:	2a1b      	cmp	r2, #27
 800df82:	68a9      	ldr	r1, [r5, #8]
 800df84:	f200 809b 	bhi.w	800e0be <_realloc_r+0x32a>
 800df88:	f10b 0210 	add.w	r2, fp, #16
 800df8c:	3508      	adds	r5, #8
 800df8e:	6011      	str	r1, [r2, #0]
 800df90:	6869      	ldr	r1, [r5, #4]
 800df92:	6051      	str	r1, [r2, #4]
 800df94:	68a9      	ldr	r1, [r5, #8]
 800df96:	6091      	str	r1, [r2, #8]
 800df98:	eb0b 0104 	add.w	r1, fp, r4
 800df9c:	eba9 0204 	sub.w	r2, r9, r4
 800dfa0:	f042 0201 	orr.w	r2, r2, #1
 800dfa4:	6099      	str	r1, [r3, #8]
 800dfa6:	604a      	str	r2, [r1, #4]
 800dfa8:	f8db 3004 	ldr.w	r3, [fp, #4]
 800dfac:	f003 0301 	and.w	r3, r3, #1
 800dfb0:	431c      	orrs	r4, r3
 800dfb2:	4640      	mov	r0, r8
 800dfb4:	f8cb 4004 	str.w	r4, [fp, #4]
 800dfb8:	f7ff fa4a 	bl	800d450 <__malloc_unlock>
 800dfbc:	e78e      	b.n	800dedc <_realloc_r+0x148>
 800dfbe:	07d3      	lsls	r3, r2, #31
 800dfc0:	f53f af15 	bmi.w	800ddee <_realloc_r+0x5a>
 800dfc4:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800dfc8:	eba7 0b03 	sub.w	fp, r7, r3
 800dfcc:	f8db 2004 	ldr.w	r2, [fp, #4]
 800dfd0:	f022 0203 	bic.w	r2, r2, #3
 800dfd4:	4410      	add	r0, r2
 800dfd6:	1983      	adds	r3, r0, r6
 800dfd8:	428b      	cmp	r3, r1
 800dfda:	f6ff af45 	blt.w	800de68 <_realloc_r+0xd4>
 800dfde:	e9d9 1202 	ldrd	r1, r2, [r9, #8]
 800dfe2:	46da      	mov	sl, fp
 800dfe4:	60ca      	str	r2, [r1, #12]
 800dfe6:	6091      	str	r1, [r2, #8]
 800dfe8:	e742      	b.n	800de70 <_realloc_r+0xdc>
 800dfea:	6001      	str	r1, [r0, #0]
 800dfec:	686b      	ldr	r3, [r5, #4]
 800dfee:	6043      	str	r3, [r0, #4]
 800dff0:	2a1b      	cmp	r2, #27
 800dff2:	d83a      	bhi.n	800e06a <_realloc_r+0x2d6>
 800dff4:	f105 0208 	add.w	r2, r5, #8
 800dff8:	f100 0308 	add.w	r3, r0, #8
 800dffc:	68a9      	ldr	r1, [r5, #8]
 800dffe:	e710      	b.n	800de22 <_realloc_r+0x8e>
 800e000:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800e004:	f023 0303 	bic.w	r3, r3, #3
 800e008:	441e      	add	r6, r3
 800e00a:	eb07 0906 	add.w	r9, r7, r6
 800e00e:	e753      	b.n	800deb8 <_realloc_r+0x124>
 800e010:	4652      	mov	r2, sl
 800e012:	e749      	b.n	800dea8 <_realloc_r+0x114>
 800e014:	4629      	mov	r1, r5
 800e016:	4650      	mov	r0, sl
 800e018:	461e      	mov	r6, r3
 800e01a:	465f      	mov	r7, fp
 800e01c:	f7ff fe56 	bl	800dccc <memmove>
 800e020:	4655      	mov	r5, sl
 800e022:	e749      	b.n	800deb8 <_realloc_r+0x124>
 800e024:	4629      	mov	r1, r5
 800e026:	f7ff fe51 	bl	800dccc <memmove>
 800e02a:	e6ff      	b.n	800de2c <_realloc_r+0x98>
 800e02c:	4427      	add	r7, r4
 800e02e:	eba9 0904 	sub.w	r9, r9, r4
 800e032:	f049 0201 	orr.w	r2, r9, #1
 800e036:	609f      	str	r7, [r3, #8]
 800e038:	607a      	str	r2, [r7, #4]
 800e03a:	f855 3c04 	ldr.w	r3, [r5, #-4]
 800e03e:	f003 0301 	and.w	r3, r3, #1
 800e042:	431c      	orrs	r4, r3
 800e044:	4640      	mov	r0, r8
 800e046:	f845 4c04 	str.w	r4, [r5, #-4]
 800e04a:	f7ff fa01 	bl	800d450 <__malloc_unlock>
 800e04e:	46aa      	mov	sl, r5
 800e050:	e744      	b.n	800dedc <_realloc_r+0x148>
 800e052:	f8cb 1010 	str.w	r1, [fp, #16]
 800e056:	68e9      	ldr	r1, [r5, #12]
 800e058:	f8cb 1014 	str.w	r1, [fp, #20]
 800e05c:	2a24      	cmp	r2, #36	; 0x24
 800e05e:	d010      	beq.n	800e082 <_realloc_r+0x2ee>
 800e060:	6929      	ldr	r1, [r5, #16]
 800e062:	f10b 0218 	add.w	r2, fp, #24
 800e066:	3510      	adds	r5, #16
 800e068:	e71e      	b.n	800dea8 <_realloc_r+0x114>
 800e06a:	68ab      	ldr	r3, [r5, #8]
 800e06c:	6083      	str	r3, [r0, #8]
 800e06e:	68eb      	ldr	r3, [r5, #12]
 800e070:	60c3      	str	r3, [r0, #12]
 800e072:	2a24      	cmp	r2, #36	; 0x24
 800e074:	d010      	beq.n	800e098 <_realloc_r+0x304>
 800e076:	f105 0210 	add.w	r2, r5, #16
 800e07a:	f100 0310 	add.w	r3, r0, #16
 800e07e:	6929      	ldr	r1, [r5, #16]
 800e080:	e6cf      	b.n	800de22 <_realloc_r+0x8e>
 800e082:	692a      	ldr	r2, [r5, #16]
 800e084:	f8cb 2018 	str.w	r2, [fp, #24]
 800e088:	696a      	ldr	r2, [r5, #20]
 800e08a:	f8cb 201c 	str.w	r2, [fp, #28]
 800e08e:	69a9      	ldr	r1, [r5, #24]
 800e090:	f10b 0220 	add.w	r2, fp, #32
 800e094:	3518      	adds	r5, #24
 800e096:	e707      	b.n	800dea8 <_realloc_r+0x114>
 800e098:	692b      	ldr	r3, [r5, #16]
 800e09a:	6103      	str	r3, [r0, #16]
 800e09c:	696b      	ldr	r3, [r5, #20]
 800e09e:	6143      	str	r3, [r0, #20]
 800e0a0:	69a9      	ldr	r1, [r5, #24]
 800e0a2:	f105 0218 	add.w	r2, r5, #24
 800e0a6:	f100 0318 	add.w	r3, r0, #24
 800e0aa:	e6ba      	b.n	800de22 <_realloc_r+0x8e>
 800e0ac:	4652      	mov	r2, sl
 800e0ae:	e76e      	b.n	800df8e <_realloc_r+0x1fa>
 800e0b0:	4629      	mov	r1, r5
 800e0b2:	4650      	mov	r0, sl
 800e0b4:	9301      	str	r3, [sp, #4]
 800e0b6:	f7ff fe09 	bl	800dccc <memmove>
 800e0ba:	9b01      	ldr	r3, [sp, #4]
 800e0bc:	e76c      	b.n	800df98 <_realloc_r+0x204>
 800e0be:	f8cb 1010 	str.w	r1, [fp, #16]
 800e0c2:	68e9      	ldr	r1, [r5, #12]
 800e0c4:	f8cb 1014 	str.w	r1, [fp, #20]
 800e0c8:	2a24      	cmp	r2, #36	; 0x24
 800e0ca:	d004      	beq.n	800e0d6 <_realloc_r+0x342>
 800e0cc:	6929      	ldr	r1, [r5, #16]
 800e0ce:	f10b 0218 	add.w	r2, fp, #24
 800e0d2:	3510      	adds	r5, #16
 800e0d4:	e75b      	b.n	800df8e <_realloc_r+0x1fa>
 800e0d6:	692a      	ldr	r2, [r5, #16]
 800e0d8:	f8cb 2018 	str.w	r2, [fp, #24]
 800e0dc:	696a      	ldr	r2, [r5, #20]
 800e0de:	f8cb 201c 	str.w	r2, [fp, #28]
 800e0e2:	69a9      	ldr	r1, [r5, #24]
 800e0e4:	f10b 0220 	add.w	r2, fp, #32
 800e0e8:	3518      	adds	r5, #24
 800e0ea:	e750      	b.n	800df8e <_realloc_r+0x1fa>
 800e0ec:	20000c60 	.word	0x20000c60

0800e0f0 <__ascii_wctomb>:
 800e0f0:	b121      	cbz	r1, 800e0fc <__ascii_wctomb+0xc>
 800e0f2:	2aff      	cmp	r2, #255	; 0xff
 800e0f4:	d804      	bhi.n	800e100 <__ascii_wctomb+0x10>
 800e0f6:	700a      	strb	r2, [r1, #0]
 800e0f8:	2001      	movs	r0, #1
 800e0fa:	4770      	bx	lr
 800e0fc:	4608      	mov	r0, r1
 800e0fe:	4770      	bx	lr
 800e100:	238a      	movs	r3, #138	; 0x8a
 800e102:	6003      	str	r3, [r0, #0]
 800e104:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800e108:	4770      	bx	lr
 800e10a:	bf00      	nop
